// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "../../framework/BrevisApp.sol";
import "../../../interface/IBrevisProof.sol";

struct TotalFee {
    uint256 token0Amt;
    uint256 token1Amt;
}

interface ITotalFeeApp {
    function totalFees(uint64 epoch) external view returns(TotalFee memory); 
}

contract SingleRewardApp is BrevisApp, Ownable {
    using SafeERC20 for IERC20;

    uint8 public maxEpochPerPosition; // max epochs per position in the zk circuit
    uint8 public maxPositionsPerUser; // max positions per user in the zk circuit
    
    bytes32 public vkHash;
    address public rewardToken;
    ITotalFeeApp public totalFeeApp;
    event Claimed(address indexed user, uint64 fromEpoch, uint64 toEpoch, uint256 amount);

    mapping(address => uint64) public userClaimedTo; // user => toEpoch

    constructor(address _brevisProof, ITotalFeeApp _totalFeeApp) BrevisApp(IBrevisProof(_brevisProof)) {
        totalFeeApp = _totalFeeApp;
    }

    // BrevisQuery contract will call our callback once Brevis backend submits the proof.
    function handleProofResult(
        bytes32 /*_requestId*/,
        bytes32 _vkHash,
        bytes calldata _circuitOutput
    ) internal override {
        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed
        // our designated verifying key. This proves that the _circuitOutput is authentic
        require(vkHash == _vkHash, "invalid vk");

        (address user, uint64 fromEpoch, uint64 toEpoch, uint256 amt) = decodeOutput(_circuitOutput);
        uint64 lastClaimedEpoch = userClaimedTo[user];
        if (lastClaimedEpoch > 0) {
            require(fromEpoch > lastClaimedEpoch, "illegal claim");
        }

        userClaimedTo[user] = toEpoch;
        if (amt > 0) {
            IERC20(rewardToken).safeTransfer(user, amt);
        }
        emit Claimed(user, fromEpoch, toEpoch, amt);
    }

    function decodeOutput(bytes calldata o) internal view returns (address user, uint64 fromEpoch, uint64 toEpoch, uint256 amt) {
        user = address(bytes20(o[0:20]));
        uint256 bytesPerPosition = 8 + 8 + 8 + 31 * 2 * maxEpochPerPosition;
        for (uint8 i = 0; i < maxPositionsPerUser; i++) {
            uint256 startBytes = 20 + bytesPerPosition * i;
            uint64 startEpoch = uint64(bytes8(o[startBytes:startBytes+8]));
            uint64 endEpoch = uint64(bytes8(o[startBytes+8:startBytes+16]));
            uint64 tokenId = uint64(bytes8(o[startBytes+16:startBytes+24]));
            for (uint8 j = 0; j < maxEpochPerPosition; j++) {
                uint248 token0FeeInTheEpoch = uint248(bytes31(o[startBytes+16+31*j:startBytes+16+31*(j+1)]));
                uint248 token1FeeInTheEpoch = uint248(bytes31(o[startBytes+16+31*(j+1):startBytes+16+31*(j+2)]));
                if (tokenId > 0 && j > 0 && startEpoch + j <= endEpoch) {
                    TotalFee memory epochTotalFee = totalFeeApp.totalFees(startEpoch + j);
                    require(epochTotalFee.token0Amt == token0FeeInTheEpoch, "epoch total fee not right");
                    require(epochTotalFee.token1Amt == token1FeeInTheEpoch, "epoch total fee not right");
                }
            }
            if (tokenId > 0 && (fromEpoch == 0 || fromEpoch > startEpoch + 1)) {
                fromEpoch = startEpoch + 1;
            }
            if (toEpoch == 0 || toEpoch < endEpoch) {
                toEpoch = endEpoch;
            }
        }

        amt = uint256(uint248(bytes31(o[20+bytesPerPosition*maxPositionsPerUser:20+bytesPerPosition*maxPositionsPerUser+31])));
    }

    function setVkHash(bytes32 _vkHash) external onlyOwner {
        vkHash = _vkHash;
    }

    function setRewardToken(address _rewardToken) external onlyOwner {
        rewardToken = _rewardToken;
    }

    function setMaxEpochPerPosition(uint8 _maxEpochPerPosition) external onlyOwner {
        maxEpochPerPosition = _maxEpochPerPosition;
    }

    function setMaxPositionsPerUser(uint8 _maxPositionsPerUser) external onlyOwner {
        maxPositionsPerUser = _maxPositionsPerUser;
    }

    function setTotalFeeApp(ITotalFeeApp _totalFeeApp) external onlyOwner {
        totalFeeApp = _totalFeeApp;
    }
}
