// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "../../framework/BrevisApp.sol";
import "../../../interface/IBrevisProof.sol";

contract SingleRewardApp is BrevisApp, Ownable {
    using SafeERC20 for IERC20;

    bytes32 public vkHash;
    address public rewardToken;
    event Claimed(address indexed user, uint64 fromEpoch, uint64 toEpoch, uint256 amount);

    mapping(address => uint64) public userClaimedTo; // user => toEpoch

    constructor(address brevisProof) BrevisApp(IBrevisProof(brevisProof)) {}

    // BrevisQuery contract will call our callback once Brevis backend submits the proof.
    function handleProofResult(
        bytes32 /*_requestId*/,
        bytes32 _vkHash,
        bytes calldata _circuitOutput
    ) internal override {
        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed
        // our designated verifying key. This proves that the _circuitOutput is authentic
        require(vkHash == _vkHash, "invalid vk");

        (address user, uint64 fromEpoch, uint64 toEpoch, uint256 amt) = decodeOutput(_circuitOutput);

        uint64 lastClaimedEpoch = userClaimedTo[user];
        if (lastClaimedEpoch > 0) {
            require(fromEpoch == lastClaimedEpoch + 1, "illegal claim");
        }

        userClaimedTo[user] = toEpoch;
        IERC20(rewardToken).safeTransfer(user, amt);
        emit Claimed(user, fromEpoch, toEpoch, amt);
    }

    function decodeOutput(bytes calldata o) internal pure returns (address user, uint64 fromEpoch, uint64 toEpoch, uint256 amt) {
        return (address(bytes20(o[0:20])), uint64(bytes8(o[20:28])), uint64(bytes8(o[28:36])), uint256(bytes32(o[36:68])));
    }

    function setVkHash(bytes32 _vkHash) external onlyOwner {
        vkHash = _vkHash;
    }

    function setRewardToken(address _rewardToken) external onlyOwner {
        rewardToken = _rewardToken;
    }
}
