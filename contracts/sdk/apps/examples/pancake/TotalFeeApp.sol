// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";

import "../../framework/BrevisApp.sol";
import "../../../interface/IBrevisProof.sol";

contract TotalFeeApp is BrevisApp, Ownable {
    bytes32 public vkHash;

    struct TotalFee {
        uint256 token0Amt;
        uint256 token1Amt;
    }

    mapping(uint64 => TotalFee) public totalFees; // epoch => total fee, for demo, pool is a predefined one
    uint64 public latestEpoch;
    event TotalFeePosted(uint64 epoch, uint256 token0Amt, uint256 token1Amt);

    constructor(address brevisProof) BrevisApp(IBrevisProof(brevisProof)) {}

    // BrevisQuery contract will call our callback once Brevis backend submits the proof.
    function handleProofResult(
        bytes32 /*_requestId*/,
        bytes32 _vkHash,
        bytes calldata _circuitOutput
    ) internal override {
        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed
        // our designated verifying key. This proves that the _circuitOutput is authentic
        require(vkHash == _vkHash, "invalid vk");

        (uint64 epoch, uint256 token0Amt, uint256 token1Amt) = decodeOutput(_circuitOutput);
        if (latestEpoch != 0) {
            require(epoch == latestEpoch + 1, "invalid epoch");
        }

        latestEpoch = epoch;
        totalFees[epoch] = TotalFee(token0Amt, token1Amt);

        emit TotalFeePosted(epoch, token0Amt, token1Amt);
    }

    function decodeOutput(bytes calldata o) internal pure returns (uint64, uint256, uint256) {
        uint64 epoch = uint64(bytes8(o[0:8])); 
        uint256 token0Amt = uint256(uint248(bytes31(o[8:39]))); 
        uint256 token1Amt = uint256(uint248(bytes31(o[39:70]))); 
        return (epoch, token0Amt, token1Amt);
    }

    function setVkHash(bytes32 _vkHash) external onlyOwner {
        vkHash = _vkHash;
    }
}
