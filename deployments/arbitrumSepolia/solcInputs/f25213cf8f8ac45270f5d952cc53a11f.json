{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/apps/demo-tx-uniswap-amount/libraries/Commands.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol\npragma solidity >=0.8.0;\n\n/// @title Commands\n/// @notice Command Flags used to decode commands\nlibrary Commands {\n    // Masks to extract certain bits of commands\n    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\n\n    // Command Types. Maximum supported command at this moment is 0x3f.\n\n    // Command Types where value<0x08, executed in the first nested-if block\n    uint256 constant V3_SWAP_EXACT_IN = 0x00;\n    uint256 constant V3_SWAP_EXACT_OUT = 0x01;\n    uint256 constant PERMIT2_TRANSFER_FROM = 0x02;\n    uint256 constant PERMIT2_PERMIT_BATCH = 0x03;\n    uint256 constant SWEEP = 0x04;\n    uint256 constant TRANSFER = 0x05;\n    uint256 constant PAY_PORTION = 0x06;\n    // COMMAND_PLACEHOLDER = 0x07;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant FIRST_IF_BOUNDARY = 0x08;\n\n    // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block\n    uint256 constant V2_SWAP_EXACT_IN = 0x08;\n    uint256 constant V2_SWAP_EXACT_OUT = 0x09;\n    uint256 constant PERMIT2_PERMIT = 0x0a;\n    uint256 constant WRAP_ETH = 0x0b;\n    uint256 constant UNWRAP_WETH = 0x0c;\n    uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;\n    uint256 constant BALANCE_CHECK_ERC20 = 0x0e;\n    // COMMAND_PLACEHOLDER = 0x0f;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant SECOND_IF_BOUNDARY = 0x10;\n\n    // Command Types where 0x10<=value<0x18, executed in the third nested-if block\n    uint256 constant SEAPORT_V1_5 = 0x10;\n    uint256 constant LOOKS_RARE_V2 = 0x11;\n    uint256 constant NFTX = 0x12;\n    uint256 constant CRYPTOPUNKS = 0x13;\n    // 0x14;\n    uint256 constant OWNER_CHECK_721 = 0x15;\n    uint256 constant OWNER_CHECK_1155 = 0x16;\n    uint256 constant SWEEP_ERC721 = 0x17;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant THIRD_IF_BOUNDARY = 0x18;\n\n    // Command Types where 0x18<=value<=0x1f, executed in the final nested-if block\n    uint256 constant X2Y2_721 = 0x18;\n    uint256 constant SUDOSWAP = 0x19;\n    uint256 constant NFT20 = 0x1a;\n    uint256 constant X2Y2_1155 = 0x1b;\n    uint256 constant FOUNDATION = 0x1c;\n    uint256 constant SWEEP_ERC1155 = 0x1d;\n    uint256 constant ELEMENT_MARKET = 0x1e;\n    // COMMAND_PLACEHOLDER = 0x1f;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant FOURTH_IF_BOUNDARY = 0x20;\n\n    // Command Types where 0x20<=value\n    uint256 constant SEAPORT_V1_4 = 0x20;\n    uint256 constant EXECUTE_SUB_PLAN = 0x21;\n    uint256 constant APPROVE_ERC20 = 0x22;\n    // COMMAND_PLACEHOLDER for 0x23 to 0x3f (all unused)\n}\n"
    },
    "contracts/apps/demo-tx-uniswap-amount/libraries/Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// from https://github.com/Uniswap/v3-periphery\npragma solidity >=0.8.0;\n\nlibrary Path {\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path) internal pure returns (address tokenA, address tokenB, uint24 fee) {\n        tokenA = toAddress(path, 0);\n        fee = toUint24(path, ADDR_SIZE);\n        tokenB = toAddress(path, NEXT_OFFSET);\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3, \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n"
    },
    "contracts/apps/demo-tx-uniswap-amount/UniswapAmount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./libraries/Commands.sol\";\nimport \"./libraries/Path.sol\";\nimport \"../../verifiers/interfaces/ITxVerifier.sol\";\n\ninterface IBrevisUniNFT {\n    function mint(address to) external;\n}\n\ncontract UniswapAmount is Ownable {\n    ITxVerifier public txVerifier;\n\n    mapping(uint64 => address) public universalRouter; // chainId -> router address\n    mapping(uint64 => address) public weth; // chainId -> WETH address\n    mapping(uint64 => address) public usdc; // chainId -> USDC address\n    mapping(uint64 => uint8) usdcDecimal; // chainId -> USDC decimal\n\n    bytes4 private executeSelector = bytes4(keccak256(bytes(\"execute(bytes,bytes[],uint256)\")));\n    bytes4 private executeNoDealineSelector = bytes4(keccak256(bytes(\"execute(bytes,bytes[])\")));\n\n    enum TierName {\n        Null,\n        Stone,\n        Bronze,\n        Silver,\n        Gold,\n        Platinum,\n        Diamond\n    }\n    mapping(TierName => address) public tierNFTs;\n    mapping(address => TierName) public userTier; // user -> tier\n\n    event VerifiedSwap(uint64 chainId, address trader, uint64 timestamp, uint256 usdcAmount, TierName tier);\n\n    constructor(ITxVerifier _txVerifier) {\n        txVerifier = _txVerifier;\n    }\n\n    function submitUniswapTxProof(\n        bytes calldata _tx,\n        bytes calldata _proof,\n        bytes calldata _auxiBlkVerifyInfo\n    ) external {\n        ITxVerifier.TxInfo memory txInfo = txVerifier.verifyTxAndLog(_tx, _proof, _auxiBlkVerifyInfo);\n        require(txInfo.to == universalRouter[txInfo.chainId], \"invalid to address\");\n        require(userTier[txInfo.from] == TierName.Null, \"swap already proved for this user\");\n\n        (uint256 amount, TierName tier) = usdcSwapAmount(txInfo.chainId, txInfo.data);\n        userTier[txInfo.from] = tier;\n        IBrevisUniNFT(tierNFTs[tier]).mint(txInfo.from);\n\n        emit VerifiedSwap(txInfo.chainId, txInfo.from, txInfo.blkTime, amount, tier);\n    }\n\n    function setUniversalRouter(uint64 _chainId, address _router) external onlyOwner {\n        universalRouter[_chainId] = _router;\n    }\n\n    function setWETH(uint64 _chainId, address _weth) external onlyOwner {\n        weth[_chainId] = _weth;\n    }\n\n    function setUSDC(uint64 _chainId, address _usdc, uint8 _decimal) external onlyOwner {\n        usdc[_chainId] = _usdc;\n        usdcDecimal[_chainId] = _decimal;\n    }\n\n    function setTierNFTs(TierName[] calldata _names, address[] calldata _nfts) external onlyOwner {\n        require(_names.length == _nfts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _names.length; i++) {\n            tierNFTs[_names[i]] = _nfts[i];\n        }\n    }\n\n    function setTxVerifier(ITxVerifier _txVerifier) external onlyOwner {\n        txVerifier = _txVerifier;\n    }\n\n    function usdcSwapAmount(uint64 _chainId, bytes memory _data) public view returns (uint256 amount, TierName tier) {\n        bytes4 method;\n        assembly {\n            method := mload(add(_data, 32))\n        }\n        require(method == executeSelector || method == executeNoDealineSelector, \"wrong method\");\n        bytes memory argdata = BytesLib.slice(_data, 4, _data.length - 4);\n        (bytes memory commands, bytes[] memory inputs, ) = abi.decode(argdata, (bytes, bytes[], uint256));\n        // assume tx succeeded, so no need to check deadline or command/input length match\n\n        uint256 command = uint8(commands[0] & Commands.COMMAND_TYPE_MASK);\n        bytes memory input;\n        if (command == Commands.WRAP_ETH || command == Commands.PERMIT2_PERMIT) {\n            command = uint8(commands[1] & Commands.COMMAND_TYPE_MASK);\n            input = inputs[1];\n        } else {\n            input = inputs[0];\n        }\n        require(command == Commands.V3_SWAP_EXACT_IN || command == Commands.V3_SWAP_EXACT_OUT, \"unsupported command\");\n        (, uint256 amountA, uint256 amountB, bytes memory path, ) = abi.decode(\n            input,\n            (address, uint256, uint256, bytes, bool)\n        );\n        (address tokenA, address tokenB, ) = Path.decodeFirstPool(path);\n        if (tokenA == weth[_chainId]) {\n            require(tokenB == usdc[_chainId], \"unsupported pair\");\n            amount = amountB;\n        } else if (tokenA == usdc[_chainId]) {\n            require(tokenB == weth[_chainId], \"unsupported pair\");\n            amount = amountA;\n        } else {\n            revert(\"unsupported pair\");\n        }\n        require(amount > 0, \"zero usdc amount\");\n        tier = getAmountTier(_chainId, amount);\n    }\n\n    function getAmountTier(uint64 _chainId, uint256 _amount) private view returns (TierName tier) {\n        uint256 decimal = 10 ** usdcDecimal[_chainId];\n        if (_amount >= 1000000 * decimal) {\n            return TierName.Diamond;\n        } else if (_amount >= 100000 * decimal) {\n            return TierName.Platinum;\n        } else if (_amount >= 10000 * decimal) {\n            return TierName.Gold;\n        } else if (_amount >= 1000 * decimal) {\n            return TierName.Silver;\n        } else if (_amount >= 100 * decimal) {\n            return TierName.Bronze;\n        }\n        return TierName.Stone;\n    }\n}\n"
    },
    "contracts/interfaces/ISMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../verifiers/zk-verifiers/common/IVerifier.sol\";\n\ninterface ISMT {\n    struct SmtUpdate {\n        bytes32 newSmtRoot;\n        uint64 endBlockNum;\n        bytes32 endBlockHash;\n        bytes32 nextChunkMerkleRoot;\n        IVerifier.Proof proof;\n        bytes32 commitPub;\n    }\n\n    function updateRoot(uint64 chainId, SmtUpdate memory u) external;\n\n    function isSmtRootValid(uint64 chainId, bytes32 smtRoot) external view returns (bool);\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/CrossChain.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IApplication.sol\";\nimport \"./interfaces/ICrossChain.sol\";\nimport \"./interfaces/ITendermintLightClient.sol\";\nimport \"./lib/Bytes.sol\";\nimport \"./lib/Memory.sol\";\nimport \"./lib/Tendermint.sol\";\nimport \"./lib/ics23/ics23.sol\";\nimport \"./Initializable.sol\";\nimport \"./System.sol\";\nimport {PROOFS_PROTO_GLOBAL_ENUMS, CommitmentProof, ProofSpec, InnerSpec, LeafOp, InnerOp} from \"./lib/proto/Proofs.sol\";\n\ncontract CrossChain is Initializable, ICrossChain {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for TmHeader.Data;\n    using TendermintHelper for ConsensusState.Data;\n    using TendermintHelper for ValidatorSet.Data;\n\n    // constant variables\n    string public constant STORE_NAME = \"ibc\";\n    uint256 public constant CROSS_CHAIN_KEY_PREFIX = 0x01006000; // last 6 bytes\n    uint8 public constant SYN_PACKAGE = 0x00;\n    uint8 public constant ACK_PACKAGE = 0x01;\n    uint8 public constant FAIL_ACK_PACKAGE = 0x02;\n    uint256 public constant INIT_BATCH_SIZE = 50;\n\n    // governable parameters\n    uint256 public batchSizeForOracle;\n\n    //state variables\n    uint256 public previousTxHeight;\n    uint256 public txCounter;\n    int64 public oracleSequence;\n    mapping(uint8 => address) public channelHandlerContractMap;\n    mapping(address => mapping(uint8 => bool)) public registeredContractChannelMap;\n    mapping(uint8 => uint64) public channelSendSequenceMap;\n    mapping(uint8 => uint64) public channelReceiveSequenceMap;\n    System private system;\n\n    struct ChannelInit {\n        uint8 channelId;\n        uint64 sequence;\n    }\n\n    ProofSpec.Data private _tmProofSpec =\n        ProofSpec.Data({\n            leaf_spec: LeafOp.Data({\n                hash: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256,\n                prehash_key: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.NO_HASH,\n                prehash_value: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256,\n                length: PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.VAR_PROTO,\n                prefix: hex\"00028cc3f922\"\n            }),\n            inner_spec: InnerSpec.Data({\n                child_order: getTmChildOrder(),\n                child_size: 32,\n                min_prefix_length: 1,\n                max_prefix_length: 128,\n                empty_child: abi.encodePacked(),\n                hash: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256\n            }),\n            min_depth: 0,\n            max_depth: 0\n        });\n\n    // event\n    event CrossChainPackage(\n        uint16 chainId,\n        uint64 indexed oracleSequence,\n        uint64 indexed packageSequence,\n        uint8 indexed channelId,\n        bytes payload\n    );\n    event ReceivedPackage(uint8 packageType, uint64 indexed packageSequence, uint8 indexed channelId);\n    event UnsupportedPackage(uint64 indexed packageSequence, uint8 indexed channelId, bytes payload);\n    event UnexpectedRevertInPackageHandler(address indexed contractAddr, string reason);\n    event UnexpectedFailureAssertionInPackageHandler(address indexed contractAddr, bytes lowLevelData);\n\n    modifier sequenceInOrder(uint64 _sequence, uint8 _channelID) {\n        uint64 expectedSequence = channelReceiveSequenceMap[_channelID];\n        require(_sequence == expectedSequence, \"sequence not in order\");\n\n        channelReceiveSequenceMap[_channelID] = expectedSequence + 1;\n        _;\n    }\n\n    modifier blockSynced(uint64 _height) {\n        require(\n            ITendermintLightClient(system.tmLightClient()).isHeaderSynced(_height),\n            \"light client not sync the block yet\"\n        );\n        _;\n    }\n\n    modifier channelSupported(uint8 _channelID) {\n        require(channelHandlerContractMap[_channelID] != address(0x0), \"channel is not supported\");\n        _;\n    }\n\n    modifier onlyRegisteredContractChannel(uint8 channelId) {\n        require(\n            registeredContractChannelMap[msg.sender][channelId],\n            \"the contract and channel have not been registered\"\n        );\n        _;\n    }\n\n    // | length   | prefix | sourceChainID| destinationChainID | channelID | sequence |\n    // | 32 bytes | 1 byte | 2 bytes      | 2 bytes            |  1 bytes  | 8 bytes  |\n    function generateKey(uint64 _sequence, uint8 _channelID) internal pure returns (bytes memory) {\n        uint256 fullCROSS_CHAIN_KEY_PREFIX = CROSS_CHAIN_KEY_PREFIX | _channelID;\n        bytes memory key = new bytes(14);\n\n        uint256 ptr;\n        assembly {\n            ptr := add(key, 14)\n        }\n        assembly {\n            mstore(ptr, _sequence)\n        }\n        ptr -= 8;\n        assembly {\n            mstore(ptr, fullCROSS_CHAIN_KEY_PREFIX)\n        }\n        ptr -= 6;\n        assembly {\n            mstore(ptr, 14)\n        }\n        return key;\n    }\n\n    function init(address _system, ChannelInit[] memory receiveChannelInit) external onlyUninitialized {\n        system = System(_system);\n        require(system.bscValidatorSet() != address(0), \"system uninitialized\");\n\n        channelHandlerContractMap[system.STAKING_CHANNEL_ID()] = system.bscValidatorSet();\n        registeredContractChannelMap[system.bscValidatorSet()][system.STAKING_CHANNEL_ID()] = true;\n\n        batchSizeForOracle = INIT_BATCH_SIZE;\n\n        oracleSequence = -1;\n        previousTxHeight = 0;\n        txCounter = 0;\n\n        for (uint256 i = 0; i < receiveChannelInit.length; i++) {\n            ChannelInit memory channelInit = receiveChannelInit[i];\n            channelReceiveSequenceMap[channelInit.channelId] = channelInit.sequence;\n        }\n\n        _initialized = true;\n    }\n\n    function encodePayload(\n        uint8 packageType,\n        uint256 relayFee,\n        bytes memory msgBytes\n    ) public pure returns (bytes memory) {\n        uint256 payloadLength = msgBytes.length + 33;\n        bytes memory payload = new bytes(payloadLength);\n        uint256 ptr;\n        assembly {\n            ptr := payload\n        }\n        ptr += 33;\n\n        assembly {\n            mstore(ptr, relayFee)\n        }\n\n        ptr -= 32;\n        assembly {\n            mstore(ptr, packageType)\n        }\n\n        ptr -= 1;\n        assembly {\n            mstore(ptr, payloadLength)\n        }\n\n        ptr += 65;\n        (uint256 src, ) = Memory.fromBytes(msgBytes);\n        Memory.copy(src, ptr, msgBytes.length);\n\n        return payload;\n    }\n\n    // | type   | relayFee   |package  |\n    // | 1 byte | 32 bytes   | bytes    |\n    function decodePayloadHeader(bytes memory payload) internal pure returns (bool, uint8, uint256, bytes memory) {\n        if (payload.length < 33) {\n            return (false, 0, 0, new bytes(0));\n        }\n\n        uint256 ptr;\n        assembly {\n            ptr := payload\n        }\n\n        uint8 packageType;\n        ptr += 1;\n        assembly {\n            packageType := mload(ptr)\n        }\n\n        uint256 relayFee;\n        ptr += 32;\n        assembly {\n            relayFee := mload(ptr)\n        }\n\n        ptr += 32;\n        bytes memory msgBytes = new bytes(payload.length - 33);\n        (uint256 dst, ) = Memory.fromBytes(msgBytes);\n        Memory.copy(ptr, dst, payload.length - 33);\n\n        return (true, packageType, relayFee, msgBytes);\n    }\n\n    function handlePackage(\n        bytes calldata payload,\n        bytes calldata proof,\n        uint64 height,\n        uint64 packageSequence,\n        uint8 channelId\n    )\n        external\n        onlyInitialized\n        sequenceInOrder(packageSequence, channelId)\n        blockSynced(height)\n        channelSupported(channelId)\n    {\n        require(msg.sender == system.relayer(), \"not relayer\");\n\n        bytes memory payloadLocal = payload; // fix error: stack too deep, try removing local variables\n        bytes memory proofLocal = proof; // fix error: stack too deep, try removing local variables\n        // TODO: Enable after BSC switches to ics-23 proofs\n        // require(\n        //     verifyMembership(\n        //         proofLocal,\n        //         ITendermintLightClient(system.tmLightClient()).getAppHash(height).toBytes(),\n        //         \"\",\n        //         bytes(generateKey(packageSequence, channelId))),\n        //         payloadLocal\n        //     )\n        // );\n\n        uint8 channelIdLocal = channelId; // fix error: stack too deep, try removing local variables\n        (bool success, uint8 packageType, , bytes memory msgBytes) = decodePayloadHeader(payloadLocal);\n        if (!success) {\n            emit UnsupportedPackage(packageSequence, channelIdLocal, payloadLocal);\n            return;\n        }\n        emit ReceivedPackage(packageType, packageSequence, channelIdLocal);\n        if (packageType == SYN_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleSynPackage(channelIdLocal, msgBytes) returns (\n                bytes memory responsePayload\n            ) {\n                if (responsePayload.length != 0) {\n                    sendPackage(\n                        channelSendSequenceMap[channelIdLocal],\n                        channelIdLocal,\n                        encodePayload(ACK_PACKAGE, 0, responsePayload)\n                    );\n                    channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                }\n            } catch Error(string memory reason) {\n                sendPackage(\n                    channelSendSequenceMap[channelIdLocal],\n                    channelIdLocal,\n                    encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n                );\n                channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                sendPackage(\n                    channelSendSequenceMap[channelIdLocal],\n                    channelIdLocal,\n                    encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n                );\n                channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        } else if (packageType == ACK_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleAckPackage(channelIdLocal, msgBytes) {} catch Error(\n                string memory reason\n            ) {\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        } else if (packageType == FAIL_ACK_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleFailAckPackage(channelIdLocal, msgBytes) {} catch Error(\n                string memory reason\n            ) {\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        }\n    }\n\n    function sendPackage(uint64 packageSequence, uint8 channelId, bytes memory payload) internal {\n        if (block.number > previousTxHeight) {\n            oracleSequence++;\n            txCounter = 1;\n            previousTxHeight = block.number;\n        } else {\n            txCounter++;\n            if (txCounter > batchSizeForOracle) {\n                oracleSequence++;\n                txCounter = 1;\n            }\n        }\n        emit CrossChainPackage(system.bscChainID(), uint64(oracleSequence), packageSequence, channelId, payload);\n    }\n\n    function sendSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes,\n        uint256 relayFee\n    ) external override onlyInitialized onlyRegisteredContractChannel(channelId) {\n        uint64 sendSequence = channelSendSequenceMap[channelId];\n        sendPackage(sendSequence, channelId, encodePayload(SYN_PACKAGE, relayFee, msgBytes));\n        sendSequence++;\n        channelSendSequenceMap[channelId] = sendSequence;\n    }\n\n    function getTmChildOrder() internal pure returns (int32[] memory) {\n        int32[] memory childOrder = new int32[](2);\n        childOrder[0] = 0;\n        childOrder[1] = 1;\n\n        return childOrder;\n    }\n\n    function verifyMembership(\n        bytes memory proof,\n        bytes memory root,\n        bytes memory prefix,\n        bytes memory slot,\n        bytes memory expectedValue\n    ) internal view returns (bool) {\n        CommitmentProof.Data memory commitmentProof = CommitmentProof.decode(proof);\n\n        Ics23.VerifyMembershipError vCode = Ics23.verifyMembership(\n            _tmProofSpec,\n            root,\n            commitmentProof,\n            slot,\n            expectedValue\n        );\n\n        return vCode == Ics23.VerifyMembershipError.None;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/Ed25519Verifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nlibrary Pairing {\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n\ncontract Ed25519Verifier {\n    using Pairing for *;\n\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(16537564926561257518103578528440315215453761258292367362288728531966371995874),\n            uint256(17745573146004211534248579212526935789334969204993357645263388924661264974187)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(18681724724964420256656295617462445194520232343683657023020438565197998259673),\n                uint256(12193837689525487485139416036830252517228166559922434453026243184766751424223)\n            ],\n            [\n                uint256(1142689458690077585879713419885020952718961581248594394197708921155425831615),\n                uint256(21176592749741182389767016778519001156128344286592614375719960199144776585881)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(19799290104465580933750348548810731188007606239377683243716104715153013203241),\n                uint256(11029356377690007782073139603897274721732913650225177555357052135977173817932)\n            ],\n            [\n                uint256(14853413044533073822755393458984382667328640010571213879456567827440818416559),\n                uint256(1410171095280489347779850966561512432991607061868962673896369110725284404185)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(14033331354156232558698818931400566889727401262494703861181881854810319611656),\n                uint256(1803778019251118312050232705802652879152144501576771122000761003085527364548)\n            ],\n            [\n                uint256(19177018991900245360077248204991378509575348272931358571227777389261756980021),\n                uint256(13491338816347045964487197971132020169975241104757177444019867803073686189354)\n            ]\n        );\n    }\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[57] calldata input\n    ) public view returns (bool r) {\n        Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(9462447710939432742848424196697728822687813011479891122131648160830275921458); // vk.K[0].X\n        vk_x.Y = uint256(11473376488241810165831757536366836850027784981839089792021378256861687455964); // vk.K[0].Y\n        mul_input[0] = uint256(2648510173551830043068139172354933052408112984889271406750039349551232576549); // vk.K[1].X\n        mul_input[1] = uint256(12122054635554892818275346487442913112730051679642997892313491753063522521582); // vk.K[1].Y\n        mul_input[2] = input[0];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(7061394255936047678059253317568688117856036320639226956214975754160049295333); // vk.K[2].X\n        mul_input[1] = uint256(14145671141784595839380141874940651481054054987062620771942604522524338984737); // vk.K[2].Y\n        mul_input[2] = input[1];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(8218011998118573873686464766508340825013181970169509029207170044008261486193); // vk.K[3].X\n        mul_input[1] = uint256(4808589679893008233603109916014512606401750471929338771914335778004460444360); // vk.K[3].Y\n        mul_input[2] = input[2];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(6078662146959222742143128212552101384988335461422265821062667538426926541518); // vk.K[4].X\n        mul_input[1] = uint256(14225787497847862685225784260006515346740700745306082959617044081310626314439); // vk.K[4].Y\n        mul_input[2] = input[3];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(15225699490833575811570520695447458343846017972639836494871931441485526096787); // vk.K[5].X\n        mul_input[1] = uint256(15569415315038112005525705058718435821481109166559557245122292405605719408925); // vk.K[5].Y\n        mul_input[2] = input[4];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(3942281303299556918937442887343925623486733341136969568571582227745440173807); // vk.K[6].X\n        mul_input[1] = uint256(4138173571813503741513576149284418571266189111210058243046675207337729400955); // vk.K[6].Y\n        mul_input[2] = input[5];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(723953850260184913681651686455204823265776604606646409438367197633827064461); // vk.K[7].X\n        mul_input[1] = uint256(20977669267739599281940138230527850695064911563027213490970977450491160080036); // vk.K[7].Y\n        mul_input[2] = input[6];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(15017582390282569744856651205092622236708068694757044392807758501545223739943); // vk.K[8].X\n        mul_input[1] = uint256(1265991120483539619897036121722423769988535691692111441020055552301420911354); // vk.K[8].Y\n        mul_input[2] = input[7];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(5221873433181937410686676698706306071488292331003715940336123836669316677478); // vk.K[9].X\n        mul_input[1] = uint256(14426879645470087966651542997861483039122804778202333350123336907198495445103); // vk.K[9].Y\n        mul_input[2] = input[8];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        mul_input[0] = uint256(20573069687094669083259174171204052569713827743866845162450148699057547764918); // vk.K[10].X\n        mul_input[1] = uint256(19125182916367006002072229187347273947735042422948150051314675975432464674658); // vk.K[10].Y\n        mul_input[2] = input[9];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[10] * input[9]\n        mul_input[0] = uint256(653108268157101410313141643706313813985558592438699399282213422712029889715); // vk.K[11].X\n        mul_input[1] = uint256(920655015136053252820652067829010626746362759835559920517492343709532195466); // vk.K[11].Y\n        mul_input[2] = input[10];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[11] * input[10]\n        mul_input[0] = uint256(20917639943585713768528304284726936606521085966431546157561891168025022757887); // vk.K[12].X\n        mul_input[1] = uint256(8262496391990750367129442871845474963121866167295779784485121209123609128682); // vk.K[12].Y\n        mul_input[2] = input[11];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[12] * input[11]\n        mul_input[0] = uint256(21382382741426387778276445265980446660720522906365157168723787305555966928178); // vk.K[13].X\n        mul_input[1] = uint256(20304725605418784279352839016897739647529600560330484467516988594075783844854); // vk.K[13].Y\n        mul_input[2] = input[12];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[13] * input[12]\n        mul_input[0] = uint256(6205744815043738292440949022257329596826099473730575848275490097888497842377); // vk.K[14].X\n        mul_input[1] = uint256(14621389881302722659870997782918885566955239423536368018214245647671237084390); // vk.K[14].Y\n        mul_input[2] = input[13];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[14] * input[13]\n        mul_input[0] = uint256(15814307705747507442630842462045602926477319899462506430805053181751486077929); // vk.K[15].X\n        mul_input[1] = uint256(20719845899119367288065102841494811826814842176184748936398855427173476589603); // vk.K[15].Y\n        mul_input[2] = input[14];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[15] * input[14]\n        mul_input[0] = uint256(13115514590566800662313134167308526149064497604562804026503299495382170121521); // vk.K[16].X\n        mul_input[1] = uint256(1332307969280655731716061244811863427539380178344062557717239827752566800649); // vk.K[16].Y\n        mul_input[2] = input[15];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[16] * input[15]\n        mul_input[0] = uint256(21831548148156992003553031892913267462010789037401082515443630438407722663969); // vk.K[17].X\n        mul_input[1] = uint256(6734282036223126997206695046254381537591284089119495472525380311105692037149); // vk.K[17].Y\n        mul_input[2] = input[16];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[17] * input[16]\n        mul_input[0] = uint256(19824054054568150451544715245329533752342566872920996747743887644800176138756); // vk.K[18].X\n        mul_input[1] = uint256(17444883232483823314330637172782524563336237772974332017836978912923943288044); // vk.K[18].Y\n        mul_input[2] = input[17];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[18] * input[17]\n        mul_input[0] = uint256(11203846533369587519929291820435945242235455090413432458828659220572895771832); // vk.K[19].X\n        mul_input[1] = uint256(16148158018136729384412794294904585957329060422316919194693060478106477584261); // vk.K[19].Y\n        mul_input[2] = input[18];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[19] * input[18]\n        mul_input[0] = uint256(21371926577928441304164289543024513366951022486217703908520862772671592138220); // vk.K[20].X\n        mul_input[1] = uint256(18107932227339892218168366645185506844179114579625951614458742714985063933868); // vk.K[20].Y\n        mul_input[2] = input[19];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[20] * input[19]\n        mul_input[0] = uint256(2078836125811363606455079208654269542518183191401138318514557936552194691549); // vk.K[21].X\n        mul_input[1] = uint256(20289036517453961776720656852506924474500493189617637737320825721964408623696); // vk.K[21].Y\n        mul_input[2] = input[20];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[21] * input[20]\n        mul_input[0] = uint256(20684528615338806451021356191176017140605638913507543305045224022571493583399); // vk.K[22].X\n        mul_input[1] = uint256(3903056905414345066553250327072636225389082733080503032794283501727725353966); // vk.K[22].Y\n        mul_input[2] = input[21];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[22] * input[21]\n        mul_input[0] = uint256(13854622650680331791998959936965711435732154320243563610773598319176375507733); // vk.K[23].X\n        mul_input[1] = uint256(1293023507593941743631670346894908106668220179131184101706263206018361614455); // vk.K[23].Y\n        mul_input[2] = input[22];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[23] * input[22]\n        mul_input[0] = uint256(3806178131996244443364939020206141693542459073159601454749540496458558677609); // vk.K[24].X\n        mul_input[1] = uint256(11373982291360652938998008416691951950539326147900435417838815437650728107752); // vk.K[24].Y\n        mul_input[2] = input[23];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[24] * input[23]\n        mul_input[0] = uint256(2956423360991834768742742798077214208812640276852161493833529280831095074781); // vk.K[25].X\n        mul_input[1] = uint256(1036790067266635965218530400023441211296511606457139237137911024262932772523); // vk.K[25].Y\n        mul_input[2] = input[24];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[25] * input[24]\n        mul_input[0] = uint256(3522982602799278288450494299627381578769489328186449628808472144237402446412); // vk.K[26].X\n        mul_input[1] = uint256(13124545182856888320922946645561369145471456600466254299605996043152521299609); // vk.K[26].Y\n        mul_input[2] = input[25];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[26] * input[25]\n        mul_input[0] = uint256(10203021712642579290406260398074627148768959317126130666994877932179153487975); // vk.K[27].X\n        mul_input[1] = uint256(19220206362979524452868254497284191194377622625329987254755474419246348464504); // vk.K[27].Y\n        mul_input[2] = input[26];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[27] * input[26]\n        mul_input[0] = uint256(13656479319858575241396965583832757201969209361023293619085267873236508281324); // vk.K[28].X\n        mul_input[1] = uint256(18653894887361004227161091206020531090371042692329436200109497793456818170297); // vk.K[28].Y\n        mul_input[2] = input[27];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[28] * input[27]\n        mul_input[0] = uint256(20667457304256598973369559213600706490691854322307004623522066355950536986052); // vk.K[29].X\n        mul_input[1] = uint256(10166524048179842305027932295420555626140631584017768928975471213820747864954); // vk.K[29].Y\n        mul_input[2] = input[28];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[29] * input[28]\n        mul_input[0] = uint256(14451586832169158165406346103518705733160542436336769287947890488919305713536); // vk.K[30].X\n        mul_input[1] = uint256(15677358351240766490224933957331428778606486522363230169083418720895728674937); // vk.K[30].Y\n        mul_input[2] = input[29];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[30] * input[29]\n        mul_input[0] = uint256(8815343788891391302884218656640023092689342750375488785771313089418754129780); // vk.K[31].X\n        mul_input[1] = uint256(13009618795398702701706372843804296988960880281370027843016246576371783417574); // vk.K[31].Y\n        mul_input[2] = input[30];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[31] * input[30]\n        mul_input[0] = uint256(7794542304670317906972413815443657110555785749184277557959662453473304832135); // vk.K[32].X\n        mul_input[1] = uint256(13613183423982157012686848485088999158423912294590394357601874166998596036708); // vk.K[32].Y\n        mul_input[2] = input[31];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[32] * input[31]\n        mul_input[0] = uint256(13829063270265614122932776384418402417255253559219713892264763147960420595663); // vk.K[33].X\n        mul_input[1] = uint256(1394492787369205690940389079323334412434996525623614329408676573910762151803); // vk.K[33].Y\n        mul_input[2] = input[32];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[33] * input[32]\n        mul_input[0] = uint256(13250480124160751683662026425319692126614649754704623898304284468074453566914); // vk.K[34].X\n        mul_input[1] = uint256(5842667319974085537473375237026886465714130878203887186671280383692949371367); // vk.K[34].Y\n        mul_input[2] = input[33];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[34] * input[33]\n        mul_input[0] = uint256(4244396663084445939427850030230353204559612848770696182862006916130063961075); // vk.K[35].X\n        mul_input[1] = uint256(5567117583761251190183987315357290694204768312790348596534705058755423324166); // vk.K[35].Y\n        mul_input[2] = input[34];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[35] * input[34]\n        mul_input[0] = uint256(16468214890309010196842237213567005731971554524310253342503592222181911831216); // vk.K[36].X\n        mul_input[1] = uint256(13015440355627709680447076370593216495840212097545614001751347318260304962870); // vk.K[36].Y\n        mul_input[2] = input[35];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[36] * input[35]\n        mul_input[0] = uint256(1710502514829787762068790998518593585732164832507101474241328558660469459552); // vk.K[37].X\n        mul_input[1] = uint256(6641523787174944064207070430739280224248149581740606756642107112326594132092); // vk.K[37].Y\n        mul_input[2] = input[36];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[37] * input[36]\n        mul_input[0] = uint256(13873688322349022545411654259743538242310790895509577137595893668751435535182); // vk.K[38].X\n        mul_input[1] = uint256(2743144454147776739466147084712345009024223781055121185226575029717710864182); // vk.K[38].Y\n        mul_input[2] = input[37];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[38] * input[37]\n        mul_input[0] = uint256(5515207890157998771775835819329897799964342326708529575708915192914192717763); // vk.K[39].X\n        mul_input[1] = uint256(6830846512538057603246995968366818367160206190590285682644456335384380744224); // vk.K[39].Y\n        mul_input[2] = input[38];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[39] * input[38]\n        mul_input[0] = uint256(12084319035206948715397631350220429569745624512314143843439943565130003131475); // vk.K[40].X\n        mul_input[1] = uint256(19823940921149166526761280180611360195654754479337467436765527950957403100421); // vk.K[40].Y\n        mul_input[2] = input[39];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[40] * input[39]\n        mul_input[0] = uint256(1707966742483292923663665240004271093118893352464133867701833789750341568293); // vk.K[41].X\n        mul_input[1] = uint256(2059830066597637963266616577934465643861703524384620495213365657208172372127); // vk.K[41].Y\n        mul_input[2] = input[40];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[41] * input[40]\n        mul_input[0] = uint256(4335683960535202743801100378397366667909285456099227829020337934512681970900); // vk.K[42].X\n        mul_input[1] = uint256(7163760264613823569250071408872840488100394969233714572137432343600611323243); // vk.K[42].Y\n        mul_input[2] = input[41];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[42] * input[41]\n        mul_input[0] = uint256(18579130060975771189412379077269037710625635418528267671299513425013575199707); // vk.K[43].X\n        mul_input[1] = uint256(7413439674648248746853580336851465886481116161464911636828558414649648473619); // vk.K[43].Y\n        mul_input[2] = input[42];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[43] * input[42]\n        mul_input[0] = uint256(16042514199832592968247672418295024202640592240955629633937928114942675433499); // vk.K[44].X\n        mul_input[1] = uint256(9176210646934564968216912647498279795139899070579664859952976743279140133749); // vk.K[44].Y\n        mul_input[2] = input[43];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[44] * input[43]\n        mul_input[0] = uint256(4605826036674863045915848920224687279865356012358913781882485214370608375866); // vk.K[45].X\n        mul_input[1] = uint256(16433469797022838005221089589473953566885756258639853768294415623922164207114); // vk.K[45].Y\n        mul_input[2] = input[44];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[45] * input[44]\n        mul_input[0] = uint256(21291606718216838223612806394353023159167853021188903625675694115824239986243); // vk.K[46].X\n        mul_input[1] = uint256(13861976516244796326502185111204736567218465632382198677006716558365310272234); // vk.K[46].Y\n        mul_input[2] = input[45];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[46] * input[45]\n        mul_input[0] = uint256(13608539239013691835986711410119733227388008030702193689279242935664405256689); // vk.K[47].X\n        mul_input[1] = uint256(21464993448394658273854216484684266808321160947909209851055873325887050492293); // vk.K[47].Y\n        mul_input[2] = input[46];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[47] * input[46]\n        mul_input[0] = uint256(14508762627123999549076601587501227009682636970076636367483491513461822793735); // vk.K[48].X\n        mul_input[1] = uint256(13086806823222303647760776079580932758835172518633536905189386855031527005867); // vk.K[48].Y\n        mul_input[2] = input[47];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[48] * input[47]\n        mul_input[0] = uint256(19620443629871450449905318328661357670363144885276650727854684127004979439411); // vk.K[49].X\n        mul_input[1] = uint256(13512145302109135260648622069026293634594965443783681487284540332451024150941); // vk.K[49].Y\n        mul_input[2] = input[48];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[49] * input[48]\n        mul_input[0] = uint256(20059550415468532205827328714175420183638104824341229821332085226225097782116); // vk.K[50].X\n        mul_input[1] = uint256(12050042602361465175864197068892829808531398334073641526653775817012796904920); // vk.K[50].Y\n        mul_input[2] = input[49];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[50] * input[49]\n        mul_input[0] = uint256(13306511629433317473594641621219799176423215443967411203563081150777664297203); // vk.K[51].X\n        mul_input[1] = uint256(675454852156663320769111000409074913392067853038809175892444203322319080285); // vk.K[51].Y\n        mul_input[2] = input[50];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[51] * input[50]\n        mul_input[0] = uint256(12076096047127155639652324319628370078197547570757038002713853288385847397853); // vk.K[52].X\n        mul_input[1] = uint256(20063073818109035475283913336465472637670645911136973171672153316960017020047); // vk.K[52].Y\n        mul_input[2] = input[51];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[52] * input[51]\n        mul_input[0] = uint256(7070926176971266168429945375853092488155813841418560246899144119253540102350); // vk.K[53].X\n        mul_input[1] = uint256(18608632252819735218114751983460803259577541150988320712643403458973379890618); // vk.K[53].Y\n        mul_input[2] = input[52];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[53] * input[52]\n        mul_input[0] = uint256(8787738969091605771927429510050738225462363969120867850034866515919420616153); // vk.K[54].X\n        mul_input[1] = uint256(280860041417881042842953968111093793049575926737744905886029164850711931023); // vk.K[54].Y\n        mul_input[2] = input[53];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[54] * input[53]\n        mul_input[0] = uint256(17470729458746471811553625923859580633403777304482076029136929287269138561286); // vk.K[55].X\n        mul_input[1] = uint256(11077695780520668039728878524992441159739768910332004302025495828550310823044); // vk.K[55].Y\n        mul_input[2] = input[54];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[55] * input[54]\n        mul_input[0] = uint256(18820732662126470829529155830450341599504017356119489964316929892787212659148); // vk.K[56].X\n        mul_input[1] = uint256(18398462213470099652091858533789910876899706114418611429055433371437676169588); // vk.K[56].Y\n        mul_input[2] = input[55];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[56] * input[55]\n        mul_input[0] = uint256(10979958723839781582509983389549268556375745246890018812028152329350660809099); // vk.K[57].X\n        mul_input[1] = uint256(8614377901484706884530978841565040782347190141813157341928120361805065861265); // vk.K[57].Y\n        mul_input[2] = input[56];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[57] * input[56]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/Initializable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nabstract contract Initializable {\n    bool internal _initialized;\n\n    modifier onlyUninitialized() {\n        require(!_initialized, \"already initialized\");\n        _;\n    }\n\n    modifier onlyInitialized() {\n        require(_initialized, \"not initialized\");\n        _;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/interfaces/IApplication.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface IApplication {\n    /**\n     * @dev Handle syn package\n     */\n    function handleSynPackage(uint8 channelId, bytes calldata msgBytes) external returns (bytes memory responsePayload);\n\n    /**\n     * @dev Handle ack package\n     */\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n\n    /**\n     * @dev Handle fail ack package\n     */\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/interfaces/ICrossChain.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface ICrossChain {\n    /**\n     * @dev Send package to Binance Chain\n     */\n    function sendSynPackage(uint8 channelId, bytes calldata msgBytes, uint256 relayFee) external;\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/interfaces/ITendermintLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface ITendermintLightClient {\n    function isHeaderSynced(uint64 height) external view returns (bool);\n\n    function getAppHash(uint64 height) external view returns (bytes32);\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nlibrary Bytes {\n    function toBytes32(bytes memory bz) internal pure returns (bytes32 ret) {\n        require(bz.length == 32, \"Bytes: toBytes32 invalid size\");\n        assembly {\n            ret := mload(add(bz, 32))\n        }\n    }\n\n    function toBytes(bytes32 data) public pure returns (bytes memory) {\n        return abi.encodePacked(data);\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64 ret) {\n        require(_bytes.length >= _start + 8, \"Bytes: toUint64 out of bounds\");\n        assembly {\n            ret := mload(add(add(_bytes, 0x8), _start))\n        }\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"Bytes: toUint256 out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAddress(bytes memory _bytes) internal pure returns (address addr) {\n        // convert last 20 bytes of keccak hash (bytes32) to address\n        bytes32 hash = keccak256(_bytes);\n        assembly {\n            mstore(0, hash)\n            addr := mload(0)\n        }\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/crypto/MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../proto/TendermintHelper.sol\";\nimport {SimpleValidator, Validator} from \"../proto/TendermintLight.sol\";\n\nlibrary MerkleTree {\n    /**\n     * @dev returns empty hash\n     */\n    function emptyHash() internal pure returns (bytes32) {\n        return sha256(abi.encode());\n    }\n\n    /**\n     * @dev returns tmhash(0x00 || leaf)\n     *\n     */\n    function leafHash(bytes memory leaf) internal pure returns (bytes32) {\n        uint8 leafPrefix = 0x00;\n        return sha256(abi.encodePacked(leafPrefix, leaf));\n    }\n\n    /**\n     * @dev returns tmhash(0x01 || left || right)\n     */\n    function innerHash(bytes32 leaf, bytes32 right) internal pure returns (bytes32) {\n        uint8 innerPrefix = 0x01;\n        return sha256(abi.encodePacked(innerPrefix, leaf, right));\n    }\n\n    /**\n     * @dev returns the largest power of 2 less than length\n     *\n     * TODO: This function can be optimized with bit shifting approach:\n     * https://www.baeldung.com/java-largest-power-of-2-less-than-number\n     */\n    function getSplitPoint(uint256 input) internal pure returns (uint256) {\n        require(input > 1, \"MerkleTree: invalid input\");\n\n        uint256 result = 1;\n        for (uint256 i = input - 1; i > 1; i--) {\n            if ((i & (i - 1)) == 0) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev computes a Merkle tree where the leaves are validators, in the provided order\n     * Follows RFC-6962\n     */\n    function merkleRootHash(\n        Validator.Data[] memory validators,\n        uint256 start,\n        uint256 total\n    ) internal pure returns (bytes32) {\n        if (total == 0) {\n            return emptyHash();\n        } else if (total == 1) {\n            bytes memory encodedValidator = SimpleValidator.encode(\n                TendermintHelper.toSimpleValidator(validators[start])\n            );\n            return leafHash(encodedValidator);\n        } else {\n            uint256 k = getSplitPoint(total);\n            bytes32 left = merkleRootHash(validators, start, k); // validators[:k]\n            bytes32 right = merkleRootHash(validators, start + k, total - k); // validators[k:]\n            return innerHash(left, right);\n        }\n    }\n\n    /**\n     * @dev computes a Merkle tree where the leaves are the byte slice in the provided order\n     * Follows RFC-6962\n     */\n    function merkleRootHash(bytes[14] memory validators, uint256 start, uint256 total) internal pure returns (bytes32) {\n        if (total == 0) {\n            return emptyHash();\n        } else if (total == 1) {\n            return leafHash(validators[start]);\n        } else {\n            uint256 k = getSplitPoint(total);\n            bytes32 left = merkleRootHash(validators, start, k); // validators[:k]\n            bytes32 right = merkleRootHash(validators, start + k, total - k); // validators[k:]\n            return innerHash(left, right);\n        }\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/ics23/ics23.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {BatchProof, CompressedBatchProof, CommitmentProof, ProofSpec, ExistenceProof, NonExistenceProof} from \"../proto/Proofs.sol\";\nimport {Compress} from \"./ics23Compress.sol\";\nimport {Proof} from \"./ics23Proof.sol\";\nimport {Ops} from \"./ics23Ops.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary Ics23 {\n    enum VerifyMembershipError {\n        None,\n        ExistenceProofIsNil,\n        ProofVerify\n    }\n\n    // verifyMembership, throws an exception in case anything goes wrong\n    function verifyMembership(\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        CommitmentProof.Data memory proof,\n        bytes memory key,\n        bytes memory value\n    ) internal pure returns (VerifyMembershipError) {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        ExistenceProof.Data memory exiProof = getExistProofForKey(decoProof, key);\n\n        //require(ExistenceProof.isNil(exiProof) == false); // dev: getExistProofForKey not available\n        if (ExistenceProof.isNil(exiProof)) return VerifyMembershipError.ExistenceProofIsNil;\n        Proof.VerifyExistenceError vCode = Proof.verify(exiProof, spec, commitmentRoot, key, value);\n        if (vCode != Proof.VerifyExistenceError.None) return VerifyMembershipError.ProofVerify;\n\n        return VerifyMembershipError.None;\n    }\n\n    enum VerifyNonMembershipError {\n        None,\n        NonExistenceProofIsNil,\n        ProofVerify\n    }\n\n    function verifyNonMembership(\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        CommitmentProof.Data memory proof,\n        bytes memory key\n    ) internal pure returns (VerifyNonMembershipError) {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        NonExistenceProof.Data memory nonProof = getNonExistProofForKey(decoProof, key);\n        //require(NonExistenceProof.isNil(nonProof) == false); // dev: getNonExistProofForKey not available\n        if (NonExistenceProof.isNil(nonProof)) return VerifyNonMembershipError.NonExistenceProofIsNil;\n        Proof.VerifyNonExistenceError vCode = Proof.verify(nonProof, spec, commitmentRoot, key);\n        if (vCode != Proof.VerifyNonExistenceError.None) return VerifyNonMembershipError.ProofVerify;\n\n        return VerifyNonMembershipError.None;\n    }\n\n    /* -- temporarily disabled as they are not covered by unit tests\n    struct BatchItem {\n        bytes key;\n        bytes value;\n    }\n    function batchVerifyMembership(ProofSpec.Data memory spec, bytes memory commitmentRoot, CommitmentProof.Data memory proof, BatchItem[] memory items ) internal pure {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        for (uint i = 0; i < items.length; i++) {\n            verifyMembership(spec, commitmentRoot, decoProof, items[i].key, items[i].value);\n        }\n    }\n\n    function batchVerifyNonMembership(ProofSpec.Data memory spec, bytes memory commitmentRoot, CommitmentProof.Data memory proof, bytes[] memory keys ) internal pure {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        for (uint i = 0; i < keys.length; i++) {\n            verifyNonMembership(spec, commitmentRoot, decoProof, keys[i]);\n        }\n    }\n*/\n\n    // private\n    function getExistProofForKey(\n        CommitmentProof.Data memory proof,\n        bytes memory key\n    ) private pure returns (ExistenceProof.Data memory) {\n        if (ExistenceProof.isNil(proof.exist) == false) {\n            if (BytesLib.equal(proof.exist.key, key) == true) {\n                return proof.exist;\n            }\n        } else if (BatchProof.isNil(proof.batch) == false) {\n            for (uint256 i = 0; i < proof.batch.entries.length; i++) {\n                if (\n                    ExistenceProof.isNil(proof.batch.entries[i].exist) == false &&\n                    BytesLib.equal(proof.batch.entries[i].exist.key, key)\n                ) {\n                    return proof.batch.entries[i].exist;\n                }\n            }\n        }\n        return ExistenceProof.nil();\n    }\n\n    function getNonExistProofForKey(\n        CommitmentProof.Data memory proof,\n        bytes memory key\n    ) private pure returns (NonExistenceProof.Data memory) {\n        if (NonExistenceProof.isNil(proof.nonexist) == false) {\n            if (isLeft(proof.nonexist.left, key) && isRight(proof.nonexist.right, key)) {\n                return proof.nonexist;\n            }\n        } else if (BatchProof.isNil(proof.batch) == false) {\n            for (uint256 i = 0; i < proof.batch.entries.length; i++) {\n                if (\n                    NonExistenceProof.isNil(proof.batch.entries[i].nonexist) == false &&\n                    isLeft(proof.batch.entries[i].nonexist.left, key) &&\n                    isRight(proof.batch.entries[i].nonexist.right, key)\n                ) {\n                    return proof.batch.entries[i].nonexist;\n                }\n            }\n        }\n        return NonExistenceProof.nil();\n    }\n\n    function isLeft(ExistenceProof.Data memory left, bytes memory key) private pure returns (bool) {\n        // ExistenceProof.isNil does not work\n        return ExistenceProof._empty(left) || Ops.compare(left.key, key) < 0;\n    }\n\n    function isRight(ExistenceProof.Data memory right, bytes memory key) private pure returns (bool) {\n        // ExistenceProof.isNil does not work\n        return ExistenceProof._empty(right) || Ops.compare(right.key, key) > 0;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/ics23/ics23Compress.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {InnerOp, ExistenceProof, NonExistenceProof, CommitmentProof, CompressedBatchEntry, CompressedBatchProof, CompressedExistenceProof, BatchEntry, BatchProof} from \"../proto/Proofs.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nlibrary Compress {\n    function decompress(CommitmentProof.Data memory proof) internal pure returns (CommitmentProof.Data memory) {\n        //CompressedBatchProof.isNil() does not work\n        if (CompressedBatchProof._empty(proof.compressed) == true) {\n            return proof;\n        }\n        return\n            CommitmentProof.Data({\n                exist: ExistenceProof.nil(),\n                nonexist: NonExistenceProof.nil(),\n                batch: BatchProof.Data({entries: decompress(proof.compressed)}),\n                compressed: CompressedBatchProof.nil()\n            });\n    }\n\n    // private\n    function decompress(CompressedBatchProof.Data memory proof) private pure returns (BatchEntry.Data[] memory) {\n        BatchEntry.Data[] memory entries = new BatchEntry.Data[](proof.entries.length);\n        for (uint256 i = 0; i < proof.entries.length; i++) {\n            entries[i] = decompressEntry(proof.entries[i], proof.lookup_inners);\n        }\n        return entries;\n    }\n\n    function decompressEntry(\n        CompressedBatchEntry.Data memory entry,\n        InnerOp.Data[] memory lookup\n    ) private pure returns (BatchEntry.Data memory) {\n        //CompressedExistenceProof.isNil does not work\n        if (CompressedExistenceProof._empty(entry.exist) == false) {\n            return BatchEntry.Data({exist: decompressExist(entry.exist, lookup), nonexist: NonExistenceProof.nil()});\n        }\n        return\n            BatchEntry.Data({\n                exist: ExistenceProof.nil(),\n                nonexist: NonExistenceProof.Data({\n                    key: entry.nonexist.key,\n                    left: decompressExist(entry.nonexist.left, lookup),\n                    right: decompressExist(entry.nonexist.right, lookup)\n                })\n            });\n    }\n\n    function decompressExist(\n        CompressedExistenceProof.Data memory proof,\n        InnerOp.Data[] memory lookup\n    ) private pure returns (ExistenceProof.Data memory) {\n        if (CompressedExistenceProof._empty(proof)) {\n            return ExistenceProof.nil();\n        }\n        ExistenceProof.Data memory decoProof = ExistenceProof.Data({\n            key: proof.key,\n            value: proof.value,\n            leaf: proof.leaf,\n            path: new InnerOp.Data[](proof.path.length)\n        });\n        for (uint256 i = 0; i < proof.path.length; i++) {\n            require(proof.path[i] >= 0); // dev: proof.path < 0\n            uint256 step = SafeCast.toUint256(proof.path[i]);\n            require(step < lookup.length); // dev: step >= lookup.length\n            decoProof.path[i] = lookup[step];\n        }\n        return decoProof;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/ics23/ics23Ops.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {LeafOp, InnerOp, PROOFS_PROTO_GLOBAL_ENUMS, ProofSpec} from \"../proto/Proofs.sol\";\nimport {ProtoBufRuntime} from \"../proto/ProtoBufRuntime.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary Ops {\n    bytes constant empty = new bytes(0);\n\n    enum ApplyLeafOpError {\n        None,\n        KeyLength,\n        ValueLength,\n        DoHash,\n        PrepareLeafData\n    }\n\n    // LeafOp operations\n    function applyOp(\n        LeafOp.Data memory leafOp,\n        bytes memory key,\n        bytes memory value\n    ) internal pure returns (bytes memory, ApplyLeafOpError) {\n        //require(key.length > 0); // dev: Leaf op needs key\n        if (key.length == 0) return (empty, ApplyLeafOpError.KeyLength);\n        //require(value.length > 0); // dev: Leaf op needs value\n        if (value.length == 0) return (empty, ApplyLeafOpError.ValueLength);\n        (bytes memory pKey, PrepareLeafDataError pCode1) = prepareLeafData(leafOp.prehash_key, leafOp.length, key);\n        if (pCode1 != PrepareLeafDataError.None) return (empty, ApplyLeafOpError.PrepareLeafData);\n        (bytes memory pValue, PrepareLeafDataError pCode2) = prepareLeafData(\n            leafOp.prehash_value,\n            leafOp.length,\n            value\n        );\n        if (pCode2 != PrepareLeafDataError.None) return (empty, ApplyLeafOpError.PrepareLeafData);\n        bytes memory data = abi.encodePacked(leafOp.prefix, pKey, pValue);\n        (bytes memory hashed, DoHashError hCode) = doHash(leafOp.hash, data);\n        if (hCode != DoHashError.None) return (empty, ApplyLeafOpError.DoHash);\n        return (hashed, ApplyLeafOpError.None);\n    }\n\n    enum PrepareLeafDataError {\n        None,\n        DoHash,\n        DoLengthOp\n    }\n\n    // preapare leaf data for encoding\n    function prepareLeafData(\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hashOp,\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp lenOp,\n        bytes memory data\n    ) internal pure returns (bytes memory, PrepareLeafDataError) {\n        (bytes memory hased, DoHashError hCode) = doHashOrNoop(hashOp, data);\n        if (hCode != DoHashError.None) return (empty, PrepareLeafDataError.DoHash);\n        (bytes memory res, DoLengthOpError lCode) = doLengthOp(lenOp, hased);\n        if (lCode != DoLengthOpError.None) return (empty, PrepareLeafDataError.DoLengthOp);\n\n        return (res, PrepareLeafDataError.None);\n    }\n\n    enum CheckAgainstSpecError {\n        None,\n        Hash,\n        PreHashKey,\n        PreHashValue,\n        Length,\n        MinPrefixLength,\n        HasPrefix,\n        MaxPrefixLength\n    }\n\n    function checkAgainstSpec(\n        LeafOp.Data memory leafOp,\n        ProofSpec.Data memory spec\n    ) internal pure returns (CheckAgainstSpecError) {\n        require(leafOp.hash == spec.leaf_spec.hash, \"checkAgainstSpec for LeafOp - Unexpected HashOp\"); // dev: checkAgainstSpec for LeafOp - Unexpected HashOp\n        if (leafOp.hash != spec.leaf_spec.hash) return CheckAgainstSpecError.Hash;\n        require(\n            leafOp.prehash_key == spec.leaf_spec.prehash_key,\n            \"checkAgainstSpec for LeafOp - Unexpected PrehashKey\"\n        ); // dev: checkAgainstSpec for LeafOp - Unexpected PrehashKey\n        if (leafOp.prehash_key != spec.leaf_spec.prehash_key) return CheckAgainstSpecError.PreHashKey;\n        require(\n            leafOp.prehash_value == spec.leaf_spec.prehash_value,\n            \"checkAgainstSpec for LeafOp - Unexpected PrehashValue\"\n        ); // dev: checkAgainstSpec for LeafOp - Unexpected PrehashValue\");\n        if (leafOp.prehash_value != spec.leaf_spec.prehash_value) return CheckAgainstSpecError.PreHashValue;\n        require(leafOp.length == spec.leaf_spec.length, \"checkAgainstSpec for LeafOp - Unexpected lengthOp\"); // dev: checkAgainstSpec for LeafOp - Unexpected lengthOp\n        if (leafOp.length != spec.leaf_spec.length) return CheckAgainstSpecError.Length;\n        bool hasprefix = hasPrefix(leafOp.prefix, spec.leaf_spec.prefix);\n        require(hasprefix, \"checkAgainstSpec for LeafOp - Leaf Prefix doesn't start with\"); // dev: checkAgainstSpec for LeafOp - Leaf Prefix doesn't start with\n        if (hasprefix == false) return CheckAgainstSpecError.HasPrefix;\n\n        return CheckAgainstSpecError.None;\n    }\n\n    enum ApplyInnerOpError {\n        None,\n        ChildLength,\n        DoHash\n    }\n\n    // InnerOp operations\n    function applyOp(\n        InnerOp.Data memory innerOp,\n        bytes memory child\n    ) internal pure returns (bytes memory, ApplyInnerOpError) {\n        //require(child.length > 0); // dev: Inner op needs child value\n        if (child.length == 0) return (empty, ApplyInnerOpError.ChildLength);\n        bytes memory preImage = abi.encodePacked(innerOp.prefix, child, innerOp.suffix);\n        (bytes memory hashed, DoHashError code) = doHash(innerOp.hash, preImage);\n        if (code != DoHashError.None) return (empty, ApplyInnerOpError.DoHash);\n\n        return (hashed, ApplyInnerOpError.None);\n    }\n\n    function checkAgainstSpec(\n        InnerOp.Data memory innerOp,\n        ProofSpec.Data memory spec\n    ) internal pure returns (CheckAgainstSpecError) {\n        // require(innerOp.hash == spec.inner_spec.hash, \"checkAgainstSpec for InnerOp - Unexpected HashOp\"); // dev: checkAgainstSpec for InnerOp - Unexpected HashOp\n        if (innerOp.hash != spec.inner_spec.hash) return CheckAgainstSpecError.Hash;\n        uint256 minPrefixLength = SafeCast.toUint256(spec.inner_spec.min_prefix_length);\n        // require(innerOp.prefix.length >= minPrefixLength, \"InnerOp prefix too short\"); // dev: InnerOp prefix too short\n        if (innerOp.prefix.length < minPrefixLength) return CheckAgainstSpecError.MinPrefixLength;\n        bytes memory leafPrefix = spec.leaf_spec.prefix;\n        bool hasprefix = hasPrefix(innerOp.prefix, leafPrefix);\n        // require(hasprefix == false, \"Inner Prefix starts with wrong value\"); // dev: Inner Prefix starts with wrong value\n        if (hasprefix) return CheckAgainstSpecError.HasPrefix;\n        uint256 childSize = SafeCast.toUint256(spec.inner_spec.child_size);\n        uint256 maxLeftChildBytes = (spec.inner_spec.child_order.length - 1) * childSize;\n        uint256 maxPrefixLength = SafeCast.toUint256(spec.inner_spec.max_prefix_length);\n        // require(innerOp.prefix.length <= maxPrefixLength + maxLeftChildBytes, \"InnerOp prefix too long\"); // dev: InnerOp prefix too long\n        if (innerOp.prefix.length > maxPrefixLength + maxLeftChildBytes) return CheckAgainstSpecError.MaxPrefixLength;\n\n        return CheckAgainstSpecError.None;\n    }\n\n    function doHashOrNoop(\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hashOp,\n        bytes memory preImage\n    ) internal pure returns (bytes memory, DoHashError) {\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.NO_HASH) {\n            return (preImage, DoHashError.None);\n        }\n        return doHash(hashOp, preImage);\n    }\n\n    enum DoHashError {\n        None,\n        Sha512,\n        Sha512_256,\n        Unsupported\n    }\n\n    function doHash(\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hashOp,\n        bytes memory preImage\n    ) internal pure returns (bytes memory, DoHashError) {\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256) {\n            return (abi.encodePacked(sha256(preImage)), DoHashError.None);\n        }\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.KECCAK) {\n            return (abi.encodePacked(keccak256(preImage)), DoHashError.None);\n        }\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.RIPEMD160) {\n            return (abi.encodePacked(ripemd160(preImage)), DoHashError.None);\n        }\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.BITCOIN) {\n            bytes memory tmp = abi.encodePacked(sha256(preImage));\n            return (abi.encodePacked(ripemd160(tmp)), DoHashError.None);\n        }\n        //require(hashOp != PROOFS_PROTO_GLOBAL_ENUMS.HashOp.Sha512); // dev: SHA512 not supported\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA512) {\n            return (empty, DoHashError.Sha512);\n        }\n        //require(hashOp != PROOFS_PROTO_GLOBAL_ENUMS.HashOp.Sha512_256); // dev: SHA512_256 not supported\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA512_256) {\n            return (empty, DoHashError.Sha512_256);\n        }\n        //revert(); // dev: Unsupported hashOp\n        return (empty, DoHashError.Unsupported);\n    }\n\n    function compare(bytes memory a, bytes memory b) internal pure returns (int256) {\n        uint256 minLen = Math.min(a.length, b.length);\n        for (uint256 i = 0; i < minLen; i++) {\n            if (uint8(a[i]) < uint8(b[i])) {\n                return -1;\n            } else if (uint8(a[i]) > uint8(b[i])) {\n                return 1;\n            }\n        }\n        if (a.length > minLen) {\n            return 1;\n        }\n        if (b.length > minLen) {\n            return -1;\n        }\n        return 0;\n    }\n\n    // private\n    enum DoLengthOpError {\n        None,\n        Require32DataLength,\n        Require64DataLength,\n        Unsupported\n    }\n\n    function doLengthOp(\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp lenOp,\n        bytes memory data\n    ) private pure returns (bytes memory, DoLengthOpError) {\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.NO_PREFIX) {\n            return (data, DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.VAR_PROTO) {\n            uint256 sz = ProtoBufRuntime._sz_varint(data.length);\n            bytes memory encoded = new bytes(sz);\n            ProtoBufRuntime._encode_varint(data.length, 32, encoded);\n            return (abi.encodePacked(encoded, data), DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.REQUIRE_32_BYTES) {\n            //require(data.length == 32); // dev: data.length != 32\n            if (data.length != 32) return (empty, DoLengthOpError.Require32DataLength);\n\n            return (data, DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.REQUIRE_64_BYTES) {\n            //require(data.length == 64); // dev: data.length != 64\"\n            if (data.length != 64) return (empty, DoLengthOpError.Require64DataLength);\n\n            return (data, DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.FIXED32_LITTLE) {\n            uint32 size = SafeCast.toUint32(data.length);\n            // maybe some assembly here to make it faster\n            bytes4 sizeB = bytes4(size);\n            bytes memory littleE = new bytes(4);\n            //unfolding for loop is cheaper\n            littleE[0] = sizeB[3];\n            littleE[1] = sizeB[2];\n            littleE[2] = sizeB[1];\n            littleE[3] = sizeB[0];\n            return (abi.encodePacked(littleE, data), DoLengthOpError.None);\n        }\n        //revert(); // dev: Unsupported lenOp\n        return (empty, DoLengthOpError.Unsupported);\n    }\n\n    function hasPrefix(bytes memory element, bytes memory prefix) private pure returns (bool) {\n        if (prefix.length == 0) {\n            return true;\n        }\n        if (prefix.length > element.length) {\n            return false;\n        }\n        bytes memory slice = BytesLib.slice(element, 0, prefix.length);\n        return BytesLib.equal(prefix, slice);\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/ics23/ics23Proof.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {LeafOp, CompressedBatchProof, ExistenceProof, NonExistenceProof, BatchEntry, BatchProof, ProofSpec, InnerOp, InnerSpec, CommitmentProof} from \"../proto/Proofs.sol\";\nimport {Ops} from \"./ics23Ops.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {Compress} from \"./ics23Compress.sol\";\nimport {Ops} from \"./ics23Ops.sol\";\n\nlibrary Proof {\n    bytes constant empty = new bytes(0);\n\n    enum VerifyExistenceError {\n        None,\n        KeyNotMatching,\n        ValueNotMatching,\n        CheckSpec,\n        CalculateRoot,\n        RootNotMatching\n    }\n\n    // ExistenceProof\n    function verify(\n        ExistenceProof.Data memory proof,\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        bytes memory key,\n        bytes memory value\n    ) internal pure returns (VerifyExistenceError) {\n        //require(BytesLib.equal(proof.key, key)); // dev: Provided key doesn't match proof\n        bool keyMatch = BytesLib.equal(proof.key, key);\n        if (keyMatch == false) return VerifyExistenceError.KeyNotMatching;\n        //require(BytesLib.equal(proof.value, value)); // dev: Provided value doesn't match proof\n        bool valueMatch = BytesLib.equal(proof.value, value);\n        if (valueMatch == false) return VerifyExistenceError.ValueNotMatching;\n        CheckAgainstSpecError cCode = checkAgainstSpec(proof, spec);\n        if (cCode != CheckAgainstSpecError.None) return VerifyExistenceError.CheckSpec;\n        (bytes memory root, CalculateRootError rCode) = calculateRoot(proof);\n        if (rCode != CalculateRootError.None) return VerifyExistenceError.CalculateRoot;\n        //require(BytesLib.equal(root, commitmentRoot)); // dev: Calculated root doesn't match provided root\n        bool rootMatch = BytesLib.equal(root, commitmentRoot);\n        if (rootMatch == false) return VerifyExistenceError.RootNotMatching;\n\n        return VerifyExistenceError.None;\n    }\n\n    enum CalculateRootError {\n        None,\n        LeafNil,\n        LeafOp,\n        PathOp,\n        BatchEntriesLength,\n        BatchEntryEmpty,\n        EmptyProof\n    }\n\n    function calculateRoot(ExistenceProof.Data memory proof) internal pure returns (bytes memory, CalculateRootError) {\n        //require(LeafOp.isNil(proof.leaf) == false); // dev: Existence Proof needs defined LeafOp\n        if (LeafOp.isNil(proof.leaf)) return (empty, CalculateRootError.LeafNil);\n        (bytes memory root, Ops.ApplyLeafOpError lCode) = Ops.applyOp(proof.leaf, proof.key, proof.value);\n        if (lCode != Ops.ApplyLeafOpError.None) return (empty, CalculateRootError.LeafOp);\n        for (uint256 i = 0; i < proof.path.length; i++) {\n            Ops.ApplyInnerOpError iCode;\n            (root, iCode) = Ops.applyOp(proof.path[i], root);\n            if (iCode != Ops.ApplyInnerOpError.None) return (empty, CalculateRootError.PathOp);\n        }\n\n        return (root, CalculateRootError.None);\n    }\n\n    enum CheckAgainstSpecError {\n        None,\n        EmptyLeaf,\n        OpsCheckAgainstSpec,\n        InnerOpsDepthTooShort,\n        InnerOpsDepthTooLong\n    }\n\n    function checkAgainstSpec(\n        ExistenceProof.Data memory proof,\n        ProofSpec.Data memory spec\n    ) internal pure returns (CheckAgainstSpecError) {\n        // LeafOp.isNil does not work\n        //require(LeafOp._empty(proof.leaf) == false); // dev: Existence Proof needs defined LeafOp\n        if (LeafOp._empty(proof.leaf)) return CheckAgainstSpecError.EmptyLeaf;\n        Ops.CheckAgainstSpecError cCode = Ops.checkAgainstSpec(proof.leaf, spec);\n        if (cCode != Ops.CheckAgainstSpecError.None) return CheckAgainstSpecError.OpsCheckAgainstSpec;\n        if (spec.min_depth > 0) {\n            bool innerOpsDepthTooShort = proof.path.length < SafeCast.toUint256(int256(spec.min_depth));\n            //require(innerOpsDepthTooShort == false); // dev: InnerOps depth too short\n            if (innerOpsDepthTooShort) return CheckAgainstSpecError.InnerOpsDepthTooShort;\n        }\n        if (spec.max_depth > 0) {\n            bool innerOpsDepthTooLong = proof.path.length > SafeCast.toUint256(int256(spec.max_depth));\n            //require(innerOpsDepthTooLong == false); // dev: InnerOps depth too long\n            if (innerOpsDepthTooLong) return CheckAgainstSpecError.InnerOpsDepthTooLong;\n        }\n        for (uint256 i = 0; i < proof.path.length; i++) {\n            Ops.CheckAgainstSpecError cCode = Ops.checkAgainstSpec(proof.path[i], spec);\n            if (cCode != Ops.CheckAgainstSpecError.None) return CheckAgainstSpecError.OpsCheckAgainstSpec;\n        }\n    }\n\n    enum VerifyNonExistenceError {\n        None,\n        VerifyLeft,\n        VerifyRight,\n        LeftAndRightKeyEmpty,\n        RightKeyRange,\n        LeftKeyRange,\n        RightProofLeftMost,\n        LeftProofRightMost,\n        IsLeftNeighbor\n    }\n\n    // NonExistenceProof\n    function verify(\n        NonExistenceProof.Data memory proof,\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        bytes memory key\n    ) internal pure returns (VerifyNonExistenceError) {\n        bytes memory leftKey;\n        bytes memory rightKey;\n        // ExistenceProof.isNil does not work\n        if (ExistenceProof._empty(proof.left) == false) {\n            VerifyExistenceError eCode = verify(proof.left, spec, commitmentRoot, proof.left.key, proof.left.value);\n            if (eCode != VerifyExistenceError.None) return VerifyNonExistenceError.VerifyLeft;\n\n            leftKey = proof.left.key;\n        }\n        if (ExistenceProof._empty(proof.right) == false) {\n            VerifyExistenceError eCode = verify(proof.right, spec, commitmentRoot, proof.right.key, proof.right.value);\n            if (eCode != VerifyExistenceError.None) return VerifyNonExistenceError.VerifyRight;\n\n            rightKey = proof.right.key;\n        }\n        // If both proofs are missing, this is not a valid proof\n        //require(leftKey.length > 0 || rightKey.length > 0); // dev: both left and right proofs missing\n        if (leftKey.length == 0 && rightKey.length == 0) return VerifyNonExistenceError.LeftAndRightKeyEmpty;\n        // Ensure in valid range\n        if (rightKey.length > 0 && Ops.compare(key, rightKey) >= 0) {\n            //require(Ops.compare(key, rightKey) < 0); // dev: key is not left of right proof\n            return VerifyNonExistenceError.RightKeyRange;\n        }\n        if (leftKey.length > 0 && Ops.compare(key, leftKey) <= 0) {\n            //require(Ops.compare(key, leftKey) > 0); // dev: key is not right of left proof\n            return VerifyNonExistenceError.LeftKeyRange;\n        }\n        if (leftKey.length == 0) {\n            //require(isLeftMost(spec.inner_spec, proof.right.path)); // dev: left proof missing, right proof must be left-most\n            if (isLeftMost(spec.inner_spec, proof.right.path) == false)\n                return VerifyNonExistenceError.RightProofLeftMost;\n        } else if (rightKey.length == 0) {\n            //require(isRightMost(spec.inner_spec, proof.left.path)); // dev: isRightMost: right proof missing, left proof must be right-most\n            if (isRightMost(spec.inner_spec, proof.left.path) == false)\n                return VerifyNonExistenceError.LeftProofRightMost;\n        } else {\n            //require(isLeftNeighbor(spec.inner_spec, proof.left.path, proof.right.path)); // dev: isLeftNeighbor: right proof missing, left proof must be right-most\n            bool isLeftNeigh = isLeftNeighbor(spec.inner_spec, proof.left.path, proof.right.path);\n            if (isLeftNeigh == false) return VerifyNonExistenceError.IsLeftNeighbor;\n        }\n\n        return VerifyNonExistenceError.None;\n    }\n\n    function calculateRoot(\n        NonExistenceProof.Data memory proof\n    ) internal pure returns (bytes memory, CalculateRootError) {\n        if (ExistenceProof._empty(proof.left) == false) {\n            return calculateRoot(proof.left);\n        }\n        if (ExistenceProof._empty(proof.right) == false) {\n            return calculateRoot(proof.right);\n        }\n        //revert(); // dev: Nonexistence proof has empty Left and Right proof\n        return (empty, CalculateRootError.EmptyProof);\n    }\n\n    // commitment proof\n    function calculateRoot(CommitmentProof.Data memory proof) internal pure returns (bytes memory, CalculateRootError) {\n        if (ExistenceProof._empty(proof.exist) == false) {\n            return calculateRoot(proof.exist);\n        }\n        if (NonExistenceProof._empty(proof.nonexist) == false) {\n            return calculateRoot(proof.nonexist);\n        }\n        if (BatchProof._empty(proof.batch) == false) {\n            //require(proof.batch.entries.length > 0); // dev: batch proof has no entry\n            if (proof.batch.entries.length == 0) return (empty, CalculateRootError.BatchEntriesLength);\n            //require(BatchEntry._empty(proof.batch.entries[0]) == false); // dev: batch proof has empty entry\n            if (BatchEntry._empty(proof.batch.entries[0])) return (empty, CalculateRootError.BatchEntryEmpty);\n            if (ExistenceProof._empty(proof.batch.entries[0].exist) == false) {\n                return calculateRoot(proof.batch.entries[0].exist);\n            }\n            if (NonExistenceProof._empty(proof.batch.entries[0].nonexist) == false) {\n                return calculateRoot(proof.batch.entries[0].nonexist);\n            }\n        }\n        if (CompressedBatchProof._empty(proof.compressed) == false) {\n            return calculateRoot(Compress.decompress(proof));\n        }\n        //revert(); // dev: calculateRoot(CommitmentProof) empty proof\n        return (empty, CalculateRootError.EmptyProof);\n    }\n\n    // private\n    function isLeftMost(InnerSpec.Data memory spec, InnerOp.Data[] memory path) private pure returns (bool) {\n        (uint256 minPrefix, uint256 maxPrefix, uint256 suffix, GetPaddingError gCode) = getPadding(spec, 0);\n        if (gCode != GetPaddingError.None) return false;\n        for (uint256 i = 0; i < path.length; i++) {\n            if (hasPadding(path[i], minPrefix, maxPrefix, suffix) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function isRightMost(InnerSpec.Data memory spec, InnerOp.Data[] memory path) private pure returns (bool) {\n        uint256 last = spec.child_order.length - 1;\n        (uint256 minPrefix, uint256 maxPrefix, uint256 suffix, GetPaddingError gCode) = getPadding(spec, last);\n        if (gCode != GetPaddingError.None) return false;\n        for (uint256 i = 0; i < path.length; i++) {\n            if (hasPadding(path[i], minPrefix, maxPrefix, suffix) == false) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function isLeftStep(\n        InnerSpec.Data memory spec,\n        InnerOp.Data memory left,\n        InnerOp.Data memory right\n    ) private pure returns (bool) {\n        (uint256 leftIdx, OrderFromPaddingError lCode) = orderFromPadding(spec, left);\n        if (lCode != OrderFromPaddingError.None) return false;\n        (uint256 rightIdx, OrderFromPaddingError rCode) = orderFromPadding(spec, right);\n        if (lCode != OrderFromPaddingError.None) return false;\n        if (rCode != OrderFromPaddingError.None) return false;\n\n        return rightIdx == leftIdx + 1;\n    }\n\n    function isLeftNeighbor(\n        InnerSpec.Data memory spec,\n        InnerOp.Data[] memory left,\n        InnerOp.Data[] memory right\n    ) private pure returns (bool) {\n        uint256 leftIdx = left.length - 1;\n        uint256 rightIdx = right.length - 1;\n        while (leftIdx >= 0 && rightIdx >= 0) {\n            if (\n                BytesLib.equal(left[leftIdx].prefix, right[rightIdx].prefix) &&\n                BytesLib.equal(left[leftIdx].suffix, right[rightIdx].suffix)\n            ) {\n                leftIdx -= 1;\n                rightIdx -= 1;\n                continue;\n            }\n            break;\n        }\n        if (isLeftStep(spec, left[leftIdx], right[rightIdx]) == false) {\n            return false;\n        }\n        // slicing does not work for ``memory`` types\n        if (isRightMost(spec, sliceInnerOps(left, 0, leftIdx)) == false) {\n            return false;\n        }\n        if (isLeftMost(spec, sliceInnerOps(right, 0, rightIdx)) == false) {\n            return false;\n        }\n        return true;\n    }\n\n    enum OrderFromPaddingError {\n        None,\n        NotFound,\n        GetPadding\n    }\n\n    function orderFromPadding(\n        InnerSpec.Data memory spec,\n        InnerOp.Data memory op\n    ) private pure returns (uint256, OrderFromPaddingError) {\n        uint256 maxBranch = spec.child_order.length;\n        for (uint256 branch = 0; branch < maxBranch; branch++) {\n            (uint256 minp, uint256 maxp, uint256 suffix, GetPaddingError gCode) = getPadding(spec, branch);\n            if (gCode != GetPaddingError.None) return (0, OrderFromPaddingError.GetPadding);\n            if (hasPadding(op, minp, maxp, suffix) == true) return (branch, OrderFromPaddingError.None);\n        }\n        //revert(); // dev: Cannot find any valid spacing for this node\n        return (0, OrderFromPaddingError.NotFound);\n    }\n\n    enum GetPaddingError {\n        None,\n        GetPosition\n    }\n\n    function getPadding(\n        InnerSpec.Data memory spec,\n        uint256 branch\n    ) private pure returns (uint256 minPrefix, uint256 maxPrefix, uint256 suffix, GetPaddingError) {\n        uint256 uChildSize = SafeCast.toUint256(spec.child_size);\n        (uint256 idx, GetPositionError gCode) = getPosition(spec.child_order, branch);\n        if (gCode != GetPositionError.None) return (0, 0, 0, GetPaddingError.GetPosition);\n        uint256 prefix = idx * uChildSize;\n        minPrefix = prefix + SafeCast.toUint256(spec.min_prefix_length);\n        maxPrefix = prefix + SafeCast.toUint256(spec.max_prefix_length);\n        suffix = (spec.child_order.length - 1 - idx) * uChildSize;\n\n        return (minPrefix, maxPrefix, suffix, GetPaddingError.None);\n    }\n\n    enum GetPositionError {\n        None,\n        BranchLength,\n        NoFound\n    }\n\n    function getPosition(int32[] memory order, uint256 branch) private pure returns (uint256, GetPositionError) {\n        //require(branch < order.length); // dev: invalid branch\n        if (branch >= order.length) return (0, GetPositionError.BranchLength);\n        for (uint256 i = 0; i < order.length; i++) {\n            if (SafeCast.toUint256(order[i]) == branch) return (i, GetPositionError.None);\n        }\n        //revert(); // dev: branch not found in order\n        return (0, GetPositionError.NoFound);\n    }\n\n    function hasPadding(\n        InnerOp.Data memory op,\n        uint256 minPrefix,\n        uint256 maxPrefix,\n        uint256 suffix\n    ) private pure returns (bool) {\n        if (op.prefix.length < minPrefix) return false;\n        if (op.prefix.length > maxPrefix) return false;\n        return op.suffix.length == suffix;\n    }\n\n    function sliceInnerOps(\n        InnerOp.Data[] memory array,\n        uint256 start,\n        uint256 end\n    ) private pure returns (InnerOp.Data[] memory) {\n        InnerOp.Data[] memory slice = new InnerOp.Data[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            slice[i] = array[i];\n        }\n        return slice;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/Memory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nlibrary Memory {\n    // Size of a word, in bytes.\n    uint256 internal constant WORD_SIZE = 32;\n    // Size of the header of a 'bytes' array.\n    uint256 internal constant BYTES_HEADER_SIZE = 32;\n    // Address of the free memory pointer.\n    uint256 internal constant FREE_MEM_PTR = 0x40;\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\n    // bytes starting at 'addr2'.\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\n    function equals(uint256 addr, uint256 addr2, uint256 len) internal pure returns (bool equal) {\n        assembly {\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\n        }\n    }\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\n    // the first 'len' bytes will be compared.\n    // Requires that 'bts.length >= len'\n    function equals(uint256 addr, uint256 len, bytes memory bts) internal pure returns (bool equal) {\n        require(bts.length >= len);\n        uint256 addr2;\n        assembly {\n            addr2 := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n        return equals(addr, addr2, len);\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\n    // This function does not check the or destination, it only copies\n    // the bytes.\n    function copy(uint256 src, uint256 dest, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_SIZE;\n            src += WORD_SIZE;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    // Returns a memory pointer to the provided bytes array.\n    function ptr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := bts\n        }\n    }\n\n    // Returns a memory pointer to the data portion of the provided bytes array.\n    function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n    }\n\n    // This function does the same as 'dataPtr(bytes memory)', but will also return the\n    // length of the provided bytes array.\n    function fromBytes(bytes memory bts) internal pure returns (uint256 addr, uint256 len) {\n        len = bts.length;\n        assembly {\n            addr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n    }\n\n    // Creates a 'bytes memory' variable from the memory address 'addr', with the\n    // length 'len'. The function will allocate new memory for the bytes array, and\n    // the 'len bytes starting at 'addr' will be copied into that new memory.\n    function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) {\n        bts = new bytes(len);\n        uint256 btsptr;\n        assembly {\n            btsptr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n        copy(addr, btsptr, len);\n    }\n\n    // Get the word stored at memory address 'addr' as a 'uint'.\n    function toUint(uint256 addr) internal pure returns (uint256 n) {\n        assembly {\n            n := mload(addr)\n        }\n    }\n\n    // Get the word stored at memory address 'addr' as a 'bytes32'.\n    function toBytes32(uint256 addr) internal pure returns (bytes32 bts) {\n        assembly {\n            bts := mload(addr)\n        }\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/Encoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./ProtoBufRuntime.sol\";\n\nlibrary Encoder {\n    uint64 private constant _MAX_UINT64 = 0xFFFFFFFFFFFFFFFF;\n\n    function cdcEncode(string memory item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_lendelim(bytes(item).length);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (bytes(item).length > 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    function cdcEncode(bytes memory item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_lendelim(item.length);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (item.length > 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    function cdcEncode(int64 item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_int64(item);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (item != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // TODO: Can we make this cheaper?\n    // https://docs.soliditylang.org/en/v0.6.5/types.html#allocating-memory-arrays\n    function encodeDelim(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length < _MAX_UINT64, \"Encoder: out of bounds (uint64)\");\n\n        uint64 length = uint64(input.length);\n        uint256 additionalEstimated = ProtoBufRuntime._sz_uint64(length);\n\n        bytes memory delimitedPrefix = new bytes(additionalEstimated);\n        uint256 delimitedPrefixLen = ProtoBufRuntime._encode_uint64(length, 32, delimitedPrefix);\n\n        assembly {\n            mstore(delimitedPrefix, delimitedPrefixLen)\n        }\n\n        // concatenate buffers\n        return abi.encodePacked(delimitedPrefix, input);\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/GoogleProtobufAny.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\nimport \"./ProtoBufRuntime.sol\";\n\nlibrary GoogleProtobufAny {\n    //struct definition\n    struct Data {\n        string type_url;\n        bytes value;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_type_url(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_type_url(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        //\n        // if `r` is NULL, then only counting the number of fields.\n        //\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.type_url = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        //\n        // if `r` is NULL, then only counting the number of fields.\n        //\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ProtoBufRuntime._encode_string(r.type_url, pointer, bs);\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.type_url).length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        return e;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.type_url = input.type_url;\n        output.value = input.value;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n//library Any\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/Proofs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"./ProtoBufRuntime.sol\";\nimport \"./GoogleProtobufAny.sol\";\n\nlibrary ExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        bytes value;\n        LeafOp.Data leaf;\n        InnerOp.Data[] path;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.path = new InnerOp.Data[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_leaf(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LeafOp.Data memory x, uint256 sz) = _decode_LeafOp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.leaf = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_path(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (InnerOp.Data memory x, uint256 sz) = _decode_InnerOp(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.path[r.path.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LeafOp(uint256 p, bytes memory bs) internal pure returns (LeafOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LeafOp.Data memory r, ) = LeafOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_InnerOp(uint256 p, bytes memory bs) internal pure returns (InnerOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (InnerOp.Data memory r, ) = InnerOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n        if (r.value.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LeafOp._encode_nested(r.leaf, pointer, bs);\n\n        if (r.path.length != 0) {\n            for (i = 0; i < r.path.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += InnerOp._encode_nested(r.path[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(LeafOp._estimate(r.leaf));\n        for (i = 0; i < r.path.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(InnerOp._estimate(r.path[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        if (r.value.length != 0) {\n            return false;\n        }\n\n        if (r.path.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        output.value = input.value;\n        LeafOp.store(input.leaf, output.leaf);\n\n        for (uint256 i4 = 0; i4 < input.path.length; i4++) {\n            output.path.push(input.path[i4]);\n        }\n    }\n\n    //array helpers for Path\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addPath(Data memory self, InnerOp.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        InnerOp.Data[] memory tmp = new InnerOp.Data[](self.path.length + 1);\n        for (uint256 i = 0; i < self.path.length; i++) {\n            tmp[i] = self.path[i];\n        }\n        tmp[self.path.length] = value;\n        self.path = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ExistenceProof\n\nlibrary NonExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        ExistenceProof.Data left;\n        ExistenceProof.Data right;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_left(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_right(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_left(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.left = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_right(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.right = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ExistenceProof.Data memory r, ) = ExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.left, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.right, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.left));\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.right));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        ExistenceProof.store(input.left, output.left);\n        ExistenceProof.store(input.right, output.right);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library NonExistenceProof\n\nlibrary CommitmentProof {\n    //struct definition\n    struct Data {\n        ExistenceProof.Data exist;\n        NonExistenceProof.Data nonexist;\n        BatchProof.Data batch;\n        CompressedBatchProof.Data compressed;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_exist(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nonexist(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_batch(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_compressed(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_exist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.exist = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nonexist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (NonExistenceProof.Data memory x, uint256 sz) = _decode_NonExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nonexist = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_batch(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BatchProof.Data memory x, uint256 sz) = _decode_BatchProof(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.batch = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_compressed(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedBatchProof.Data memory x, uint256 sz) = _decode_CompressedBatchProof(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.compressed = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ExistenceProof.Data memory r, ) = ExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_NonExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (NonExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (NonExistenceProof.Data memory r, ) = NonExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BatchProof(uint256 p, bytes memory bs) internal pure returns (BatchProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BatchProof.Data memory r, ) = BatchProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedBatchProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedBatchProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedBatchProof.Data memory r, ) = CompressedBatchProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.exist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += NonExistenceProof._encode_nested(r.nonexist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BatchProof._encode_nested(r.batch, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedBatchProof._encode_nested(r.compressed, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.exist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(NonExistenceProof._estimate(r.nonexist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(BatchProof._estimate(r.batch));\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedBatchProof._estimate(r.compressed));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        ExistenceProof.store(input.exist, output.exist);\n        NonExistenceProof.store(input.nonexist, output.nonexist);\n        BatchProof.store(input.batch, output.batch);\n        CompressedBatchProof.store(input.compressed, output.compressed);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CommitmentProof\n\nlibrary LeafOp {\n    //struct definition\n    struct Data {\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hash;\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp prehash_key;\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp prehash_value;\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp length;\n        bytes prefix;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[6] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_prehash_key(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_prehash_value(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_length(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_prefix(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prehash_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.prehash_key = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prehash_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.prehash_value = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_length(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_LengthOp(tmp);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.length = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prefix(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.prefix = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.hash) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_hash = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash);\n            pointer += ProtoBufRuntime._encode_enum(_enum_hash, pointer, bs);\n        }\n        if (uint256(r.prehash_key) != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_prehash_key = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_key);\n            pointer += ProtoBufRuntime._encode_enum(_enum_prehash_key, pointer, bs);\n        }\n        if (uint256(r.prehash_value) != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_prehash_value = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_value);\n            pointer += ProtoBufRuntime._encode_enum(_enum_prehash_value, pointer, bs);\n        }\n        if (uint256(r.length) != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_length = PROOFS_PROTO_GLOBAL_ENUMS.encode_LengthOp(r.length);\n            pointer += ProtoBufRuntime._encode_enum(_enum_length, pointer, bs);\n        }\n        if (r.prefix.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.prefix, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash));\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_key));\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_value));\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_LengthOp(r.length));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.prefix.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.hash) != 0) {\n            return false;\n        }\n\n        if (uint256(r.prehash_key) != 0) {\n            return false;\n        }\n\n        if (uint256(r.prehash_value) != 0) {\n            return false;\n        }\n\n        if (uint256(r.length) != 0) {\n            return false;\n        }\n\n        if (r.prefix.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        output.prehash_key = input.prehash_key;\n        output.prehash_value = input.prehash_value;\n        output.length = input.length;\n        output.prefix = input.prefix;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library LeafOp\n\nlibrary InnerOp {\n    //struct definition\n    struct Data {\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hash;\n        bytes prefix;\n        bytes suffix;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_prefix(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_suffix(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prefix(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.prefix = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_suffix(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.suffix = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.hash) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_hash = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash);\n            pointer += ProtoBufRuntime._encode_enum(_enum_hash, pointer, bs);\n        }\n        if (r.prefix.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.prefix, pointer, bs);\n        }\n        if (r.suffix.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.suffix, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.prefix.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.suffix.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.hash) != 0) {\n            return false;\n        }\n\n        if (r.prefix.length != 0) {\n            return false;\n        }\n\n        if (r.suffix.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        output.prefix = input.prefix;\n        output.suffix = input.suffix;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library InnerOp\n\nlibrary ProofSpec {\n    //struct definition\n    struct Data {\n        LeafOp.Data leaf_spec;\n        InnerSpec.Data inner_spec;\n        int32 max_depth;\n        int32 min_depth;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_leaf_spec(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_inner_spec(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_max_depth(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_min_depth(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_leaf_spec(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LeafOp.Data memory x, uint256 sz) = _decode_LeafOp(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.leaf_spec = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_inner_spec(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (InnerSpec.Data memory x, uint256 sz) = _decode_InnerSpec(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.inner_spec = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_depth(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.max_depth = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_min_depth(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.min_depth = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LeafOp(uint256 p, bytes memory bs) internal pure returns (LeafOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LeafOp.Data memory r, ) = LeafOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_InnerSpec(uint256 p, bytes memory bs) internal pure returns (InnerSpec.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (InnerSpec.Data memory r, ) = InnerSpec._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LeafOp._encode_nested(r.leaf_spec, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += InnerSpec._encode_nested(r.inner_spec, pointer, bs);\n\n        if (r.max_depth != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.max_depth, pointer, bs);\n        }\n        if (r.min_depth != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.min_depth, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(LeafOp._estimate(r.leaf_spec));\n        e += 1 + ProtoBufRuntime._sz_lendelim(InnerSpec._estimate(r.inner_spec));\n        e += 1 + ProtoBufRuntime._sz_int32(r.max_depth);\n        e += 1 + ProtoBufRuntime._sz_int32(r.min_depth);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.max_depth != 0) {\n            return false;\n        }\n\n        if (r.min_depth != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        LeafOp.store(input.leaf_spec, output.leaf_spec);\n        InnerSpec.store(input.inner_spec, output.inner_spec);\n        output.max_depth = input.max_depth;\n        output.min_depth = input.min_depth;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ProofSpec\n\nlibrary InnerSpec {\n    //struct definition\n    struct Data {\n        int32[] child_order;\n        int32 child_size;\n        int32 min_prefix_length;\n        int32 max_prefix_length;\n        bytes empty_child;\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[7] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_child_order(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_child_size(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_min_prefix_length(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_max_prefix_length(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_empty_child(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.child_order = new int32[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_child_order(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_child_size(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_min_prefix_length(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_max_prefix_length(pointer, bs, nil(), counters);\n            } else if (fieldId == 5) {\n                pointer += _read_empty_child(pointer, bs, nil(), counters);\n            } else if (fieldId == 6) {\n                pointer += _read_hash(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_child_order(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.child_order[r.child_order.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_child_size(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.child_size = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_min_prefix_length(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.min_prefix_length = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_prefix_length(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.max_prefix_length = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_empty_child(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.empty_child = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.hash = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.child_order.length != 0) {\n            for (i = 0; i < r.child_order.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n                pointer += ProtoBufRuntime._encode_int32(r.child_order[i], pointer, bs);\n            }\n        }\n        if (r.child_size != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.child_size, pointer, bs);\n        }\n        if (r.min_prefix_length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.min_prefix_length, pointer, bs);\n        }\n        if (r.max_prefix_length != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.max_prefix_length, pointer, bs);\n        }\n        if (r.empty_child.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.empty_child, pointer, bs);\n        }\n        if (uint256(r.hash) != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_hash = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash);\n            pointer += ProtoBufRuntime._encode_enum(_enum_hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.child_order.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_int32(r.child_order[i]);\n        }\n        e += 1 + ProtoBufRuntime._sz_int32(r.child_size);\n        e += 1 + ProtoBufRuntime._sz_int32(r.min_prefix_length);\n        e += 1 + ProtoBufRuntime._sz_int32(r.max_prefix_length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.empty_child.length);\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.child_order.length != 0) {\n            return false;\n        }\n\n        if (r.child_size != 0) {\n            return false;\n        }\n\n        if (r.min_prefix_length != 0) {\n            return false;\n        }\n\n        if (r.max_prefix_length != 0) {\n            return false;\n        }\n\n        if (r.empty_child.length != 0) {\n            return false;\n        }\n\n        if (uint256(r.hash) != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.child_order = input.child_order;\n        output.child_size = input.child_size;\n        output.min_prefix_length = input.min_prefix_length;\n        output.max_prefix_length = input.max_prefix_length;\n        output.empty_child = input.empty_child;\n        output.hash = input.hash;\n    }\n\n    //array helpers for ChildOrder\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addChildOrder(Data memory self, int32 value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        int32[] memory tmp = new int32[](self.child_order.length + 1);\n        for (uint256 i = 0; i < self.child_order.length; i++) {\n            tmp[i] = self.child_order[i];\n        }\n        tmp[self.child_order.length] = value;\n        self.child_order = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library InnerSpec\n\nlibrary BatchProof {\n    //struct definition\n    struct Data {\n        BatchEntry.Data[] entries;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[2] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.entries = new BatchEntry.Data[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_entries(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[2] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BatchEntry.Data memory x, uint256 sz) = _decode_BatchEntry(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.entries[r.entries.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BatchEntry(uint256 p, bytes memory bs) internal pure returns (BatchEntry.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BatchEntry.Data memory r, ) = BatchEntry._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.entries.length != 0) {\n            for (i = 0; i < r.entries.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += BatchEntry._encode_nested(r.entries[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.entries.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(BatchEntry._estimate(r.entries[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.entries.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.entries.length; i1++) {\n            output.entries.push(input.entries[i1]);\n        }\n    }\n\n    //array helpers for Entries\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addEntries(Data memory self, BatchEntry.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        BatchEntry.Data[] memory tmp = new BatchEntry.Data[](self.entries.length + 1);\n        for (uint256 i = 0; i < self.entries.length; i++) {\n            tmp[i] = self.entries[i];\n        }\n        tmp[self.entries.length] = value;\n        self.entries = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BatchProof\n\nlibrary BatchEntry {\n    //struct definition\n    struct Data {\n        ExistenceProof.Data exist;\n        NonExistenceProof.Data nonexist;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_exist(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nonexist(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_exist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.exist = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nonexist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (NonExistenceProof.Data memory x, uint256 sz) = _decode_NonExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nonexist = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ExistenceProof.Data memory r, ) = ExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_NonExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (NonExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (NonExistenceProof.Data memory r, ) = NonExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.exist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += NonExistenceProof._encode_nested(r.nonexist, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.exist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(NonExistenceProof._estimate(r.nonexist));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        ExistenceProof.store(input.exist, output.exist);\n        NonExistenceProof.store(input.nonexist, output.nonexist);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BatchEntry\n\nlibrary CompressedBatchProof {\n    //struct definition\n    struct Data {\n        CompressedBatchEntry.Data[] entries;\n        InnerOp.Data[] lookup_inners;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_lookup_inners(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.entries = new CompressedBatchEntry.Data[](counters[1]);\n        r.lookup_inners = new InnerOp.Data[](counters[2]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_lookup_inners(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_entries(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedBatchEntry.Data memory x, uint256 sz) = _decode_CompressedBatchEntry(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.entries[r.entries.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_lookup_inners(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (InnerOp.Data memory x, uint256 sz) = _decode_InnerOp(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.lookup_inners[r.lookup_inners.length - counters[2]] = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedBatchEntry(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedBatchEntry.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedBatchEntry.Data memory r, ) = CompressedBatchEntry._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_InnerOp(uint256 p, bytes memory bs) internal pure returns (InnerOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (InnerOp.Data memory r, ) = InnerOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.entries.length != 0) {\n            for (i = 0; i < r.entries.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += CompressedBatchEntry._encode_nested(r.entries[i], pointer, bs);\n            }\n        }\n        if (r.lookup_inners.length != 0) {\n            for (i = 0; i < r.lookup_inners.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += InnerOp._encode_nested(r.lookup_inners[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.entries.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(CompressedBatchEntry._estimate(r.entries[i]));\n        }\n        for (i = 0; i < r.lookup_inners.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(InnerOp._estimate(r.lookup_inners[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.entries.length != 0) {\n            return false;\n        }\n\n        if (r.lookup_inners.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.entries.length; i1++) {\n            output.entries.push(input.entries[i1]);\n        }\n\n        for (uint256 i2 = 0; i2 < input.lookup_inners.length; i2++) {\n            output.lookup_inners.push(input.lookup_inners[i2]);\n        }\n    }\n\n    //array helpers for Entries\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addEntries(Data memory self, CompressedBatchEntry.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        CompressedBatchEntry.Data[] memory tmp = new CompressedBatchEntry.Data[](self.entries.length + 1);\n        for (uint256 i = 0; i < self.entries.length; i++) {\n            tmp[i] = self.entries[i];\n        }\n        tmp[self.entries.length] = value;\n        self.entries = tmp;\n    }\n\n    //array helpers for LookupInners\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addLookupInners(Data memory self, InnerOp.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        InnerOp.Data[] memory tmp = new InnerOp.Data[](self.lookup_inners.length + 1);\n        for (uint256 i = 0; i < self.lookup_inners.length; i++) {\n            tmp[i] = self.lookup_inners[i];\n        }\n        tmp[self.lookup_inners.length] = value;\n        self.lookup_inners = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedBatchProof\n\nlibrary CompressedBatchEntry {\n    //struct definition\n    struct Data {\n        CompressedExistenceProof.Data exist;\n        CompressedNonExistenceProof.Data nonexist;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_exist(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nonexist(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_exist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedExistenceProof.Data memory x, uint256 sz) = _decode_CompressedExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.exist = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nonexist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedNonExistenceProof.Data memory x, uint256 sz) = _decode_CompressedNonExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nonexist = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedExistenceProof.Data memory r, ) = CompressedExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedNonExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedNonExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedNonExistenceProof.Data memory r, ) = CompressedNonExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedExistenceProof._encode_nested(r.exist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedNonExistenceProof._encode_nested(r.nonexist, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedExistenceProof._estimate(r.exist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedNonExistenceProof._estimate(r.nonexist));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        CompressedExistenceProof.store(input.exist, output.exist);\n        CompressedNonExistenceProof.store(input.nonexist, output.nonexist);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedBatchEntry\n\nlibrary CompressedExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        bytes value;\n        LeafOp.Data leaf;\n        int32[] path;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.path = new int32[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_leaf(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LeafOp.Data memory x, uint256 sz) = _decode_LeafOp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.leaf = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_path(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.path[r.path.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LeafOp(uint256 p, bytes memory bs) internal pure returns (LeafOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LeafOp.Data memory r, ) = LeafOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n        if (r.value.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LeafOp._encode_nested(r.leaf, pointer, bs);\n\n        if (r.path.length != 0) {\n            for (i = 0; i < r.path.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n                pointer += ProtoBufRuntime._encode_int32(r.path[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(LeafOp._estimate(r.leaf));\n        for (i = 0; i < r.path.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_int32(r.path[i]);\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        if (r.value.length != 0) {\n            return false;\n        }\n\n        if (r.path.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        output.value = input.value;\n        LeafOp.store(input.leaf, output.leaf);\n        output.path = input.path;\n    }\n\n    //array helpers for Path\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addPath(Data memory self, int32 value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        int32[] memory tmp = new int32[](self.path.length + 1);\n        for (uint256 i = 0; i < self.path.length; i++) {\n            tmp[i] = self.path[i];\n        }\n        tmp[self.path.length] = value;\n        self.path = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedExistenceProof\n\nlibrary CompressedNonExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        CompressedExistenceProof.Data left;\n        CompressedExistenceProof.Data right;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_left(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_right(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_left(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedExistenceProof.Data memory x, uint256 sz) = _decode_CompressedExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.left = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_right(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedExistenceProof.Data memory x, uint256 sz) = _decode_CompressedExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.right = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedExistenceProof.Data memory r, ) = CompressedExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedExistenceProof._encode_nested(r.left, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedExistenceProof._encode_nested(r.right, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedExistenceProof._estimate(r.left));\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedExistenceProof._estimate(r.right));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        CompressedExistenceProof.store(input.left, output.left);\n        CompressedExistenceProof.store(input.right, output.right);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedNonExistenceProof\n\nlibrary PROOFS_PROTO_GLOBAL_ENUMS {\n    //enum definition\n    // Solidity enum definitions\n    enum HashOp {\n        NO_HASH,\n        SHA256,\n        SHA512,\n        KECCAK,\n        RIPEMD160,\n        BITCOIN,\n        SHA512_256\n    }\n\n    // Solidity enum encoder\n    function encode_HashOp(HashOp x) internal pure returns (int32) {\n        if (x == HashOp.NO_HASH) {\n            return 0;\n        }\n\n        if (x == HashOp.SHA256) {\n            return 1;\n        }\n\n        if (x == HashOp.SHA512) {\n            return 2;\n        }\n\n        if (x == HashOp.KECCAK) {\n            return 3;\n        }\n\n        if (x == HashOp.RIPEMD160) {\n            return 4;\n        }\n\n        if (x == HashOp.BITCOIN) {\n            return 5;\n        }\n\n        if (x == HashOp.SHA512_256) {\n            return 6;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_HashOp(int64 x) internal pure returns (HashOp) {\n        if (x == 0) {\n            return HashOp.NO_HASH;\n        }\n\n        if (x == 1) {\n            return HashOp.SHA256;\n        }\n\n        if (x == 2) {\n            return HashOp.SHA512;\n        }\n\n        if (x == 3) {\n            return HashOp.KECCAK;\n        }\n\n        if (x == 4) {\n            return HashOp.RIPEMD160;\n        }\n\n        if (x == 5) {\n            return HashOp.BITCOIN;\n        }\n\n        if (x == 6) {\n            return HashOp.SHA512_256;\n        }\n        revert();\n    }\n\n    // Solidity enum definitions\n    enum LengthOp {\n        NO_PREFIX,\n        VAR_PROTO,\n        VAR_RLP,\n        FIXED32_BIG,\n        FIXED32_LITTLE,\n        FIXED64_BIG,\n        FIXED64_LITTLE,\n        REQUIRE_32_BYTES,\n        REQUIRE_64_BYTES\n    }\n\n    // Solidity enum encoder\n    function encode_LengthOp(LengthOp x) internal pure returns (int32) {\n        if (x == LengthOp.NO_PREFIX) {\n            return 0;\n        }\n\n        if (x == LengthOp.VAR_PROTO) {\n            return 1;\n        }\n\n        if (x == LengthOp.VAR_RLP) {\n            return 2;\n        }\n\n        if (x == LengthOp.FIXED32_BIG) {\n            return 3;\n        }\n\n        if (x == LengthOp.FIXED32_LITTLE) {\n            return 4;\n        }\n\n        if (x == LengthOp.FIXED64_BIG) {\n            return 5;\n        }\n\n        if (x == LengthOp.FIXED64_LITTLE) {\n            return 6;\n        }\n\n        if (x == LengthOp.REQUIRE_32_BYTES) {\n            return 7;\n        }\n\n        if (x == LengthOp.REQUIRE_64_BYTES) {\n            return 8;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_LengthOp(int64 x) internal pure returns (LengthOp) {\n        if (x == 0) {\n            return LengthOp.NO_PREFIX;\n        }\n\n        if (x == 1) {\n            return LengthOp.VAR_PROTO;\n        }\n\n        if (x == 2) {\n            return LengthOp.VAR_RLP;\n        }\n\n        if (x == 3) {\n            return LengthOp.FIXED32_BIG;\n        }\n\n        if (x == 4) {\n            return LengthOp.FIXED32_LITTLE;\n        }\n\n        if (x == 5) {\n            return LengthOp.FIXED64_BIG;\n        }\n\n        if (x == 6) {\n            return LengthOp.FIXED64_LITTLE;\n        }\n\n        if (x == 7) {\n            return LengthOp.REQUIRE_32_BYTES;\n        }\n\n        if (x == 8) {\n            return LengthOp.REQUIRE_64_BYTES;\n        }\n        revert();\n    }\n}\n//library PROOFS_PROTO_GLOBAL_ENUMS\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/ProtoBufRuntime.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n/**\n * @title Runtime library for ProtoBuf serialization and/or deserialization.\n * All ProtoBuf generated code will use this library.\n */\nlibrary ProtoBufRuntime {\n    // Types defined in ProtoBuf\n    enum WireType {\n        Varint,\n        Fixed64,\n        LengthDelim,\n        StartGroup,\n        EndGroup,\n        Fixed32\n    }\n    // Constants for bytes calculation\n    uint256 constant WORD_LENGTH = 32;\n    uint256 constant HEADER_SIZE_LENGTH_IN_BYTES = 4;\n    uint256 constant BYTE_SIZE = 8;\n    uint256 constant REMAINING_LENGTH = WORD_LENGTH - HEADER_SIZE_LENGTH_IN_BYTES;\n    string constant OVERFLOW_MESSAGE = \"length overflow\";\n\n    //Storages\n    /**\n     * @dev Encode to storage location using assembly to save storage space.\n     * @param location The location of storage\n     * @param encoded The encoded ProtoBuf bytes\n     */\n    function encodeStorage(bytes storage location, bytes memory encoded) internal {\n        //\n        // This code use the first four bytes as size,\n        // and then put the rest of `encoded` bytes.\n        //\n        uint256 length = encoded.length;\n        uint256 firstWord;\n        uint256 wordLength = WORD_LENGTH;\n        uint256 remainingLength = REMAINING_LENGTH;\n\n        assembly {\n            firstWord := mload(add(encoded, wordLength))\n        }\n        firstWord =\n            (firstWord >> (BYTE_SIZE * HEADER_SIZE_LENGTH_IN_BYTES)) |\n            (length << (BYTE_SIZE * REMAINING_LENGTH));\n\n        assembly {\n            sstore(location.slot, firstWord)\n        }\n\n        if (length > REMAINING_LENGTH) {\n            length -= REMAINING_LENGTH;\n            for (uint256 i = 0; i < ceil(length, WORD_LENGTH); i++) {\n                assembly {\n                    let offset := add(mul(i, wordLength), remainingLength)\n                    let slotIndex := add(i, 1)\n                    sstore(add(location.slot, slotIndex), mload(add(add(encoded, wordLength), offset)))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Decode storage location using assembly using the format in `encodeStorage`.\n     * @param location The location of storage\n     * @return The encoded bytes\n     */\n    function decodeStorage(bytes storage location) internal view returns (bytes memory) {\n        //\n        // This code is to decode the first four bytes as size,\n        // and then decode the rest using the decoded size.\n        //\n        uint256 firstWord;\n        uint256 remainingLength = REMAINING_LENGTH;\n        uint256 wordLength = WORD_LENGTH;\n\n        assembly {\n            firstWord := sload(location.slot)\n        }\n\n        uint256 length = firstWord >> (BYTE_SIZE * REMAINING_LENGTH);\n        bytes memory encoded = new bytes(length);\n\n        assembly {\n            mstore(add(encoded, remainingLength), firstWord)\n        }\n\n        if (length > REMAINING_LENGTH) {\n            length -= REMAINING_LENGTH;\n            for (uint256 i = 0; i < ceil(length, WORD_LENGTH); i++) {\n                assembly {\n                    let offset := add(mul(i, wordLength), remainingLength)\n                    let slotIndex := add(i, 1)\n                    mstore(add(add(encoded, wordLength), offset), sload(add(location.slot, slotIndex)))\n                }\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Fast memory copy of bytes using assembly.\n     * @param src The source memory address\n     * @param dest The destination memory address\n     * @param len The length of bytes to copy\n     */\n    function copyBytes(uint256 src, uint256 dest, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_LENGTH; len -= WORD_LENGTH) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_LENGTH;\n            src += WORD_LENGTH;\n        }\n\n        // Copy remaining bytes\n        // TODO: There are two changes in solidity 0.8.x\n        // 1. exponential literal handling\n        // 2. overflow/underflow check enabled by default\n        //\n        // https://docs.soliditylang.org/en/latest/080-breaking-changes.html#how-to-update-your-code\n        //\n        // Here we have underflow / overflow and I don't yet know why. I tested:\n        //    uint256 WORD_LENGTH = 32;\n        //    uint256 len = 20;\n        //    uint256 mask =  256**(WORD_LENGTH - len) - 1;\n        //    uint256 mask2 = (256**(5)) - 1;\n        //    uint256 mask3 = 256**((5) - 1);\n        //\n        // all of them seem to return the same value, so I believe this is the overflow issue.\n        //\n        // To mitigate the issue I wrapped this in unchecked { }\n        uint256 mask;\n        unchecked {\n            mask = 256 ** (WORD_LENGTH - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Use assembly to get memory address.\n     * @param r The in-memory bytes array\n     * @return The memory address of `r`\n     */\n    function getMemoryAddress(bytes memory r) internal pure returns (uint256) {\n        uint256 addr;\n        assembly {\n            addr := r\n        }\n        return addr;\n    }\n\n    /**\n     * @dev Implement Math function of ceil\n     * @param a The denominator\n     * @param m The numerator\n     * @return r The result of ceil(a/m)\n     */\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256 r) {\n        return (a + m - 1) / m;\n    }\n\n    // Decoders\n    /**\n     * This section of code `_decode_(u)int(32|64)`, `_decode_enum` and `_decode_bool`\n     * is to decode ProtoBuf native integers,\n     * using the `varint` encoding.\n     */\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uint32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        return (uint32(varint), sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uint64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        return (uint64(varint), sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_int32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        int32 r;\n        assembly {\n            r := varint\n        }\n        return (r, sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_int64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        int64 r;\n        assembly {\n            r := varint\n        }\n        return (r, sz);\n    }\n\n    /**\n     * @dev Decode enum\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded enum's integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_enum(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        return _decode_int64(p, bs);\n    }\n\n    /**\n     * @dev Decode enum\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded boolean\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_bool(uint256 p, bytes memory bs) internal pure returns (bool, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        if (varint == 0) {\n            return (false, sz);\n        }\n        return (true, sz);\n    }\n\n    /**\n     * This section of code `_decode_sint(32|64)`\n     * is to decode ProtoBuf native signed integers,\n     * using the `zig-zag` encoding.\n     */\n\n    /**\n     * @dev Decode signed integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_sint32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (int256 varint, uint256 sz) = _decode_varints(p, bs);\n        return (int32(varint), sz);\n    }\n\n    /**\n     * @dev Decode signed integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_sint64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (int256 varint, uint256 sz) = _decode_varints(p, bs);\n        return (int64(varint), sz);\n    }\n\n    /**\n     * @dev Decode string\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded string\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_string(uint256 p, bytes memory bs) internal pure returns (string memory, uint256) {\n        (bytes memory x, uint256 sz) = _decode_lendelim(p, bs);\n        return (string(x), sz);\n    }\n\n    /**\n     * @dev Decode bytes array\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded bytes array\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_bytes(uint256 p, bytes memory bs) internal pure returns (bytes memory, uint256) {\n        return _decode_lendelim(p, bs);\n    }\n\n    /**\n     * @dev Decode ProtoBuf key\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded field ID\n     * @return The decoded WireType specified in ProtoBuf\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_key(uint256 p, bytes memory bs) internal pure returns (uint256, WireType, uint256) {\n        (uint256 x, uint256 n) = _decode_varint(p, bs);\n        WireType typeId = WireType(x & 7);\n        uint256 fieldId = x / 8;\n        return (fieldId, typeId, n);\n    }\n\n    /**\n     * @dev Decode ProtoBuf varint\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded unsigned integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_varint(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        //\n        // Read a byte.\n        // Use the lower 7 bits and shift it to the left,\n        // until the most significant bit is 0.\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 x = 0;\n        uint256 sz = 0;\n        uint256 length = bs.length + WORD_LENGTH;\n        assembly {\n            let b := 0x80\n            p := add(bs, p)\n            for {\n\n            } eq(0x80, and(b, 0x80)) {\n\n            } {\n                if eq(lt(sub(p, bs), length), 0) {\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000) //error function selector\n                    mstore(4, 32)\n                    mstore(36, 15)\n                    mstore(68, 0x6c656e677468206f766572666c6f770000000000000000000000000000000000) // length overflow in hex\n                    revert(0, 83)\n                }\n                let tmp := mload(p)\n                let pos := 0\n                for {\n\n                } and(eq(0x80, and(b, 0x80)), lt(pos, 32)) {\n\n                } {\n                    if eq(lt(sub(p, bs), length), 0) {\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000) //error function selector\n                        mstore(4, 32)\n                        mstore(36, 15)\n                        mstore(68, 0x6c656e677468206f766572666c6f770000000000000000000000000000000000) // length overflow in hex\n                        revert(0, 83)\n                    }\n                    b := byte(pos, tmp)\n                    x := or(x, shl(mul(7, sz), and(0x7f, b)))\n                    sz := add(sz, 1)\n                    pos := add(pos, 1)\n                    p := add(p, 0x01)\n                }\n            }\n        }\n        return (x, sz);\n    }\n\n    /**\n     * @dev Decode ProtoBuf zig-zag encoding\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded signed integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_varints(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        (uint256 u, uint256 sz) = _decode_varint(p, bs);\n        int256 s;\n        assembly {\n            s := xor(shr(1, u), add(not(and(u, 1)), 1))\n        }\n        return (s, sz);\n    }\n\n    /**\n     * @dev Decode ProtoBuf fixed-length encoding\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded unsigned integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uintf(uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256, uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 x = 0;\n        uint256 length = bs.length + WORD_LENGTH;\n        assert(p + sz <= length);\n        assembly {\n            let i := 0\n            p := add(bs, p)\n            let tmp := mload(p)\n            for {\n\n            } lt(i, sz) {\n\n            } {\n                x := or(x, shl(mul(8, i), byte(i, tmp)))\n                p := add(p, 0x01)\n                i := add(i, 1)\n            }\n        }\n        return (x, sz);\n    }\n\n    /**\n     * `_decode_(s)fixed(32|64)` is the concrete implementation of `_decode_uintf`\n     */\n    function _decode_fixed32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 4);\n        return (uint32(x), sz);\n    }\n\n    function _decode_fixed64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 8);\n        return (uint64(x), sz);\n    }\n\n    function _decode_sfixed32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 4);\n        int256 r;\n        assembly {\n            r := x\n        }\n        return (int32(r), sz);\n    }\n\n    function _decode_sfixed64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 8);\n        int256 r;\n        assembly {\n            r := x\n        }\n        return (int64(r), sz);\n    }\n\n    /**\n     * @dev Decode bytes array\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded bytes array\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_lendelim(uint256 p, bytes memory bs) internal pure returns (bytes memory, uint256) {\n        //\n        // First read the size encoded in `varint`, then use the size to read bytes.\n        //\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        bytes memory b = new bytes(len);\n        uint256 length = bs.length + WORD_LENGTH;\n        assert(p + sz + len <= length);\n        uint256 sourcePtr;\n        uint256 destPtr;\n        assembly {\n            destPtr := add(b, 32)\n            sourcePtr := add(add(bs, p), sz)\n        }\n        copyBytes(sourcePtr, destPtr, len);\n        return (b, sz + len);\n    }\n\n    // Encoders\n    /**\n     * @dev Encode ProtoBuf key\n     * @param x The field ID\n     * @param wt The WireType specified in ProtoBuf\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_key(uint256 x, WireType wt, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 i;\n        assembly {\n            i := or(mul(x, 8), mod(wt, 8))\n        }\n        return _encode_varint(i, p, bs);\n    }\n\n    /**\n     * @dev Encode ProtoBuf varint\n     * @param x The unsigned integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_varint(uint256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 sz = 0;\n        assembly {\n            let bsptr := add(bs, p)\n            let byt := and(x, 0x7f)\n            for {\n\n            } gt(shr(7, x), 0) {\n\n            } {\n                mstore8(bsptr, or(0x80, byt))\n                bsptr := add(bsptr, 1)\n                sz := add(sz, 1)\n                x := shr(7, x)\n                byt := and(x, 0x7f)\n            }\n            mstore8(bsptr, byt)\n            sz := add(sz, 1)\n        }\n        return sz;\n    }\n\n    /**\n     * @dev Encode ProtoBuf zig-zag encoding\n     * @param x The signed integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_varints(int256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 encodedInt = _encode_zigzag(x);\n        return _encode_varint(encodedInt, p, bs);\n    }\n\n    /**\n     * @dev Encode ProtoBuf bytes\n     * @param xs The bytes array to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_bytes(bytes memory xs, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 xsLength = xs.length;\n        uint256 sz = _encode_varint(xsLength, p, bs);\n        uint256 count = 0;\n        assembly {\n            let bsptr := add(bs, add(p, sz))\n            let xsptr := add(xs, 32)\n            for {\n\n            } lt(count, xsLength) {\n\n            } {\n                mstore8(bsptr, byte(0, mload(xsptr)))\n                bsptr := add(bsptr, 1)\n                xsptr := add(xsptr, 1)\n                count := add(count, 1)\n            }\n        }\n        return sz + count;\n    }\n\n    /**\n     * @dev Encode ProtoBuf string\n     * @param xs The string to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_string(string memory xs, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_bytes(bytes(xs), p, bs);\n    }\n\n    //\n    // `_encode_(u)int(32|64)`, `_encode_enum` and `_encode_bool`\n    // are concrete implementation of `_encode_varint`\n    //\n    function _encode_uint32(uint32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varint(x, p, bs);\n    }\n\n    function _encode_uint64(uint64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varint(x, p, bs);\n    }\n\n    function _encode_int32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_varint(twosComplement, p, bs);\n    }\n\n    function _encode_int64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_varint(twosComplement, p, bs);\n    }\n\n    function _encode_enum(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_int32(x, p, bs);\n    }\n\n    function _encode_bool(bool x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        if (x) {\n            return _encode_varint(1, p, bs);\n        } else return _encode_varint(0, p, bs);\n    }\n\n    //\n    // `_encode_sint(32|64)`, `_encode_enum` and `_encode_bool`\n    // are the concrete implementation of `_encode_varints`\n    //\n    function _encode_sint32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varints(x, p, bs);\n    }\n\n    function _encode_sint64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varints(x, p, bs);\n    }\n\n    //\n    // `_encode_(s)fixed(32|64)` is the concrete implementation of `_encode_uintf`\n    //\n    function _encode_fixed32(uint32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_uintf(x, p, bs, 4);\n    }\n\n    function _encode_fixed64(uint64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_uintf(x, p, bs, 8);\n    }\n\n    function _encode_sfixed32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint32 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_uintf(twosComplement, p, bs, 4);\n    }\n\n    function _encode_sfixed64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_uintf(twosComplement, p, bs, 8);\n    }\n\n    /**\n     * @dev Encode ProtoBuf fixed-length integer\n     * @param x The unsigned integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_uintf(uint256 x, uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256) {\n        assembly {\n            let bsptr := add(sz, add(bs, p))\n            let count := sz\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                bsptr := sub(bsptr, 1)\n                mstore8(bsptr, byte(sub(32, count), x))\n                count := sub(count, 1)\n            }\n        }\n        return sz;\n    }\n\n    /**\n     * @dev Encode ProtoBuf zig-zag signed integer\n     * @param i The unsigned integer to be encoded\n     * @return The encoded unsigned integer\n     */\n    function _encode_zigzag(int256 i) internal pure returns (uint256) {\n        if (i >= 0) {\n            return uint256(i) * 2;\n        } else return uint256(i * -2) - 1;\n    }\n\n    // Estimators\n    /**\n     * @dev Estimate the length of encoded LengthDelim\n     * @param i The length of LengthDelim\n     * @return The estimated encoded length\n     */\n    function _sz_lendelim(uint256 i) internal pure returns (uint256) {\n        return i + _sz_varint(i);\n    }\n\n    /**\n     * @dev Estimate the length of encoded ProtoBuf field ID\n     * @param i The field ID\n     * @return The estimated encoded length\n     */\n    function _sz_key(uint256 i) internal pure returns (uint256) {\n        if (i < 16) {\n            return 1;\n        } else if (i < 2048) {\n            return 2;\n        } else if (i < 262144) {\n            return 3;\n        } else {\n            revert(\"not supported\");\n        }\n    }\n\n    /**\n     * @dev Estimate the length of encoded ProtoBuf varint\n     * @param i The unsigned integer\n     * @return The estimated encoded length\n     */\n    function _sz_varint(uint256 i) internal pure returns (uint256) {\n        uint256 count = 1;\n        assembly {\n            i := shr(7, i)\n            for {\n\n            } gt(i, 0) {\n\n            } {\n                i := shr(7, i)\n                count := add(count, 1)\n            }\n        }\n        return count;\n    }\n\n    /**\n     * `_sz_(u)int(32|64)` and `_sz_enum` are the concrete implementation of `_sz_varint`\n     */\n    function _sz_uint32(uint32 i) internal pure returns (uint256) {\n        return _sz_varint(i);\n    }\n\n    function _sz_uint64(uint64 i) internal pure returns (uint256) {\n        return _sz_varint(i);\n    }\n\n    function _sz_int32(int32 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint32(i));\n    }\n\n    function _sz_int64(int64 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint64(i));\n    }\n\n    function _sz_enum(int64 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint64(i));\n    }\n\n    /**\n     * `_sz_sint(32|64)` and `_sz_enum` are the concrete implementation of zig-zag encoding\n     */\n    function _sz_sint32(int32 i) internal pure returns (uint256) {\n        return _sz_varint(_encode_zigzag(i));\n    }\n\n    function _sz_sint64(int64 i) internal pure returns (uint256) {\n        return _sz_varint(_encode_zigzag(i));\n    }\n\n    // Soltype extensions\n    /**\n     * @dev Decode Solidity integer and/or fixed-size bytes array, filling from lowest bit.\n     * @param n The maximum number of bytes to read\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The bytes32 representation\n     * @return The number of bytes used to decode\n     */\n    function _decode_sol_bytesN_lower(uint8 n, uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        uint256 r;\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        if (len + sz > n + 3) {\n            revert(OVERFLOW_MESSAGE);\n        }\n        p += 3;\n        assert(p < bs.length + WORD_LENGTH);\n        assembly {\n            r := mload(add(p, bs))\n        }\n        for (uint256 i = len - 2; i < WORD_LENGTH; i++) {\n            r /= 256;\n        }\n        return (bytes32(r), len + sz);\n    }\n\n    /**\n     * @dev Decode Solidity integer and/or fixed-size bytes array, filling from highest bit.\n     * @param n The maximum number of bytes to read\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The bytes32 representation\n     * @return The number of bytes used to decode\n     */\n    function _decode_sol_bytesN(uint8 n, uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        uint256 wordLength = WORD_LENGTH;\n        uint256 byteSize = BYTE_SIZE;\n        if (len + sz > n + 3) {\n            revert(OVERFLOW_MESSAGE);\n        }\n        p += 3;\n        bytes32 acc;\n        assert(p < bs.length + WORD_LENGTH);\n        assembly {\n            acc := mload(add(p, bs))\n            let difference := sub(wordLength, sub(len, 2))\n            let bits := mul(byteSize, difference)\n            acc := shl(bits, shr(bits, acc))\n        }\n        return (acc, len + sz);\n    }\n\n    /*\n     * `_decode_sol*` are the concrete implementation of decoding Solidity types\n     */\n    function _decode_sol_address(uint256 p, bytes memory bs) internal pure returns (address, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytesN(20, p, bs);\n        return (address(bytes20(r)), sz);\n    }\n\n    function _decode_sol_bool(uint256 p, bytes memory bs) internal pure returns (bool, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(1, p, bs);\n        if (r == 0) {\n            return (false, sz);\n        }\n        return (true, sz);\n    }\n\n    function _decode_sol_uint(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        return _decode_sol_uint256(p, bs);\n    }\n\n    function _decode_sol_uintN(uint8 n, uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN_lower(n, p, bs);\n        uint256 r;\n        assembly {\n            r := u\n        }\n        return (r, sz);\n    }\n\n    function _decode_sol_uint8(uint256 p, bytes memory bs) internal pure returns (uint8, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(1, p, bs);\n        return (uint8(r), sz);\n    }\n\n    function _decode_sol_uint16(uint256 p, bytes memory bs) internal pure returns (uint16, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(2, p, bs);\n        return (uint16(r), sz);\n    }\n\n    function _decode_sol_uint24(uint256 p, bytes memory bs) internal pure returns (uint24, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(3, p, bs);\n        return (uint24(r), sz);\n    }\n\n    function _decode_sol_uint32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(4, p, bs);\n        return (uint32(r), sz);\n    }\n\n    function _decode_sol_uint40(uint256 p, bytes memory bs) internal pure returns (uint40, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(5, p, bs);\n        return (uint40(r), sz);\n    }\n\n    function _decode_sol_uint48(uint256 p, bytes memory bs) internal pure returns (uint48, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(6, p, bs);\n        return (uint48(r), sz);\n    }\n\n    function _decode_sol_uint56(uint256 p, bytes memory bs) internal pure returns (uint56, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(7, p, bs);\n        return (uint56(r), sz);\n    }\n\n    function _decode_sol_uint64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(8, p, bs);\n        return (uint64(r), sz);\n    }\n\n    function _decode_sol_uint72(uint256 p, bytes memory bs) internal pure returns (uint72, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(9, p, bs);\n        return (uint72(r), sz);\n    }\n\n    function _decode_sol_uint80(uint256 p, bytes memory bs) internal pure returns (uint80, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(10, p, bs);\n        return (uint80(r), sz);\n    }\n\n    function _decode_sol_uint88(uint256 p, bytes memory bs) internal pure returns (uint88, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(11, p, bs);\n        return (uint88(r), sz);\n    }\n\n    function _decode_sol_uint96(uint256 p, bytes memory bs) internal pure returns (uint96, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(12, p, bs);\n        return (uint96(r), sz);\n    }\n\n    function _decode_sol_uint104(uint256 p, bytes memory bs) internal pure returns (uint104, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(13, p, bs);\n        return (uint104(r), sz);\n    }\n\n    function _decode_sol_uint112(uint256 p, bytes memory bs) internal pure returns (uint112, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(14, p, bs);\n        return (uint112(r), sz);\n    }\n\n    function _decode_sol_uint120(uint256 p, bytes memory bs) internal pure returns (uint120, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(15, p, bs);\n        return (uint120(r), sz);\n    }\n\n    function _decode_sol_uint128(uint256 p, bytes memory bs) internal pure returns (uint128, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(16, p, bs);\n        return (uint128(r), sz);\n    }\n\n    function _decode_sol_uint136(uint256 p, bytes memory bs) internal pure returns (uint136, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(17, p, bs);\n        return (uint136(r), sz);\n    }\n\n    function _decode_sol_uint144(uint256 p, bytes memory bs) internal pure returns (uint144, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(18, p, bs);\n        return (uint144(r), sz);\n    }\n\n    function _decode_sol_uint152(uint256 p, bytes memory bs) internal pure returns (uint152, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(19, p, bs);\n        return (uint152(r), sz);\n    }\n\n    function _decode_sol_uint160(uint256 p, bytes memory bs) internal pure returns (uint160, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(20, p, bs);\n        return (uint160(r), sz);\n    }\n\n    function _decode_sol_uint168(uint256 p, bytes memory bs) internal pure returns (uint168, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(21, p, bs);\n        return (uint168(r), sz);\n    }\n\n    function _decode_sol_uint176(uint256 p, bytes memory bs) internal pure returns (uint176, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(22, p, bs);\n        return (uint176(r), sz);\n    }\n\n    function _decode_sol_uint184(uint256 p, bytes memory bs) internal pure returns (uint184, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(23, p, bs);\n        return (uint184(r), sz);\n    }\n\n    function _decode_sol_uint192(uint256 p, bytes memory bs) internal pure returns (uint192, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(24, p, bs);\n        return (uint192(r), sz);\n    }\n\n    function _decode_sol_uint200(uint256 p, bytes memory bs) internal pure returns (uint200, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(25, p, bs);\n        return (uint200(r), sz);\n    }\n\n    function _decode_sol_uint208(uint256 p, bytes memory bs) internal pure returns (uint208, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(26, p, bs);\n        return (uint208(r), sz);\n    }\n\n    function _decode_sol_uint216(uint256 p, bytes memory bs) internal pure returns (uint216, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(27, p, bs);\n        return (uint216(r), sz);\n    }\n\n    function _decode_sol_uint224(uint256 p, bytes memory bs) internal pure returns (uint224, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(28, p, bs);\n        return (uint224(r), sz);\n    }\n\n    function _decode_sol_uint232(uint256 p, bytes memory bs) internal pure returns (uint232, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(29, p, bs);\n        return (uint232(r), sz);\n    }\n\n    function _decode_sol_uint240(uint256 p, bytes memory bs) internal pure returns (uint240, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(30, p, bs);\n        return (uint240(r), sz);\n    }\n\n    function _decode_sol_uint248(uint256 p, bytes memory bs) internal pure returns (uint248, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(31, p, bs);\n        return (uint248(r), sz);\n    }\n\n    function _decode_sol_uint256(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(32, p, bs);\n        return (uint256(r), sz);\n    }\n\n    function _decode_sol_int(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        return _decode_sol_int256(p, bs);\n    }\n\n    function _decode_sol_intN(uint8 n, uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN_lower(n, p, bs);\n        int256 r;\n        assembly {\n            r := u\n            r := signextend(sub(sz, 4), r)\n        }\n        return (r, sz);\n    }\n\n    function _decode_sol_bytes(uint8 n, uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN(n, p, bs);\n        return (u, sz);\n    }\n\n    function _decode_sol_int8(uint256 p, bytes memory bs) internal pure returns (int8, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(1, p, bs);\n        return (int8(r), sz);\n    }\n\n    function _decode_sol_int16(uint256 p, bytes memory bs) internal pure returns (int16, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(2, p, bs);\n        return (int16(r), sz);\n    }\n\n    function _decode_sol_int24(uint256 p, bytes memory bs) internal pure returns (int24, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(3, p, bs);\n        return (int24(r), sz);\n    }\n\n    function _decode_sol_int32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(4, p, bs);\n        return (int32(r), sz);\n    }\n\n    function _decode_sol_int40(uint256 p, bytes memory bs) internal pure returns (int40, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(5, p, bs);\n        return (int40(r), sz);\n    }\n\n    function _decode_sol_int48(uint256 p, bytes memory bs) internal pure returns (int48, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(6, p, bs);\n        return (int48(r), sz);\n    }\n\n    function _decode_sol_int56(uint256 p, bytes memory bs) internal pure returns (int56, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(7, p, bs);\n        return (int56(r), sz);\n    }\n\n    function _decode_sol_int64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(8, p, bs);\n        return (int64(r), sz);\n    }\n\n    function _decode_sol_int72(uint256 p, bytes memory bs) internal pure returns (int72, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(9, p, bs);\n        return (int72(r), sz);\n    }\n\n    function _decode_sol_int80(uint256 p, bytes memory bs) internal pure returns (int80, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(10, p, bs);\n        return (int80(r), sz);\n    }\n\n    function _decode_sol_int88(uint256 p, bytes memory bs) internal pure returns (int88, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(11, p, bs);\n        return (int88(r), sz);\n    }\n\n    function _decode_sol_int96(uint256 p, bytes memory bs) internal pure returns (int96, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(12, p, bs);\n        return (int96(r), sz);\n    }\n\n    function _decode_sol_int104(uint256 p, bytes memory bs) internal pure returns (int104, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(13, p, bs);\n        return (int104(r), sz);\n    }\n\n    function _decode_sol_int112(uint256 p, bytes memory bs) internal pure returns (int112, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(14, p, bs);\n        return (int112(r), sz);\n    }\n\n    function _decode_sol_int120(uint256 p, bytes memory bs) internal pure returns (int120, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(15, p, bs);\n        return (int120(r), sz);\n    }\n\n    function _decode_sol_int128(uint256 p, bytes memory bs) internal pure returns (int128, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(16, p, bs);\n        return (int128(r), sz);\n    }\n\n    function _decode_sol_int136(uint256 p, bytes memory bs) internal pure returns (int136, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(17, p, bs);\n        return (int136(r), sz);\n    }\n\n    function _decode_sol_int144(uint256 p, bytes memory bs) internal pure returns (int144, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(18, p, bs);\n        return (int144(r), sz);\n    }\n\n    function _decode_sol_int152(uint256 p, bytes memory bs) internal pure returns (int152, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(19, p, bs);\n        return (int152(r), sz);\n    }\n\n    function _decode_sol_int160(uint256 p, bytes memory bs) internal pure returns (int160, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(20, p, bs);\n        return (int160(r), sz);\n    }\n\n    function _decode_sol_int168(uint256 p, bytes memory bs) internal pure returns (int168, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(21, p, bs);\n        return (int168(r), sz);\n    }\n\n    function _decode_sol_int176(uint256 p, bytes memory bs) internal pure returns (int176, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(22, p, bs);\n        return (int176(r), sz);\n    }\n\n    function _decode_sol_int184(uint256 p, bytes memory bs) internal pure returns (int184, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(23, p, bs);\n        return (int184(r), sz);\n    }\n\n    function _decode_sol_int192(uint256 p, bytes memory bs) internal pure returns (int192, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(24, p, bs);\n        return (int192(r), sz);\n    }\n\n    function _decode_sol_int200(uint256 p, bytes memory bs) internal pure returns (int200, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(25, p, bs);\n        return (int200(r), sz);\n    }\n\n    function _decode_sol_int208(uint256 p, bytes memory bs) internal pure returns (int208, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(26, p, bs);\n        return (int208(r), sz);\n    }\n\n    function _decode_sol_int216(uint256 p, bytes memory bs) internal pure returns (int216, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(27, p, bs);\n        return (int216(r), sz);\n    }\n\n    function _decode_sol_int224(uint256 p, bytes memory bs) internal pure returns (int224, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(28, p, bs);\n        return (int224(r), sz);\n    }\n\n    function _decode_sol_int232(uint256 p, bytes memory bs) internal pure returns (int232, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(29, p, bs);\n        return (int232(r), sz);\n    }\n\n    function _decode_sol_int240(uint256 p, bytes memory bs) internal pure returns (int240, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(30, p, bs);\n        return (int240(r), sz);\n    }\n\n    function _decode_sol_int248(uint256 p, bytes memory bs) internal pure returns (int248, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(31, p, bs);\n        return (int248(r), sz);\n    }\n\n    function _decode_sol_int256(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(32, p, bs);\n        return (int256(r), sz);\n    }\n\n    function _decode_sol_bytes1(uint256 p, bytes memory bs) internal pure returns (bytes1, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(1, p, bs);\n        return (bytes1(r), sz);\n    }\n\n    function _decode_sol_bytes2(uint256 p, bytes memory bs) internal pure returns (bytes2, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(2, p, bs);\n        return (bytes2(r), sz);\n    }\n\n    function _decode_sol_bytes3(uint256 p, bytes memory bs) internal pure returns (bytes3, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(3, p, bs);\n        return (bytes3(r), sz);\n    }\n\n    function _decode_sol_bytes4(uint256 p, bytes memory bs) internal pure returns (bytes4, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(4, p, bs);\n        return (bytes4(r), sz);\n    }\n\n    function _decode_sol_bytes5(uint256 p, bytes memory bs) internal pure returns (bytes5, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(5, p, bs);\n        return (bytes5(r), sz);\n    }\n\n    function _decode_sol_bytes6(uint256 p, bytes memory bs) internal pure returns (bytes6, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(6, p, bs);\n        return (bytes6(r), sz);\n    }\n\n    function _decode_sol_bytes7(uint256 p, bytes memory bs) internal pure returns (bytes7, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(7, p, bs);\n        return (bytes7(r), sz);\n    }\n\n    function _decode_sol_bytes8(uint256 p, bytes memory bs) internal pure returns (bytes8, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(8, p, bs);\n        return (bytes8(r), sz);\n    }\n\n    function _decode_sol_bytes9(uint256 p, bytes memory bs) internal pure returns (bytes9, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(9, p, bs);\n        return (bytes9(r), sz);\n    }\n\n    function _decode_sol_bytes10(uint256 p, bytes memory bs) internal pure returns (bytes10, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(10, p, bs);\n        return (bytes10(r), sz);\n    }\n\n    function _decode_sol_bytes11(uint256 p, bytes memory bs) internal pure returns (bytes11, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(11, p, bs);\n        return (bytes11(r), sz);\n    }\n\n    function _decode_sol_bytes12(uint256 p, bytes memory bs) internal pure returns (bytes12, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(12, p, bs);\n        return (bytes12(r), sz);\n    }\n\n    function _decode_sol_bytes13(uint256 p, bytes memory bs) internal pure returns (bytes13, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(13, p, bs);\n        return (bytes13(r), sz);\n    }\n\n    function _decode_sol_bytes14(uint256 p, bytes memory bs) internal pure returns (bytes14, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(14, p, bs);\n        return (bytes14(r), sz);\n    }\n\n    function _decode_sol_bytes15(uint256 p, bytes memory bs) internal pure returns (bytes15, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(15, p, bs);\n        return (bytes15(r), sz);\n    }\n\n    function _decode_sol_bytes16(uint256 p, bytes memory bs) internal pure returns (bytes16, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(16, p, bs);\n        return (bytes16(r), sz);\n    }\n\n    function _decode_sol_bytes17(uint256 p, bytes memory bs) internal pure returns (bytes17, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(17, p, bs);\n        return (bytes17(r), sz);\n    }\n\n    function _decode_sol_bytes18(uint256 p, bytes memory bs) internal pure returns (bytes18, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(18, p, bs);\n        return (bytes18(r), sz);\n    }\n\n    function _decode_sol_bytes19(uint256 p, bytes memory bs) internal pure returns (bytes19, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(19, p, bs);\n        return (bytes19(r), sz);\n    }\n\n    function _decode_sol_bytes20(uint256 p, bytes memory bs) internal pure returns (bytes20, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(20, p, bs);\n        return (bytes20(r), sz);\n    }\n\n    function _decode_sol_bytes21(uint256 p, bytes memory bs) internal pure returns (bytes21, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(21, p, bs);\n        return (bytes21(r), sz);\n    }\n\n    function _decode_sol_bytes22(uint256 p, bytes memory bs) internal pure returns (bytes22, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(22, p, bs);\n        return (bytes22(r), sz);\n    }\n\n    function _decode_sol_bytes23(uint256 p, bytes memory bs) internal pure returns (bytes23, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(23, p, bs);\n        return (bytes23(r), sz);\n    }\n\n    function _decode_sol_bytes24(uint256 p, bytes memory bs) internal pure returns (bytes24, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(24, p, bs);\n        return (bytes24(r), sz);\n    }\n\n    function _decode_sol_bytes25(uint256 p, bytes memory bs) internal pure returns (bytes25, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(25, p, bs);\n        return (bytes25(r), sz);\n    }\n\n    function _decode_sol_bytes26(uint256 p, bytes memory bs) internal pure returns (bytes26, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(26, p, bs);\n        return (bytes26(r), sz);\n    }\n\n    function _decode_sol_bytes27(uint256 p, bytes memory bs) internal pure returns (bytes27, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(27, p, bs);\n        return (bytes27(r), sz);\n    }\n\n    function _decode_sol_bytes28(uint256 p, bytes memory bs) internal pure returns (bytes28, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(28, p, bs);\n        return (bytes28(r), sz);\n    }\n\n    function _decode_sol_bytes29(uint256 p, bytes memory bs) internal pure returns (bytes29, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(29, p, bs);\n        return (bytes29(r), sz);\n    }\n\n    function _decode_sol_bytes30(uint256 p, bytes memory bs) internal pure returns (bytes30, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(30, p, bs);\n        return (bytes30(r), sz);\n    }\n\n    function _decode_sol_bytes31(uint256 p, bytes memory bs) internal pure returns (bytes31, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(31, p, bs);\n        return (bytes31(r), sz);\n    }\n\n    function _decode_sol_bytes32(uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        return _decode_sol_bytes(32, p, bs);\n    }\n\n    /*\n     * `_encode_sol*` are the concrete implementation of encoding Solidity types\n     */\n    function _encode_sol_address(address x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(uint160(x)), 20, p, bs);\n    }\n\n    function _encode_sol_uint(uint256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 32, p, bs);\n    }\n\n    function _encode_sol_uint8(uint8 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 1, p, bs);\n    }\n\n    function _encode_sol_uint16(uint16 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 2, p, bs);\n    }\n\n    function _encode_sol_uint24(uint24 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 3, p, bs);\n    }\n\n    function _encode_sol_uint32(uint32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 4, p, bs);\n    }\n\n    function _encode_sol_uint40(uint40 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 5, p, bs);\n    }\n\n    function _encode_sol_uint48(uint48 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 6, p, bs);\n    }\n\n    function _encode_sol_uint56(uint56 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 7, p, bs);\n    }\n\n    function _encode_sol_uint64(uint64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 8, p, bs);\n    }\n\n    function _encode_sol_uint72(uint72 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 9, p, bs);\n    }\n\n    function _encode_sol_uint80(uint80 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 10, p, bs);\n    }\n\n    function _encode_sol_uint88(uint88 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 11, p, bs);\n    }\n\n    function _encode_sol_uint96(uint96 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 12, p, bs);\n    }\n\n    function _encode_sol_uint104(uint104 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 13, p, bs);\n    }\n\n    function _encode_sol_uint112(uint112 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 14, p, bs);\n    }\n\n    function _encode_sol_uint120(uint120 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 15, p, bs);\n    }\n\n    function _encode_sol_uint128(uint128 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 16, p, bs);\n    }\n\n    function _encode_sol_uint136(uint136 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 17, p, bs);\n    }\n\n    function _encode_sol_uint144(uint144 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 18, p, bs);\n    }\n\n    function _encode_sol_uint152(uint152 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 19, p, bs);\n    }\n\n    function _encode_sol_uint160(uint160 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 20, p, bs);\n    }\n\n    function _encode_sol_uint168(uint168 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 21, p, bs);\n    }\n\n    function _encode_sol_uint176(uint176 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 22, p, bs);\n    }\n\n    function _encode_sol_uint184(uint184 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 23, p, bs);\n    }\n\n    function _encode_sol_uint192(uint192 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 24, p, bs);\n    }\n\n    function _encode_sol_uint200(uint200 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 25, p, bs);\n    }\n\n    function _encode_sol_uint208(uint208 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 26, p, bs);\n    }\n\n    function _encode_sol_uint216(uint216 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 27, p, bs);\n    }\n\n    function _encode_sol_uint224(uint224 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 28, p, bs);\n    }\n\n    function _encode_sol_uint232(uint232 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 29, p, bs);\n    }\n\n    function _encode_sol_uint240(uint240 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 30, p, bs);\n    }\n\n    function _encode_sol_uint248(uint248 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 31, p, bs);\n    }\n\n    function _encode_sol_uint256(uint256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 32, p, bs);\n    }\n\n    function _encode_sol_int(int256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(x, 32, p, bs);\n    }\n\n    function _encode_sol_int8(int8 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 1, p, bs);\n    }\n\n    function _encode_sol_int16(int16 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 2, p, bs);\n    }\n\n    function _encode_sol_int24(int24 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 3, p, bs);\n    }\n\n    function _encode_sol_int32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 4, p, bs);\n    }\n\n    function _encode_sol_int40(int40 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 5, p, bs);\n    }\n\n    function _encode_sol_int48(int48 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 6, p, bs);\n    }\n\n    function _encode_sol_int56(int56 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 7, p, bs);\n    }\n\n    function _encode_sol_int64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 8, p, bs);\n    }\n\n    function _encode_sol_int72(int72 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 9, p, bs);\n    }\n\n    function _encode_sol_int80(int80 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 10, p, bs);\n    }\n\n    function _encode_sol_int88(int88 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 11, p, bs);\n    }\n\n    function _encode_sol_int96(int96 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 12, p, bs);\n    }\n\n    function _encode_sol_int104(int104 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 13, p, bs);\n    }\n\n    function _encode_sol_int112(int112 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 14, p, bs);\n    }\n\n    function _encode_sol_int120(int120 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 15, p, bs);\n    }\n\n    function _encode_sol_int128(int128 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 16, p, bs);\n    }\n\n    function _encode_sol_int136(int136 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 17, p, bs);\n    }\n\n    function _encode_sol_int144(int144 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 18, p, bs);\n    }\n\n    function _encode_sol_int152(int152 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 19, p, bs);\n    }\n\n    function _encode_sol_int160(int160 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 20, p, bs);\n    }\n\n    function _encode_sol_int168(int168 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 21, p, bs);\n    }\n\n    function _encode_sol_int176(int176 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 22, p, bs);\n    }\n\n    function _encode_sol_int184(int184 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 23, p, bs);\n    }\n\n    function _encode_sol_int192(int192 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 24, p, bs);\n    }\n\n    function _encode_sol_int200(int200 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 25, p, bs);\n    }\n\n    function _encode_sol_int208(int208 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 26, p, bs);\n    }\n\n    function _encode_sol_int216(int216 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 27, p, bs);\n    }\n\n    function _encode_sol_int224(int224 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 28, p, bs);\n    }\n\n    function _encode_sol_int232(int232 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 29, p, bs);\n    }\n\n    function _encode_sol_int240(int240 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 30, p, bs);\n    }\n\n    function _encode_sol_int248(int248 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 31, p, bs);\n    }\n\n    function _encode_sol_int256(int256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(x, 32, p, bs);\n    }\n\n    function _encode_sol_bytes1(bytes1 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 1, p, bs);\n    }\n\n    function _encode_sol_bytes2(bytes2 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 2, p, bs);\n    }\n\n    function _encode_sol_bytes3(bytes3 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 3, p, bs);\n    }\n\n    function _encode_sol_bytes4(bytes4 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 4, p, bs);\n    }\n\n    function _encode_sol_bytes5(bytes5 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 5, p, bs);\n    }\n\n    function _encode_sol_bytes6(bytes6 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 6, p, bs);\n    }\n\n    function _encode_sol_bytes7(bytes7 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 7, p, bs);\n    }\n\n    function _encode_sol_bytes8(bytes8 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 8, p, bs);\n    }\n\n    function _encode_sol_bytes9(bytes9 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 9, p, bs);\n    }\n\n    function _encode_sol_bytes10(bytes10 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 10, p, bs);\n    }\n\n    function _encode_sol_bytes11(bytes11 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 11, p, bs);\n    }\n\n    function _encode_sol_bytes12(bytes12 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 12, p, bs);\n    }\n\n    function _encode_sol_bytes13(bytes13 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 13, p, bs);\n    }\n\n    function _encode_sol_bytes14(bytes14 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 14, p, bs);\n    }\n\n    function _encode_sol_bytes15(bytes15 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 15, p, bs);\n    }\n\n    function _encode_sol_bytes16(bytes16 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 16, p, bs);\n    }\n\n    function _encode_sol_bytes17(bytes17 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 17, p, bs);\n    }\n\n    function _encode_sol_bytes18(bytes18 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 18, p, bs);\n    }\n\n    function _encode_sol_bytes19(bytes19 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 19, p, bs);\n    }\n\n    function _encode_sol_bytes20(bytes20 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 20, p, bs);\n    }\n\n    function _encode_sol_bytes21(bytes21 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 21, p, bs);\n    }\n\n    function _encode_sol_bytes22(bytes22 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 22, p, bs);\n    }\n\n    function _encode_sol_bytes23(bytes23 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 23, p, bs);\n    }\n\n    function _encode_sol_bytes24(bytes24 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 24, p, bs);\n    }\n\n    function _encode_sol_bytes25(bytes25 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 25, p, bs);\n    }\n\n    function _encode_sol_bytes26(bytes26 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 26, p, bs);\n    }\n\n    function _encode_sol_bytes27(bytes27 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 27, p, bs);\n    }\n\n    function _encode_sol_bytes28(bytes28 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 28, p, bs);\n    }\n\n    function _encode_sol_bytes29(bytes29 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 29, p, bs);\n    }\n\n    function _encode_sol_bytes30(bytes30 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 30, p, bs);\n    }\n\n    function _encode_sol_bytes31(bytes31 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 31, p, bs);\n    }\n\n    function _encode_sol_bytes32(bytes32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(x, 32, p, bs);\n    }\n\n    /**\n     * @dev Encode the key of Solidity integer and/or fixed-size bytes array.\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol_header(uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        p += _encode_varint(sz + 2, p, bs);\n        p += _encode_key(1, WireType.LengthDelim, p, bs);\n        p += _encode_varint(sz, p, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The unsinged integer to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol(uint256 x, uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_other(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The signed integer to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol(int256 x, uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_other(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The fixed-size byte array to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol_bytes(bytes32 x, uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_bytes_array(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Get the actual size needed to encoding an unsigned integer\n     * @param x The unsigned integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _get_real_size(uint256 x, uint256 sz) internal pure returns (uint256) {\n        uint256 base = 0xff;\n        uint256 realSize = sz;\n        while (x & (base << (realSize * BYTE_SIZE - BYTE_SIZE)) == 0 && realSize > 0) {\n            realSize -= 1;\n        }\n        if (realSize == 0) {\n            realSize = 1;\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Get the actual size needed to encoding an signed integer\n     * @param x The signed integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _get_real_size(int256 x, uint256 sz) internal pure returns (uint256) {\n        int256 base = 0xff;\n        if (x >= 0) {\n            uint256 tmp = _get_real_size(uint256(x), sz);\n            int256 remainder = (x & (base << (tmp * BYTE_SIZE - BYTE_SIZE))) >> (tmp * BYTE_SIZE - BYTE_SIZE);\n            if (remainder >= 128) {\n                tmp += 1;\n            }\n            return tmp;\n        }\n\n        uint256 realSize = sz;\n        while (\n            x & (base << (realSize * BYTE_SIZE - BYTE_SIZE)) == (base << (realSize * BYTE_SIZE - BYTE_SIZE)) &&\n            realSize > 0\n        ) {\n            realSize -= 1;\n        }\n        int256 remainder = (x & (base << (realSize * BYTE_SIZE - BYTE_SIZE))) >> (realSize * BYTE_SIZE - BYTE_SIZE);\n        if (remainder < 128) {\n            realSize += 1;\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Encode the fixed-bytes array\n     * @param x The fixed-size byte array to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_bytes_array(\n        bytes32 x,\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (uint256) {\n        //\n        // The idea is to not encode the leading bytes of zero.\n        //\n        uint256 actualSize = sz;\n        for (uint256 i = 0; i < sz; i++) {\n            uint8 current = uint8(x[sz - 1 - i]);\n            if (current == 0 && actualSize > 1) {\n                actualSize--;\n            } else {\n                break;\n            }\n        }\n        assembly {\n            let bsptr := add(bs, p)\n            let count := actualSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(actualSize, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return actualSize;\n    }\n\n    /**\n     * @dev Encode the signed integer\n     * @param x The signed integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_other(int256 x, uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256) {\n        //\n        // The idea is to not encode the leading bytes of zero.or one,\n        // depending on whether it is positive.\n        //\n        uint256 realSize = _get_real_size(x, sz);\n        assembly {\n            let bsptr := add(bs, p)\n            let count := realSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(32, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Encode the unsigned integer\n     * @param x The unsigned integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_other(uint256 x, uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256) {\n        uint256 realSize = _get_real_size(x, sz);\n        assembly {\n            let bsptr := add(bs, p)\n            let count := realSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(32, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return realSize;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/TendermintHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS, Validator, SimpleValidator, BlockID, Vote, CanonicalBlockID, CanonicalPartSetHeader, CanonicalVote, TmHeader, ConsensusState, MerkleRoot, Commit, CommitSig, SignedHeader, ValidatorSet, Duration, Timestamp, Consensus} from \"./TendermintLight.sol\";\nimport \"./Encoder.sol\";\nimport \"../crypto/MerkleTree.sol\";\n\nlibrary TendermintHelper {\n    function toSimpleValidator(Validator.Data memory val) internal pure returns (SimpleValidator.Data memory) {\n        return SimpleValidator.Data({pub_key: val.pub_key, voting_power: val.voting_power});\n    }\n\n    function toCanonicalBlockID(BlockID.Data memory blockID) internal pure returns (CanonicalBlockID.Data memory) {\n        return\n            CanonicalBlockID.Data({\n                hash: blockID.hash,\n                part_set_header: CanonicalPartSetHeader.Data({\n                    total: blockID.part_set_header.total,\n                    hash: blockID.part_set_header.hash\n                })\n            });\n    }\n\n    function toCanonicalVote(\n        Vote.Data memory vote,\n        string memory chainID\n    ) internal pure returns (CanonicalVote.Data memory) {\n        return\n            CanonicalVote.Data({\n                Type: vote.Type,\n                height: vote.height,\n                round: int64(vote.round),\n                block_id: toCanonicalBlockID(vote.block_id),\n                timestamp: vote.timestamp,\n                chain_id: chainID\n            });\n    }\n\n    function toConsensusState(TmHeader.Data memory tmHeader) internal pure returns (ConsensusState.Data memory) {\n        return\n            ConsensusState.Data({\n                timestamp: tmHeader.signed_header.header.time,\n                root: MerkleRoot.Data({hash: tmHeader.signed_header.header.app_hash}),\n                next_validators_hash: tmHeader.signed_header.header.next_validators_hash\n            });\n    }\n\n    function toVote(Commit.Data memory commit, uint256 valIdx) internal pure returns (Vote.Data memory) {\n        CommitSig.Data memory commitSig = commit.signatures[valIdx];\n\n        return\n            Vote.Data({\n                Type: TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT,\n                height: commit.height,\n                round: commit.round,\n                block_id: commit.block_id,\n                timestamp: commitSig.timestamp,\n                validator_address: commitSig.validator_address,\n                validator_index: SafeCast.toInt32(int256(valIdx)),\n                signature: commitSig.signature\n            });\n    }\n\n    function isEqual(BlockID.Data memory b1, BlockID.Data memory b2) internal pure returns (bool) {\n        if (keccak256(abi.encodePacked(b1.hash)) != keccak256(abi.encodePacked(b2.hash))) {\n            return false;\n        }\n\n        if (b1.part_set_header.total != b2.part_set_header.total) {\n            return false;\n        }\n\n        if (\n            keccak256(abi.encodePacked(b1.part_set_header.hash)) != keccak256(abi.encodePacked(b2.part_set_header.hash))\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function isEqual(ConsensusState.Data memory cs1, ConsensusState.Data memory cs2) internal pure returns (bool) {\n        return\n            keccak256(abi.encodePacked(ConsensusState.encode(cs1))) ==\n            keccak256(abi.encodePacked(ConsensusState.encode(cs2)));\n    }\n\n    function isExpired(\n        SignedHeader.Data memory header,\n        Duration.Data memory trustingPeriod,\n        Duration.Data memory currentTime\n    ) internal pure returns (bool) {\n        Timestamp.Data memory expirationTime = Timestamp.Data({\n            Seconds: header.header.time.Seconds + int64(trustingPeriod.Seconds),\n            nanos: header.header.time.nanos\n        });\n\n        return gt(Timestamp.Data({Seconds: int64(currentTime.Seconds), nanos: 0}), expirationTime);\n    }\n\n    function gt(Timestamp.Data memory t1, Timestamp.Data memory t2) internal pure returns (bool) {\n        if (t1.Seconds > t2.Seconds) {\n            return true;\n        }\n\n        if (t1.Seconds == t2.Seconds && t1.nanos > t2.nanos) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function hash(SignedHeader.Data memory h) internal pure returns (bytes32) {\n        require(h.header.validators_hash.length > 0, \"Tendermint: hash can't be empty\");\n\n        bytes memory hbz = Consensus.encode(h.header.version);\n        bytes memory pbt = Timestamp.encode(h.header.time);\n        bytes memory bzbi = BlockID.encode(h.header.last_block_id);\n\n        bytes[14] memory all = [\n            hbz,\n            Encoder.cdcEncode(h.header.chain_id),\n            Encoder.cdcEncode(h.header.height),\n            pbt,\n            bzbi,\n            Encoder.cdcEncode(h.header.last_commit_hash),\n            Encoder.cdcEncode(h.header.data_hash),\n            Encoder.cdcEncode(h.header.validators_hash),\n            Encoder.cdcEncode(h.header.next_validators_hash),\n            Encoder.cdcEncode(h.header.consensus_hash),\n            Encoder.cdcEncode(h.header.app_hash),\n            Encoder.cdcEncode(h.header.last_results_hash),\n            Encoder.cdcEncode(h.header.evidence_hash),\n            Encoder.cdcEncode(h.header.proposer_address)\n        ];\n\n        return MerkleTree.merkleRootHash(all, 0, all.length);\n    }\n\n    function hash(ValidatorSet.Data memory vs) internal pure returns (bytes32) {\n        return MerkleTree.merkleRootHash(vs.validators, 0, vs.validators.length);\n    }\n\n    function getByAddress(\n        ValidatorSet.Data memory vals,\n        bytes memory addr\n    ) internal pure returns (uint256 index, bool found) {\n        bytes32 addrHash = keccak256(abi.encodePacked(addr));\n        for (uint256 idx; idx < vals.validators.length; idx++) {\n            if (keccak256(abi.encodePacked(vals.validators[idx].Address)) == addrHash) {\n                return (idx, true);\n            }\n        }\n\n        return (0, false);\n    }\n\n    function getTotalVotingPower(ValidatorSet.Data memory vals) internal pure returns (int64) {\n        if (vals.total_voting_power == 0) {\n            uint256 sum = 0;\n            uint256 maxInt64 = 1 << (63 - 1);\n            uint256 maxTotalVotingPower = maxInt64 / 8;\n\n            for (uint256 i = 0; i < vals.validators.length; i++) {\n                sum += (SafeCast.toUint256(int256(vals.validators[i].voting_power)));\n                require(sum <= maxTotalVotingPower, \"total voting power should be guarded to not exceed\");\n            }\n\n            vals.total_voting_power = SafeCast.toInt64(int256(sum));\n        }\n\n        return vals.total_voting_power;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/TendermintLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\nimport \"./ProtoBufRuntime.sol\";\nimport \"./GoogleProtobufAny.sol\";\n\nlibrary Fraction {\n    //struct definition\n    struct Data {\n        uint64 numerator;\n        uint64 denominator;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_numerator(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_denominator(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_numerator(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.numerator = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_denominator(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.denominator = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.numerator != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.numerator, pointer, bs);\n        }\n        if (r.denominator != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.denominator, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint64(r.numerator);\n        e += 1 + ProtoBufRuntime._sz_uint64(r.denominator);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.numerator != 0) {\n            return false;\n        }\n\n        if (r.denominator != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.numerator = input.numerator;\n        output.denominator = input.denominator;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Fraction\n\nlibrary Duration {\n    //struct definition\n    struct Data {\n        int64 Seconds;\n        int32 nanos;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Seconds(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nanos(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Seconds(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Seconds = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nanos(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nanos = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Seconds != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.Seconds, pointer, bs);\n        }\n        if (r.nanos != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.nanos, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_int64(r.Seconds);\n        e += 1 + ProtoBufRuntime._sz_int32(r.nanos);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Seconds != 0) {\n            return false;\n        }\n\n        if (r.nanos != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Seconds = input.Seconds;\n        output.nanos = input.nanos;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Duration\n\nlibrary Consensus {\n    //struct definition\n    struct Data {\n        uint64 block;\n        uint64 app;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_block(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_app(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.block = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_app(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.app = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.block != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.block, pointer, bs);\n        }\n        if (r.app != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.app, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint64(r.block);\n        e += 1 + ProtoBufRuntime._sz_uint64(r.app);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.block != 0) {\n            return false;\n        }\n\n        if (r.app != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.block = input.block;\n        output.app = input.app;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Consensus\n\nlibrary ClientState {\n    //struct definition\n    struct Data {\n        string chain_id;\n        Fraction.Data trust_level;\n        Duration.Data trusting_period;\n        Duration.Data unbonding_period;\n        Duration.Data max_clock_drift;\n        int64 frozen_height;\n        int64 latest_height;\n        bool allow_update_after_expiry;\n        bool allow_update_after_misbehaviour;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[10] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_trust_level(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_trusting_period(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_unbonding_period(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_max_clock_drift(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_frozen_height(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_latest_height(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_allow_update_after_expiry(pointer, bs, r, counters);\n            } else if (fieldId == 9) {\n                pointer += _read_allow_update_after_misbehaviour(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trust_level(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Fraction.Data memory x, uint256 sz) = _decode_Fraction(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.trust_level = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusting_period(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.trusting_period = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_unbonding_period(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.unbonding_period = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_clock_drift(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.max_clock_drift = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_frozen_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.frozen_height = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_latest_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.latest_height = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_allow_update_after_expiry(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bool x, uint256 sz) = ProtoBufRuntime._decode_bool(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.allow_update_after_expiry = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_allow_update_after_misbehaviour(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bool x, uint256 sz) = ProtoBufRuntime._decode_bool(p, bs);\n        if (isNil(r)) {\n            counters[9] += 1;\n        } else {\n            r.allow_update_after_misbehaviour = x;\n            if (counters[9] > 0) counters[9] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Fraction(uint256 p, bytes memory bs) internal pure returns (Fraction.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Fraction.Data memory r, ) = Fraction._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Duration(uint256 p, bytes memory bs) internal pure returns (Duration.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Duration.Data memory r, ) = Duration._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Fraction._encode_nested(r.trust_level, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.trusting_period, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.unbonding_period, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.max_clock_drift, pointer, bs);\n\n        if (r.frozen_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.frozen_height, pointer, bs);\n        }\n        if (r.latest_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.latest_height, pointer, bs);\n        }\n        if (r.allow_update_after_expiry != false) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bool(r.allow_update_after_expiry, pointer, bs);\n        }\n        if (r.allow_update_after_misbehaviour != false) {\n            pointer += ProtoBufRuntime._encode_key(9, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bool(r.allow_update_after_misbehaviour, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Fraction._estimate(r.trust_level));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.trusting_period));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.unbonding_period));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.max_clock_drift));\n        e += 1 + ProtoBufRuntime._sz_int64(r.frozen_height);\n        e += 1 + ProtoBufRuntime._sz_int64(r.latest_height);\n        e += 1 + 1;\n        e += 1 + 1;\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        if (r.frozen_height != 0) {\n            return false;\n        }\n\n        if (r.latest_height != 0) {\n            return false;\n        }\n\n        if (r.allow_update_after_expiry != false) {\n            return false;\n        }\n\n        if (r.allow_update_after_misbehaviour != false) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.chain_id = input.chain_id;\n        Fraction.store(input.trust_level, output.trust_level);\n        Duration.store(input.trusting_period, output.trusting_period);\n        Duration.store(input.unbonding_period, output.unbonding_period);\n        Duration.store(input.max_clock_drift, output.max_clock_drift);\n        output.frozen_height = input.frozen_height;\n        output.latest_height = input.latest_height;\n        output.allow_update_after_expiry = input.allow_update_after_expiry;\n        output.allow_update_after_misbehaviour = input.allow_update_after_misbehaviour;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ClientState\n\nlibrary ConsensusState {\n    //struct definition\n    struct Data {\n        Timestamp.Data timestamp;\n        MerkleRoot.Data root;\n        bytes next_validators_hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_root(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_next_validators_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_root(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (MerkleRoot.Data memory x, uint256 sz) = _decode_MerkleRoot(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.root = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_next_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.next_validators_hash = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_MerkleRoot(uint256 p, bytes memory bs) internal pure returns (MerkleRoot.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (MerkleRoot.Data memory r, ) = MerkleRoot._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += MerkleRoot._encode_nested(r.root, pointer, bs);\n\n        if (r.next_validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.next_validators_hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(MerkleRoot._estimate(r.root));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.next_validators_hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.next_validators_hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        Timestamp.store(input.timestamp, output.timestamp);\n        MerkleRoot.store(input.root, output.root);\n        output.next_validators_hash = input.next_validators_hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ConsensusState\n\nlibrary MerkleRoot {\n    //struct definition\n    struct Data {\n        bytes hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[2] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[2] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library MerkleRoot\n\n// TODO: Fix field order after potential BSC upgrade\nlibrary CanonicalPartSetHeader {\n    //struct definition\n    struct Data {\n        bytes hash;\n        uint32 total;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_total(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint32 x, uint256 sz) = ProtoBufRuntime._decode_uint32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.total = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.hash = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        if (r.total != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint32(r.total, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint32(r.total);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.total != 0) {\n            return false;\n        }\n\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.total = input.total;\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalPartSetHeader\n\nlibrary CanonicalBlockID {\n    //struct definition\n    struct Data {\n        bytes hash;\n        CanonicalPartSetHeader.Data part_set_header;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_part_set_header(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_part_set_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CanonicalPartSetHeader.Data memory x, uint256 sz) = _decode_CanonicalPartSetHeader(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.part_set_header = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CanonicalPartSetHeader(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CanonicalPartSetHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CanonicalPartSetHeader.Data memory r, ) = CanonicalPartSetHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CanonicalPartSetHeader._encode_nested(r.part_set_header, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(CanonicalPartSetHeader._estimate(r.part_set_header));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        CanonicalPartSetHeader.store(input.part_set_header, output.part_set_header);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalBlockID\n\nlibrary CanonicalVote {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType Type;\n        int64 height;\n        int64 round;\n        CanonicalBlockID.Data block_id;\n        Timestamp.Data timestamp;\n        string chain_id;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[7] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Type(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Type(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_SignedMsgType(\n            tmp\n        );\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Type = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_sfixed64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.height = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_sfixed64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.round = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CanonicalBlockID.Data memory x, uint256 sz) = _decode_CanonicalBlockID(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CanonicalBlockID(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CanonicalBlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CanonicalBlockID.Data memory r, ) = CanonicalBlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.Type) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_Type = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type);\n            pointer += ProtoBufRuntime._encode_enum(_enum_Type, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Fixed64, pointer, bs);\n            pointer += ProtoBufRuntime._encode_sfixed64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Fixed64, pointer, bs);\n            pointer += ProtoBufRuntime._encode_sfixed64(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CanonicalBlockID._encode_nested(r.block_id, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type));\n        e += 1 + 8;\n        e += 1 + 8;\n        e += 1 + ProtoBufRuntime._sz_lendelim(CanonicalBlockID._estimate(r.block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.Type) != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Type = input.Type;\n        output.height = input.height;\n        output.round = input.round;\n        CanonicalBlockID.store(input.block_id, output.block_id);\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.chain_id = input.chain_id;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalVote\n\nlibrary Vote {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType Type;\n        int64 height;\n        int32 round;\n        BlockID.Data block_id;\n        Timestamp.Data timestamp;\n        bytes validator_address;\n        int32 validator_index;\n        bytes signature;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[9] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Type(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_validator_address(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_validator_index(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_signature(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Type(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_SignedMsgType(\n            tmp\n        );\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Type = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.height = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.round = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.validator_address = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_index(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.validator_index = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signature(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.signature = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.Type) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_Type = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type);\n            pointer += ProtoBufRuntime._encode_enum(_enum_Type, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.block_id, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (r.validator_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validator_address, pointer, bs);\n        }\n        if (r.validator_index != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.validator_index, pointer, bs);\n        }\n        if (r.signature.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.signature, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type));\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_int32(r.round);\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validator_address.length);\n        e += 1 + ProtoBufRuntime._sz_int32(r.validator_index);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.signature.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.Type) != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (r.validator_address.length != 0) {\n            return false;\n        }\n\n        if (r.validator_index != 0) {\n            return false;\n        }\n\n        if (r.signature.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Type = input.Type;\n        output.height = input.height;\n        output.round = input.round;\n        BlockID.store(input.block_id, output.block_id);\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.validator_address = input.validator_address;\n        output.validator_index = input.validator_index;\n        output.signature = input.signature;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Vote\n\nlibrary ValidatorSet {\n    //struct definition\n    struct Data {\n        Validator.Data[] validators;\n        Validator.Data proposer;\n        int64 total_voting_power;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_validators(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_proposer(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_total_voting_power(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.validators = new Validator.Data[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_validators(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_proposer(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_total_voting_power(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validators(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Validator.Data memory x, uint256 sz) = _decode_Validator(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.validators[r.validators.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Validator.Data memory x, uint256 sz) = _decode_Validator(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.proposer = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.total_voting_power = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Validator(uint256 p, bytes memory bs) internal pure returns (Validator.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Validator.Data memory r, ) = Validator._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.validators.length != 0) {\n            for (i = 0; i < r.validators.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += Validator._encode_nested(r.validators[i], pointer, bs);\n            }\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Validator._encode_nested(r.proposer, pointer, bs);\n\n        if (r.total_voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.total_voting_power, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.validators.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(Validator._estimate(r.validators[i]));\n        }\n        e += 1 + ProtoBufRuntime._sz_lendelim(Validator._estimate(r.proposer));\n        e += 1 + ProtoBufRuntime._sz_int64(r.total_voting_power);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.validators.length != 0) {\n            return false;\n        }\n\n        if (r.total_voting_power != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.validators.length; i1++) {\n            output.validators.push(input.validators[i1]);\n        }\n\n        Validator.store(input.proposer, output.proposer);\n        output.total_voting_power = input.total_voting_power;\n    }\n\n    //array helpers for Validators\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addValidators(Data memory self, Validator.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        Validator.Data[] memory tmp = new Validator.Data[](self.validators.length + 1);\n        for (uint256 i = 0; i < self.validators.length; i++) {\n            tmp[i] = self.validators[i];\n        }\n        tmp[self.validators.length] = value;\n        self.validators = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ValidatorSet\n\nlibrary Validator {\n    //struct definition\n    struct Data {\n        bytes Address;\n        PublicKey.Data pub_key;\n        int64 voting_power;\n        int64 proposer_priority;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Address(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_pub_key(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_voting_power(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_proposer_priority(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Address = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_pub_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PublicKey.Data memory x, uint256 sz) = _decode_PublicKey(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.pub_key = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.voting_power = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer_priority(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.proposer_priority = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PublicKey(uint256 p, bytes memory bs) internal pure returns (PublicKey.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PublicKey.Data memory r, ) = PublicKey._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.Address, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PublicKey._encode_nested(r.pub_key, pointer, bs);\n\n        if (r.voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.voting_power, pointer, bs);\n        }\n        if (r.proposer_priority != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.proposer_priority, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.Address.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(PublicKey._estimate(r.pub_key));\n        e += 1 + ProtoBufRuntime._sz_int64(r.voting_power);\n        e += 1 + ProtoBufRuntime._sz_int64(r.proposer_priority);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Address.length != 0) {\n            return false;\n        }\n\n        if (r.voting_power != 0) {\n            return false;\n        }\n\n        if (r.proposer_priority != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Address = input.Address;\n        PublicKey.store(input.pub_key, output.pub_key);\n        output.voting_power = input.voting_power;\n        output.proposer_priority = input.proposer_priority;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Validator\n\nlibrary SimpleValidator {\n    //struct definition\n    struct Data {\n        PublicKey.Data pub_key;\n        int64 voting_power;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_pub_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_voting_power(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_pub_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PublicKey.Data memory x, uint256 sz) = _decode_PublicKey(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.pub_key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.voting_power = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PublicKey(uint256 p, bytes memory bs) internal pure returns (PublicKey.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PublicKey.Data memory r, ) = PublicKey._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PublicKey._encode_nested(r.pub_key, pointer, bs);\n\n        if (r.voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.voting_power, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(PublicKey._estimate(r.pub_key));\n        e += 1 + ProtoBufRuntime._sz_int64(r.voting_power);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.voting_power != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        PublicKey.store(input.pub_key, output.pub_key);\n        output.voting_power = input.voting_power;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library SimpleValidator\n\nlibrary PublicKey {\n    //struct definition\n    struct Data {\n        bytes ed25519;\n        bytes secp256k1;\n        bytes sr25519;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_ed25519(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_secp256k1(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_sr25519(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_ed25519(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.ed25519 = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_secp256k1(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.secp256k1 = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_sr25519(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.sr25519 = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.ed25519.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.ed25519, pointer, bs);\n        }\n        if (r.secp256k1.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.secp256k1, pointer, bs);\n        }\n        if (r.sr25519.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.sr25519, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.ed25519.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.secp256k1.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.sr25519.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.ed25519.length != 0) {\n            return false;\n        }\n\n        if (r.secp256k1.length != 0) {\n            return false;\n        }\n\n        if (r.sr25519.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.ed25519 = input.ed25519;\n        output.secp256k1 = input.secp256k1;\n        output.sr25519 = input.sr25519;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library PublicKey\n\nlibrary PartSetHeader {\n    //struct definition\n    struct Data {\n        uint32 total;\n        bytes hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_total(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint32 x, uint256 sz) = ProtoBufRuntime._decode_uint32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.total = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.hash = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.total != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint32(r.total, pointer, bs);\n        }\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint32(r.total);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.total != 0) {\n            return false;\n        }\n\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.total = input.total;\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library PartSetHeader\n\nlibrary BlockID {\n    //struct definition\n    struct Data {\n        bytes hash;\n        PartSetHeader.Data part_set_header;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_part_set_header(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_part_set_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PartSetHeader.Data memory x, uint256 sz) = _decode_PartSetHeader(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.part_set_header = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PartSetHeader(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (PartSetHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PartSetHeader.Data memory r, ) = PartSetHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PartSetHeader._encode_nested(r.part_set_header, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(PartSetHeader._estimate(r.part_set_header));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        PartSetHeader.store(input.part_set_header, output.part_set_header);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BlockID\n\nlibrary Commit {\n    //struct definition\n    struct Data {\n        int64 height;\n        int32 round;\n        BlockID.Data block_id;\n        CommitSig.Data[] signatures;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signatures(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.signatures = new CommitSig.Data[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_height(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_round(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_block_id(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signatures(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.height = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.round = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signatures(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CommitSig.Data memory x, uint256 sz) = _decode_CommitSig(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.signatures[r.signatures.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CommitSig(uint256 p, bytes memory bs) internal pure returns (CommitSig.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CommitSig.Data memory r, ) = CommitSig._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.block_id, pointer, bs);\n\n        if (r.signatures.length != 0) {\n            for (i = 0; i < r.signatures.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += CommitSig._encode_nested(r.signatures[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_int32(r.round);\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.block_id));\n        for (i = 0; i < r.signatures.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(CommitSig._estimate(r.signatures[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (r.signatures.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.height = input.height;\n        output.round = input.round;\n        BlockID.store(input.block_id, output.block_id);\n\n        for (uint256 i4 = 0; i4 < input.signatures.length; i4++) {\n            output.signatures.push(input.signatures[i4]);\n        }\n    }\n\n    //array helpers for Signatures\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addSignatures(Data memory self, CommitSig.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        CommitSig.Data[] memory tmp = new CommitSig.Data[](self.signatures.length + 1);\n        for (uint256 i = 0; i < self.signatures.length; i++) {\n            tmp[i] = self.signatures[i];\n        }\n        tmp[self.signatures.length] = value;\n        self.signatures = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Commit\n\nlibrary CommitSig {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag block_id_flag;\n        bytes validator_address;\n        Timestamp.Data timestamp;\n        bytes signature;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_block_id_flag(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_validator_address(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signature(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id_flag(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_BlockIDFlag(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.block_id_flag = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.validator_address = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signature(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.signature = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.block_id_flag) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_block_id_flag = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_BlockIDFlag(r.block_id_flag);\n            pointer += ProtoBufRuntime._encode_enum(_enum_block_id_flag, pointer, bs);\n        }\n        if (r.validator_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validator_address, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (r.signature.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.signature, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_BlockIDFlag(r.block_id_flag));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validator_address.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.signature.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.block_id_flag) != 0) {\n            return false;\n        }\n\n        if (r.validator_address.length != 0) {\n            return false;\n        }\n\n        if (r.signature.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.block_id_flag = input.block_id_flag;\n        output.validator_address = input.validator_address;\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.signature = input.signature;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CommitSig\n\nlibrary Timestamp {\n    //struct definition\n    struct Data {\n        int64 Seconds;\n        int32 nanos;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Seconds(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nanos(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Seconds(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Seconds = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nanos(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nanos = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Seconds != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.Seconds, pointer, bs);\n        }\n        if (r.nanos != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.nanos, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_int64(r.Seconds);\n        e += 1 + ProtoBufRuntime._sz_int32(r.nanos);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Seconds != 0) {\n            return false;\n        }\n\n        if (r.nanos != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Seconds = input.Seconds;\n        output.nanos = input.nanos;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Timestamp\n\nlibrary LightHeader {\n    //struct definition\n    struct Data {\n        Consensus.Data version;\n        string chain_id;\n        int64 height;\n        Timestamp.Data time;\n        BlockID.Data last_block_id;\n        bytes last_commit_hash;\n        bytes data_hash;\n        bytes validators_hash;\n        bytes next_validators_hash;\n        bytes consensus_hash;\n        bytes app_hash;\n        bytes last_results_hash;\n        bytes evidence_hash;\n        bytes proposer_address;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[15] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_version(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_time(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_last_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_last_commit_hash(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_data_hash(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_validators_hash(pointer, bs, r, counters);\n            } else if (fieldId == 9) {\n                pointer += _read_next_validators_hash(pointer, bs, r, counters);\n            } else if (fieldId == 10) {\n                pointer += _read_consensus_hash(pointer, bs, r, counters);\n            } else if (fieldId == 11) {\n                pointer += _read_app_hash(pointer, bs, r, counters);\n            } else if (fieldId == 12) {\n                pointer += _read_last_results_hash(pointer, bs, r, counters);\n            } else if (fieldId == 13) {\n                pointer += _read_evidence_hash(pointer, bs, r, counters);\n            } else if (fieldId == 14) {\n                pointer += _read_proposer_address(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_version(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Consensus.Data memory x, uint256 sz) = _decode_Consensus(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.version = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.height = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_time(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.time = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.last_block_id = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_commit_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.last_commit_hash = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_data_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.data_hash = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.validators_hash = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_next_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[9] += 1;\n        } else {\n            r.next_validators_hash = x;\n            if (counters[9] > 0) counters[9] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_consensus_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[10] += 1;\n        } else {\n            r.consensus_hash = x;\n            if (counters[10] > 0) counters[10] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_app_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[11] += 1;\n        } else {\n            r.app_hash = x;\n            if (counters[11] > 0) counters[11] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_results_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[12] += 1;\n        } else {\n            r.last_results_hash = x;\n            if (counters[12] > 0) counters[12] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_evidence_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[13] += 1;\n        } else {\n            r.evidence_hash = x;\n            if (counters[13] > 0) counters[13] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[14] += 1;\n        } else {\n            r.proposer_address = x;\n            if (counters[14] > 0) counters[14] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Consensus(uint256 p, bytes memory bs) internal pure returns (Consensus.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Consensus.Data memory r, ) = Consensus._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Consensus._encode_nested(r.version, pointer, bs);\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.time, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.last_block_id, pointer, bs);\n\n        if (r.last_commit_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.last_commit_hash, pointer, bs);\n        }\n        if (r.data_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.data_hash, pointer, bs);\n        }\n        if (r.validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validators_hash, pointer, bs);\n        }\n        if (r.next_validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(9, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.next_validators_hash, pointer, bs);\n        }\n        if (r.consensus_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(10, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.consensus_hash, pointer, bs);\n        }\n        if (r.app_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(11, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.app_hash, pointer, bs);\n        }\n        if (r.last_results_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(12, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.last_results_hash, pointer, bs);\n        }\n        if (r.evidence_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(13, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.evidence_hash, pointer, bs);\n        }\n        if (r.proposer_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(14, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.proposer_address, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(Consensus._estimate(r.version));\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.time));\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.last_block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.last_commit_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.data_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validators_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.next_validators_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.consensus_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.app_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.last_results_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.evidence_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.proposer_address.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.last_commit_hash.length != 0) {\n            return false;\n        }\n\n        if (r.data_hash.length != 0) {\n            return false;\n        }\n\n        if (r.validators_hash.length != 0) {\n            return false;\n        }\n\n        if (r.next_validators_hash.length != 0) {\n            return false;\n        }\n\n        if (r.consensus_hash.length != 0) {\n            return false;\n        }\n\n        if (r.app_hash.length != 0) {\n            return false;\n        }\n\n        if (r.last_results_hash.length != 0) {\n            return false;\n        }\n\n        if (r.evidence_hash.length != 0) {\n            return false;\n        }\n\n        if (r.proposer_address.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        Consensus.store(input.version, output.version);\n        output.chain_id = input.chain_id;\n        output.height = input.height;\n        Timestamp.store(input.time, output.time);\n        BlockID.store(input.last_block_id, output.last_block_id);\n        output.last_commit_hash = input.last_commit_hash;\n        output.data_hash = input.data_hash;\n        output.validators_hash = input.validators_hash;\n        output.next_validators_hash = input.next_validators_hash;\n        output.consensus_hash = input.consensus_hash;\n        output.app_hash = input.app_hash;\n        output.last_results_hash = input.last_results_hash;\n        output.evidence_hash = input.evidence_hash;\n        output.proposer_address = input.proposer_address;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library LightHeader\n\nlibrary SignedHeader {\n    //struct definition\n    struct Data {\n        LightHeader.Data header;\n        Commit.Data commit;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_header(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_commit(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LightHeader.Data memory x, uint256 sz) = _decode_LightHeader(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.header = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_commit(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Commit.Data memory x, uint256 sz) = _decode_Commit(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.commit = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LightHeader(uint256 p, bytes memory bs) internal pure returns (LightHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LightHeader.Data memory r, ) = LightHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Commit(uint256 p, bytes memory bs) internal pure returns (Commit.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Commit.Data memory r, ) = Commit._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LightHeader._encode_nested(r.header, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Commit._encode_nested(r.commit, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(LightHeader._estimate(r.header));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Commit._estimate(r.commit));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        LightHeader.store(input.header, output.header);\n        Commit.store(input.commit, output.commit);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library SignedHeader\n\nlibrary TmHeader {\n    //struct definition\n    struct Data {\n        SignedHeader.Data signed_header;\n        ValidatorSet.Data validator_set;\n        int64 trusted_height;\n        ValidatorSet.Data trusted_validators;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_signed_header(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_validator_set(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_trusted_height(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_trusted_validators(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signed_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (SignedHeader.Data memory x, uint256 sz) = _decode_SignedHeader(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.signed_header = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_set(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ValidatorSet.Data memory x, uint256 sz) = _decode_ValidatorSet(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.validator_set = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusted_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.trusted_height = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusted_validators(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ValidatorSet.Data memory x, uint256 sz) = _decode_ValidatorSet(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.trusted_validators = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_SignedHeader(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (SignedHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (SignedHeader.Data memory r, ) = SignedHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ValidatorSet(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ValidatorSet.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ValidatorSet.Data memory r, ) = ValidatorSet._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += SignedHeader._encode_nested(r.signed_header, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ValidatorSet._encode_nested(r.validator_set, pointer, bs);\n\n        if (r.trusted_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.trusted_height, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ValidatorSet._encode_nested(r.trusted_validators, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(SignedHeader._estimate(r.signed_header));\n        e += 1 + ProtoBufRuntime._sz_lendelim(ValidatorSet._estimate(r.validator_set));\n        e += 1 + ProtoBufRuntime._sz_int64(r.trusted_height);\n        e += 1 + ProtoBufRuntime._sz_lendelim(ValidatorSet._estimate(r.trusted_validators));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.trusted_height != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        SignedHeader.store(input.signed_header, output.signed_header);\n        ValidatorSet.store(input.validator_set, output.validator_set);\n        output.trusted_height = input.trusted_height;\n        ValidatorSet.store(input.trusted_validators, output.trusted_validators);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library TmHeader\n\nlibrary TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS {\n    //enum definition\n    // Solidity enum definitions\n    enum BlockIDFlag {\n        BLOCK_ID_FLAG_UNKNOWN,\n        BLOCK_ID_FLAG_ABSENT,\n        BLOCK_ID_FLAG_COMMIT,\n        BLOCK_ID_FLAG_NIL\n    }\n\n    // Solidity enum encoder\n    function encode_BlockIDFlag(BlockIDFlag x) internal pure returns (int32) {\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN) {\n            return 0;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_ABSENT) {\n            return 1;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_COMMIT) {\n            return 2;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_NIL) {\n            return 3;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_BlockIDFlag(int64 x) internal pure returns (BlockIDFlag) {\n        if (x == 0) {\n            return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;\n        }\n\n        if (x == 1) {\n            return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;\n        }\n\n        if (x == 2) {\n            return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;\n        }\n\n        if (x == 3) {\n            return BlockIDFlag.BLOCK_ID_FLAG_NIL;\n        }\n        revert();\n    }\n\n    // Solidity enum definitions\n    enum SignedMsgType {\n        SIGNED_MSG_TYPE_UNKNOWN,\n        SIGNED_MSG_TYPE_PREVOTE,\n        SIGNED_MSG_TYPE_PRECOMMIT,\n        SIGNED_MSG_TYPE_PROPOSAL\n    }\n\n    // Solidity enum encoder\n    function encode_SignedMsgType(SignedMsgType x) internal pure returns (int32) {\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN) {\n            return 0;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PREVOTE) {\n            return 1;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT) {\n            return 2;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL) {\n            return 32;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_SignedMsgType(int64 x) internal pure returns (SignedMsgType) {\n        if (x == 0) {\n            return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;\n        }\n\n        if (x == 1) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;\n        }\n\n        if (x == 2) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;\n        }\n\n        if (x == 32) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;\n        }\n        revert();\n    }\n}\n//library TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/Tendermint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./Bytes.sol\";\nimport {TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS, SignedHeader, BlockID, Timestamp, ValidatorSet, Duration, Fraction, Commit, Validator, CommitSig, CanonicalVote, Vote} from \"./proto/TendermintLight.sol\";\nimport \"./proto/TendermintHelper.sol\";\nimport \"./proto/Encoder.sol\";\nimport \"../Ed25519Verifier.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary Tendermint {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for ValidatorSet.Data;\n    using TendermintHelper for SignedHeader.Data;\n    using TendermintHelper for Timestamp.Data;\n    using TendermintHelper for BlockID.Data;\n    using TendermintHelper for Commit.Data;\n    using TendermintHelper for Vote.Data;\n\n    // TODO: Change visibility to public for deployment. For some reason have to use internal for abigen.\n    function verify(\n        SignedHeader.Data memory trustedHeader,\n        SignedHeader.Data memory untrustedHeader,\n        ValidatorSet.Data memory untrustedVals,\n        address verifier,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) internal view returns (bool) {\n        verifyNewHeaderAndVals(untrustedHeader, untrustedVals, trustedHeader);\n\n        // Check the validator hashes are the same\n        require(\n            untrustedHeader.header.validators_hash.toBytes32() == trustedHeader.header.next_validators_hash.toBytes32(),\n            \"expected old header next validators to match those from new header\"\n        );\n\n        // Ensure that +2/3 of new validators signed correctly.\n        bool ok = verifyCommitLight(\n            untrustedVals,\n            trustedHeader.header.chain_id,\n            untrustedHeader.commit.block_id,\n            untrustedHeader.header.height,\n            untrustedHeader.commit,\n            verifier,\n            proofA,\n            proofB,\n            proofC,\n            proofCommit,\n            proofCommitPub\n        );\n\n        return ok;\n    }\n\n    function verifyNewHeaderAndVals(\n        SignedHeader.Data memory untrustedHeader,\n        ValidatorSet.Data memory untrustedVals,\n        SignedHeader.Data memory trustedHeader\n    ) internal pure {\n        // SignedHeader validate basic\n        require(\n            keccak256(abi.encodePacked(untrustedHeader.header.chain_id)) ==\n                keccak256(abi.encodePacked(trustedHeader.header.chain_id)),\n            \"header belongs to another chain\"\n        );\n        require(untrustedHeader.commit.height == untrustedHeader.header.height, \"header and commit height mismatch\");\n\n        bytes32 untrustedHeaderBlockHash = untrustedHeader.hash();\n        // TODO: Fix block hash\n        // require(\n        //     untrustedHeaderBlockHash == untrustedHeader.commit.block_id.hash.toBytes32(),\n        //     \"commit signs signs block failed\"\n        // );\n\n        require(\n            untrustedHeader.header.height > trustedHeader.header.height,\n            \"expected new header height to be greater than one of old header\"\n        );\n\n        // Skip time verification for now\n\n        bytes32 validatorsHash = untrustedVals.hash();\n        // TODO: Fix validators hash\n        // require(\n        //     untrustedHeader.header.validators_hash.toBytes32() == validatorsHash,\n        //     \"expected new header validators to match those that were supplied at height XX\"\n        // );\n    }\n\n    // VerifyCommitLight\n    // Proof of concept header verification with batch signature SNARK proof\n    function verifyCommitLight(\n        ValidatorSet.Data memory vals,\n        string memory chainID,\n        BlockID.Data memory blockID,\n        int64 height,\n        Commit.Data memory commit,\n        address verifier,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) internal view returns (bool) {\n        require(vals.validators.length == commit.signatures.length, \"invalid commit signatures\");\n        require(commit.signatures.length > 8, \"insufficient signatures\");\n\n        require(height == commit.height, \"invalid commit height\");\n\n        require(commit.block_id.isEqual(blockID), \"invalid commit -- wrong block ID\");\n\n        bytes[8] memory pubkeys;\n        bytes[8] memory messages;\n        uint256 sigCount;\n        for (uint256 i = 0; i < commit.signatures.length; i++) {\n            // no need to verify absent or nil votes.\n            if (\n                commit.signatures[i].block_id_flag !=\n                TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag.BLOCK_ID_FLAG_COMMIT\n            ) {\n                continue;\n            }\n\n            pubkeys[sigCount] = vals.validators[i].pub_key.ed25519;\n            messages[sigCount] = Encoder.encodeDelim(voteSignBytes(commit, chainID, i));\n\n            sigCount++;\n            if (sigCount == 8) {\n                break;\n            }\n        }\n\n        uint256[57] memory input = prepareInput(pubkeys, messages, proofCommitPub);\n        return Ed25519Verifier(verifier).verifyProof(proofA, proofB, proofC, proofCommit, input);\n    }\n\n    function prepareInput(\n        bytes[8] memory pubkeys,\n        bytes[8] memory messages,\n        uint256 proofCommitPub\n    ) private pure returns (uint256[57] memory input) {\n        for (uint256 i = 0; i < 8; i++) {\n            bytes memory messagePart0 = BytesLib.slice(messages[i], 0, 25);\n            bytes memory messagePart1 = BytesLib.slice(messages[i], 25, 25);\n            bytes memory messagePart2 = BytesLib.slice(messages[i], 50, 25);\n            bytes memory messagePart3 = BytesLib.slice(messages[i], 75, 25);\n            bytes memory messagePart4 = BytesLib.slice(messages[i], 100, 22);\n            input[5 * i] = uint256(uint200(bytes25(messagePart0)));\n            input[5 * i + 1] = uint256(uint200(bytes25(messagePart1)));\n            input[5 * i + 2] = uint256(uint200(bytes25(messagePart2)));\n            input[5 * i + 3] = uint256(uint200(bytes25(messagePart3)));\n            input[5 * i + 4] = uint256(uint176(bytes22(messagePart4)));\n            bytes memory pubkeyHigh = BytesLib.slice(pubkeys[i], 0, 16);\n            bytes memory pubkeyLow = BytesLib.slice(pubkeys[i], 16, 16);\n            input[2 * i + 40] = uint256(uint128(bytes16(pubkeyHigh)));\n            input[2 * i + 1 + 40] = uint256(uint128(bytes16(pubkeyLow)));\n        }\n        input[56] = proofCommitPub;\n        return input;\n    }\n\n    function voteSignBytes(\n        Commit.Data memory commit,\n        string memory chainID,\n        uint256 idx\n    ) internal pure returns (bytes memory) {\n        Vote.Data memory vote;\n        vote = commit.toVote(idx);\n\n        return CanonicalVote.encode(vote.toCanonicalVote(chainID));\n    }\n\n    function voteSignBytesDelim(\n        Commit.Data memory commit,\n        string memory chainID,\n        uint256 idx\n    ) internal pure returns (bytes memory) {\n        return Encoder.encodeDelim(voteSignBytes(commit, chainID, idx));\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/System.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Initializable.sol\";\n\ncontract System is Ownable, Initializable {\n    uint32 public constant CODE_OK = 0;\n    uint32 public constant ERROR_FAIL_DECODE = 100;\n\n    uint8 public constant STAKING_CHANNEL_ID = 0x08;\n\n    address public bscValidatorSet;\n    address public tmLightClient;\n    address public crossChain;\n\n    uint16 public bscChainID;\n    address public relayer;\n\n    function init(\n        uint16 _bscChainID,\n        address _relayer,\n        address _bscValidatorSet,\n        address _tmLightClient,\n        address _crossChain\n    ) external onlyUninitialized onlyOwner {\n        bscChainID = _bscChainID;\n        relayer = _relayer;\n        bscValidatorSet = _bscValidatorSet;\n        tmLightClient = _tmLightClient;\n        crossChain = _crossChain;\n\n        _initialized = true;\n    }\n\n    function setRelayer(address _relayer) external onlyOwner {\n        relayer = _relayer;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/TendermintLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"./Initializable.sol\";\nimport \"./System.sol\";\nimport \"./lib/Tendermint.sol\";\nimport \"./interfaces/ITendermintLightClient.sol\";\nimport {GoogleProtobufAny as Any} from \"./lib/proto/GoogleProtobufAny.sol\";\nimport {LightHeader, ValidatorSet, ConsensusState, TmHeader} from \"./lib/proto/TendermintLight.sol\";\n\ncontract TendermintLightClient is Initializable, ITendermintLightClient {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for TmHeader.Data;\n    using TendermintHelper for ConsensusState.Data;\n    using TendermintHelper for ValidatorSet.Data;\n\n    struct ProtoTypes {\n        bytes32 consensusState;\n        bytes32 tmHeader;\n    }\n\n    ProtoTypes private _pts;\n    mapping(uint64 => ConsensusState.Data) public consensusStates;\n    mapping(uint64 => bool) public synced;\n    uint64 public initialHeight;\n    uint64 public latestHeight;\n    System private system;\n    address ed25519Verifier;\n\n    event ConsensusStateInit(uint64 initialHeight, bytes32 appHash);\n    event ConsensusStateSynced(uint64 height, bytes32 appHash);\n\n    constructor(address _ed25519Verifier) {\n        ed25519Verifier = _ed25519Verifier;\n    }\n\n    function init(address _system, bytes memory _initHeader) external onlyUninitialized {\n        _pts = ProtoTypes({\n            consensusState: keccak256(abi.encodePacked(\"/tendermint.types.ConsensusState\")),\n            tmHeader: keccak256(abi.encodePacked(\"/tendermint.types.TmHeader\"))\n        });\n\n        system = System(_system);\n\n        (TmHeader.Data memory tmHeader, bool ok) = unmarshalTmHeader(_initHeader);\n        require(ok, \"LC: light block is invalid\");\n\n        uint64 height = uint64(tmHeader.signed_header.header.height);\n        ConsensusState.Data memory cs = tmHeader.toConsensusState();\n        consensusStates[height] = cs;\n\n        initialHeight = height;\n        latestHeight = height;\n\n        emit ConsensusStateInit(initialHeight, bytes32(cs.root.hash));\n\n        _initialized = true;\n    }\n\n    function syncTendermintHeader(\n        bytes calldata header,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) external returns (bool) {\n        require(msg.sender == system.relayer(), \"not relayer\");\n\n        (TmHeader.Data memory tmHeader, bool ok) = unmarshalTmHeader(header);\n        require(ok, \"LC: light block is invalid\");\n\n        uint64 height = uint64(tmHeader.signed_header.header.height);\n        require(!synced[height], \"can't sync duplicated header\");\n        // assert header height is newer than consensus state\n        require(height > latestHeight, \"LC: header height not newer than consensus state height\");\n\n        checkValidity(consensusStates[latestHeight], tmHeader, proofA, proofB, proofC, proofCommit, proofCommitPub);\n\n        synced[height] = true;\n\n        // Store new cs\n        ConsensusState.Data memory cs = tmHeader.toConsensusState();\n        consensusStates[height] = cs;\n\n        emit ConsensusStateSynced(height, bytes32(cs.root.hash));\n\n        return true;\n    }\n\n    // checkValidity checks if the Tendermint header is valid.\n    function checkValidity(\n        ConsensusState.Data memory trustedConsensusState,\n        TmHeader.Data memory tmHeader,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) private view {\n        LightHeader.Data memory lc;\n        lc.chain_id = tmHeader.signed_header.header.chain_id;\n        lc.height = int64(latestHeight);\n        lc.next_validators_hash = trustedConsensusState.next_validators_hash;\n\n        SignedHeader.Data memory trustedHeader;\n        trustedHeader.header = lc;\n\n        SignedHeader.Data memory untrustedHeader = tmHeader.signed_header;\n        ValidatorSet.Data memory untrustedVals = tmHeader.validator_set;\n\n        bool ok = Tendermint.verify(\n            trustedHeader,\n            untrustedHeader,\n            untrustedVals,\n            ed25519Verifier,\n            proofA,\n            proofB,\n            proofC,\n            proofCommit,\n            proofCommitPub\n        );\n\n        require(ok, \"LC: failed to verify header\");\n    }\n\n    function isHeaderSynced(uint64 height) external view override returns (bool) {\n        return synced[height] || height == initialHeight;\n    }\n\n    function getAppHash(uint64 height) external view override returns (bytes32) {\n        return bytes32(consensusStates[height].root.hash);\n    }\n\n    function unmarshalTmHeader(bytes memory bz) internal view returns (TmHeader.Data memory header, bool ok) {\n        Any.Data memory anyHeader = Any.decode(bz);\n        if (keccak256(abi.encodePacked(anyHeader.type_url)) != _pts.tmHeader) {\n            return (header, false);\n        }\n        return (TmHeader.decode(anyHeader.value), true);\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/pancake/RewardApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\ncontract RewardApp is BrevisApp, Ownable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public vkHash;\n    bytes32 public rewardsMerkleRoot; //leaf (address user, uint64 fromEpoch, uint amount) \n    uint64 public rewardsToEpoch;\n    address public rewardToken;\n    event RewardPosted(uint64 rewardsToEpoch, bytes32 rewardsMerkleRoot);\n    event Claimed(address indexed user, uint64 fromEpoch, uint64 toEpoch, uint256 amount);\n\n    mapping(address => uint64) public userClaimedTo; // user => toEpoch\n\n    constructor(address brevisProof) BrevisApp(IBrevisProof(brevisProof)) {}\n\n    // BrevisQuery contract will call our callback once Brevis backend submits the proof.\n    function handleProofResult(\n        bytes32 /*_requestId*/,\n        bytes32 _vkHash,\n        bytes calldata _circuitOutput\n    ) internal override {\n        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed\n        // our designated verifying key. This proves that the _circuitOutput is authentic\n        require(vkHash == _vkHash, \"invalid vk\");\n\n        (rewardsToEpoch, rewardsMerkleRoot) = decodeOutput(_circuitOutput);\n\n        emit RewardPosted(rewardsToEpoch, rewardsMerkleRoot);\n    }\n\n    function decodeOutput(bytes calldata o) internal pure returns (uint64 epoch, bytes32 merkleRoot) {\n        return (uint64(bytes8(o[0:8])), bytes32(o[8:40]));\n    }\n\n    function claim(\n        address user, // msg.sender can claim on behalf of user\n        uint256 amount,\n        uint64 fromEpoch, \n        bytes32[] calldata merkleProof\n    ) external {\n        // Verifying proof\n        bytes32 leaf = keccak256(abi.encode(user, fromEpoch, amount));\n        require(_verifyProof(leaf, merkleProof), \"not valid proof\");\n        uint64 lastClaimedEpoch = userClaimedTo[user];\n        if (lastClaimedEpoch > 0) {\n            require(fromEpoch == lastClaimedEpoch + 1, \"illegal claim\");\n        }\n\n        userClaimedTo[user] = rewardsToEpoch;\n        IERC20(rewardToken).safeTransfer(user, amount);\n        emit Claimed(user, fromEpoch, rewardsToEpoch, amount);\n    }\n\n    function _verifyProof(bytes32 leaf, bytes32[] memory proof) internal view returns (bool) {\n        require(rewardsMerkleRoot != bytes32(0), \"merkle root not set\");\n        bytes32 currentHash = leaf;\n        uint256 proofLength = proof.length;\n        for (uint256 i; i < proofLength; ) {\n            if (currentHash < proof[i]) {\n                currentHash = keccak256(abi.encode(currentHash, proof[i]));\n            } else {\n                currentHash = keccak256(abi.encode(proof[i], currentHash));\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return currentHash == rewardsMerkleRoot;\n    }\n\n    function setVkHash(bytes32 _vkHash) external onlyOwner {\n        vkHash = _vkHash;\n    }\n\n    function setRewardToken(address _rewardToken) external onlyOwner {\n        rewardToken = _rewardToken;\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/pancake/SingleRewardApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\ncontract SingleRewardApp is BrevisApp, Ownable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public vkHash;\n    address public rewardToken;\n    event Claimed(address indexed user, uint64 fromEpoch, uint64 toEpoch, uint256 amount);\n\n    mapping(address => uint64) public userClaimedTo; // user => toEpoch\n\n    constructor(address brevisProof) BrevisApp(IBrevisProof(brevisProof)) {}\n\n    // BrevisQuery contract will call our callback once Brevis backend submits the proof.\n    function handleProofResult(\n        bytes32 /*_requestId*/,\n        bytes32 _vkHash,\n        bytes calldata _circuitOutput\n    ) internal override {\n        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed\n        // our designated verifying key. This proves that the _circuitOutput is authentic\n        require(vkHash == _vkHash, \"invalid vk\");\n\n        (address user, uint64 fromEpoch, uint64 toEpoch, uint256 amt) = decodeOutput(_circuitOutput);\n\n        uint64 lastClaimedEpoch = userClaimedTo[user];\n        if (lastClaimedEpoch > 0) {\n            require(fromEpoch == lastClaimedEpoch + 1, \"illegal claim\");\n        }\n\n        userClaimedTo[user] = toEpoch;\n        IERC20(rewardToken).safeTransfer(user, amt);\n        emit Claimed(user, fromEpoch, toEpoch, amt);\n    }\n\n    function decodeOutput(bytes calldata o) internal pure returns (address user, uint64 fromEpoch, uint64 toEpoch, uint256 amt) {\n        return (address(bytes20(o[0:20])), uint64(bytes8(o[20:28])), uint64(bytes8(o[28:36])), uint256(bytes32(o[36:68])));\n    }\n\n    function setVkHash(bytes32 _vkHash) external onlyOwner {\n        vkHash = _vkHash;\n    }\n\n    function setRewardToken(address _rewardToken) external onlyOwner {\n        rewardToken = _rewardToken;\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/pancake/TotalFeeApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\ncontract TotalFeeApp is BrevisApp, Ownable {\n    bytes32 public vkHash;\n\n    struct TotalFee {\n        uint256 token0Amt;\n        uint256 token1Amt;\n    }\n\n    mapping(uint64 => TotalFee) public totalFees; // epoch => total fee, for demo, pool is a predefined one\n    uint64 public latestEpoch;\n    event TotalFeePosted(uint64 epoch, uint256 token0Amt, uint256 token1Amt);\n\n    constructor(address brevisProof) BrevisApp(IBrevisProof(brevisProof)) {}\n\n    // BrevisQuery contract will call our callback once Brevis backend submits the proof.\n    function handleProofResult(\n        bytes32 /*_requestId*/,\n        bytes32 _vkHash,\n        bytes calldata _circuitOutput\n    ) internal override {\n        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed\n        // our designated verifying key. This proves that the _circuitOutput is authentic\n        require(vkHash == _vkHash, \"invalid vk\");\n\n        (uint64 epoch, uint256 token0Amt, uint256 token1Amt) = decodeOutput(_circuitOutput);\n        if (latestEpoch != 0) {\n            require(epoch == latestEpoch + 1, \"invalid epoch\");\n        }\n\n        latestEpoch = epoch;\n        totalFees[epoch] = TotalFee(token0Amt, token1Amt);\n\n        emit TotalFeePosted(epoch, token0Amt, token1Amt);\n    }\n\n    function decodeOutput(bytes calldata o) internal pure returns (uint64, uint256, uint256) {\n        uint64 epoch = uint64(bytes8(o[0:8])); \n        uint256 token0Amt = uint256(uint248(bytes31(o[8:39]))); \n        uint256 token1Amt = uint256(uint248(bytes31(o[39:70]))); \n        return (epoch, token0Amt, token1Amt);\n    }\n\n    function setVkHash(bytes32 _vkHash) external onlyOwner {\n        vkHash = _vkHash;\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/receipt/DemoLiquidationProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../framework/SimpleReceiptApp.sol\";\nimport \"../../../lib/Lib.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\n// Single receipt: Proof of liquidation\n// Use Brevis to prove that an address has been liquidated in Compound v2.\n// Specifically, prove there was a LiquidateBorrow event emitted by Compound v2 contract for an borrower address.\n\ncontract DemoLiquidationProof is SimpleReceiptApp {\n    mapping(address => bool) public liquiationFlags;\n\n    constructor(IBrevisProof _brevisProof) BrevisApp(_brevisProof) {}\n\n    // should set correct FieldLocation in BrevisApp.setFieldLocations() to restrict\n    // the first field address as from CompoundV2 and the topic as LiquidateBorrow\n    function submitUserEvent(\n        bytes32 _proofRequestId,\n        uint64 _chainId,\n        bytes32 _smtRoot,\n        Brevis.ReceiptInfo calldata _info\n    ) external {\n        Brevis.ExtractInfos memory info;\n        info.smtRoot = _smtRoot;\n        info.receipts = new Brevis.ReceiptInfo[](1);\n        info.receipts[0] = _info;\n\n        validateRequest(_proofRequestId, _chainId, info);\n\n        address borrower = address(bytes20(_info.logs[0].value));\n        liquiationFlags[borrower] = true;\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/receipt/DemoUniswapVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../framework/SimpleReceiptApp.sol\";\nimport \"../../../lib/Lib.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\n// Multiple receipts: Aggregate trading volume in Uniswap pool\n// Use Brevis to prove someones accumulative trading volume for a given pair in Uniswap.\n\ncontract DemoUniswapVolume is SimpleReceiptApp {\n    mapping(address => uint256) public volumes;\n    event SumVolume(address user, uint64 fromChain, uint256 volume);\n\n    constructor(IBrevisProof _brevisProof) BrevisApp(_brevisProof) {}\n\n    function submitUserVolume(\n        bytes32 _proofRequestId,\n        uint64 _chainId,\n        bytes32 _smtRoot,\n        Brevis.ReceiptInfo[] calldata _info\n    ) external {\n        Brevis.ExtractInfos memory info;\n        info.smtRoot = _smtRoot;\n        info.receipts = _info;\n        validateRequest(_proofRequestId, _chainId, info);\n\n        address swapper = address(bytes20(_info[0].logs[0].value));\n        uint256 volume = abs(int256(uint256(_info[0].logs[1].value)));\n        if (_info.length > 1) {\n            for (uint256 i = 1; i < _info.length; i++) {\n                require(swapper == address(bytes20(_info[i].logs[0].value)), \"not a unique swapper\");\n                volume += abs(int256(uint256(_info[i].logs[1].value)));\n            }\n        }\n\n        volumes[swapper] = volume;\n        emit SumVolume(swapper, _chainId, volume);\n    }\n\n    function abs(int256 x) private pure returns (uint256) {\n        return uint256(x >= 0 ? x : -x);\n    }\n\n    function getAttestedSwapSumVolume(address _swapper) external view returns (uint256) {\n        return volumes[_swapper];\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/slot/DemoAccountAge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../lib/Lib.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\n// Single storage slot: Account age proof\n// Use Brevis to prove the age of an address by proving its oldest storage slot.\n\ncontract DemoAccountAge is BrevisApp {\n    mapping(address => uint64) public visibleSinceBlocks;\n\n    constructor(IBrevisProof _brevisProof) BrevisApp(_brevisProof) {}\n\n    function submitUserStorageInfo(\n        bytes32 _proofRequestId,\n        uint64 _chainId,\n        bytes32 _smtRoot,\n        Brevis.StorageInfo calldata _info\n    ) external {\n        Brevis.ExtractInfos memory info;\n        info.smtRoot = _smtRoot;\n        info.stores = new Brevis.StorageInfo[](1);\n        info.stores[0] = _info;\n\n        validateRequest(_proofRequestId, _chainId, info);\n\n        visibleSinceBlocks[_info.account] = _info.blockNumber;\n    }\n\n    function getAccountAge(address _account) external view returns (uint64) {\n        uint64 visibleSinceBlock = visibleSinceBlocks[_account];\n        require(visibleSinceBlock > 0, \"no proof yet\");\n\n        return uint64(block.number) - visibleSinceBlock; // if the proof is from another chain, then should get current block number from SMT\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/slot/DemoTWAP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../lib/Lib.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\n// Multiple storage slots: TWAP over an interval in Uniswap\n// Use Brevis to prove the time-weighted average price of the WETH-USDC pair over a given block range in Uniswap.\n\ncontract DemoTWAP is BrevisApp {\n    struct Observation {\n        // the block timestamp of the observation\n        uint32 blockTimestamp;\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n        int56 tickCumulative;\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n        uint160 secondsPerLiquidityCumulativeX128;\n        // whether or not the observation is initialized\n        bool initialized;\n    }\n\n    address public poolAddr; // Uniswap V3 WETH-USDC pool addr\n    bytes32 public slotHash; // keccak hash of the index of the Observation slot\n\n    constructor(IBrevisProof _brevisProof, address _poolAddr, bytes32 _slotHash) BrevisApp(_brevisProof) {\n        poolAddr = _poolAddr;\n        slotHash = _slotHash;\n    }\n\n    function submitWETHUSDCPoolStorageInfosAndReturnTWATick(\n        bytes32 _proofRequestId,\n        uint64 _chainId,\n        bytes32 _smtRoot,\n        Brevis.StorageInfo[] calldata _info\n    ) external view returns (int56 twaTick) {\n        require(_info.length == 2, \"only needs two uniswap pool observations to calculate twa Tick\");\n        Brevis.ExtractInfos memory info;\n        info.smtRoot = _smtRoot;\n        info.stores = _info;\n        for (uint256 i = 0; i < 2; i++) {\n            require(_info[i].account == poolAddr, \"not exepcted pool\");\n            require(_info[i].slot == slotHash, \"not expected slot\");\n        }\n        validateRequest(_proofRequestId, _chainId, info);\n\n        require(_info[1].blockNumber > _info[0].blockNumber, \"not right sequence\");\n        Observation memory o1 = unpackObs(uint256(_info[1].slotValue));\n        Observation memory o0 = unpackObs(uint256(_info[0].slotValue));\n\n        return (o1.tickCumulative - o1.tickCumulative) / int56(uint56(o1.blockTimestamp - o0.blockTimestamp));\n    }\n\n    function unpackObs(uint256 observation) private pure returns (Observation memory) {\n        return\n            Observation({\n                blockTimestamp: uint32(observation),\n                tickCumulative: int56(uint56(observation >> 32)),\n                secondsPerLiquidityCumulativeX128: uint160(observation >> 88),\n                initialized: true\n            });\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/slot/SlotValueExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\ncontract SlotValueExample is BrevisApp, Ownable {\n    event PastOwnerAttested(address contractAddr, address ownerAddr, uint64 blockNum);\n\n    bytes32 public vkHash;\n\n    constructor(address brevisProof) BrevisApp(IBrevisProof(brevisProof)) {}\n\n    // BrevisQuery contract will call our callback once Brevis backend submits the proof.\n    // This method is called with once the proof is verified.\n    function handleProofResult(\n        bytes32 /*_requestId*/,\n        bytes32 _vkHash,\n        bytes calldata _circuitOutput\n    ) internal override {\n        // We need to check if the verifying key that Brevis used to verify the proof\n        // generated by our circuit is indeed our designated verifying key. This proves\n        // that the _circuitOutput is authentic\n        require(vkHash == _vkHash, \"invalid vk\");\n        (address contractAddr, address ownerAddr, uint64 blockNum) = decodeOutput(_circuitOutput);\n        emit PastOwnerAttested(contractAddr, ownerAddr, blockNum);\n    }\n\n    // In guest circuit we have:\n    // api.OutputAddress(s.Contract)\n    // api.OutputAddress(owner)\n    // api.OutputUint(64, s.BlockNum)\n    function decodeOutput(bytes calldata o) internal pure returns (address, address, uint64) {\n        address contractAddr = address(bytes20(o[0:20]));\n        address ownerAddr = address(bytes20(o[20:40]));\n        uint64 blockNum = uint64(bytes8(o[40:48]));\n        return (contractAddr, ownerAddr, blockNum);\n    }\n\n    function setVkHash(bytes32 _vkHash) external onlyOwner {\n        vkHash = _vkHash;\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/transactions/DemoTokenTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../lib/Lib.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\n// Single tx: Proof of USDC transfer\n// Use Brevis to prove address #1 has ever made a USDC transfer to address #2.\n// This example is useful in the social recovery of account abstraction where a friend\n// with proven interaction can help recover the lost wallet.\n\ncontract DemoTokenTransfer is BrevisApp {\n    address public token;\n    bytes4 public transferSelector;\n\n    // (sender, receiver) -> timestamp of latest tx\n    mapping(address => mapping(address => uint64)) public txTimestamps;\n\n    constructor(IBrevisProof _brevisProof, address _token, bytes4 _transferSelector) BrevisApp(_brevisProof) {\n        token = _token;\n        transferSelector = _transferSelector;\n    }\n\n    function submitUserTx(\n        bytes32 _proofRequestId,\n        uint64 _chainId,\n        bytes32 _smtRoot,\n        Brevis.TransactionInfo calldata _info,\n        bytes calldata _txRaw\n    ) external {\n        Brevis.ExtractInfos memory info;\n        info.smtRoot = _smtRoot;\n        info.txs = new Brevis.TransactionInfo[](1);\n        info.txs[0] = _info;\n\n        validateRequest(_proofRequestId, _chainId, info);\n\n        bytes memory leafRlp = bytes.concat(_info.leafRlpPrefix, _txRaw);\n        bytes32 leafHash = keccak256(leafRlp);\n        require(leafHash == _info.leafHash, \"leafHash not match\");\n\n        Tx.TxInfo memory txInfo = Tx.decodeTx(_txRaw);\n        require(txInfo.to == token, \"not a token transfer\");\n        (bytes4 sig, address receiver, ) = abiDecodeTransfer(txInfo.data);\n        require(sig == transferSelector, \"not transfer selector\");\n        txTimestamps[txInfo.from][receiver] = _info.blockTime;\n    }\n\n    function abiDecodeTransfer(bytes memory _data) private pure returns (bytes4 sig, address receiver, uint256 amount) {\n        assembly {\n            sig := mload(add(_data, 32))\n            receiver := mload(add(_data, 36))\n            amount := mload(add(_data, 68))\n        }\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/transactions/DemoTokenTransferVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../lib/Lib.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\n// Multiple txs: Proof of USDC transfer volume\n// Use Brevis to prove address #1s accumulative USDC transfer volume to address #2.\n\ncontract DemoTokenTransferVolume is BrevisApp {\n    address public token;\n    bytes4 public transferSelector;\n\n    // (sender, receiver) -> volume\n    mapping(address => mapping(address => uint256)) public volumes;\n\n    constructor(IBrevisProof _brevisProof, address _token, bytes4 _transferSelector) BrevisApp(_brevisProof) {\n        token = _token;\n        transferSelector = _transferSelector;\n    }\n\n    function submitUserTxs(\n        bytes32 _proofRequestId,\n        uint64 _chainId,\n        bytes32 _smtRoot,\n        Brevis.TransactionInfo[] calldata _info,\n        bytes[] calldata _txRaw\n    ) external {\n        require(_info.length == _txRaw.length, \"length not match\");\n\n        Brevis.ExtractInfos memory info;\n        info.smtRoot = _smtRoot;\n        info.txs = _info;\n\n        validateRequest(_proofRequestId, _chainId, info);\n\n        address from;\n        address receiver;\n        uint256 volume;\n        for (uint256 i = 0; i < _info.length; i++) {\n            bytes memory leafRlp = bytes.concat(_info[i].leafRlpPrefix, _txRaw[i]);\n            bytes32 leafHash = keccak256(leafRlp);\n            require(leafHash == _info[i].leafHash, \"leafHash not match\");\n\n            Tx.TxInfo memory txInfo = Tx.decodeTx(_txRaw[i]);\n            require(txInfo.to == token, \"not a token transfer\");\n            (bytes4 sig, address recv, uint256 amount) = abiDecodeTransfer(txInfo.data);\n            require(sig == transferSelector, \"not transfer selector\");\n            if (i > 0) {\n                require(from == txInfo.from, \"not same sender\");\n                require(recv == receiver, \"not same receiver\");\n            } else {\n                receiver = recv;\n                from = txInfo.from;\n            }\n            volume = volume + amount;\n        }\n        volumes[from][receiver] = volume;\n    }\n\n    function abiDecodeTransfer(bytes memory _data) private pure returns (bytes4 sig, address receiver, uint256 amount) {\n        assembly {\n            sig := mload(add(_data, 32))\n            receiver := mload(add(_data, 36))\n            amount := mload(add(_data, 68))\n        }\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/uniswap-volume/UniswapVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../interface/IBrevisProof.sol\";\n\ncontract UniswapVolume is BrevisApp, Ownable {\n    event SwapVolumeAttested(address user, uint64 sinceBlockNum, uint256 volume);\n\n    bytes32 public vkHash;\n\n    constructor(address brevisProof) BrevisApp(IBrevisProof(brevisProof)) {}\n\n    // BrevisQuery contract will call our callback once Brevis backend submits the proof.\n    function handleProofResult(\n        bytes32 /*_requestId*/,\n        bytes32 _vkHash,\n        bytes calldata _circuitOutput\n    ) internal override {\n        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed\n        // our designated verifying key. This proves that the _circuitOutput is authentic\n        require(vkHash == _vkHash, \"invalid vk\");\n\n        (uint256 sumVolume, uint64 minBlockNum, address userAddr) = decodeOutput(_circuitOutput);\n\n        emit SwapVolumeAttested(userAddr, minBlockNum, sumVolume);\n    }\n\n    // In guest circuit we have:\n    // api.OutputUint256(Salt)\n    // api.OutputUint(248, sumVolume)\n    // api.OutputUint(64, minBlockNum)\n    // api.OutputAddress(c.UserAddr)\n    function decodeOutput(bytes calldata o) internal pure returns (uint256, uint64, address) {\n        uint256 sumVolume = uint256(bytes32(o[32:63])); // sumVolume is packed as a uint248 but we cast it to uint256 here\n        uint64 minBlockNum = uint64(bytes8(o[63:71])); // minBlockNum is uint64 (8 bytes) field in the output\n        address userAddr = address(bytes20(o[71:91])); // c.UserAddr is an address (20 bytes) field in the output\n        return (sumVolume, minBlockNum, userAddr);\n    }\n\n    function setVkHash(bytes32 _vkHash) external onlyOwner {\n        vkHash = _vkHash;\n    }\n}\n"
    },
    "contracts/sdk/apps/framework/BrevisApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../interface/IBrevisProof.sol\";\n\nabstract contract BrevisApp {\n    IBrevisProof public immutable brevisProof;\n\n    constructor(IBrevisProof _brevisProof) {\n        brevisProof = _brevisProof;\n    }\n\n    function validateRequest(\n        bytes32 _requestId,\n        uint64 _chainId,\n        Brevis.ExtractInfos memory _extractInfos\n    ) public view virtual returns (bool) {\n        brevisProof.validateRequest(_requestId, _chainId, _extractInfos);\n        return true;\n    }\n\n    function brevisCallback(bytes32 _requestId, bytes calldata _appCircuitOutput) external {\n        (bytes32 appCommitHash, bytes32 appVkHash) = IBrevisProof(brevisProof).getProofAppData(_requestId);\n        require(appCommitHash == keccak256(_appCircuitOutput), \"failed to open output commitment\");\n        handleProofResult(_requestId, appVkHash, _appCircuitOutput);\n    }\n\n    function handleProofResult(bytes32 _requestId, bytes32 _vkHash, bytes calldata _appCircuitOutput) internal virtual {\n        // to be overrided by custom app\n    }\n}\n"
    },
    "contracts/sdk/apps/framework/SimpleReceiptApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../lib/Lib.sol\";\nimport \"./BrevisApp.sol\";\n\nabstract contract SimpleReceiptApp is BrevisApp, Ownable {\n    Brevis.LogExtraInfo[] private logExtraInfos;\n\n    event LogExtraInfoUpdated(Brevis.LogExtraInfo[] logExtraInfos);\n\n    function validateRequest(\n        bytes32 _requestId,\n        uint64 _chainId,\n        Brevis.ExtractInfos memory _extractInfos\n    ) public view override returns (bool) {\n        brevisProof.validateRequest(_requestId, _chainId, _extractInfos);\n        if (_extractInfos.receipts.length > 0) {\n            _validateLogExtraInfo(_extractInfos.receipts);\n        }\n        return true;\n    }\n\n    // default implementation, can be overwritten\n    function _validateLogExtraInfo(Brevis.ReceiptInfo[] memory _infos) internal view virtual {\n        Brevis.LogExtraInfo[] memory logExtras = logExtraInfos;\n        uint256 receiptFieldsNum = logExtraInfos.length;\n        for (uint256 i = 0; i < _infos.length; i++) {\n            for (uint256 j = 0; j < receiptFieldsNum; j++) {\n                Brevis.LogExtraInfo memory logExtra = _infos[i].logs[j].logExtraInfo;\n                require(logExtras[j].valueFromTopic == logExtra.valueFromTopic, \"wrong valueFromTopic\");\n                require(logExtras[j].valueIndex == logExtra.valueIndex, \"wrong valueIndex\");\n                require(logExtras[j].contractAddress == logExtra.contractAddress, \"wrong contractAddress\");\n                require(logExtras[j].logTopic0 == logExtra.logTopic0, \"wrong logTopic0\");\n            }\n        }\n    }\n\n    function setFieldLocations(Brevis.LogExtraInfo[] calldata _logExtraInfos) public onlyOwner {\n        require(_logExtraInfos.length <= Brevis.NumField);\n        logExtraInfos = _logExtraInfos;\n        emit LogExtraInfoUpdated(_logExtraInfos);\n    }\n\n    function getFieldLocations() public view returns (Brevis.LogExtraInfo[] memory) {\n        return logExtraInfos;\n    }\n}\n"
    },
    "contracts/sdk/apps/test/TestBrevisApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../framework/SimpleReceiptApp.sol\";\nimport \"../../lib/Lib.sol\";\nimport \"../../interface/IBrevisProof.sol\";\n\ncontract TestBrevisApp is SimpleReceiptApp {\n    constructor(IBrevisProof _brevisProof) BrevisApp(_brevisProof) {}\n\n    event Success();\n\n    function submit(\n        bytes32 _proofRequestId,\n        uint64 _chainId,\n        bytes32 _smtRoot,\n        Brevis.ReceiptInfo calldata _rinfo,\n        Brevis.StorageInfo calldata _sinfo,\n        Brevis.TransactionInfo calldata _tinfo\n    ) external {\n        Brevis.ExtractInfos memory info;\n        info.smtRoot = _smtRoot;\n        info.receipts = new Brevis.ReceiptInfo[](1);\n        info.receipts[0] = _rinfo;\n        info.stores = new Brevis.StorageInfo[](1);\n        info.stores[0] = _sinfo;\n        info.txs = new Brevis.TransactionInfo[](1);\n        info.txs[0] = _tinfo;\n\n        validateRequest(_proofRequestId, _chainId, info);\n\n        emit Success();\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../lib/Lib.sol\";\nimport \"../../interfaces/ISMT.sol\";\nimport \"../../verifiers/interfaces/IZkpVerifier.sol\";\n\ncontract BrevisProof is Ownable {\n    uint32 constant PUBLIC_BYTES_START_IDX = 11 * 32; // the first 10 32bytes are groth16 proof (A/B/C/Commitment), the 11th 32bytes is cPub\n\n    struct ChainZKVerifier {\n        IZkpVerifier contractAppZkVerifier;\n        IZkpVerifier circuitAppZkVerifier;\n    }\n    mapping(uint64 => ChainZKVerifier) public verifierAddresses; // chainid => snark verifier contract address\n\n    mapping(bytes32 => Brevis.ProofData) public proofs; // TODO: store hash of proof data to save gas cost\n    mapping(bytes32 => uint256) public vkHashesToBatchSize; // batch tier vk hashes => tier batch size\n\n    ISMT public smtContract;\n\n    event VerifierAddressesUpdated(uint64[] chainIds, ChainZKVerifier[] newAddresses);\n    event SmtContractUpdated(ISMT smtContract);\n    event BatchTierVkHashesUpdated(bytes32[] vkHashes, uint256[] sizes);\n\n    constructor(ISMT _smtContract) {\n        smtContract = _smtContract;\n    }\n\n    function submitProof(\n        uint64 _chainId,\n        bytes calldata _proofWithPubInputs,\n        bool _withAppProof\n    ) external returns (bytes32 _requestId) {\n        require(verifyRaw(_chainId, _proofWithPubInputs, _withAppProof), \"proof not valid\");\n        Brevis.ProofData memory data = unpackProofData(_proofWithPubInputs, _withAppProof);\n        require(data.vkHash > 0, \"vkHash should be larger than 0\");\n        uint256 batchSize = vkHashesToBatchSize[data.vkHash];\n        require(batchSize > 0, \"vkHash not valid\");\n\n        if (_withAppProof) {\n            require(smtContract.isSmtRootValid(_chainId, data.smtRoot), \"smt root not valid\");\n        }\n\n        proofs[data.commitHash] = data;\n        _requestId = data.commitHash;\n    }\n\n    // used by contract app\n    function validateRequest(\n        bytes32 _requestId,\n        uint64 _chainId,\n        Brevis.ExtractInfos calldata _extractInfos\n    ) external view {\n        Brevis.ProofData memory data = proofs[_requestId];\n        require(data.commitHash != bytes32(0), \"proof not exists\");\n        require(smtContract.isSmtRootValid(_chainId, _extractInfos.smtRoot), \"smt root not valid\");\n\n        uint256 itemsLength = _extractInfos.receipts.length + _extractInfos.stores.length + _extractInfos.txs.length;\n        require(itemsLength > 0, \"empty items\");\n        uint256 batchSize = vkHashesToBatchSize[data.vkHash];\n        require(itemsLength <= batchSize, \"item length exceeds batch size\");\n\n        bytes memory hashes;\n\n        for (uint256 i = 0; i < _extractInfos.receipts.length; i++) {\n            bytes memory fieldInfos;\n            for (uint256 j = 0; j < Brevis.NumField; j++) {\n                fieldInfos = abi.encodePacked(\n                    fieldInfos,\n                    _extractInfos.receipts[i].logs[j].logExtraInfo.valueFromTopic,\n                    _extractInfos.receipts[i].logs[j].logIndex,\n                    _extractInfos.receipts[i].logs[j].logExtraInfo.valueIndex,\n                    _extractInfos.receipts[i].logs[j].logExtraInfo.contractAddress,\n                    _extractInfos.receipts[i].logs[j].logExtraInfo.logTopic0,\n                    _extractInfos.receipts[i].logs[j].value\n                );\n            }\n\n            hashes = abi.encodePacked(\n                hashes,\n                keccak256(\n                    abi.encodePacked(\n                        _extractInfos.smtRoot,\n                        _extractInfos.receipts[i].blkNum,\n                        _extractInfos.receipts[i].receiptIndex,\n                        fieldInfos\n                    )\n                )\n            );\n        }\n\n        for (uint256 i = 0; i < _extractInfos.stores.length; i++) {\n            hashes = abi.encodePacked(\n                hashes,\n                keccak256(\n                    abi.encodePacked(\n                        _extractInfos.smtRoot,\n                        _extractInfos.stores[i].blockHash,\n                        keccak256(abi.encodePacked(_extractInfos.stores[i].account)),\n                        _extractInfos.stores[i].slot,\n                        _extractInfos.stores[i].slotValue,\n                        _extractInfos.stores[i].blockNumber\n                    )\n                )\n            );\n        }\n        for (uint256 i = 0; i < _extractInfos.txs.length; i++) {\n            hashes = abi.encodePacked(\n                hashes,\n                keccak256(\n                    abi.encodePacked(\n                        _extractInfos.smtRoot,\n                        _extractInfos.txs[i].leafHash,\n                        _extractInfos.txs[i].blockHash,\n                        _extractInfos.txs[i].blockNumber,\n                        _extractInfos.txs[i].blockTime\n                    )\n                )\n            );\n        }\n\n        if (itemsLength < batchSize) {\n            bytes32 emptyHash = bytes32(0x0000000000000000000000000000000100000000000000000000000000000001);\n            for (uint256 i = itemsLength; i < batchSize; i++) {\n                hashes = abi.encodePacked(hashes, emptyHash);\n            }\n        }\n        require(keccak256(hashes) == data.commitHash, \"commitHash and info not match\");\n    }\n\n    function hasProof(bytes32 _requestId) external view returns (bool) {\n        return proofs[_requestId].commitHash != bytes32(0);\n    }\n\n    function getProofData(bytes32 _requestId) external view returns (Brevis.ProofData memory) {\n        return proofs[_requestId];\n    }\n\n    function getProofAppData(bytes32 _requestId) external view returns (bytes32, bytes32) {\n        return (proofs[_requestId].appCommitHash, proofs[_requestId].appVkHash);\n    }\n\n    function verifyRaw(\n        uint64 _chainId,\n        bytes calldata _proofWithPubInputs,\n        bool _withAppProof\n    ) private view returns (bool) {\n        IZkpVerifier verifier;\n        if (!_withAppProof) {\n            verifier = verifierAddresses[_chainId].contractAppZkVerifier;\n        } else {\n            verifier = verifierAddresses[_chainId].circuitAppZkVerifier;\n        }\n        require(address(verifier) != address(0), \"chain verifier not set\");\n        return verifier.verifyRaw(_proofWithPubInputs);\n    }\n\n    function unpackProofData(\n        bytes calldata _proofWithPubInputs,\n        bool _withAppProof\n    ) internal pure returns (Brevis.ProofData memory data) {\n        if (_withAppProof) {\n            data.commitHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32]);\n            data.smtRoot = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 32:PUBLIC_BYTES_START_IDX + 2 * 32]);\n            data.vkHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32]);\n            data.appCommitHash = bytes32(\n                _proofWithPubInputs[PUBLIC_BYTES_START_IDX + 3 * 32:PUBLIC_BYTES_START_IDX + 4 * 32]\n            );\n            data.appVkHash = bytes32(\n                _proofWithPubInputs[PUBLIC_BYTES_START_IDX + 4 * 32:PUBLIC_BYTES_START_IDX + 5 * 32]\n            );\n        } else {\n            data.commitHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32]);\n            data.length = uint256(\n                bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 32:PUBLIC_BYTES_START_IDX + 2 * 32])\n            );\n            data.vkHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32]);\n        }\n    }\n\n    function updateVerifierAddress(\n        uint64[] calldata _chainIds,\n        ChainZKVerifier[] calldata _verifierAddresses\n    ) public onlyOwner {\n        require(_chainIds.length == _verifierAddresses.length, \"length not match\");\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            verifierAddresses[_chainIds[i]] = _verifierAddresses[i];\n        }\n        emit VerifierAddressesUpdated(_chainIds, _verifierAddresses);\n    }\n\n    function updateSmtContract(ISMT _smtContract) public onlyOwner {\n        smtContract = _smtContract;\n        emit SmtContractUpdated(smtContract);\n    }\n\n    function setBatchTierVkHashes(bytes32[] calldata _vkHashes, uint256[] calldata _sizes) public onlyOwner {\n        require(_vkHashes.length == _sizes.length, \"length not match\");\n        for (uint256 i = 0; i < _vkHashes.length; i++) {\n            vkHashesToBatchSize[_vkHashes[i]] = _sizes[i];\n        }\n\n        emit BatchTierVkHashesUpdated(_vkHashes, _sizes);\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./FeeVault.sol\";\nimport \"../interface/IBrevisProof.sol\";\nimport \"../interface/IBrevisApp.sol\";\n\ncontract BrevisRequest is FeeVault {\n    uint256 public requestTimeout;\n    IBrevisProof public brevisProof;\n\n    enum RequestStatus {\n        Pending,\n        ZkAttested,\n        Refunded\n    }\n\n    struct Request {\n        uint256 deadline;\n        uint256 fee;\n        address refundee;\n        address callback;\n        RequestStatus status;\n    }\n    mapping(bytes32 => Request) public requests; // TODO: store hash of request data to save gas cost\n\n    event RequestTimeoutUpdated(uint256 from, uint256 to);\n    event RequestSent(bytes32 requestId, address sender, uint256 fee, address callback);\n    event RequestFulfilled(bytes32 requestId);\n\n    constructor(address _feeCollector, IBrevisProof _brevisProof) FeeVault(_feeCollector) {\n        brevisProof = _brevisProof;\n    }\n\n    function sendRequest(bytes32 _requestId, address _refundee, address _callback) external payable {\n        require(requests[_requestId].deadline == 0, \"request already in queue\");\n        require(_refundee != address(0), \"refundee not provided\");\n        requests[_requestId] = Request(\n            block.timestamp + requestTimeout,\n            msg.value,\n            _refundee,\n            _callback,\n            RequestStatus.Pending\n        );\n        emit RequestSent(_requestId, msg.sender, msg.value, _callback);\n    }\n\n    function fulfillRequest(\n        bytes32 _requestId,\n        uint64 _chainId,\n        bytes calldata _proof,\n        bool _withAppProof,\n        bytes calldata _appCircuitOutput\n    ) external {\n        bytes32 reqIdFromProof = IBrevisProof(brevisProof).submitProof(_chainId, _proof, _withAppProof); // will revert if proof is not valid\n        require(_requestId == reqIdFromProof, \"requestId and proof not match\");\n        chargeFee(_requestId); // will be reverted when failed to charge fee\n        requests[_requestId].status = RequestStatus.ZkAttested;\n\n        emit RequestFulfilled(_requestId);\n\n        address app = requests[_requestId].callback;\n        if (app != address(0)) {\n            // No matter if the call is success or not. The relayer should set correct gas limit.\n            // If the call exceeds the gasleft(), as the proof data is saved ahead,\n            // anyone can still call the app.callback directly to proceed\n            app.call(abi.encodeWithSelector(IBrevisApp.brevisCallback.selector, _requestId, _appCircuitOutput));\n        }\n    }\n\n    function chargeFee(bytes32 _requestId) public {\n        require(requests[_requestId].deadline != 0, \"request not in queue\");\n        require(IBrevisProof(brevisProof).hasProof(_requestId), \"proof not generated\");\n        requests[_requestId].deadline = 0; //simply set deadline to 0, then fee is not able be refunded\n    }\n\n    function refund(bytes32 _requestId) public {\n        require(requests[_requestId].deadline != 0, \"request not in queue\");\n        require(block.timestamp > requests[_requestId].deadline);\n        requests[_requestId].deadline = 0;\n        (bool sent, ) = requests[_requestId].refundee.call{value: requests[_requestId].fee, gas: 50000}(\"\");\n        require(sent, \"send native failed\");\n        requests[_requestId].status = RequestStatus.Refunded;\n    }\n\n    function setRequestTimeout(uint256 _timeout) external onlyOwner {\n        uint256 oldTimeout = requestTimeout;\n        requestTimeout = _timeout;\n        emit RequestTimeoutUpdated(oldTimeout, _timeout);\n    }\n\n    function queryRequestStatus(bytes32 _requestId) external view returns (RequestStatus) {\n        return requests[_requestId].status;\n    }\n}\n"
    },
    "contracts/sdk/core/FeeVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Allows the owner to set fee collector and allows fee collectors to collect fees\n */\ncontract FeeVault is Ownable {\n    using SafeERC20 for IERC20;\n\n    address public feeCollector;\n\n    event FeeCollectorUpdated(address from, address to);\n\n    constructor(address _feeCollector) {\n        feeCollector = _feeCollector;\n    }\n\n    modifier onlyFeeCollector() {\n        require(msg.sender == feeCollector, \"not fee collector\");\n        _;\n    }\n\n    function collectFee(uint256 _amount, address _to) external onlyFeeCollector {\n        (bool sent, ) = _to.call{value: _amount, gas: 50000}(\"\");\n        require(sent, \"send native failed\");\n    }\n\n    function setFeeCollector(address _feeCollector) external onlyOwner {\n        address oldFeeCollector = feeCollector;\n        feeCollector = _feeCollector;\n        emit FeeCollectorUpdated(oldFeeCollector, _feeCollector);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/sdk/interface/IBrevisApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/Lib.sol\";\n\ninterface IBrevisApp {\n    function brevisCallback(bytes32 _requestId, bytes calldata _appCircuitOutput) external;\n}\n"
    },
    "contracts/sdk/interface/IBrevisProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/Lib.sol\";\n\ninterface IBrevisProof {\n    function submitProof(\n        uint64 _chainId,\n        bytes calldata _proofWithPubInputs,\n        bool _withAppProof\n    ) external returns (bytes32 _requestId);\n\n    function hasProof(bytes32 _requestId) external view returns (bool);\n\n    // used by contract app\n    function validateRequest(bytes32 _requestId, uint64 _chainId, Brevis.ExtractInfos memory _info) external view;\n\n    function getProofData(bytes32 _requestId) external view returns (Brevis.ProofData memory);\n\n    // return appCommitHash and appVkHash\n    function getProofAppData(bytes32 _requestId) external view returns (bytes32, bytes32);\n}\n"
    },
    "contracts/sdk/lib/Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"solidity-rlp/contracts/RLPReader.sol\";\n\nlibrary Brevis {\n    uint256 constant NumField = 5; // supports at most 5 fields per receipt log\n\n    struct ReceiptInfo {\n        uint64 blkNum;\n        uint64 receiptIndex; // ReceiptIndex in the block\n        LogInfo[NumField] logs;\n    }\n\n    struct LogInfo {\n        LogExtraInfo logExtraInfo;\n        uint64 logIndex; // LogIndex of the field\n        bytes32 value;\n    }\n\n    struct LogExtraInfo {\n        uint8 valueFromTopic;\n        uint64 valueIndex; // index of the fields in topic or data\n        address contractAddress;\n        bytes32 logTopic0;\n    }\n\n    struct StorageInfo {\n        bytes32 blockHash;\n        address account;\n        bytes32 slot;\n        bytes32 slotValue;\n        uint64 blockNumber;\n    }\n\n    struct TransactionInfo {\n        bytes32 leafHash;\n        bytes32 blockHash;\n        uint64 blockNumber;\n        uint64 blockTime;\n        bytes leafRlpPrefix;\n    }\n\n    struct ExtractInfos {\n        bytes32 smtRoot;\n        ReceiptInfo[] receipts;\n        StorageInfo[] stores;\n        TransactionInfo[] txs;\n    }\n\n    // retrieved from proofData, to align the logs with circuit...\n    struct ProofData {\n        bytes32 commitHash;\n        uint256 length; // for contract computing proof only\n        bytes32 vkHash;\n        bytes32 appCommitHash; // zk-program computing circuit commit hash\n        bytes32 appVkHash; // zk-program computing circuit Verify Key hash\n        bytes32 smtRoot; // for zk-program computing proof only\n    }\n}\n\nlibrary Tx {\n    using RLPReader for bytes;\n    using RLPReader for uint;\n    using RLPReader for RLPReader.RLPItem;\n\n    struct TxInfo {\n        uint64 chainId;\n        uint64 nonce;\n        uint256 gasTipCap;\n        uint256 gasFeeCap;\n        uint256 gas;\n        address to;\n        uint256 value;\n        bytes data;\n        address from; // calculate from V R S\n    }\n\n    // support DynamicFeeTxType for now\n    function decodeTx(bytes calldata txRaw) public pure returns (TxInfo memory info) {\n        uint8 txType = uint8(txRaw[0]);\n        require(txType == 2, \"not a DynamicFeeTxType\");\n\n        bytes memory rlpData = txRaw[1:];\n        RLPReader.RLPItem[] memory values = rlpData.toRlpItem().toList();\n        info.chainId = uint64(values[0].toUint());\n        info.nonce = uint64(values[1].toUint());\n        info.gasTipCap = values[2].toUint();\n        info.gasFeeCap = values[3].toUint();\n        info.gas = values[4].toUint();\n        info.to = values[5].toAddress();\n        info.value = values[6].toUint();\n        info.data = values[7].toBytes();\n\n        (uint8 v, bytes32 r, bytes32 s) = (\n            uint8(values[9].toUint()),\n            bytes32(values[10].toBytes()),\n            bytes32(values[11].toBytes())\n        );\n        // remove r,s,v and adjust length field\n        bytes memory unsignedTxRaw;\n        uint16 unsignedTxRawDataLength;\n        uint8 prefix = uint8(txRaw[1]);\n        uint8 lenBytes = prefix - 0xf7; // assume lenBytes won't larger than 2, means the tx rlp data size won't exceed 2^16\n        if (lenBytes == 1) {\n            unsignedTxRawDataLength = uint8(bytes1(txRaw[2:3])) - 67; //67 is the bytes of r,s,v\n        } else {\n            unsignedTxRawDataLength = uint16(bytes2(txRaw[2:2 + lenBytes])) - 67;\n        }\n        if (unsignedTxRawDataLength <= 55) {\n            unsignedTxRaw = abi.encodePacked(txRaw[:2], txRaw[3:txRaw.length - 67]);\n            unsignedTxRaw[1] = bytes1(0xc0 + uint8(unsignedTxRawDataLength));\n        } else {\n            if (unsignedTxRawDataLength <= 255) {\n                unsignedTxRaw = abi.encodePacked(\n                    txRaw[0],\n                    bytes1(0xf8),\n                    bytes1(uint8(unsignedTxRawDataLength)),\n                    txRaw[2 + lenBytes:txRaw.length - 67]\n                );\n            } else {\n                unsignedTxRaw = abi.encodePacked(\n                    txRaw[0],\n                    bytes1(0xf9),\n                    bytes2(unsignedTxRawDataLength),\n                    txRaw[2 + lenBytes:txRaw.length - 67]\n                );\n            }\n        }\n        info.from = recover(keccak256(unsignedTxRaw), r, s, v);\n    }\n\n    function recover(bytes32 message, bytes32 r, bytes32 s, uint8 v) internal pure returns (address) {\n        if (v < 27) {\n            v += 27;\n        }\n        return ecrecover(message, v, r, s);\n    }\n}\n"
    },
    "contracts/verifiers/interfaces/ITxVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface ITxVerifier {\n    struct TxInfo {\n        uint64 chainId;\n        uint64 nonce;\n        uint256 gasTipCap;\n        uint256 gasFeeCap;\n        uint256 gas;\n        address to;\n        uint256 value;\n        bytes data;\n        address from; // calculate from V R S\n        uint32 blkNum;\n        bytes32 blkHash;\n        uint64 blkTime;\n    }\n\n    // reverts if not verified\n    // - txRaw: signed dynamic fee tx rlp encode data\n    // - proofData: tx proof data\n    // - auxiBlkVerifyInfo: auxiliary info for blk verify in chunk sync contract\n    function verifyTx(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external view returns (TxInfo memory txInfo);\n\n    // verifyTx and emit event\n    function verifyTxAndLog(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external returns (TxInfo memory info);\n}\n"
    },
    "contracts/verifiers/interfaces/IZkpVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IZkpVerifier {\n    function verifyRaw(bytes calldata proofData) external view returns (bool r);\n}\n"
    },
    "contracts/verifiers/zk-verifiers/common/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IVerifier {\n    struct Proof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[2] commitment;\n    }\n\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[10] calldata input\n    ) external view returns (bool r);\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "solidity-rlp/contracts/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity >=0.5.10 <0.9.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}