{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/light-client-eth/AnchorBlocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IEthereumLightClient.sol\";\nimport \"./interfaces/IAnchorBlocks.sol\";\nimport \"./common/Helpers.sol\";\nimport \"./common/Constants.sol\";\nimport \"./common/Types.sol\";\nimport \"../safeguard/BrevisAccess.sol\";\n\nuint256 constant EXECUTION_BLOCK_LEFT_PREFIX_LEN = 4;\n\ncontract AnchorBlocks is IAnchorBlocks, BrevisAccess {\n    // BlockHashWitness is the RLP code that witnesses the generation of block hash given the ParentHash field\n    struct BlockHashWitness {\n        bytes left;\n        bytes right;\n    }\n\n    event AnchorBlockUpdated(uint256 blockNum, bytes32 blockHash);\n\n    IEthereumLightClient public lightClient;\n    // execution block number => execution block hash\n    mapping(uint256 => bytes32) public blocks;\n    uint256 public latestBlockNum;\n\n    constructor(address _lightClient) {\n        lightClient = IEthereumLightClient(_lightClient);\n    }\n\n    /// @notice Updates an \"anchor block\" of a specific block number to the contract state\n    function processUpdate(LightClientOptimisticUpdate memory hb) external {\n        (uint256 blockNum, bytes32 blockHash) = verifyHeadBlock(hb);\n        require(blockHash != bytes32(0), \"empty blockHash\");\n        doUpdate(blockNum, blockHash);\n    }\n\n    /// @notice Updates an \"anchor block\" of a specific block number to the contract state\n    /// @dev It is possible that an attested block doesn't collect enough sync committee signatures in its corresponding\n    /// signature slot and thus cannot be used in an anchor update. In that case, the updater can pick a later block\n    /// that has enough sigs, and supply a chainProof to show that the block they want to sync can chain to the head block.\n    function processUpdateWithChainProof(\n        LightClientOptimisticUpdate memory hb,\n        bytes32 blockHash,\n        BlockHashWitness[] memory chainProof\n    ) external onlyActiveProver {\n        require(chainProof.length > 0, \"invalid proof length\");\n        (uint256 headBlockNum, bytes32 headBlockHash) = verifyHeadBlock(hb);\n        uint256 blockNum = headBlockNum - chainProof.length;\n        verifyChainProof(blockHash, chainProof, headBlockHash);\n        doUpdate(blockNum, blockHash);\n    }\n\n    function verifyHeadBlock(LightClientOptimisticUpdate memory hb) private view returns (uint256, bytes32) {\n        require(hasSupermajority(hb.syncAggregate.participation), \"quorum not reached\");\n        verifyExecutionPayload(hb.attestedHeader);\n        lightClient.verifyCommitteeSignature(hb.signatureSlot, hb.attestedHeader.beacon, hb.syncAggregate);\n        HeaderWithExecution memory h = hb.attestedHeader;\n        uint256 blockNum = Helpers.revertEndian(uint256(h.execution.blockNumber.leaf));\n        return (blockNum, h.execution.blockHash.leaf);\n    }\n\n    function verifyExecutionPayload(HeaderWithExecution memory h) private pure {\n        bool valid = Helpers.isValidMerkleBranch(h.executionRoot, EXECUTION_PAYLOAD_ROOT_INDEX, h.beacon.bodyRoot);\n        require(valid, \"bad exec root proof\");\n        verifyMerkleProof(h.execution.blockNumber, EXECUTION_BLOCK_NUMBER_LOCAL_INDEX, h.executionRoot.leaf);\n        verifyMerkleProof(h.execution.blockHash, EXECUTION_BLOCK_HASH_LOCAL_INDEX, h.executionRoot.leaf);\n    }\n\n    function doUpdate(uint256 blockNum, bytes32 blockHash) private {\n        require(blocks[blockNum] == bytes32(0), \"block hash already exists\");\n        blocks[blockNum] = blockHash;\n        if (blockNum > latestBlockNum) {\n            latestBlockNum = blockNum;\n        }\n        emit AnchorBlockUpdated(blockNum, blockHash);\n    }\n\n    function verifyChainProof(\n        bytes32 blockHash,\n        BlockHashWitness[] memory chainProof,\n        bytes32 headBlockHash\n    ) private pure {\n        bytes32 h = blockHash;\n        for (uint256 i = 0; i < chainProof.length; i++) {\n            // small hack to save some RLP encoding:\n            // We only care about whether the given blockHash can somehow combine with something to hash into headBlockHash.\n            // The RLP oding of a block always has 3 bytes for total length prefix and 1 byte (0xa0) for bytes32's length\n            // prefix; and the ParentHash field is always the first element. So there are always 8 bytes preceding ParentHash.\n            require(chainProof[i].left.length == EXECUTION_BLOCK_LEFT_PREFIX_LEN, \"invalid left len\");\n            h = keccak256(bytes.concat(chainProof[i].left, h, chainProof[i].right));\n        }\n        require(h == headBlockHash, \"invalid chainProof\");\n    }\n\n    function verifyMerkleProof(LeafWithBranch memory proof, uint256 index, bytes32 root) private pure {\n        require(Helpers.isValidMerkleBranch(proof, index, root), \"bad proof\");\n    }\n\n    function hasSupermajority(uint64 participation) private pure returns (bool) {\n        return participation * 3 >= SYNC_COMMITTEE_SIZE * 2;\n    }\n\n    function setLightClient(address _lightClient) external onlyOwner {\n        lightClient = IEthereumLightClient(_lightClient);\n    }\n}\n"
    },
    "contracts/light-client-eth/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n// light client security params\nuint256 constant MIN_SYNC_COMMITTEE_PARTICIPANTS = 1;\nuint256 constant UPDATE_TIMEOUT = 86400;\n\n// beacon chain constants\nuint256 constant FINALIZED_ROOT_INDEX = 105;\nuint256 constant NEXT_SYNC_COMMITTEE_INDEX = 55;\nuint256 constant SYNC_COMMITTEE_SIZE = 512;\nuint64 constant SLOTS_PER_EPOCH = 32;\nuint64 constant EPOCHS_PER_SYNC_COMMITTEE_PERIOD = 256;\nbytes32 constant DOMAIN_SYNC_COMMITTEE = bytes32(uint256(0x07) << 248);\nuint256 constant SLOT_LENGTH_SECONDS = 12;\n\n// the following indices are gindices counting from the executionPayloadRoot\n// beaconBodyRoot -> executionPayloadRoot gindex: 2 << 4 | 9\nuint256 constant EXECUTION_PAYLOAD_ROOT_INDEX = 25;\n\n// executionPayloadRoot -> stateRoot gindex: 2 << 5 | 2\nuint256 constant EXECUTION_STATE_ROOT_LOCAL_INDEX = 34;\n// executionPayloadRoot -> blockNumber gindex: 2 << 5 | 6\nuint256 constant EXECUTION_BLOCK_NUMBER_LOCAL_INDEX = 38;\n// executionPayloadRoot -> blockHash gindex: 2 << 5 | 12\nuint256 constant EXECUTION_BLOCK_HASH_LOCAL_INDEX = 44;\n"
    },
    "contracts/light-client-eth/common/Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./Types.sol\";\n\nlibrary Helpers {\n    function isValidMerkleBranch(LeafWithBranch memory lwb, uint256 index, bytes32 root) internal pure returns (bool) {\n        bytes32 restoredMerkleRoot = restoreMerkleRoot(lwb.leaf, lwb.branch, index);\n        return root == restoredMerkleRoot;\n    }\n\n    function isValidMerkleBranch(\n        bytes32 leaf,\n        bytes32[] memory branch,\n        uint256 index,\n        bytes32 root\n    ) internal pure returns (bool) {\n        bytes32 restoredMerkleRoot = restoreMerkleRoot(leaf, branch, index);\n        return root == restoredMerkleRoot;\n    }\n\n    function concatMerkleBranches(bytes32[] memory a, bytes32[] memory b) internal pure returns (bytes32[] memory) {\n        bytes32[] memory c = new bytes32[](a.length + b.length);\n        for (uint256 i = 0; i < a.length + b.length; i++) {\n            if (i < a.length) {\n                c[i] = a[i];\n            } else {\n                c[i] = b[i - a.length];\n            }\n        }\n        return c;\n    }\n\n    function restoreMerkleRoot(bytes32 leaf, bytes32[] memory branch, uint256 index) internal pure returns (bytes32) {\n        bytes32 value = leaf;\n        for (uint256 i = 0; i < branch.length; i++) {\n            if ((index / (2 ** i)) % 2 == 1) {\n                value = sha256(bytes.concat(branch[i], value));\n            } else {\n                value = sha256(bytes.concat(value, branch[i]));\n            }\n        }\n        return value;\n    }\n\n    function hashTreeRoot(BeaconBlockHeader memory header) internal pure returns (bytes32) {\n        bytes32 left = sha256(\n            bytes.concat(\n                sha256(bytes.concat(bytes32(revertEndian(header.slot)), bytes32(revertEndian(header.proposerIndex)))),\n                sha256(bytes.concat(header.parentRoot, header.stateRoot))\n            )\n        );\n        bytes32 right = sha256(\n            bytes.concat(\n                sha256(bytes.concat(header.bodyRoot, bytes32(0))),\n                sha256(bytes.concat(bytes32(0), bytes32(0)))\n            )\n        );\n        return sha256(bytes.concat(left, right));\n    }\n\n    function revertEndian(uint256 x) internal pure returns (uint256) {\n        uint256 res;\n        for (uint256 i = 0; i < 32; i++) {\n            res = (res << 8) | (x & 0xff);\n            x >>= 8;\n        }\n        return res;\n    }\n}\n"
    },
    "contracts/light-client-eth/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../verifiers/interfaces/IBeaconVerifier.sol\";\n\nstruct LightClientOptimisticUpdate {\n    // Header attested to by the sync committee\n    HeaderWithExecution attestedHeader;\n    // Sync committee aggregate signature participation & zk proof\n    SyncAggregate syncAggregate;\n    // Slot at which the aggregate signature was created (untrusted)\n    uint64 signatureSlot;\n}\n\nstruct LightClientUpdate {\n    // Header attested to by the sync committee\n    HeaderWithExecution attestedHeader;\n    HeaderWithExecution finalizedHeader;\n    // merkle branch from finalized beacon header root to attestedHeader.stateRoot\n    bytes32[] finalityBranch;\n    bytes32 nextSyncCommitteeRoot;\n    bytes32[] nextSyncCommitteeBranch;\n    bytes32 nextSyncCommitteePoseidonRoot;\n    IBeaconVerifier.Proof nextSyncCommitteeRootMappingProof;\n    // Sync committee aggregate signature participation & zk proof\n    SyncAggregate syncAggregate;\n    // Slot at which the aggregate signature was created (untrusted)\n    uint64 signatureSlot;\n}\n\nstruct HeaderWithExecution {\n    BeaconBlockHeader beacon;\n    ExecutionPayload execution;\n    // merkle branch from execution payload root to beacon block root\n    LeafWithBranch executionRoot;\n}\n\nfunction isEmpty(HeaderWithExecution memory header) pure returns (bool) {\n    return header.beacon.stateRoot == bytes32(0);\n}\n\n// only contains the fields we care about in execution payload\nstruct ExecutionPayload {\n    // merkle branch from execution state root to execution payload root\n    LeafWithBranch stateRoot;\n    // merkle branch from execution block hash to execution payload root\n    LeafWithBranch blockHash;\n    // merkle branch from execution block number to execution payload root\n    LeafWithBranch blockNumber;\n}\n\nfunction isEmpty(ExecutionPayload memory payload) pure returns (bool) {\n    return\n        payload.stateRoot.leaf == bytes32(0) &&\n        payload.blockHash.leaf == bytes32(0) &&\n        payload.blockNumber.leaf == bytes32(0);\n}\n\nstruct LeafWithBranch {\n    bytes32 leaf;\n    bytes32[] branch;\n}\n\nstruct BeaconBlockHeader {\n    uint64 slot;\n    uint64 proposerIndex;\n    bytes32 parentRoot;\n    bytes32 stateRoot;\n    bytes32 bodyRoot;\n}\n\nstruct SyncAggregate {\n    uint64 participation;\n    bytes32 poseidonRoot;\n    uint256 commitment;\n    IBeaconVerifier.Proof proof;\n}\n"
    },
    "contracts/light-client-eth/EthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IEthereumLightClient.sol\";\nimport \"./LightClientStore.sol\";\nimport \"./common/Helpers.sol\";\nimport \"./common/Constants.sol\";\nimport \"./common/Types.sol\";\nimport \"../safeguard/BrevisAccess.sol\";\n\ncontract EthereumLightClient is IEthereumLightClient, LightClientStore, BrevisAccess {\n    event OptimisticUpdate(uint256 slot, bytes32 executionStateRoot);\n    event FinalityUpdate(uint256 slot, bytes32 executionStateRoot);\n    event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot);\n    event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion);\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        uint64 _finalizedSlot,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    )\n        LightClientStore(\n            genesisTime,\n            genesisValidatorsRoot,\n            _forkEpochs,\n            _forkVersions,\n            _finalizedSlot,\n            syncCommitteeRoot,\n            syncCommitteePoseidonRoot,\n            _zkVerifier\n        )\n    {}\n\n    function latestFinalizedSlotAndCommitteeRoots()\n        external\n        view\n        returns (uint64 slot, bytes32 currentRoot, bytes32 nextRoot)\n    {\n        return (finalizedSlot, currentSyncCommitteeRoot, nextSyncCommitteeRoot);\n    }\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (optimisticExecutionStateRoot, optimisticSlot);\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (finalizedExecutionStateRoot, finalizedSlot);\n    }\n\n    function updateForkVersion(uint64 epoch, bytes4 forkVersion) external onlyOwner {\n        require(forkVersion != bytes4(0), \"bad fork version\");\n        forkEpochs.push(epoch);\n        forkVersions.push(forkVersion);\n        emit ForkVersionUpdated(epoch, forkVersion);\n    }\n\n    function processLightClientForceUpdate() external onlyOwner {\n        require(currentSlot() > finalizedSlot + UPDATE_TIMEOUT, \"timeout not passed\");\n        require(bestValidUpdate.attestedHeader.beacon.slot > 0, \"no best valid update\");\n\n        // Forced best update when the update timeout has elapsed.\n        // Because the apply logic waits for finalizedHeader.beacon.slot to indicate sync committee fin,\n        // the attestedHeader may be treated as finalizedHeader in extended periods of non-fin\n        // to guarantee progression into later sync committee periods according to isBetterUpdate().\n        if (bestValidUpdate.finalizedHeader.beacon.slot <= finalizedSlot) {\n            bestValidUpdate.finalizedHeader = bestValidUpdate.attestedHeader;\n        }\n        applyFinalityUpdate(bestValidUpdate);\n        delete bestValidUpdate;\n    }\n\n    function processLightClientUpdate(LightClientUpdate memory update) public onlyActiveProver {\n        bool quorumReached = hasSupermajority(update.syncAggregate.participation);\n        bool betterUpdate = isBetterUpdate(update, bestValidUpdate);\n        require(betterUpdate || quorumReached, \"quorum not reached\");\n        validateLightClientUpdate(update);\n\n        // Update the best update in case we have to force-update to it if the timeout elapses\n        if (betterUpdate) {\n            bestValidUpdate = update;\n        }\n        // Apply optimistic update\n        if (quorumReached && update.attestedHeader.beacon.slot > optimisticSlot) {\n            applyOptimisticUpdate(update);\n        }\n        // Apply finality update\n        if (\n            quorumReached &&\n            (update.finalizedHeader.beacon.slot > finalizedSlot ||\n                (hasNextSyncCommittee(update) && nextSyncCommitteeRoot == bytes32(0)))\n        ) {\n            applyFinalityUpdate(update);\n            delete bestValidUpdate;\n        }\n    }\n\n    function validateLightClientUpdate(LightClientUpdate memory update) private view {\n        // Verify sync committee has sufficient participants\n        require(update.syncAggregate.participation > MIN_SYNC_COMMITTEE_PARTICIPANTS, \"not enough participation\");\n        // Verify update does not skip a sync committee period\n        require(\n            currentSlot() > update.attestedHeader.beacon.slot &&\n                update.attestedHeader.beacon.slot > update.finalizedHeader.beacon.slot,\n            \"bad slot\"\n        );\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedSlot);\n\n        // Verify update is relavant\n        uint64 updateAttestedPeriod = computeSyncCommitteePeriodAtSlot(update.attestedHeader.beacon.slot);\n        bool updateHasNextSyncCommittee = nextSyncCommitteeRoot == bytes32(0) &&\n            hasNextSyncCommitteeProof(update) &&\n            updateAttestedPeriod == storePeriod;\n        // Since sync committee update prefers older header (see isBetterUpdate), an update either\n        // needs to have a newer header or it should have sync committee update.\n        require(\n            update.attestedHeader.beacon.slot > finalizedSlot || updateHasNextSyncCommittee,\n            \"bad att slot or committee\"\n        );\n\n        // Verify that the finalityBranch, if present, confirms finalizedHeader\n        // to match the finalized checkpoint root saved in the state of attestedHeader.\n        // Note that the genesis finalized checkpoint root is represented as a zero hash.\n        if (!hasFinalityProof(update)) {\n            require(isEmpty(update.finalizedHeader), \"no fin proof\");\n        } else {\n            // genesis block header\n            if (update.finalizedHeader.beacon.slot == 0) {\n                require(isEmpty(update.finalizedHeader), \"genesis header should be empty\");\n            } else {\n                bool isValidFinalityProof = Helpers.isValidMerkleBranch(\n                    Helpers.hashTreeRoot(update.finalizedHeader.beacon),\n                    update.finalityBranch,\n                    FINALIZED_ROOT_INDEX,\n                    update.attestedHeader.beacon.stateRoot\n                );\n                require(isValidFinalityProof, \"bad fin proof\");\n                verifyExecutionPayload(update.finalizedHeader, \"finalized\");\n            }\n        }\n\n        // Verify that the update's nextSyncCommittee, if present, actually is the next sync committee\n        // saved in the state of the update's attested header\n        if (!hasNextSyncCommitteeProof(update)) {\n            require(\n                update.nextSyncCommitteeRoot == bytes32(0) && update.nextSyncCommitteePoseidonRoot == bytes32(0),\n                \"no next sync committee proof\"\n            );\n        } else {\n            if (updateAttestedPeriod == storePeriod && nextSyncCommitteeRoot != bytes32(0)) {\n                require(update.nextSyncCommitteeRoot == nextSyncCommitteeRoot, \"bad next sync committee\");\n            }\n            bool validSyncCommitteeProof = Helpers.isValidMerkleBranch(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteeBranch,\n                NEXT_SYNC_COMMITTEE_INDEX,\n                update.attestedHeader.beacon.stateRoot\n            );\n            require(validSyncCommitteeProof, \"bad next sync committee proof\");\n            bool validCommitteeRootMappingProof = zkVerifier.verifySyncCommitteeRootMappingProof(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteePoseidonRoot,\n                update.nextSyncCommitteeRootMappingProof\n            );\n            require(validCommitteeRootMappingProof, \"bad next sync committee root mapping proof\");\n        }\n\n        // Verify optimistic execution payload\n        verifyExecutionPayload(update.attestedHeader, \"optimistic\");\n\n        // Verify sync committee signature ZK proof\n        verifyCommitteeSignature(update.signatureSlot, update.attestedHeader.beacon, update.syncAggregate);\n    }\n\n    function verifyCommitteeSignature(\n        uint64 signatureSlot,\n        BeaconBlockHeader memory header,\n        SyncAggregate memory syncAggregate\n    ) public view {\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedSlot);\n        uint64 updateSigPeriod = computeSyncCommitteePeriodAtSlot(signatureSlot);\n        if (nextSyncCommitteeRoot != bytes32(0)) {\n            require(updateSigPeriod == storePeriod || updateSigPeriod == storePeriod + 1, \"bad sig period 2\");\n        } else {\n            require(updateSigPeriod == storePeriod, \"bad sig period 1\");\n        }\n\n        bytes4 forkVersion = computeForkVersion(computeEpochAtSlot(signatureSlot));\n        bytes32 domain = computeDomain(forkVersion);\n        bytes32 signingRoot = computeSigningRoot(header, domain);\n        bytes32 activeSyncCommitteePoseidonRoot;\n        if (updateSigPeriod == storePeriod) {\n            require(currentSyncCommitteePoseidonRoot == syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = currentSyncCommitteePoseidonRoot;\n        } else {\n            require(nextSyncCommitteePoseidonRoot == syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n        }\n        require(\n            zkVerifier.verifySignatureProof(\n                signingRoot,\n                activeSyncCommitteePoseidonRoot,\n                syncAggregate.participation,\n                syncAggregate.commitment,\n                syncAggregate.proof\n            ),\n            \"bad bls sig proof\"\n        );\n    }\n\n    function verifyExecutionPayload(HeaderWithExecution memory h, string memory name) private pure {\n        ExecutionPayload memory exec = h.execution;\n        bool valid = Helpers.isValidMerkleBranch(h.executionRoot, EXECUTION_PAYLOAD_ROOT_INDEX, h.beacon.bodyRoot);\n        require(valid, string.concat(\"bad exec root proof \", name));\n        valid = Helpers.isValidMerkleBranch(exec.stateRoot, EXECUTION_STATE_ROOT_LOCAL_INDEX, h.executionRoot.leaf);\n        require(valid, string.concat(\"bad exec state root proof \", name));\n    }\n\n    function applyOptimisticUpdate(LightClientUpdate memory update) private {\n        HeaderWithExecution memory h = update.attestedHeader;\n        bytes32 stateRoot = h.execution.stateRoot.leaf;\n        optimisticExecutionStateRoot = stateRoot;\n        optimisticSlot = h.beacon.slot;\n        emit OptimisticUpdate(h.beacon.slot, stateRoot);\n    }\n\n    function applyFinalityUpdate(LightClientUpdate memory update) private {\n        uint64 updateSlot = update.finalizedHeader.beacon.slot;\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedSlot);\n        uint64 updateFinalizedPeriod = computeSyncCommitteePeriodAtSlot(updateSlot);\n        if (nextSyncCommitteeRoot == bytes32(0)) {\n            require(updateFinalizedPeriod == storePeriod, \"mismatch period\");\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        } else if (updateFinalizedPeriod == storePeriod + 1) {\n            currentSyncCommitteeRoot = nextSyncCommitteeRoot;\n            currentSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        }\n        bytes32 updateExecStateRoot = update.finalizedHeader.execution.stateRoot.leaf;\n        if (updateSlot > finalizedSlot) {\n            finalizedExecutionStateRoot = updateExecStateRoot;\n            finalizedSlot = updateSlot;\n            emit FinalityUpdate(updateSlot, updateExecStateRoot);\n            return;\n        }\n    }\n\n    /*\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#is_better_update\n     */\n    function isBetterUpdate(\n        LightClientUpdate memory newUpdate,\n        LightClientUpdate memory oldUpdate\n    ) private pure returns (bool) {\n        // Old update doesn't exist\n        if (oldUpdate.syncAggregate.participation == 0) {\n            return newUpdate.syncAggregate.participation > 0;\n        }\n\n        // Compare supermajority (> 2/3) sync committee participation\n        bool newHasSupermajority = hasSupermajority(newUpdate.syncAggregate.participation);\n        bool oldHasSupermajority = hasSupermajority(oldUpdate.syncAggregate.participation);\n        if (newHasSupermajority != oldHasSupermajority) {\n            // the new update is a better one if new has supermajority but old doesn't\n            return newHasSupermajority && !oldHasSupermajority;\n        }\n        if (!newHasSupermajority && newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            // a better update is the one with higher participation when both new and old doesn't have supermajority\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Compare presence of relevant sync committee\n        bool newHasSyncCommittee = hasRelavantSyncCommittee(newUpdate);\n        bool oldHasSyncCommittee = hasRelavantSyncCommittee(oldUpdate);\n        if (newHasSyncCommittee != oldHasSyncCommittee) {\n            return newHasSyncCommittee;\n        }\n\n        // Compare indication of any fin\n        bool newHasFinality = hasFinalityProof(newUpdate);\n        bool oldHasFinality = hasFinalityProof(oldUpdate);\n        if (newHasFinality != oldHasFinality) {\n            return newHasFinality;\n        }\n\n        // Compare sync committee fin\n        if (newHasFinality) {\n            bool newHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(newUpdate.finalizedHeader.beacon.slot) ==\n                computeSyncCommitteePeriodAtSlot(newUpdate.attestedHeader.beacon.slot);\n            bool oldHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(oldUpdate.finalizedHeader.beacon.slot) ==\n                computeSyncCommitteePeriodAtSlot(oldUpdate.attestedHeader.beacon.slot);\n            if (newHasCommitteeFinality != oldHasCommitteeFinality) {\n                return newHasCommitteeFinality;\n            }\n        }\n\n        // Tiebreaker 1: Sync committee participation beyond supermajority\n        if (newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Tiebreaker 2: Prefer older data (fewer changes to best)\n        if (newUpdate.attestedHeader.beacon.slot != oldUpdate.attestedHeader.beacon.slot) {\n            return newUpdate.attestedHeader.beacon.slot < oldUpdate.attestedHeader.beacon.slot;\n        }\n\n        return newUpdate.signatureSlot < oldUpdate.signatureSlot;\n    }\n\n    function hasRelavantSyncCommittee(LightClientUpdate memory update) private pure returns (bool) {\n        return\n            hasNextSyncCommitteeProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.beacon.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.signatureSlot);\n    }\n\n    function hasNextSyncCommitteeProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.nextSyncCommitteeBranch.length > 0;\n    }\n\n    function hasNextSyncCommittee(LightClientUpdate memory update) private pure returns (bool) {\n        return\n            hasNextSyncCommitteeProof(update) &&\n            hasFinalityProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.finalizedHeader.beacon.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.beacon.slot);\n    }\n\n    function hasFinalityProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.finalityBranch.length > 0;\n    }\n\n    function hasSupermajority(uint64 participation) private pure returns (bool) {\n        return participation * 3 >= SYNC_COMMITTEE_SIZE * 2;\n    }\n\n    function currentSlot() private view returns (uint64) {\n        return uint64((block.timestamp - GENESIS_TIME) / SLOT_LENGTH_SECONDS);\n    }\n\n    function computeForkVersion(uint64 epoch) private view returns (bytes4) {\n        for (uint256 i = forkVersions.length - 1; i >= 0; i--) {\n            if (epoch >= forkEpochs[i]) {\n                return forkVersions[i];\n            }\n        }\n        revert(\"fork versions not set\");\n    }\n\n    function computeSyncCommitteePeriodAtSlot(uint64 slot) private pure returns (uint64) {\n        return computeSyncCommitteePeriod(computeEpochAtSlot(slot));\n    }\n\n    function computeEpochAtSlot(uint64 slot) private pure returns (uint64) {\n        return slot / SLOTS_PER_EPOCH;\n    }\n\n    function computeSyncCommitteePeriod(uint64 epoch) private pure returns (uint64) {\n        return epoch / EPOCHS_PER_SYNC_COMMITTEE_PERIOD;\n    }\n\n    /**\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_domain\n     */\n    function computeDomain(bytes4 forkVersion) public view returns (bytes32) {\n        return DOMAIN_SYNC_COMMITTEE | (sha256(abi.encode(forkVersion, GENESIS_VALIDATOR_ROOT)) >> 32);\n    }\n\n    // computeDomain(forkVersion, genesisValidatorsRoot)\n    function computeSigningRoot(BeaconBlockHeader memory header, bytes32 domain) public pure returns (bytes32) {\n        return sha256(bytes.concat(Helpers.hashTreeRoot(header), domain));\n    }\n}\n"
    },
    "contracts/light-client-eth/interfaces/IAnchorBlocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IAnchorBlocks {\n    function blocks(uint256 blockNum) external view returns (bytes32);\n}\n"
    },
    "contracts/light-client-eth/interfaces/IEthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../common/Types.sol\";\n\ninterface IEthereumLightClient {\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n\n    // reverts if check fails\n    function verifyCommitteeSignature(\n        uint64 signatureSlot,\n        BeaconBlockHeader memory header,\n        SyncAggregate memory syncAggregate\n    ) external view;\n}\n"
    },
    "contracts/light-client-eth/LightClientStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./common/Types.sol\";\nimport \"../verifiers/interfaces/IBeaconVerifier.sol\";\n\nabstract contract LightClientStore {\n    // beacon chain genesis information\n    uint256 immutable GENESIS_TIME;\n    bytes32 immutable GENESIS_VALIDATOR_ROOT;\n\n    uint64 public finalizedSlot;\n    bytes32 public finalizedExecutionStateRoot;\n\n    uint64 public optimisticSlot;\n    bytes32 public optimisticExecutionStateRoot;\n\n    bytes32 public currentSyncCommitteeRoot;\n    bytes32 public currentSyncCommitteePoseidonRoot;\n    bytes32 public nextSyncCommitteeRoot;\n    bytes32 public nextSyncCommitteePoseidonRoot;\n\n    LightClientUpdate public bestValidUpdate;\n\n    // fork versions\n    uint64[] public forkEpochs;\n    bytes4[] public forkVersions;\n\n    // zk verifier\n    IBeaconVerifier public zkVerifier; // contract too big. need to move this one out\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        uint64 _finalizedSlot,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    ) {\n        GENESIS_TIME = genesisTime;\n        GENESIS_VALIDATOR_ROOT = genesisValidatorsRoot;\n        forkEpochs = _forkEpochs;\n        forkVersions = _forkVersions;\n        finalizedSlot = _finalizedSlot;\n        currentSyncCommitteeRoot = syncCommitteeRoot;\n        currentSyncCommitteePoseidonRoot = syncCommitteePoseidonRoot;\n        zkVerifier = IBeaconVerifier(_zkVerifier);\n    }\n}\n"
    },
    "contracts/safeguard/BrevisAccess.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"./Pauser.sol\";\n\n// prover and pauser access control using a single map lookup\nabstract contract BrevisAccess is Pauser {\n    enum ProverState {\n        Null,\n        Active,\n        Paused\n    }\n    mapping(address => ProverState) public proverStates;\n    address[] public provers;\n\n    event ProverAdded(address account);\n    event ProverRemoved(address account);\n\n    modifier onlyProver() {\n        require(proverStates[msg.sender] != ProverState.Null, \"invalid prover\");\n        _;\n    }\n\n    modifier onlyActiveProver() {\n        require(proverStates[msg.sender] == ProverState.Active, \"invalid prover\");\n        _;\n    }\n\n    function addProvers(address[] memory _accounts) public onlyOwner {\n        ProverState state = paused() ? ProverState.Paused : ProverState.Active;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addProver(_accounts[i], state);\n        }\n    }\n\n    function removeProvers(address[] memory _accounts) public onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _removeProver(_accounts[i]);\n        }\n    }\n\n    function pause() public override onlyPauser {\n        _pause();\n        for (uint256 i = 0; i < provers.length; i++) {\n            proverStates[provers[i]] = ProverState.Paused;\n        }\n    }\n\n    function unpause() public override onlyPauser {\n        _unpause();\n        for (uint256 i = 0; i < provers.length; i++) {\n            proverStates[provers[i]] = ProverState.Active;\n        }\n    }\n\n    function numProvers() public view returns (uint256) {\n        return provers.length;\n    }\n\n    function isActiveProver(address _account) public view returns (bool) {\n        return proverStates[_account] == ProverState.Active;\n    }\n\n    function _addProver(address _account, ProverState _state) private {\n        require(proverStates[_account] == ProverState.Null, \"account is prover\");\n        provers.push(_account);\n        proverStates[_account] = _state;\n        emit ProverAdded(_account);\n    }\n\n    function _removeProver(address _account) private {\n        require(proverStates[_account] != ProverState.Null, \"account is not prover\");\n        uint256 lastIndex = provers.length - 1;\n        for (uint256 i = 0; i < provers.length; i++) {\n            if (provers[i] == _account) {\n                if (i < lastIndex) {\n                    provers[i] = provers[lastIndex];\n                }\n                provers.pop();\n                delete proverStates[_account];\n                emit ProverRemoved(_account);\n                return;\n            }\n        }\n        revert(\"prover not found\"); // this should never happen\n    }\n}\n"
    },
    "contracts/safeguard/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\n * This adds a normal func that setOwner if _owner is address(0). So we can't allow\n * renounceOwnership. So we can support Proxy based upgradable contract\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Only to be called by inherit contracts, in their init func called by Proxy\n     * we require _owner == address(0), which is only possible when it's a delegateCall\n     * because constructor sets _owner in contract state.\n     */\n    function initOwner() internal {\n        require(_owner == address(0), \"owner already set\");\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/safeguard/Pauser.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./Ownable.sol\";\n\nabstract contract Pauser is Ownable, Pausable {\n    mapping(address => bool) public pausers;\n    address[] public pauserList;\n\n    event PauserAdded(address account);\n    event PauserRemoved(address account);\n\n    constructor() {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"Caller is not pauser\");\n        _;\n    }\n\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return pausers[account];\n    }\n\n    function addPauser(address account) public onlyOwner {\n        _addPauser(account);\n    }\n\n    function addPausers(address[] memory accounts) public onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _addPauser(accounts[i]);\n        }\n    }\n\n    function removePauser(address account) public onlyOwner {\n        _removePauser(account);\n    }\n\n    function removePausers(address[] memory accounts) public onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _removePauser(accounts[i]);\n        }\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function numPausers() public view returns (uint256) {\n        return pauserList.length;\n    }\n\n    function _addPauser(address account) private {\n        require(!isPauser(account), \"Account is already pauser\");\n        pauserList.push(account);\n        pausers[account] = true;\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) private {\n        require(isPauser(account), \"Account is not pauser\");\n        uint256 lastIndex = pauserList.length - 1;\n        for (uint256 i = 0; i < pauserList.length; i++) {\n            if (pauserList[i] == account) {\n                if (i < lastIndex) {\n                    pauserList[i] = pauserList[lastIndex];\n                }\n                pauserList.pop();\n                pausers[account] = false;\n                emit PauserRemoved(account);\n                return;\n            }\n        }\n        revert(\"pauser not found\"); // this should never happen\n    }\n}\n"
    },
    "contracts/verifiers/interfaces/IBeaconVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IBeaconVerifier {\n    struct Proof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[2] commitment;\n    }\n\n    function verifySignatureProof(\n        bytes32 signingRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        uint256 participation,\n        uint256 commitment,\n        Proof memory p\n    ) external view returns (bool);\n\n    function verifySyncCommitteeRootMappingProof(\n        bytes32 sszRoot,\n        bytes32 poseidonRoot,\n        Proof memory p\n    ) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}