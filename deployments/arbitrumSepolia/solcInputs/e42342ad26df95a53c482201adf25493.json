{
  "language": "Solidity",
  "sources": {
    "contracts/sdk/core/verifiers/Plonky2ProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract Plonky2ProofVerifier {\n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 3630180744704320788844233763608291127950106285684998507223106347915185149792;\n    uint256 constant ALPHA_Y = 13196198558047642402967732277888811606425784559073035773689603364150396504816;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 4793484071695097477578958515547222684223988209770319530038156381048085979731;\n    uint256 constant BETA_NEG_X_1 = 498684634633471661575694288850467457247566219699189449452930818924949618182;\n    uint256 constant BETA_NEG_Y_0 = 11815609728158707801899957509825248461371039895071057944908382533378624078558;\n    uint256 constant BETA_NEG_Y_1 = 12070313006730149903002039026455163366723840475641524599405320033715241375801;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 5955796502819209530519694682997659119464302455444832863178103707638947420117;\n    uint256 constant GAMMA_NEG_X_1 = 1915485519747312921250251119556669374406920349125905464211566252925045075994;\n    uint256 constant GAMMA_NEG_Y_0 = 7307269706974652445827026828173386359328065570805643722662315112380547144827;\n    uint256 constant GAMMA_NEG_Y_1 = 13985735928739904577303054467633195478887414235040255108511623137484769155804;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 863848829239739785718979233236880605336144624213666685025715876762701006720;\n    uint256 constant DELTA_NEG_X_1 = 16231221169861854000828594997407132192455085048582418933589026320111871068020;\n    uint256 constant DELTA_NEG_Y_0 = 5181202426557983626764339767300839679945679900175004234699592936768828651190;\n    uint256 constant DELTA_NEG_Y_1 = 3615832298736737239987675125624399578544079718482934521984705578417868497258;\n    // Pedersen G point in G2 in powers of i\n    uint256 constant PEDERSEN_G_X_0 = 7490179471310076975591245968955394447981648517543123204182300937475283823331;\n    uint256 constant PEDERSEN_G_X_1 = 12956451950241817505957304150968014606470514673841286287720322402761079477557;\n    uint256 constant PEDERSEN_G_Y_0 = 6245856491266623046114236797309693711346785601144287735799792298891246888721;\n    uint256 constant PEDERSEN_G_Y_1 = 10443758596703157728252362115676625834776649185200184484507739795379033706117;\n\n    // Pedersen GRootSigmaNeg point in G2 in powers of i\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_0 = 454433384312897944445468187729925984500371054333846261197128896848710713215;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_1 = 6453903701314664536774415567386846109194149516037532722713971365679979026008;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_0 = 2438098120394322163257888186400283184889733431347369635949505540595910719330;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_1 = 15513178767012717087202831195810534996444208792857470280610978549375725820641;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 17100475366564672631107870126486416833993880904421683020986652350482564384631;\n    uint256 constant CONSTANT_Y = 17667009527642897780017359415718756539919338267490647166315147697136741525785;\n    uint256 constant PUB_0_X = 1162852544627308225421003907682595293344096140811042622844919183028795576201;\n    uint256 constant PUB_0_Y = 7462326333469811331153404954093896712181871303015088728085232937141224405929;\n    uint256 constant PUB_1_X = 4955364365495882637301685169891321575266518387465780561256018367011097407776;\n    uint256 constant PUB_1_Y = 12439330526017835811033560419106034135998021806744525240192427062115544584553;\n    uint256 constant PUB_2_X = 2747792336525268850053625398296340810331081221680706277168008824034195872355;\n    uint256 constant PUB_2_Y = 9146052361846171427848138313940203788569600522894449772237133413389577964215;\n    uint256 constant PUB_3_X = 18081740525633248696447681034992326116157316831281073798185445101652768447345;\n    uint256 constant PUB_3_Y = 1588444792118132375127633317817753266297216226458154078288830827076574968059;\n    uint256 constant PUB_4_X = 21760296273730010311495962498587571131667815332153224334956544183781331427572;\n    uint256 constant PUB_4_Y = 12564232489115746913193058182111092693244146295891199517091630967938194376453;\n    uint256 constant PUB_5_X = 4662912319109720615072141400110727933479753451024261708289527382129800918464;\n    uint256 constant PUB_5_Y = 8884623790550273249384602209236593267811238907637146916915700944193893627995;\n    uint256 constant PUB_6_X = 21861092172552514086480735533251208693499259630614811201696984182597580526413;\n    uint256 constant PUB_6_Y = 21736171081614810269854279746900244530163073334501317356413534930524969873024;\n    uint256 constant PUB_7_X = 5947951566350892334973722370211902525393523821140620996059752326072442750740;\n    uint256 constant PUB_7_Y = 5739604200024524486432918263958527581964498791531698017848663948450362781421;\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(\n        uint256[7] memory input,\n        uint256 publicCommit,\n        uint256[2] memory commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s := mload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s := mload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_2_X)\n            mstore(add(g, 0x20), PUB_2_Y)\n            s := mload(add(input, 64))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_3_X)\n            mstore(add(g, 0x20), PUB_3_Y)\n            s := mload(add(input, 96))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_4_X)\n            mstore(add(g, 0x20), PUB_4_Y)\n            s := mload(add(input, 128))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_5_X)\n            mstore(add(g, 0x20), PUB_5_Y)\n            s := mload(add(input, 160))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_6_X)\n            mstore(add(g, 0x20), PUB_6_Y)\n            s := mload(add(input, 192))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_7_X)\n            mstore(add(g, 0x20), PUB_7_Y)\n\n            s := mload(add(input, 224))\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := mload(commit)\n            mstore(g, s) // save commit[0]\n            s := mload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Verify an uncompressed Groth16 proof.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\n    /// of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyProof(\n        uint256[8] memory proof,\n        uint256[2] memory commitment,\n        uint256[2] memory commitmentPOK,\n        uint256[7] memory input\n    ) public view returns (bool) {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commitment[0], commitment[1]))) % MOD_R;\n        (uint256 x, uint256 y) = publicInputMSM(input, inputFr, commitment);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n\n        uint256 a0 = proof[0];\n        uint256 a1 = proof[1];\n        uint256 b00 = proof[2];\n        uint256 b01 = proof[3];\n        uint256 b10 = proof[4];\n        uint256 b11 = proof[5];\n        uint256 c0 = proof[6];\n        uint256 c1 = proof[7];\n\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n            // Copy points (A, B, C) to memory. They are already in correct encoding.\n            // This is pairing e(A, B) and G1 of e(C, -δ).\n            mstore(f, a0)\n            mstore(add(f, 0x20), a1)\n            mstore(add(f, 0x40), b00)\n            mstore(add(f, 0x60), b01)\n            mstore(add(f, 0x80), b10)\n            mstore(add(f, 0xa0), b11)\n            mstore(add(f, 0xc0), c0)\n            mstore(add(f, 0xe0), c1)\n\n            // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n            // OPT: This could be better done using a single codecopy, but\n            //      Solidity (unlike standalone Yul) doesn't provide a way to\n            //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := mload(commitment)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := mload(add(commitment, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), PEDERSEN_G_Y_0)\n\n            c := mload(commitmentPOK)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := mload(add(commitmentPOK, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), PEDERSEN_GROOTSIGMANEG_X_1)\n            mstore(add(f, 0x420), PEDERSEN_GROOTSIGMANEG_X_0)\n            mstore(add(f, 0x440), PEDERSEN_GROOTSIGMANEG_Y_1)\n            mstore(add(f, 0x460), PEDERSEN_GROOTSIGMANEG_Y_0)\n\n            // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n            // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n        return success;\n    }\n\n    function verifyRaw(bytes calldata proofData) external view returns (bool) {\n        uint256[8] memory proof;\n        proof[0] = uint256(bytes32(proofData[:32]));\n        proof[1] = uint256(bytes32(proofData[32:64]));\n        proof[2] = uint256(bytes32(proofData[64:96]));\n        proof[3] = uint256(bytes32(proofData[96:128]));\n        proof[4] = uint256(bytes32(proofData[128:160]));\n        proof[5] = uint256(bytes32(proofData[160:192]));\n        proof[6] = uint256(bytes32(proofData[192:224]));\n        proof[7] = uint256(bytes32(proofData[224:256]));\n\n        uint256[2] memory commitment;\n        commitment[0] = uint256(bytes32(proofData[256:288]));\n        commitment[1] = uint256(bytes32(proofData[288:320]));\n\n        uint256[2] memory commitmentPOK;\n        commitmentPOK[0] = uint256(bytes32(proofData[320:352]));\n        commitmentPOK[1] = uint256(bytes32(proofData[352:384]));\n\n        uint256[7] memory input;\n        input[0] = uint256(bytes32(proofData[384:416])); // commit hash\n        input[1] = uint256(uint128(bytes16(proofData[416:432]))); // smt root 0\n        input[2] = uint256(uint128(bytes16(proofData[432:448]))); // smt root 1\n        input[3] = uint256(uint128(bytes16(proofData[448:464]))); // output commitment 0\n        input[4] = uint256(uint128(bytes16(proofData[464:480]))); // output commitment 1\n        input[5] = uint256(bytes32(proofData[480:512])); // app vk hash\n        input[6] = uint256(bytes32(proofData[512:544])); // dummy commitment\n\n        return this.verifyProof(proof, commitment, commitmentPOK, input);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}