{
  "address": "0x601247215C88Bcc6947cf44B470e5d721db291CA",
  "abi": [
    {
      "inputs": [],
      "name": "ProofInvalid",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PublicInputNotInField",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[8]",
          "name": "proof",
          "type": "uint256[8]"
        }
      ],
      "name": "compressProof",
      "outputs": [
        {
          "internalType": "uint256[4]",
          "name": "compressed",
          "type": "uint256[4]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[4]",
          "name": "compressedProof",
          "type": "uint256[4]"
        },
        {
          "internalType": "uint256[8]",
          "name": "input",
          "type": "uint256[8]"
        }
      ],
      "name": "verifyCompressedProof",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[8]",
          "name": "proof",
          "type": "uint256[8]"
        },
        {
          "internalType": "uint256[2]",
          "name": "commit",
          "type": "uint256[2]"
        },
        {
          "internalType": "uint256[8]",
          "name": "input",
          "type": "uint256[8]"
        }
      ],
      "name": "verifyProofWithCommit",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "proofData",
          "type": "bytes"
        }
      ],
      "name": "verifyRaw",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x49f1ee55a396a894204ea97bd55d582b32df6b44fb5df6b0e63d531b165e266c",
  "receipt": {
    "to": null,
    "from": "0x58b529F9084D7eAA598EB3477Fe36064C5B7bbC1",
    "contractAddress": "0x601247215C88Bcc6947cf44B470e5d721db291CA",
    "transactionIndex": 72,
    "gasUsed": "1466324",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1f1e443a44aeb228b086a444049b6e88f91bccc9b6fc09049beb6d9a0685d4cc",
    "transactionHash": "0x49f1ee55a396a894204ea97bd55d582b32df6b44fb5df6b0e63d531b165e266c",
    "logs": [],
    "blockNumber": 4971559,
    "cumulativeGasUsed": "10005352",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "6e484fccc0b216f785832bb0f197105d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ProofInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PublicInputNotInField\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"proof\",\"type\":\"uint256[8]\"}],\"name\":\"compressProof\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"compressed\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"compressedProof\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256[8]\",\"name\":\"input\",\"type\":\"uint256[8]\"}],\"name\":\"verifyCompressedProof\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"proof\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[8]\",\"name\":\"input\",\"type\":\"uint256[8]\"}],\"name\":\"verifyProofWithCommit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"verifyRaw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Remco Bloemen\",\"errors\":{\"ProofInvalid()\":[{\"details\":\"This can mean that provided Groth16 proof points are not on their curves, that pairing equation fails, or that the proof is not for the provided public input.\"}],\"PublicInputNotInField()\":[{\"details\":\"Public input elements are not automatically reduced, as this is can be a dangerous source of bugs.\"}]},\"kind\":\"dev\",\"methods\":{\"compressProof(uint256[8])\":{\"params\":{\"proof\":\"The uncompressed Groth16 proof. Elements are in the same order as for verifyProof. I.e. Groth16 points (A, B, C) encoded as in EIP-197.\"},\"returns\":{\"compressed\":\"The compressed proof. Elements are in the same order as for verifyCompressedProof. I.e. points (A, B, C) in compressed format.\"}},\"verifyCompressedProof(uint256[4],uint256[8])\":{\"params\":{\"compressedProof\":\"the points (A, B, C) in compressed format matching the output of compressProof.\",\"input\":\"the public input field elements in the scalar field Fr. Elements must be reduced.\"}},\"verifyProofWithCommit(uint256[8],uint256[2],uint256[8])\":{\"params\":{\"input\":\"the public input field elements in the scalar field Fr. Elements must be reduced.\",\"proof\":\"the points (A, B, C) in EIP-197 format matching the output of compressProof.\"}}},\"title\":\"Groth16 verifier template.\",\"version\":1},\"userdoc\":{\"errors\":{\"ProofInvalid()\":[{\"notice\":\"The proof is invalid.\"}],\"PublicInputNotInField()\":[{\"notice\":\"Some of the provided public input values are larger than the field modulus.\"}]},\"kind\":\"user\",\"methods\":{\"compressProof(uint256[8])\":{\"notice\":\"Compress a proof.Will revert with InvalidProof if the curve points are invalid, but does not verify the proof itself.\"},\"verifyCompressedProof(uint256[4],uint256[8])\":{\"notice\":\"Verify a Groth16 proof with compressed points.Reverts with InvalidProof if the proof is invalid or with PublicInputNotInField the public input is not reduced.There is no return value. If the function does not revert, the proof was successfully verified.\"},\"verifyProofWithCommit(uint256[8],uint256[2],uint256[8])\":{\"notice\":\"Verify an uncompressed Groth16 proof.Reverts with InvalidProof if the proof is invalid or with PublicInputNotInField the public input is not reduced.There is no return value. If the function does not revert, the proof was successfully verified.\"}},\"notice\":\"Supports verifying Groth16 proofs. Proofs can be in uncompressed (256 bytes) and compressed (128 bytes) format. A view function is provided to compress proofs.See <https://2\\u03c0.com/23/bn254-compression> for further explanation.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/sdk/core/AggregationVerifier.sol\":\"AggregationVerifier\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/sdk/core/AggregationVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Groth16 verifier template.\\n/// @author Remco Bloemen\\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\\n/// to compress proofs.\\n/// @notice See <https://2\\u03c0.com/23/bn254-compression> for further explanation.\\ncontract AggregationVerifier {\\n    /// Some of the provided public input values are larger than the field modulus.\\n    /// @dev Public input elements are not automatically reduced, as this is can be\\n    /// a dangerous source of bugs.\\n    error PublicInputNotInField();\\n\\n    /// The proof is invalid.\\n    /// @dev This can mean that provided Groth16 proof points are not on their\\n    /// curves, that pairing equation fails, or that the proof is not for the\\n    /// provided public input.\\n    error ProofInvalid();\\n\\n    // Addresses of precompiles\\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\\n    uint256 constant PRECOMPILE_ADD = 0x06;\\n    uint256 constant PRECOMPILE_MUL = 0x07;\\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\\n\\n    // Base field Fp order P and scalar field Fr order R.\\n    // For BN254 these are computed as follows:\\n    //     t = 4965661367192848881\\n    //     P = 36\\u22c5t\\u2074 + 36\\u22c5t\\u00b3 + 24\\u22c5t\\u00b2 + 6\\u22c5t + 1\\n    //     R = 36\\u22c5t\\u2074 + 36\\u22c5t\\u00b3 + 18\\u22c5t\\u00b2 + 6\\u22c5t + 1\\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\\n\\n    // Extension field Fp2 = Fp[i] / (i\\u00b2 + 1)\\n    // Note: This is the complex extension field of Fp with i\\u00b2 = -1.\\n    //       Values in Fp2 are represented as a pair of Fp elements (a\\u2080, a\\u2081) as a\\u2080 + a\\u2081\\u22c5i.\\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\\n    //       expects Fp2 elements in order (a\\u2081, a\\u2080). This is also the order in which\\n    //       Fp2 elements are encoded in the public interface as this became convention.\\n\\n    // Constants in Fp\\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\\n\\n    // Exponents for inversions and square roots mod P\\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\\n\\n    // Groth16 alpha point in G1\\n    uint256 constant ALPHA_X = 18137944238853917161311242110860070255729414944569707816747039464945601418804;\\n    uint256 constant ALPHA_Y = 9661612135667042581290269931104246373242186850047309049039340679174928843102;\\n\\n    // Groth16 beta point in G2 in powers of i\\n    uint256 constant BETA_NEG_X_0 = 8417953261367873330162035868467351208667119241619555642213685508872108179406;\\n    uint256 constant BETA_NEG_X_1 = 2250963588043469152300320083346411209643543083866936470930035273910972699714;\\n    uint256 constant BETA_NEG_Y_0 = 1516285039929923819820080676312295672544704148521023382451931438268507482083;\\n    uint256 constant BETA_NEG_Y_1 = 18819933702512175407820607866873248362627686866844142203858915911096808416144;\\n\\n    // Groth16 gamma point in G2 in powers of i\\n    uint256 constant GAMMA_NEG_X_0 = 8664366817826456777299149724528974557711251721271336576334899008505537301628;\\n    uint256 constant GAMMA_NEG_X_1 = 1782110020334161377660580030904866608010675311083845032966797804000306319628;\\n    uint256 constant GAMMA_NEG_Y_0 = 19604199545575151699694622845465614081509421704586466172841212221700137535245;\\n    uint256 constant GAMMA_NEG_Y_1 = 17013630610419897620661521093705479571372864433426751351629140366085661346343;\\n\\n    // Groth16 delta point in G2 in powers of i\\n    uint256 constant DELTA_NEG_X_0 = 446508881557515076646415916493722200511066399686483994802923378164454643831;\\n    uint256 constant DELTA_NEG_X_1 = 3762257418791382007742642444598637942699974436037223843660745901714186623910;\\n    uint256 constant DELTA_NEG_Y_0 = 6700347068070373061497220446800416167938882908273173208364615238121233809709;\\n    uint256 constant DELTA_NEG_Y_1 = 14234191371410519099505850000748164952571362672679863923753767997810691748961;\\n\\n    // Constant and public input points\\n    uint256 constant CONSTANT_X = 19167729869952969721286927244059100767403656216619871675145750850161453484034;\\n    uint256 constant CONSTANT_Y = 12354086857259585175246854513166643008535036915847939641528070776231369482596;\\n    uint256 constant PUB_0_X = 17915397004253106177070119427841701494825170688076761758729717483797348518368;\\n    uint256 constant PUB_0_Y = 15337507953663835112788926198629705033394289918004371032852406701098952504004;\\n    uint256 constant PUB_1_X = 4793121170719316613063411915891707110891341000648387940720577500324180049267;\\n    uint256 constant PUB_1_Y = 3135839360408621206002259792284818534075825169882534127752399645185989267647;\\n    uint256 constant PUB_2_X = 17902121318174403601324303789935896102666521702583863326782195181655068795520;\\n    uint256 constant PUB_2_Y = 15042308753547808086675414338668399645077904590937525395093478051646255012896;\\n    uint256 constant PUB_3_X = 18203923209672766016779189533042567713824632288454546875389724722965766426134;\\n    uint256 constant PUB_3_Y = 3721519711337263291619818733489075374691988001648462748953205677956877400035;\\n    uint256 constant PUB_4_X = 19639987287319833569628347795735361021493722493812118793960328852910486838249;\\n    uint256 constant PUB_4_Y = 16257045696999517639043023372491425953680887766556168824461529286443176001583;\\n    uint256 constant PUB_5_X = 11614053277523153809515348074303027856793618484261173637493114544680033175812;\\n    uint256 constant PUB_5_Y = 18010473992413421891952569529588263469836769450078591814474736662048264107573;\\n    uint256 constant PUB_6_X = 11474139989141364408490639365411267160332530091389154607893547984468021109730;\\n    uint256 constant PUB_6_Y = 7454146988223874225495624418683927948457358158512158783852822771986858374912;\\n    uint256 constant PUB_7_X = 10010576029909199407745787104816872387247819184605205047487164205660719829183;\\n    uint256 constant PUB_7_Y = 5774636822755597910471006490367812169032092687979097700269093083477892500989;\\n\\n    /// Negation in Fp.\\n    /// @notice Returns a number x such that a + x = 0 in Fp.\\n    /// @notice The input does not need to be reduced.\\n    /// @param a the base\\n    /// @return x the result\\n    function negate(uint256 a) internal pure returns (uint256 x) {\\n        unchecked {\\n            x = (P - (a % P)) % P; // Modulo is cheaper than branching\\n        }\\n    }\\n\\n    /// Exponentiation in Fp.\\n    /// @notice Returns a number x such that a ^ e = x in Fp.\\n    /// @notice The input does not need to be reduced.\\n    /// @param a the base\\n    /// @param e the exponent\\n    /// @return x the result\\n    function exp(uint256 a, uint256 e) internal view returns (uint256 x) {\\n        bool success;\\n        assembly (\\\"memory-safe\\\") {\\n            let f := mload(0x40)\\n            mstore(f, 0x20)\\n            mstore(add(f, 0x20), 0x20)\\n            mstore(add(f, 0x40), 0x20)\\n            mstore(add(f, 0x60), a)\\n            mstore(add(f, 0x80), e)\\n            mstore(add(f, 0xa0), P)\\n            success := staticcall(gas(), PRECOMPILE_MODEXP, f, 0xc0, f, 0x20)\\n            x := mload(f)\\n        }\\n        if (!success) {\\n            // Exponentiation failed.\\n            // Should not happen.\\n            revert ProofInvalid();\\n        }\\n    }\\n\\n    /// Invertsion in Fp.\\n    /// @notice Returns a number x such that a * x = 1 in Fp.\\n    /// @notice The input does not need to be reduced.\\n    /// @notice Reverts with ProofInvalid() if the inverse does not exist\\n    /// @param a the input\\n    /// @return x the solution\\n    function invert_Fp(uint256 a) internal view returns (uint256 x) {\\n        x = exp(a, EXP_INVERSE_FP);\\n        if (mulmod(a, x, P) != 1) {\\n            // Inverse does not exist.\\n            // Can only happen during G2 point decompression.\\n            revert ProofInvalid();\\n        }\\n    }\\n\\n    /// Square root in Fp.\\n    /// @notice Returns a number x such that x * x = a in Fp.\\n    /// @notice Will revert with InvalidProof() if the input is not a square\\n    /// or not reduced.\\n    /// @param a the square\\n    /// @return x the solution\\n    function sqrt_Fp(uint256 a) internal view returns (uint256 x) {\\n        x = exp(a, EXP_SQRT_FP);\\n        if (mulmod(x, x, P) != a) {\\n            // Square root does not exist or a is not reduced.\\n            // Happens when G1 point is not on curve.\\n            revert ProofInvalid();\\n        }\\n    }\\n\\n    /// Square test in Fp.\\n    /// @notice Returns wheter a number x exists such that x * x = a in Fp.\\n    /// @notice Will revert with InvalidProof() if the input is not a square\\n    /// or not reduced.\\n    /// @param a the square\\n    /// @return x the solution\\n    function isSquare_Fp(uint256 a) internal view returns (bool) {\\n        uint256 x = exp(a, EXP_SQRT_FP);\\n        return mulmod(x, x, P) == a;\\n    }\\n\\n    /// Square root in Fp2.\\n    /// @notice Fp2 is the complex extension Fp[i]/(i^2 + 1). The input is\\n    /// a0 + a1 \\u22c5 i and the result is x0 + x1 \\u22c5 i.\\n    /// @notice Will revert with InvalidProof() if\\n    ///   * the input is not a square,\\n    ///   * the hint is incorrect, or\\n    ///   * the input coefficents are not reduced.\\n    /// @param a0 The real part of the input.\\n    /// @param a1 The imaginary part of the input.\\n    /// @param hint A hint which of two possible signs to pick in the equation.\\n    /// @return x0 The real part of the square root.\\n    /// @return x1 The imaginary part of the square root.\\n    function sqrt_Fp2(uint256 a0, uint256 a1, bool hint) internal view returns (uint256 x0, uint256 x1) {\\n        // If this square root reverts there is no solution in Fp2.\\n        uint256 d = sqrt_Fp(addmod(mulmod(a0, a0, P), mulmod(a1, a1, P), P));\\n        if (hint) {\\n            d = negate(d);\\n        }\\n        // If this square root reverts there is no solution in Fp2.\\n        x0 = sqrt_Fp(mulmod(addmod(a0, d, P), FRACTION_1_2_FP, P));\\n        x1 = mulmod(a1, invert_Fp(mulmod(x0, 2, P)), P);\\n\\n        // Check result to make sure we found a root.\\n        // Note: this also fails if a0 or a1 is not reduced.\\n        if (a0 != addmod(mulmod(x0, x0, P), negate(mulmod(x1, x1, P)), P) || a1 != mulmod(2, mulmod(x0, x1, P), P)) {\\n            revert ProofInvalid();\\n        }\\n    }\\n\\n    /// Compress a G1 point.\\n    /// @notice Reverts with InvalidProof if the coordinates are not reduced\\n    /// or if the point is not on the curve.\\n    /// @notice The point at infinity is encoded as (0,0) and compressed to 0.\\n    /// @param x The X coordinate in Fp.\\n    /// @param y The Y coordinate in Fp.\\n    /// @return c The compresed point (x with one signal bit).\\n    function compress_g1(uint256 x, uint256 y) internal view returns (uint256 c) {\\n        if (x >= P || y >= P) {\\n            // G1 point not in field.\\n            revert ProofInvalid();\\n        }\\n        if (x == 0 && y == 0) {\\n            // Point at infinity\\n            return 0;\\n        }\\n\\n        // Note: sqrt_Fp reverts if there is no solution, i.e. the x coordinate is invalid.\\n        uint256 y_pos = sqrt_Fp(addmod(mulmod(mulmod(x, x, P), x, P), 3, P));\\n        if (y == y_pos) {\\n            return (x << 1) | 0;\\n        } else if (y == negate(y_pos)) {\\n            return (x << 1) | 1;\\n        } else {\\n            // G1 point not on curve.\\n            revert ProofInvalid();\\n        }\\n    }\\n\\n    /// Decompress a G1 point.\\n    /// @notice Reverts with InvalidProof if the input does not represent a valid point.\\n    /// @notice The point at infinity is encoded as (0,0) and compressed to 0.\\n    /// @param c The compresed point (x with one signal bit).\\n    /// @return x The X coordinate in Fp.\\n    /// @return y The Y coordinate in Fp.\\n    function decompress_g1(uint256 c) internal view returns (uint256 x, uint256 y) {\\n        // Note that X = 0 is not on the curve since 0\\u00b3 + 3 = 3 is not a square.\\n        // so we can use it to represent the point at infinity.\\n        if (c == 0) {\\n            // Point at infinity as encoded in EIP196 and EIP197.\\n            return (0, 0);\\n        }\\n        bool negate_point = c & 1 == 1;\\n        x = c >> 1;\\n        if (x >= P) {\\n            // G1 x coordinate not in field.\\n            revert ProofInvalid();\\n        }\\n\\n        // Note: (x\\u00b3 + 3) is irreducible in Fp, so it can not be zero and therefore\\n        //       y can not be zero.\\n        // Note: sqrt_Fp reverts if there is no solution, i.e. the point is not on the curve.\\n        y = sqrt_Fp(addmod(mulmod(mulmod(x, x, P), x, P), 3, P));\\n        if (negate_point) {\\n            y = negate(y);\\n        }\\n    }\\n\\n    /// Compress a G2 point.\\n    /// @notice Reverts with InvalidProof if the coefficients are not reduced\\n    /// or if the point is not on the curve.\\n    /// @notice The G2 curve is defined over the complex extension Fp[i]/(i^2 + 1)\\n    /// with coordinates (x0 + x1 \\u22c5 i, y0 + y1 \\u22c5 i).\\n    /// @notice The point at infinity is encoded as (0,0,0,0) and compressed to (0,0).\\n    /// @param x0 The real part of the X coordinate.\\n    /// @param x1 The imaginary poart of the X coordinate.\\n    /// @param y0 The real part of the Y coordinate.\\n    /// @param y1 The imaginary part of the Y coordinate.\\n    /// @return c0 The first half of the compresed point (x0 with two signal bits).\\n    /// @return c1 The second half of the compressed point (x1 unmodified).\\n    function compress_g2(\\n        uint256 x0,\\n        uint256 x1,\\n        uint256 y0,\\n        uint256 y1\\n    ) internal view returns (uint256 c0, uint256 c1) {\\n        if (x0 >= P || x1 >= P || y0 >= P || y1 >= P) {\\n            // G2 point not in field.\\n            revert ProofInvalid();\\n        }\\n        if ((x0 | x1 | y0 | y1) == 0) {\\n            // Point at infinity\\n            return (0, 0);\\n        }\\n\\n        // Compute y^2\\n        // Note: shadowing variables and scoping to avoid stack-to-deep.\\n        uint256 y0_pos;\\n        uint256 y1_pos;\\n        {\\n            uint256 n3ab = mulmod(mulmod(x0, x1, P), P - 3, P);\\n            uint256 a_3 = mulmod(mulmod(x0, x0, P), x0, P);\\n            uint256 b_3 = mulmod(mulmod(x1, x1, P), x1, P);\\n            y0_pos = addmod(FRACTION_27_82_FP, addmod(a_3, mulmod(n3ab, x1, P), P), P);\\n            y1_pos = negate(addmod(FRACTION_3_82_FP, addmod(b_3, mulmod(n3ab, x0, P), P), P));\\n        }\\n\\n        // Determine hint bit\\n        // If this sqrt fails the x coordinate is not on the curve.\\n        bool hint;\\n        {\\n            uint256 d = sqrt_Fp(addmod(mulmod(y0_pos, y0_pos, P), mulmod(y1_pos, y1_pos, P), P));\\n            hint = !isSquare_Fp(mulmod(addmod(y0_pos, d, P), FRACTION_1_2_FP, P));\\n        }\\n\\n        // Recover y\\n        (y0_pos, y1_pos) = sqrt_Fp2(y0_pos, y1_pos, hint);\\n        if (y0 == y0_pos && y1 == y1_pos) {\\n            c0 = (x0 << 2) | (hint ? 2 : 0) | 0;\\n            c1 = x1;\\n        } else if (y0 == negate(y0_pos) && y1 == negate(y1_pos)) {\\n            c0 = (x0 << 2) | (hint ? 2 : 0) | 1;\\n            c1 = x1;\\n        } else {\\n            // G1 point not on curve.\\n            revert ProofInvalid();\\n        }\\n    }\\n\\n    /// Decompress a G2 point.\\n    /// @notice Reverts with InvalidProof if the input does not represent a valid point.\\n    /// @notice The G2 curve is defined over the complex extension Fp[i]/(i^2 + 1)\\n    /// with coordinates (x0 + x1 \\u22c5 i, y0 + y1 \\u22c5 i).\\n    /// @notice The point at infinity is encoded as (0,0,0,0) and compressed to (0,0).\\n    /// @param c0 The first half of the compresed point (x0 with two signal bits).\\n    /// @param c1 The second half of the compressed point (x1 unmodified).\\n    /// @return x0 The real part of the X coordinate.\\n    /// @return x1 The imaginary poart of the X coordinate.\\n    /// @return y0 The real part of the Y coordinate.\\n    /// @return y1 The imaginary part of the Y coordinate.\\n    function decompress_g2(\\n        uint256 c0,\\n        uint256 c1\\n    ) internal view returns (uint256 x0, uint256 x1, uint256 y0, uint256 y1) {\\n        // Note that X = (0, 0) is not on the curve since 0\\u00b3 + 3/(9 + i) is not a square.\\n        // so we can use it to represent the point at infinity.\\n        if (c0 == 0 && c1 == 0) {\\n            // Point at infinity as encoded in EIP197.\\n            return (0, 0, 0, 0);\\n        }\\n        bool negate_point = c0 & 1 == 1;\\n        bool hint = c0 & 2 == 2;\\n        x0 = c0 >> 2;\\n        x1 = c1;\\n        if (x0 >= P || x1 >= P) {\\n            // G2 x0 or x1 coefficient not in field.\\n            revert ProofInvalid();\\n        }\\n\\n        uint256 n3ab = mulmod(mulmod(x0, x1, P), P - 3, P);\\n        uint256 a_3 = mulmod(mulmod(x0, x0, P), x0, P);\\n        uint256 b_3 = mulmod(mulmod(x1, x1, P), x1, P);\\n\\n        y0 = addmod(FRACTION_27_82_FP, addmod(a_3, mulmod(n3ab, x1, P), P), P);\\n        y1 = negate(addmod(FRACTION_3_82_FP, addmod(b_3, mulmod(n3ab, x0, P), P), P));\\n\\n        // Note: sqrt_Fp2 reverts if there is no solution, i.e. the point is not on the curve.\\n        // Note: (X\\u00b3 + 3/(9 + i)) is irreducible in Fp2, so y can not be zero.\\n        //       But y0 or y1 may still independently be zero.\\n        (y0, y1) = sqrt_Fp2(y0, y1, hint);\\n        if (negate_point) {\\n            y0 = negate(y0);\\n            y1 = negate(y1);\\n        }\\n    }\\n\\n    /// Compute the public input linear combination.\\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\\n    /// @notice Computes the multi-scalar-multiplication of the public input\\n    /// elements and the verification key including the constant term.\\n    /// @param input The public inputs. These are elements of the scalar field Fr.\\n    /// @return x The X coordinate of the resulting G1 point.\\n    /// @return y The Y coordinate of the resulting G1 point.\\n    function publicInputMSM(uint256[8] calldata input) internal view returns (uint256 x, uint256 y) {\\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\\n        //       code-size is in the PUB_ constants.\\n        // ECMUL has input (x, y, scalar) and output (x', y').\\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\\n        // We call them such that ecmul output is already in the second point\\n        // argument to ECADD so we can have a tight loop.\\n        bool success = true;\\n        assembly (\\\"memory-safe\\\") {\\n            let f := mload(0x40)\\n            let g := add(f, 0x40)\\n            let s\\n            mstore(f, CONSTANT_X)\\n            mstore(add(f, 0x20), CONSTANT_Y)\\n            mstore(g, PUB_0_X)\\n            mstore(add(g, 0x20), PUB_0_Y)\\n            s := calldataload(input)\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_1_X)\\n            mstore(add(g, 0x20), PUB_1_Y)\\n            s := calldataload(add(input, 32))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_2_X)\\n            mstore(add(g, 0x20), PUB_2_Y)\\n            s := calldataload(add(input, 64))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_3_X)\\n            mstore(add(g, 0x20), PUB_3_Y)\\n            s := calldataload(add(input, 96))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_4_X)\\n            mstore(add(g, 0x20), PUB_4_Y)\\n            s := calldataload(add(input, 128))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_5_X)\\n            mstore(add(g, 0x20), PUB_5_Y)\\n            s := calldataload(add(input, 160))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_6_X)\\n            mstore(add(g, 0x20), PUB_6_Y)\\n            s := calldataload(add(input, 192))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_7_X)\\n            mstore(add(g, 0x20), PUB_7_Y)\\n            s := calldataload(add(input, 224))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            x := mload(f)\\n            y := mload(add(f, 0x20))\\n        }\\n        if (!success) {\\n            // Either Public input not in field, or verification key invalid.\\n            // We assume the contract is correctly generated, so the verification key is valid.\\n            revert PublicInputNotInField();\\n        }\\n    }\\n\\n    /// Compute the public input linear combination.\\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\\n    /// @notice Computes the multi-scalar-multiplication of the public input\\n    /// elements and the verification key including the constant term.\\n    /// @param input The public inputs. These are elements of the scalar field Fr.\\n    /// @return x The X coordinate of the resulting G1 point.\\n    /// @return y The Y coordinate of the resulting G1 point.\\n    function publicInputMSMWithCommit(\\n        uint256[8] memory input,\\n        uint256[2] memory commit\\n    ) internal view returns (uint256 x, uint256 y) {\\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\\n        //       code-size is in the PUB_ constants.\\n        // ECMUL has input (x, y, scalar) and output (x', y').\\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\\n        // We call them such that ecmul output is already in the second point\\n        // argument to ECADD so we can have a tight loop.\\n        bool success = true;\\n        assembly (\\\"memory-safe\\\") {\\n            let f := mload(0x40)\\n            let g := add(f, 0x40)\\n            let s\\n            mstore(f, CONSTANT_X)\\n            mstore(add(f, 0x20), CONSTANT_Y)\\n            mstore(g, PUB_0_X)\\n            mstore(add(g, 0x20), PUB_0_Y)\\n            s := mload(input)\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_1_X)\\n            mstore(add(g, 0x20), PUB_1_Y)\\n            s := mload(add(input, 32))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_2_X)\\n            mstore(add(g, 0x20), PUB_2_Y)\\n            s := mload(add(input, 64))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_3_X)\\n            mstore(add(g, 0x20), PUB_3_Y)\\n            s := mload(add(input, 96))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_4_X)\\n            mstore(add(g, 0x20), PUB_4_Y)\\n            s := mload(add(input, 128))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_5_X)\\n            mstore(add(g, 0x20), PUB_5_Y)\\n            s := mload(add(input, 160))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_6_X)\\n            mstore(add(g, 0x20), PUB_6_Y)\\n            s := mload(add(input, 192))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n            mstore(g, PUB_7_X)\\n            mstore(add(g, 0x20), PUB_7_Y)\\n            s := mload(add(input, 224))\\n            mstore(add(g, 0x40), s)\\n            success := and(success, lt(s, R))\\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n\\n            s := mload(commit)\\n            mstore(g, s) // save commit[0]\\n            x := mload(add(commit, 32))\\n            mstore(add(g, 0x20), x) // save commit[1]\\n\\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\\n\\n            x := mload(f)\\n            y := mload(add(f, 0x20))\\n        }\\n        if (!success) {\\n            // Either Public input not in field, or verification key invalid.\\n            // We assume the contract is correctly generated, so the verification key is valid.\\n            revert PublicInputNotInField();\\n        }\\n    }\\n\\n    /// Compress a proof.\\n    /// @notice Will revert with InvalidProof if the curve points are invalid,\\n    /// but does not verify the proof itself.\\n    /// @param proof The uncompressed Groth16 proof. Elements are in the same order as for\\n    /// verifyProof. I.e. Groth16 points (A, B, C) encoded as in EIP-197.\\n    /// @return compressed The compressed proof. Elements are in the same order as for\\n    /// verifyCompressedProof. I.e. points (A, B, C) in compressed format.\\n    function compressProof(uint256[8] calldata proof) public view returns (uint256[4] memory compressed) {\\n        compressed[0] = compress_g1(proof[0], proof[1]);\\n        (compressed[2], compressed[1]) = compress_g2(proof[3], proof[2], proof[5], proof[4]);\\n        compressed[3] = compress_g1(proof[6], proof[7]);\\n    }\\n\\n    /// Verify a Groth16 proof with compressed points.\\n    /// @notice Reverts with InvalidProof if the proof is invalid or\\n    /// with PublicInputNotInField the public input is not reduced.\\n    /// @notice There is no return value. If the function does not revert, the\\n    /// proof was successfully verified.\\n    /// @param compressedProof the points (A, B, C) in compressed format\\n    /// matching the output of compressProof.\\n    /// @param input the public input field elements in the scalar field Fr.\\n    /// Elements must be reduced.\\n    function verifyCompressedProof(uint256[4] calldata compressedProof, uint256[8] calldata input) public view {\\n        (uint256 Ax, uint256 Ay) = decompress_g1(compressedProof[0]);\\n        (uint256 Bx0, uint256 Bx1, uint256 By0, uint256 By1) = decompress_g2(compressedProof[2], compressedProof[1]);\\n        (uint256 Cx, uint256 Cy) = decompress_g1(compressedProof[3]);\\n        (uint256 Lx, uint256 Ly) = publicInputMSM(input);\\n\\n        // Verify the pairing\\n        // Note: The precompile expects the F2 coefficients in big-endian order.\\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\\n        uint256[24] memory pairings;\\n        // e(A, B)\\n        pairings[0] = Ax;\\n        pairings[1] = Ay;\\n        pairings[2] = Bx1;\\n        pairings[3] = Bx0;\\n        pairings[4] = By1;\\n        pairings[5] = By0;\\n        // e(C, -\\u03b4)\\n        pairings[6] = Cx;\\n        pairings[7] = Cy;\\n        pairings[8] = DELTA_NEG_X_1;\\n        pairings[9] = DELTA_NEG_X_0;\\n        pairings[10] = DELTA_NEG_Y_1;\\n        pairings[11] = DELTA_NEG_Y_0;\\n        // e(\\u03b1, -\\u03b2)\\n        pairings[12] = ALPHA_X;\\n        pairings[13] = ALPHA_Y;\\n        pairings[14] = BETA_NEG_X_1;\\n        pairings[15] = BETA_NEG_X_0;\\n        pairings[16] = BETA_NEG_Y_1;\\n        pairings[17] = BETA_NEG_Y_0;\\n        // e(L_pub, -\\u03b3)\\n        pairings[18] = Lx;\\n        pairings[19] = Ly;\\n        pairings[20] = GAMMA_NEG_X_1;\\n        pairings[21] = GAMMA_NEG_X_0;\\n        pairings[22] = GAMMA_NEG_Y_1;\\n        pairings[23] = GAMMA_NEG_Y_0;\\n\\n        // Check pairing equation.\\n        bool success;\\n        uint256[1] memory output;\\n        assembly (\\\"memory-safe\\\") {\\n            success := staticcall(gas(), PRECOMPILE_VERIFY, pairings, 0x300, output, 0x20)\\n        }\\n        if (!success || output[0] != 1) {\\n            // Either proof or verification key invalid.\\n            // We assume the contract is correctly generated, so the verification key is valid.\\n            revert ProofInvalid();\\n        }\\n    }\\n\\n    /// Verify an uncompressed Groth16 proof.\\n    /// @notice Reverts with InvalidProof if the proof is invalid or\\n    /// with PublicInputNotInField the public input is not reduced.\\n    /// @notice There is no return value. If the function does not revert, the\\n    /// proof was successfully verified.\\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\\n    /// of compressProof.\\n    /// @param input the public input field elements in the scalar field Fr.\\n    /// Elements must be reduced.\\n    function verifyProofWithCommit(\\n        uint256[8] memory proof,\\n        uint256[2] memory commit,\\n        uint256[8] memory input\\n    ) public view returns (bool) {\\n        (uint256 x, uint256 y) = publicInputMSMWithCommit(input, commit);\\n\\n        // Note: The precompile expects the F2 coefficients in big-endian order.\\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\\n\\n        bool success;\\n\\n        uint256 a0 = proof[0];\\n        uint256 a1 = proof[1];\\n        uint256 b00 = proof[2];\\n        uint256 b01 = proof[3];\\n        uint256 b10 = proof[4];\\n        uint256 b11 = proof[5];\\n        uint256 c0 = proof[6];\\n        uint256 c1 = proof[7];\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let f := mload(0x40) // Free memory pointer.\\n\\n            // Copy points (A, B, C) to memory. They are already in correct encoding.\\n            // This is pairing e(A, B) and G1 of e(C, -\\u03b4).\\n            mstore(f, a0)\\n            mstore(add(f, 0x20), a1)\\n            mstore(add(f, 0x40), b00)\\n            mstore(add(f, 0x60), b01)\\n            mstore(add(f, 0x80), b10)\\n            mstore(add(f, 0xa0), b11)\\n            mstore(add(f, 0xc0), c0)\\n            mstore(add(f, 0xe0), c1)\\n\\n            // Complete e(C, -\\u03b4) and write e(\\u03b1, -\\u03b2), e(L_pub, -\\u03b3) to memory.\\n            // OPT: This could be better done using a single codecopy, but\\n            //      Solidity (unlike standalone Yul) doesn't provide a way to\\n            //      to do this.\\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\\n            mstore(add(f, 0x180), ALPHA_X)\\n            mstore(add(f, 0x1a0), ALPHA_Y)\\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\\n            mstore(add(f, 0x240), x)\\n            mstore(add(f, 0x260), y)\\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\\n\\n            // Check pairing equation.\\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x300, f, 0x20)\\n            // Also check returned value (both are either 1 or 0).\\n            success := and(success, mload(f))\\n        }\\n        if (!success) {\\n            // Either proof or verification key invalid.\\n            // We assume the contract is correctly generated, so the verification key is valid.\\n            revert ProofInvalid();\\n        }\\n        return success;\\n    }\\n\\n    function verifyRaw(bytes calldata proofData) external view returns (bool) {\\n        uint256[8] memory proof;\\n        proof[0] = uint256(bytes32(proofData[:32]));\\n        proof[1] = uint256(bytes32(proofData[32:64]));\\n        proof[2] = uint256(bytes32(proofData[64:96]));\\n        proof[3] = uint256(bytes32(proofData[96:128]));\\n        proof[4] = uint256(bytes32(proofData[128:160]));\\n        proof[5] = uint256(bytes32(proofData[160:192]));\\n        proof[6] = uint256(bytes32(proofData[192:224]));\\n        proof[7] = uint256(bytes32(proofData[224:256]));\\n\\n        uint256[2] memory commit;\\n        commit[0] = uint256(bytes32(proofData[256:288]));\\n        commit[1] = uint256(bytes32(proofData[288:320]));\\n\\n        uint256[8] memory input;\\n        input[7] = uint256(bytes32(proofData[320:352])); //input last one is cpub\\n\\n        input[0] = uint256(bytes32(proofData[352:384]));\\n        input[1] = uint256(uint128(bytes16(proofData[384:400])));\\n        input[2] = uint256(uint128(bytes16(proofData[400:416])));\\n        input[3] = uint256(bytes32(proofData[416:448]));\\n        input[4] = uint256(uint128(bytes16(proofData[448:464])));\\n        input[5] = uint256(uint128(bytes16(proofData[464:480])));\\n        input[6] = uint256(bytes32(proofData[480:512]));\\n\\n        return verifyProofWithCommit(proof, commit, input);\\n    }\\n}\\n\",\"keccak256\":\"0x4ff9364266c89b916482885bb6dfef9018de255c402375c90d2d11355953dc67\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001657611989908161001c8239f35b600080fdfe60808060405260048036101561001457600080fd5b600091823560e01c90816344f6369214610ae957508063457726e614610916578063483066711461013a5763cc73d2a31461004e57600080fd5b346101365761024036600319011261013657366023121561013657610071610ba5565b806101049236841161013257905b83821061012257505036610123121561011e5761009a610bdc565b806101449336851161011a57905b84821061010a575050366101631215610106576100c3610ba5565b9182610244943686116101025760209650905b8582106100f35750506100e993506111ee565b6040519015158152f35b813581529086019086016100d6565b8680fd5b8380fd5b81358152602091820191016100a8565b8580fd5b8280fd5b813581526020918201910161007f565b8480fd5b5080fd5b5034610136576101803660031901126101365736608411610136573661018411610136576101688135611059565b6101766024356044356110c0565b91939290610185606435611059565b939092604051967f2a608cf7488fe48c0417d1fe9c07c1cc12e6c9fce521fdd342a91173ef7ec802885260208801967f1b502a55921bf1a279cd3b3f7e5a9494ed6610a3c82bde8597920ad31131a16488527f279bc15f9a1148ed70bface05642c159563533bf7eda88b7d4b96567ab9289e060408a01527f21e8b8cc61250a2e6220ee267801a8624861fac6a6f59cdf304d8de304a332c460608a015260843560808a01526040808a016060828c0160075afa60408a60808160065afa906000805160206119348339815191526084351016167f0a98cf79463366e415ec245b5551d1a05938d048780cb271760e9ab8102cbd7360408b01527f06eed27a6e94841429ae67982a323118f19890a5044e1228493885267035d0bf60608b015260a435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f27943dd909892777ad045e00151d9385dd1572abd53eb9240d34058ccb44628060408b01527f2141a5217df2e7b6158d308eb7195f03753dcf767207666d77c0f4c2a4861c2060608b015260c435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f283f0e2f5c0e9175d4a686d063fbe17cbeb1465cc7b9eb6c43db570cb0e74e1660408b01527f083a4e36082ef58a40cccbfe40be6e2aecb800fbed6cc44d81a672a9c29237e360608b015260e435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f2b6bd6c0749b507caa9f6de59968958858ce628945490614fa1330f67b8bdbe960408b01527f23f1296ae9c5912432fae199c743130632ef2bf3d16da0a2b0d5f96b4803802f60608b01528960016101043592836080840152600080516020611934833981519152604080808601606082880160075afa9460808160065afa9410161616167f19ad523a8395b1412108d2ffac34dbbd9b713fd87ad95d7d0b505f5f38fdc90460408b01527f27d191291834e3af74da2fbfe0a18ec21bb6b7c4c2009ca90fd578bc8933363560608b015261012435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f195e22123739328851661d6f93957bb25a1961426f791a003e49630a4e0863e260408b01527f107ae5ce9187fa86c2fcc12a7650612e62f41379d425a286e25f7d792a05f70060608b015261014435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f1621c905d214fc230cbfbd6004151e12b1eb32adfe2a6f9a815b1ecb30ec50bf60408b01527f0cc4542035a288c3bb9d1c8883cc9eb138417cce2b797dcaed95a170acd18dfd60608b015261016435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa931016161698519751981561090557604051998a61030081011067ffffffffffffffff6103008d0111176108f2576103008b01604052610300368c378a5260208a015260408901526060880152608087015260a086015260c085015260e08401527f08515cbb951ef7637e4bebdb8f9090ac3b9dfa0e78d293f1705e89e5a522dba66101008401527efcb70ee5e9aebacb4fc8fa9fa94258d8b61767fefbd83b105b65d36133d8776101208401527f1f78444dd95691b9a779400739a944f5891648075fe261191522a722b59334616101408401527f0ed0431590f71be0e84653b26177634e5d9b9a228cde0c13c4403afedd9b812d6101608401527f2819b66f50d9dc5f8a726f09868ddc07e697633c8327433cc3b3b5c3097316346101808401527f155c4757977b3df944bcc334da471e4b41476366c2d31b87846fead41dddc15e6101a08401527f04fa000fdb815c2b90b84ed34d6d7022f686ae58ac0f9617cbeed3127065d4426101c08401527f129c648821f552077e952b63687d53d3498047b45a15778bfd9610afc2d6ffce6101e08401527f299bb47a72e993115d3f1b8be6f210dc0b0ac60261bd88dc2637bb556f22a3906102008401527f035a2fd9f68964b90958f6a51f1bd7290da2e047d3bfd0e1611f68284b83e7e36102208401526102408301526102608201527f03f0a3767c7afb9dc86bad41515fcf048b46e8eb3ee0f6d3c78782d5c2fcd10c6102808201527f1327db9aecc8cc68c62b5e7f7547964082c81a18395085276305c4eb73130c7c6102a08201527f259d5fa90e932484c7bdc0c41702337c28ae660b2fb1fd0dde8f6418376f4a276102c08201527f2b57956f5666fe1073bf4a3751a330f9c56ec2260605b8e2e4909491a757c70d6102e0820152604051906020820182811067ffffffffffffffff8211176108df5761030060209284926040528336843760085afa159081156108d2575b506108c3575080f35b604051631ff3747d60e21b8152fd5b60019150511415386108ba565b634e487b7160e01b855260418452602485fd5b634e487b7160e01b8d5260418c5260248dfd5b60405163a54f8e2760e01b81528b90fd5b509034610ae65760209081600319360112610ae65782359267ffffffffffffffff9081851161011e573660238601121561011e5784013590811161013657366024828601011161013657610968610ba5565b6101009283368337828511610ae6576024860135825282604011610ae65760448601358583015282606011610ae6576064860135604083015260809280841161013657608487013560608401528060a0116101365760a4870135848401528060c0116101365760c487013560a08401528060e0116101365760e487013560c08401528085116101365761010487013560e0840152610a04610bdc565b936040368637816101201161011e576101248801358552816101401161011e5761014488013587860152610a36610ba5565b95368737816101601161011e5761016488013560e0870152816101801161011e576101848801358652816101901161011e576101a4880135811c87870152816101a01161011e576101b4880135811c6040870152816101c01161011e576101c48801356060870152816101d01161011e576101e4880135811c81870152816101e01161011e576101f4880135901c60a086015261020011610ae657506102046100e99495013560c08401526111ee565b80fd5b828434610ae657610100366003190112610ae6573661010411610ae6576080830183811067ffffffffffffffff821117610b9257604052916080368237610b336024358335610bfc565b8152610b4960843560a435604435606435610d4d565b9190602092838301526040820152610b6560e43560c435610bfc565b60608201526040519390845b848310610b7d57608086f35b83806001928451815201920192019190610b71565b506041602492634e487b7160e01b835252fd5b60405190610100820182811067ffffffffffffffff821117610bc657604052565b634e487b7160e01b600052604160045260246000fd5b604051906040820182811067ffffffffffffffff821117610bc657604052565b907f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47808310801590610c92575b610c7057821580610c8a575b610c8257610c4c8160038186818180090908610c9c565b828103610c5c5750505060011b90565b81900681030603610c7057600190811b1790565b604051631ff3747d60e21b8152600490fd5b505050600090565b508115610c35565b5080821015610c29565b90610ca682610cd2565b917f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4783800903610c7057565b9060405191602083526020808401526020604084015260608301527f0c19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f5260808301527f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760a083015260208260c08160055afa91519115610c7057565b909293917f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4794858310801590610f2f575b8015610f25575b8015610f1b575b610c70578082868517171715610f0f5785610e8081808080808981808e9f8f9e9f7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd448280928709099e8f0981848181800909087f2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5089b09818d8181800909087f2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775080681030695827f183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea481610e6781808c80098187800908610c9c565b84080983610e7482610cd2565b80091415968791610f39565b939080821480610f06575b15610eb857505050505090600090600014610eb0575060ff60025b169060021b179190565b60ff90610ea6565b82809106810306149283610ef5575b505050600014610c705760019160009015610eed575060ff60025b169060021b17179190565b60ff90610ee2565b819293500681030614388080610ec7565b50848414610e8b565b50600094508493505050565b5085811015610d8c565b5085821015610d85565b5085851015610d7e565b91610fa97f183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4919492947f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd479283809281610f9a81808c8009818c800908610c9c565b9161104d575b50870809610c9c565b9381600286096040519060208252602080830152602060408301528060608301527f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4560808301528360a083015260208260c08160055afa91519115610c705783826001920903610c7057829082099382808080888009068103068188800908149182159261103a575b5050610c7057565b8091925084860960020914153880611032565b80910681030681610fa0565b80156110b7578060011c917f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780841015610c70576001806110a38360038189818180090908610c9c565b9416146110ad5750565b8091920681030690565b50600090600090565b9190918015806111e6575b6111d9578060021c9280927f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47918286108015906111cf575b610c70578584848080858180808080600280827f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd446111a69f8f90839109099b16149a8a0981868181800909087f2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e77508068103069409818b8181800909087f2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e508610f39565b90928193600180829716146111ba57505050565b81900681038190069450908190068103069150565b5082811015611103565b5060009150819081908190565b5082156110cb565b91906020604051927f2a608cf7488fe48c0417d1fe9c07c1cc12e6c9fce521fdd342a91173ef7ec80284527f1b502a55921bf1a279cd3b3f7e5a9494ed6610a3c82bde8597920ad31131a164828501527f279bc15f9a1148ed70bface05642c159563533bf7eda88b7d4b96567ab9289e060408501527f21e8b8cc61250a2e6220ee267801a8624861fac6a6f59cdf304d8de304a332c4606085015260e081518060808701526040808701606082890160075afa60008051602061193483398151915260408860808160065afa921016167f0a98cf79463366e415ec245b5551d1a05938d048780cb271760e9ab8102cbd7360408701527f06eed27a6e94841429ae67982a323118f19890a5044e1228493885267035d0bf6060870152838301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa93101616167f27943dd909892777ad045e00151d9385dd1572abd53eb9240d34058ccb44628060408701527f2141a5217df2e7b6158d308eb7195f03753dcf767207666d77c0f4c2a4861c20606087015260408301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa93101616167f283f0e2f5c0e9175d4a686d063fbe17cbeb1465cc7b9eb6c43db570cb0e74e1660408701527f083a4e36082ef58a40cccbfe40be6e2aecb800fbed6cc44d81a672a9c29237e3606087015260608301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa93101616167f2b6bd6c0749b507caa9f6de59968958858ce628945490614fa1330f67b8bdbe960408701527f23f1296ae9c5912432fae199c743130632ef2bf3d16da0a2b0d5f96b4803802f6060870152608083015190816080880152600160408089016060828b0160075afa9160008051602061193483398151915260408a60808160065afa9410161616167f19ad523a8395b1412108d2ffac34dbbd9b713fd87ad95d7d0b505f5f38fdc90460408701527f27d191291834e3af74da2fbfe0a18ec21bb6b7c4c2009ca90fd578bc89333635606087015260a08301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa93101616167f195e22123739328851661d6f93957bb25a1961426f791a003e49630a4e0863e260408701527f107ae5ce9187fa86c2fcc12a7650612e62f41379d425a286e25f7d792a05f700606087015260c08301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa9310161616917f1621c905d214fc230cbfbd6004151e12b1eb32adfe2a6f9a815b1ecb30ec50bf60408701527f0cc4542035a288c3bb9d1c8883cc9eb138417cce2b797dcaed95a170acd18dfd60608701520151908160808601526040808601606082880160075afa9060008051602061193483398151915260408760808160065afa931016161691805160408501520151606083015260408260808160065afa1690602081519101519115611921578251926020810151906040810151606082015160808301519060a08401519260e060c086015195015195604051998a5260208a015260408901526060880152608087015260a086015260c085015260e08401527f08515cbb951ef7637e4bebdb8f9090ac3b9dfa0e78d293f1705e89e5a522dba66101008401527efcb70ee5e9aebacb4fc8fa9fa94258d8b61767fefbd83b105b65d36133d8776101208401527f1f78444dd95691b9a779400739a944f5891648075fe261191522a722b59334616101408401527f0ed0431590f71be0e84653b26177634e5d9b9a228cde0c13c4403afedd9b812d6101608401527f2819b66f50d9dc5f8a726f09868ddc07e697633c8327433cc3b3b5c3097316346101808401527f155c4757977b3df944bcc334da471e4b41476366c2d31b87846fead41dddc15e6101a08401527f04fa000fdb815c2b90b84ed34d6d7022f686ae58ac0f9617cbeed3127065d4426101c08401527f129c648821f552077e952b63687d53d3498047b45a15778bfd9610afc2d6ffce6101e08401527f299bb47a72e993115d3f1b8be6f210dc0b0ac60261bd88dc2637bb556f22a3906102008401527f035a2fd9f68964b90958f6a51f1bd7290da2e047d3bfd0e1611f68284b83e7e36102208401526102408301526102608201527f03f0a3767c7afb9dc86bad41515fcf048b46e8eb3ee0f6d3c78782d5c2fcd10c6102808201527f1327db9aecc8cc68c62b5e7f7547964082c81a18395085276305c4eb73130c7c6102a08201527f259d5fa90e932484c7bdc0c41702337c28ae660b2fb1fd0dde8f6418376f4a276102c08201527f2b57956f5666fe1073bf4a3751a330f9c56ec2260605b8e2e4909491a757c70d6102e08201526020816103008160085afa9051168015610c705790565b60405163a54f8e2760e01b8152600490fdfe30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001a26469706673582212209047bbf0580898580011e5c7bd1f5f241053ae7b7db0d5435d9ab026b1ef862264736f6c63430008140033",
  "deployedBytecode": "0x60808060405260048036101561001457600080fd5b600091823560e01c90816344f6369214610ae957508063457726e614610916578063483066711461013a5763cc73d2a31461004e57600080fd5b346101365761024036600319011261013657366023121561013657610071610ba5565b806101049236841161013257905b83821061012257505036610123121561011e5761009a610bdc565b806101449336851161011a57905b84821061010a575050366101631215610106576100c3610ba5565b9182610244943686116101025760209650905b8582106100f35750506100e993506111ee565b6040519015158152f35b813581529086019086016100d6565b8680fd5b8380fd5b81358152602091820191016100a8565b8580fd5b8280fd5b813581526020918201910161007f565b8480fd5b5080fd5b5034610136576101803660031901126101365736608411610136573661018411610136576101688135611059565b6101766024356044356110c0565b91939290610185606435611059565b939092604051967f2a608cf7488fe48c0417d1fe9c07c1cc12e6c9fce521fdd342a91173ef7ec802885260208801967f1b502a55921bf1a279cd3b3f7e5a9494ed6610a3c82bde8597920ad31131a16488527f279bc15f9a1148ed70bface05642c159563533bf7eda88b7d4b96567ab9289e060408a01527f21e8b8cc61250a2e6220ee267801a8624861fac6a6f59cdf304d8de304a332c460608a015260843560808a01526040808a016060828c0160075afa60408a60808160065afa906000805160206119348339815191526084351016167f0a98cf79463366e415ec245b5551d1a05938d048780cb271760e9ab8102cbd7360408b01527f06eed27a6e94841429ae67982a323118f19890a5044e1228493885267035d0bf60608b015260a435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f27943dd909892777ad045e00151d9385dd1572abd53eb9240d34058ccb44628060408b01527f2141a5217df2e7b6158d308eb7195f03753dcf767207666d77c0f4c2a4861c2060608b015260c435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f283f0e2f5c0e9175d4a686d063fbe17cbeb1465cc7b9eb6c43db570cb0e74e1660408b01527f083a4e36082ef58a40cccbfe40be6e2aecb800fbed6cc44d81a672a9c29237e360608b015260e435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f2b6bd6c0749b507caa9f6de59968958858ce628945490614fa1330f67b8bdbe960408b01527f23f1296ae9c5912432fae199c743130632ef2bf3d16da0a2b0d5f96b4803802f60608b01528960016101043592836080840152600080516020611934833981519152604080808601606082880160075afa9460808160065afa9410161616167f19ad523a8395b1412108d2ffac34dbbd9b713fd87ad95d7d0b505f5f38fdc90460408b01527f27d191291834e3af74da2fbfe0a18ec21bb6b7c4c2009ca90fd578bc8933363560608b015261012435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f195e22123739328851661d6f93957bb25a1961426f791a003e49630a4e0863e260408b01527f107ae5ce9187fa86c2fcc12a7650612e62f41379d425a286e25f7d792a05f70060608b015261014435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa93101616167f1621c905d214fc230cbfbd6004151e12b1eb32adfe2a6f9a815b1ecb30ec50bf60408b01527f0cc4542035a288c3bb9d1c8883cc9eb138417cce2b797dcaed95a170acd18dfd60608b015261016435908160808c015260408b606082808301920160075afa9060008051602061193483398151915260408d60808160065afa931016161698519751981561090557604051998a61030081011067ffffffffffffffff6103008d0111176108f2576103008b01604052610300368c378a5260208a015260408901526060880152608087015260a086015260c085015260e08401527f08515cbb951ef7637e4bebdb8f9090ac3b9dfa0e78d293f1705e89e5a522dba66101008401527efcb70ee5e9aebacb4fc8fa9fa94258d8b61767fefbd83b105b65d36133d8776101208401527f1f78444dd95691b9a779400739a944f5891648075fe261191522a722b59334616101408401527f0ed0431590f71be0e84653b26177634e5d9b9a228cde0c13c4403afedd9b812d6101608401527f2819b66f50d9dc5f8a726f09868ddc07e697633c8327433cc3b3b5c3097316346101808401527f155c4757977b3df944bcc334da471e4b41476366c2d31b87846fead41dddc15e6101a08401527f04fa000fdb815c2b90b84ed34d6d7022f686ae58ac0f9617cbeed3127065d4426101c08401527f129c648821f552077e952b63687d53d3498047b45a15778bfd9610afc2d6ffce6101e08401527f299bb47a72e993115d3f1b8be6f210dc0b0ac60261bd88dc2637bb556f22a3906102008401527f035a2fd9f68964b90958f6a51f1bd7290da2e047d3bfd0e1611f68284b83e7e36102208401526102408301526102608201527f03f0a3767c7afb9dc86bad41515fcf048b46e8eb3ee0f6d3c78782d5c2fcd10c6102808201527f1327db9aecc8cc68c62b5e7f7547964082c81a18395085276305c4eb73130c7c6102a08201527f259d5fa90e932484c7bdc0c41702337c28ae660b2fb1fd0dde8f6418376f4a276102c08201527f2b57956f5666fe1073bf4a3751a330f9c56ec2260605b8e2e4909491a757c70d6102e0820152604051906020820182811067ffffffffffffffff8211176108df5761030060209284926040528336843760085afa159081156108d2575b506108c3575080f35b604051631ff3747d60e21b8152fd5b60019150511415386108ba565b634e487b7160e01b855260418452602485fd5b634e487b7160e01b8d5260418c5260248dfd5b60405163a54f8e2760e01b81528b90fd5b509034610ae65760209081600319360112610ae65782359267ffffffffffffffff9081851161011e573660238601121561011e5784013590811161013657366024828601011161013657610968610ba5565b6101009283368337828511610ae6576024860135825282604011610ae65760448601358583015282606011610ae6576064860135604083015260809280841161013657608487013560608401528060a0116101365760a4870135848401528060c0116101365760c487013560a08401528060e0116101365760e487013560c08401528085116101365761010487013560e0840152610a04610bdc565b936040368637816101201161011e576101248801358552816101401161011e5761014488013587860152610a36610ba5565b95368737816101601161011e5761016488013560e0870152816101801161011e576101848801358652816101901161011e576101a4880135811c87870152816101a01161011e576101b4880135811c6040870152816101c01161011e576101c48801356060870152816101d01161011e576101e4880135811c81870152816101e01161011e576101f4880135901c60a086015261020011610ae657506102046100e99495013560c08401526111ee565b80fd5b828434610ae657610100366003190112610ae6573661010411610ae6576080830183811067ffffffffffffffff821117610b9257604052916080368237610b336024358335610bfc565b8152610b4960843560a435604435606435610d4d565b9190602092838301526040820152610b6560e43560c435610bfc565b60608201526040519390845b848310610b7d57608086f35b83806001928451815201920192019190610b71565b506041602492634e487b7160e01b835252fd5b60405190610100820182811067ffffffffffffffff821117610bc657604052565b634e487b7160e01b600052604160045260246000fd5b604051906040820182811067ffffffffffffffff821117610bc657604052565b907f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47808310801590610c92575b610c7057821580610c8a575b610c8257610c4c8160038186818180090908610c9c565b828103610c5c5750505060011b90565b81900681030603610c7057600190811b1790565b604051631ff3747d60e21b8152600490fd5b505050600090565b508115610c35565b5080821015610c29565b90610ca682610cd2565b917f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4783800903610c7057565b9060405191602083526020808401526020604084015260608301527f0c19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f5260808301527f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760a083015260208260c08160055afa91519115610c7057565b909293917f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4794858310801590610f2f575b8015610f25575b8015610f1b575b610c70578082868517171715610f0f5785610e8081808080808981808e9f8f9e9f7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd448280928709099e8f0981848181800909087f2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5089b09818d8181800909087f2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775080681030695827f183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea481610e6781808c80098187800908610c9c565b84080983610e7482610cd2565b80091415968791610f39565b939080821480610f06575b15610eb857505050505090600090600014610eb0575060ff60025b169060021b179190565b60ff90610ea6565b82809106810306149283610ef5575b505050600014610c705760019160009015610eed575060ff60025b169060021b17179190565b60ff90610ee2565b819293500681030614388080610ec7565b50848414610e8b565b50600094508493505050565b5085811015610d8c565b5085821015610d85565b5085851015610d7e565b91610fa97f183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4919492947f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd479283809281610f9a81808c8009818c800908610c9c565b9161104d575b50870809610c9c565b9381600286096040519060208252602080830152602060408301528060608301527f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4560808301528360a083015260208260c08160055afa91519115610c705783826001920903610c7057829082099382808080888009068103068188800908149182159261103a575b5050610c7057565b8091925084860960020914153880611032565b80910681030681610fa0565b80156110b7578060011c917f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4780841015610c70576001806110a38360038189818180090908610c9c565b9416146110ad5750565b8091920681030690565b50600090600090565b9190918015806111e6575b6111d9578060021c9280927f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47918286108015906111cf575b610c70578584848080858180808080600280827f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd446111a69f8f90839109099b16149a8a0981868181800909087f2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e77508068103069409818b8181800909087f2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e508610f39565b90928193600180829716146111ba57505050565b81900681038190069450908190068103069150565b5082811015611103565b5060009150819081908190565b5082156110cb565b91906020604051927f2a608cf7488fe48c0417d1fe9c07c1cc12e6c9fce521fdd342a91173ef7ec80284527f1b502a55921bf1a279cd3b3f7e5a9494ed6610a3c82bde8597920ad31131a164828501527f279bc15f9a1148ed70bface05642c159563533bf7eda88b7d4b96567ab9289e060408501527f21e8b8cc61250a2e6220ee267801a8624861fac6a6f59cdf304d8de304a332c4606085015260e081518060808701526040808701606082890160075afa60008051602061193483398151915260408860808160065afa921016167f0a98cf79463366e415ec245b5551d1a05938d048780cb271760e9ab8102cbd7360408701527f06eed27a6e94841429ae67982a323118f19890a5044e1228493885267035d0bf6060870152838301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa93101616167f27943dd909892777ad045e00151d9385dd1572abd53eb9240d34058ccb44628060408701527f2141a5217df2e7b6158d308eb7195f03753dcf767207666d77c0f4c2a4861c20606087015260408301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa93101616167f283f0e2f5c0e9175d4a686d063fbe17cbeb1465cc7b9eb6c43db570cb0e74e1660408701527f083a4e36082ef58a40cccbfe40be6e2aecb800fbed6cc44d81a672a9c29237e3606087015260608301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa93101616167f2b6bd6c0749b507caa9f6de59968958858ce628945490614fa1330f67b8bdbe960408701527f23f1296ae9c5912432fae199c743130632ef2bf3d16da0a2b0d5f96b4803802f6060870152608083015190816080880152600160408089016060828b0160075afa9160008051602061193483398151915260408a60808160065afa9410161616167f19ad523a8395b1412108d2ffac34dbbd9b713fd87ad95d7d0b505f5f38fdc90460408701527f27d191291834e3af74da2fbfe0a18ec21bb6b7c4c2009ca90fd578bc89333635606087015260a08301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa93101616167f195e22123739328851661d6f93957bb25a1961426f791a003e49630a4e0863e260408701527f107ae5ce9187fa86c2fcc12a7650612e62f41379d425a286e25f7d792a05f700606087015260c08301519081608088015260408088016060828a0160075afa9060008051602061193483398151915260408960808160065afa9310161616917f1621c905d214fc230cbfbd6004151e12b1eb32adfe2a6f9a815b1ecb30ec50bf60408701527f0cc4542035a288c3bb9d1c8883cc9eb138417cce2b797dcaed95a170acd18dfd60608701520151908160808601526040808601606082880160075afa9060008051602061193483398151915260408760808160065afa931016161691805160408501520151606083015260408260808160065afa1690602081519101519115611921578251926020810151906040810151606082015160808301519060a08401519260e060c086015195015195604051998a5260208a015260408901526060880152608087015260a086015260c085015260e08401527f08515cbb951ef7637e4bebdb8f9090ac3b9dfa0e78d293f1705e89e5a522dba66101008401527efcb70ee5e9aebacb4fc8fa9fa94258d8b61767fefbd83b105b65d36133d8776101208401527f1f78444dd95691b9a779400739a944f5891648075fe261191522a722b59334616101408401527f0ed0431590f71be0e84653b26177634e5d9b9a228cde0c13c4403afedd9b812d6101608401527f2819b66f50d9dc5f8a726f09868ddc07e697633c8327433cc3b3b5c3097316346101808401527f155c4757977b3df944bcc334da471e4b41476366c2d31b87846fead41dddc15e6101a08401527f04fa000fdb815c2b90b84ed34d6d7022f686ae58ac0f9617cbeed3127065d4426101c08401527f129c648821f552077e952b63687d53d3498047b45a15778bfd9610afc2d6ffce6101e08401527f299bb47a72e993115d3f1b8be6f210dc0b0ac60261bd88dc2637bb556f22a3906102008401527f035a2fd9f68964b90958f6a51f1bd7290da2e047d3bfd0e1611f68284b83e7e36102208401526102408301526102608201527f03f0a3767c7afb9dc86bad41515fcf048b46e8eb3ee0f6d3c78782d5c2fcd10c6102808201527f1327db9aecc8cc68c62b5e7f7547964082c81a18395085276305c4eb73130c7c6102a08201527f259d5fa90e932484c7bdc0c41702337c28ae660b2fb1fd0dde8f6418376f4a276102c08201527f2b57956f5666fe1073bf4a3751a330f9c56ec2260605b8e2e4909491a757c70d6102e08201526020816103008160085afa9051168015610c705790565b60405163a54f8e2760e01b8152600490fdfe30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001a26469706673582212209047bbf0580898580011e5c7bd1f5f241053ae7b7db0d5435d9ab026b1ef862264736f6c63430008140033",
  "devdoc": {
    "author": "Remco Bloemen",
    "errors": {
      "ProofInvalid()": [
        {
          "details": "This can mean that provided Groth16 proof points are not on their curves, that pairing equation fails, or that the proof is not for the provided public input."
        }
      ],
      "PublicInputNotInField()": [
        {
          "details": "Public input elements are not automatically reduced, as this is can be a dangerous source of bugs."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "compressProof(uint256[8])": {
        "params": {
          "proof": "The uncompressed Groth16 proof. Elements are in the same order as for verifyProof. I.e. Groth16 points (A, B, C) encoded as in EIP-197."
        },
        "returns": {
          "compressed": "The compressed proof. Elements are in the same order as for verifyCompressedProof. I.e. points (A, B, C) in compressed format."
        }
      },
      "verifyCompressedProof(uint256[4],uint256[8])": {
        "params": {
          "compressedProof": "the points (A, B, C) in compressed format matching the output of compressProof.",
          "input": "the public input field elements in the scalar field Fr. Elements must be reduced."
        }
      },
      "verifyProofWithCommit(uint256[8],uint256[2],uint256[8])": {
        "params": {
          "input": "the public input field elements in the scalar field Fr. Elements must be reduced.",
          "proof": "the points (A, B, C) in EIP-197 format matching the output of compressProof."
        }
      }
    },
    "title": "Groth16 verifier template.",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "ProofInvalid()": [
        {
          "notice": "The proof is invalid."
        }
      ],
      "PublicInputNotInField()": [
        {
          "notice": "Some of the provided public input values are larger than the field modulus."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "compressProof(uint256[8])": {
        "notice": "Compress a proof.Will revert with InvalidProof if the curve points are invalid, but does not verify the proof itself."
      },
      "verifyCompressedProof(uint256[4],uint256[8])": {
        "notice": "Verify a Groth16 proof with compressed points.Reverts with InvalidProof if the proof is invalid or with PublicInputNotInField the public input is not reduced.There is no return value. If the function does not revert, the proof was successfully verified."
      },
      "verifyProofWithCommit(uint256[8],uint256[2],uint256[8])": {
        "notice": "Verify an uncompressed Groth16 proof.Reverts with InvalidProof if the proof is invalid or with PublicInputNotInField the public input is not reduced.There is no return value. If the function does not revert, the proof was successfully verified."
      }
    },
    "notice": "Supports verifying Groth16 proofs. Proofs can be in uncompressed (256 bytes) and compressed (128 bytes) format. A view function is provided to compress proofs.See <https://2π.com/23/bn254-compression> for further explanation.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}