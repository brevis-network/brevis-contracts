{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/apps/message-bridge/apps/examples/MsgInOrder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9;\n\nimport \"../../framework/MessageApp.sol\";\n\n// a simple example to enforce in-order message delivery\ncontract MsgInOrder is MessageApp {\n    event MessageReceived(uint64 srcChainId, address srcContract, address sender, uint64 seq, bytes message);\n\n    // map at source chain. (dstChainId, dstContract) -> seq\n    mapping(uint64 => mapping(address => uint64)) public sendSeq;\n\n    // map at destination chain (srcChainId, srcContract) -> seq\n    mapping(uint64 => mapping(address => uint64)) public recvSeq;\n\n    constructor(IMessageBridge _messageBridge) MessageApp(_messageBridge) {}\n\n    // called by user on source chain to send cross-chain message\n    function sendMessage(uint64 _dstChainId, address _dstContract, bytes calldata _message) external payable {\n        uint64 seq = sendSeq[_dstChainId][_dstContract];\n        bytes memory message = abi.encode(msg.sender, seq, _message);\n        _sendMessage(_dstChainId, _dstContract, message);\n        sendSeq[_dstChainId][_dstContract] += 1;\n    }\n\n    // called by MessageBridge on destination chain to receive message\n    function _handleMessage(\n        uint64 _srcChainId,\n        address _srcContract,\n        bytes calldata _message,\n        address // execution\n    ) internal override {\n        (address sender, uint64 seq, bytes memory message) = abi.decode((_message), (address, uint64, bytes));\n        uint64 expectedSeq = recvSeq[_srcChainId][_srcContract];\n        require(seq == expectedSeq, _abortReason(\"sequence number not expected\")); // let execution retry later.\n        emit MessageReceived(_srcChainId, _srcContract, sender, seq, message);\n        recvSeq[_srcChainId][_srcContract] += 1;\n    }\n}\n"
    },
    "contracts/apps/message-bridge/apps/examples/MsgTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9;\n\nimport \"../../framework/MessageApp.sol\";\n\n// A HelloWorld test example for basic cross-chain message passing\ncontract MsgTest is MessageApp {\n    event MessageReceived(uint64 srcChainId, address srcContract, address sender, uint64 number);\n\n    constructor(IMessageBridge _messageBridge) MessageApp(_messageBridge) {}\n\n    // called by user on source chain to send cross-chain messages\n    function sendMessage(uint64 _dstChainId, address _dstContract, uint64 _number) external {\n        bytes memory message = abi.encode(msg.sender, _number);\n        _sendMessage(_dstChainId, _dstContract, message);\n    }\n\n    // called by MessageBridge on destination chain to receive cross-chain messages\n    function _handleMessage(\n        uint64 _srcChainId,\n        address _srcContract,\n        bytes calldata _message,\n        address // execution\n    ) internal override {\n        (address sender, uint64 number) = abi.decode((_message), (address, uint64));\n        require(number != 1000, _abortReason(\"test abort\"));\n        require(number != 1001, \"test revert\");\n        emit MessageReceived(_srcChainId, _srcContract, sender, number);\n    }\n}\n"
    },
    "contracts/apps/message-bridge/apps/token-bridge/PegBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../framework/MessageApp.sol\";\n\ninterface IPeggedToken {\n    function mint(address _to, uint256 _amount) external;\n\n    function burnFrom(address _from, uint256 _amount) external;\n}\n\ncontract PegBridge is MessageApp, Ownable {\n    using SafeERC20 for IERC20;\n\n    mapping(bytes32 => bool) public records;\n    mapping(address => uint256) public supplies;\n    mapping(address => address) public vaultToPegTokens; // vault -> peg\n    mapping(address => address) public pegToVaultTokens; // peg -> vault\n\n    mapping(address => uint256) public minBurn;\n\n    uint64 public vaultChain;\n    address public vaultAddress;\n\n    event Mint(bytes32 mintId, address account, address token, uint256 amount, bytes32 refId, address depositor);\n\n    event Burn(\n        bytes32 burnId,\n        address burnAccount,\n        address token,\n        uint256 amount,\n        address withdrawAccount,\n        uint64 nonce,\n        bytes32 messageId\n    );\n\n    event BridgeTokenAdded(address vaultToken, address pegToken);\n    event BridgeTokenDeleted(address vaultToken, address pegToken);\n    event MinBurnUpdated(address token, uint256 amount);\n\n    constructor(IMessageBridge _messageBridge) MessageApp(_messageBridge) {}\n\n    function _handleMessage(\n        uint64 _srcChainId,\n        address _sender,\n        bytes calldata _message,\n        address // execution\n    ) internal override {\n        require(_srcChainId == vaultChain, \"not from vault chain\");\n        require(_sender == vaultAddress, \"sender is not token vault\");\n        _mint(_message);\n    }\n\n    function _mint(bytes calldata _message) private {\n        (address vaultToken, uint256 amount, address mintAccount, address depositor, bytes32 depositId) = abi.decode(\n            (_message),\n            (address, uint256, address, address, bytes32)\n        );\n        address pegToken = vaultToPegTokens[vaultToken];\n        require(pegToken != address(0), \"no peg token\");\n        bytes32 mintId = keccak256(\n            abi.encodePacked(pegToken, amount, mintAccount, depositor, depositId, address(this))\n        );\n        require(records[mintId] == false, \"record exists\");\n        records[mintId] = true;\n        IPeggedToken(pegToken).mint(mintAccount, amount);\n        supplies[pegToken] += amount;\n        emit Mint(mintId, mintAccount, pegToken, amount, depositId, depositor);\n    }\n\n    function burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) external returns (bytes32) {\n        bytes32 burnId = _burn(_token, _amount, _toChainId, _withdrawAccount, _nonce);\n        IPeggedToken(_token).burnFrom(msg.sender, _amount);\n        return burnId;\n    }\n\n    function _burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) private returns (bytes32) {\n        require(_amount > minBurn[_token], \"amount too small\");\n        address vaultToken = pegToVaultTokens[_token];\n        require(vaultToken != address(0), \"no vault token\");\n        supplies[_token] -= _amount;\n        bytes32 burnId = keccak256(\n            abi.encodePacked(\n                msg.sender,\n                _token,\n                _amount,\n                _toChainId,\n                _withdrawAccount,\n                _nonce,\n                uint64(block.chainid),\n                address(this)\n            )\n        );\n        require(records[burnId] == false, \"record exists\");\n        records[burnId] = true;\n        bytes memory message = abi.encode(vaultToken, _amount, _withdrawAccount, msg.sender, burnId);\n        bytes32 messageId = _sendMessage(_toChainId, vaultAddress, message);\n        emit Burn(burnId, msg.sender, _token, _amount, _withdrawAccount, _nonce, messageId);\n        return burnId;\n    }\n\n    function setBridgeTokens(address[] calldata _vaultTokens, address[] calldata _pegTokens) external onlyOwner {\n        require(_vaultTokens.length == _pegTokens.length, \"length mismatch\");\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            vaultToPegTokens[_vaultTokens[i]] = _pegTokens[i];\n            pegToVaultTokens[_pegTokens[i]] = _vaultTokens[i];\n            emit BridgeTokenAdded(_vaultTokens[i], _pegTokens[i]);\n        }\n    }\n\n    function deletePegTokens(address[] calldata _pegTokens) external onlyOwner {\n        for (uint256 i = 0; i < _pegTokens.length; i++) {\n            address pegToken = _pegTokens[i];\n            address vaultToken = pegToVaultTokens[pegToken];\n            delete vaultToPegTokens[vaultToken];\n            delete pegToVaultTokens[pegToken];\n            emit BridgeTokenDeleted(vaultToken, pegToken);\n        }\n    }\n\n    function deleteVaultTokens(address[] calldata _vaultTokens) external onlyOwner {\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address vaultToken = _vaultTokens[i];\n            address pegToken = vaultToPegTokens[vaultToken];\n            delete vaultToPegTokens[vaultToken];\n            delete pegToVaultTokens[pegToken];\n            emit BridgeTokenDeleted(vaultToken, pegToken);\n        }\n    }\n\n    function setMinBurn(address[] calldata _tokens, uint256[] calldata _amounts) external onlyOwner {\n        require(_tokens.length == _amounts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            minBurn[_tokens[i]] = _amounts[i];\n            emit MinBurnUpdated(_tokens[i], _amounts[i]);\n        }\n    }\n\n    function setTokenVault(uint64 _vaultChain, address _vaultAddress) external onlyOwner {\n        vaultChain = _vaultChain;\n        vaultAddress = _vaultAddress;\n    }\n}\n"
    },
    "contracts/apps/message-bridge/apps/token-bridge/TokenVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../framework/MessageApp.sol\";\n\ncontract TokenVault is MessageApp, Ownable {\n    using SafeERC20 for IERC20;\n\n    mapping(bytes32 => bool) public records;\n\n    mapping(uint64 => address) public remotePegBridges;\n\n    mapping(address => uint256) public minDeposit;\n\n    event Deposited(\n        bytes32 depositId,\n        address depositor,\n        address token,\n        uint256 amount,\n        address mintAccount,\n        uint64 nonce,\n        bytes32 messageId\n    );\n\n    event Withdrawn(\n        bytes32 withdrawId,\n        address receiver,\n        address token,\n        uint256 amount,\n        bytes32 refId,\n        address burnAccount\n    );\n\n    event MinDepositUpdated(address token, uint256 amount);\n\n    constructor(IMessageBridge _messageBridge) MessageApp(_messageBridge) {}\n\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external returns (bytes32) {\n        (bytes32 depositId, bytes32 messageId) = _deposit(_token, _amount, _mintChainId, _mintAccount, _nonce);\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        emit Deposited(depositId, msg.sender, _token, _amount, _mintAccount, _nonce, messageId);\n        return depositId;\n    }\n\n    function _deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) private returns (bytes32, bytes32) {\n        require(_amount > minDeposit[_token], \"amount too small\");\n        require(remotePegBridges[_mintChainId] != address(0), \"invalid mint chain\");\n        bytes32 depositId = keccak256(\n            abi.encodePacked(msg.sender, _token, _amount, _mintAccount, _nonce, uint64(block.chainid), address(this))\n        );\n        require(records[depositId] == false, \"record exists\");\n        bytes memory message = abi.encode(_token, _amount, _mintAccount, msg.sender, depositId);\n        bytes32 messageId = _sendMessage(_mintChainId, remotePegBridges[_mintChainId], message);\n        records[depositId] = true;\n        return (depositId, messageId);\n    }\n\n    function _handleMessage(\n        uint64 _srcChainId,\n        address _sender,\n        bytes calldata _message,\n        address // execution\n    ) internal override {\n        require(_sender == remotePegBridges[_srcChainId], \"sender is not remote peg bridge\");\n        _withdraw(_message);\n    }\n\n    function _withdraw(bytes calldata _message) private {\n        (address token, uint256 amount, address receiver, address burnAccount, bytes32 burnId) = abi.decode(\n            (_message),\n            (address, uint256, address, address, bytes32)\n        );\n        bytes32 withdrawId = keccak256(abi.encodePacked(receiver, token, amount, burnAccount, burnId, address(this)));\n        require(records[withdrawId] == false, \"record exists\");\n        records[withdrawId] = true;\n        IERC20(token).safeTransfer(receiver, amount);\n        emit Withdrawn(withdrawId, receiver, token, amount, burnId, burnAccount);\n    }\n\n    function setMinDeposit(address[] calldata _tokens, uint256[] calldata _amounts) external onlyOwner {\n        require(_tokens.length == _amounts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            minDeposit[_tokens[i]] = _amounts[i];\n            emit MinDepositUpdated(_tokens[i], _amounts[i]);\n        }\n    }\n\n    function setRemotePegBridge(uint64 _remoteChainId, address _remotePegBridge) external onlyOwner {\n        remotePegBridges[_remoteChainId] = _remotePegBridge;\n    }\n}\n"
    },
    "contracts/apps/message-bridge/framework/MessageApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./MessageSenderApp.sol\";\nimport \"./MessageReceiverApp.sol\";\n\nabstract contract MessageApp is MessageSenderApp, MessageReceiverApp {\n    constructor(IMessageBridge _messageBridge) {\n        messageBridge = _messageBridge;\n    }\n}\n"
    },
    "contracts/apps/message-bridge/framework/MessageBridgeAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IMessageBridge.sol\";\n\nabstract contract MessageBridgeAddress {\n    IMessageBridge public messageBridge;\n}\n"
    },
    "contracts/apps/message-bridge/framework/MessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IMessageReceiverApp.sol\";\nimport \"../libraries/MsgLib.sol\";\nimport \"./MessageBridgeAddress.sol\";\n\nabstract contract MessageReceiverApp is IMessageReceiverApp, MessageBridgeAddress {\n    modifier onlyMessageBridge() {\n        require(msg.sender == address(messageBridge), \"caller is not message bridge\");\n        _;\n    }\n\n    /**\n     * @notice Called by MessageBridge to execute a message\n     * @param srcChainId The source chain ID where the message is originated from\n     * @param sender The address of the source app contract\n     * @param message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param executor Address who called the MessageBridge execution function\n     * @return true Always return true if _handleMessage is not reverted\n     */\n    function executeMessage(\n        uint64 srcChainId,\n        address sender,\n        bytes calldata message,\n        address executor\n    ) external onlyMessageBridge returns (bool) {\n        _handleMessage(srcChainId, sender, message, executor);\n        return true;\n    }\n\n    /**\n     * @notice Internally called by executeMessage function to execute a message\n     * @param srcChainId The source chain ID where the message is originated from\n     * @param sender The address of the source app contract\n     * @param message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param executor Address who called the MessageBridge execution function\n     */\n    function _handleMessage(\n        uint64 srcChainId,\n        address sender,\n        bytes calldata message,\n        address executor\n    ) internal virtual;\n\n    // Add abort prefix in the reason string for require or revert.\n    // This will abort (revert) the message execution without markig it as failed state,\n    // making it possible to retry later.\n    function _abortReason(string memory reason) internal pure returns (string memory) {\n        return string.concat(MsgLib.ABORT_PREFIX, reason);\n    }\n}\n"
    },
    "contracts/apps/message-bridge/framework/MessageSenderApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IMessageBridge.sol\";\nimport \"./MessageBridgeAddress.sol\";\n\nabstract contract MessageSenderApp is MessageBridgeAddress {\n    /**\n     * @notice Send a message to a contract on another chain.\n     * @param dstChainId The destination chain ID.\n     * @param receiver The address of the destination app contract.\n     * @param message Arbitrary message bytes to be decoded by the destination app contract.\n     * @return messageId Message Id computed by MessageBridge\n     */\n    function _sendMessage(\n        uint64 dstChainId,\n        address receiver,\n        bytes memory message\n    ) internal returns (bytes32 messageId) {\n        return messageBridge.sendMessage(dstChainId, receiver, message);\n    }\n}\n"
    },
    "contracts/apps/message-bridge/interfaces/IMessageBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"../../../interfaces/IEthereumLightClient.sol\";\n\ninterface IMessageBridge {\n    enum MessageStatus {\n        Null,\n        Success,\n        Fail\n    }\n\n    event MessageSent(\n        bytes32 indexed messageId,\n        uint256 indexed nonce,\n        uint64 dstChainId,\n        address sender,\n        address receiver,\n        bytes message\n    );\n    event MessageExecuted(\n        bytes32 indexed messageId,\n        uint256 indexed nonce,\n        uint64 srcChainId,\n        address sender,\n        address receiver,\n        bytes message,\n        bool success\n    );\n    event MessageCallReverted(bytes32 messageId, string reason); // help debug\n\n    function lightClients(uint256 chainId) external view returns (IEthereumLightClient);\n\n    function sendMessage(uint64 dstChainId, address receiver, bytes calldata message) external returns (bytes32);\n\n    function executeMessage(\n        uint64 srcChainId,\n        uint64 nonce,\n        address sender,\n        address receiver,\n        bytes calldata message,\n        bytes[] calldata accountProof,\n        bytes[] calldata storageProof\n    ) external returns (bool);\n\n    function getExecutionStateRootAndSlot(uint64 chainId) external view returns (bytes32 root, uint64 slot);\n}\n"
    },
    "contracts/apps/message-bridge/interfaces/IMessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IMessageReceiverApp {\n    /**\n     * @notice Called by MessageBridge to execute a message\n     * @param _srcChainId The source chain ID where the message is originated from\n     * @param _sender The address of the source app contract\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBridge execution function\n     */\n    function executeMessage(\n        uint64 _srcChainId,\n        address _sender,\n        bytes calldata _message,\n        address _executor\n    ) external returns (bool);\n}\n"
    },
    "contracts/apps/message-bridge/libraries/MerkleProofTree.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"../../../lib/RLPReader.sol\";\n\nlibrary MerkleProofTree {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    function _gnaw(uint256 index, bytes32 key) private pure returns (uint256 gnaw) {\n        assembly {\n            gnaw := shr(mul(sub(63, index), 4), key)\n        }\n        return gnaw % 16;\n    }\n\n    function _pathLength(bytes memory path) private pure returns (uint256, bool) {\n        uint256 gnaw = uint256(uint8(path[0])) / 16;\n        return ((path.length - 1) * 2 + (gnaw % 2), gnaw > 1);\n    }\n\n    function read(bytes32 key, bytes[] memory proof) internal pure returns (bytes memory result) {\n        bytes32 root;\n        bytes memory node = proof[0];\n\n        uint256 index = 0;\n        uint256 pathLength = 0;\n\n        while (true) {\n            RLPReader.RLPItem[] memory items = node.toRlpItem().toList();\n            if (items.length == 17) {\n                uint256 gnaw = _gnaw(pathLength++, key);\n                root = bytes32(items[gnaw].toUint());\n            } else {\n                require(items.length == 2, \"MessageBridge: Iinvalid RLP list length\");\n                (uint256 nodePathLength, bool isLeaf) = _pathLength(items[0].toBytes());\n                pathLength += nodePathLength;\n                if (isLeaf) {\n                    return items[1].toBytes();\n                } else {\n                    root = bytes32(items[1].toUint());\n                }\n            }\n\n            node = proof[++index];\n            require(root == keccak256(node), \"MessageBridge: node hash mismatched\");\n        }\n    }\n\n    function restoreMerkleRoot(bytes32 leaf, uint256 index, bytes32[] memory proof) internal pure returns (bytes32) {\n        bytes32 value = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            if ((index / (2 ** i)) % 2 == 1) {\n                value = sha256(bytes.concat(proof[i], value));\n            } else {\n                value = sha256(bytes.concat(value, proof[i]));\n            }\n        }\n        return value;\n    }\n}\n"
    },
    "contracts/apps/message-bridge/libraries/MsgLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"../../../lib/Utils.sol\";\n\nlibrary MsgLib {\n    string constant ABORT_PREFIX = \"MSG::ABORT:\";\n\n    function computeMessageId(\n        uint64 _nonce,\n        address _sender,\n        address _receiver,\n        uint64 _srcChainId,\n        uint64 _dstChainId,\n        bytes calldata _message\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, _sender, _receiver, _srcChainId, _dstChainId, _message));\n    }\n\n    function checkRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        string memory revertMsg = Utils.getRevertMsg(_returnData);\n        checkAbortPrefix(revertMsg);\n        return revertMsg;\n    }\n\n    function checkAbortPrefix(string memory _revertMsg) private pure {\n        bytes memory prefixBytes = bytes(ABORT_PREFIX);\n        bytes memory msgBytes = bytes(_revertMsg);\n        if (msgBytes.length >= prefixBytes.length) {\n            for (uint256 i = 0; i < prefixBytes.length; i++) {\n                if (msgBytes[i] != prefixBytes[i]) {\n                    return; // prefix not match, return\n                }\n            }\n            revert(_revertMsg); // prefix match, revert\n        }\n    }\n}\n"
    },
    "contracts/apps/message-bridge/MessageBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IMessageBridge.sol\";\nimport \"./interfaces/IMessageReceiverApp.sol\";\nimport \"./libraries/MerkleProofTree.sol\";\nimport \"./libraries/MsgLib.sol\";\nimport \"../../lib/RLPReader.sol\";\nimport \"../../interfaces/IEthereumLightClient.sol\";\nimport \"../../verifiers/interfaces/ISlotValueVerifier.sol\";\n\ncontract MessageBridge is IMessageBridge, ReentrancyGuard, Ownable {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    /* Sender side (source chain) storage */\n    mapping(uint64 => bytes32) public sentMessages; // nonce -> messageId\n    uint256 constant SENT_MESSAGES_STORAGE_SLOT = 2;\n    uint64 public nonce;\n\n    /* Receiver side (dest chain) storage */\n    mapping(bytes32 => MessageStatus) public receivedMessages; // messageId -> status\n    mapping(uint256 => IEthereumLightClient) public lightClients; // chainId -> light client\n    mapping(uint256 => address) public remoteMessageBridges; // chainId -> source chain bridge\n    mapping(uint256 => bytes32) public remoteMessageBridgeHashes;\n    ISlotValueVerifier public slotValueVerifier;\n    // minimum amount of gas needed by this contract before it tries to deliver a message to the target.\n    uint256 public preExecuteMessageGasUsage;\n\n    /****************************************\n     * Sender side (source chain) functions *\n     ****************************************/\n\n    function sendMessage(uint64 _dstChainId, address _receiver, bytes calldata _message) external returns (bytes32) {\n        bytes32 messageId = MsgLib.computeMessageId(\n            nonce,\n            msg.sender,\n            _receiver,\n            uint64(block.chainid),\n            _dstChainId,\n            _message\n        );\n        sentMessages[nonce] = messageId;\n        emit MessageSent(messageId, nonce++, _dstChainId, msg.sender, _receiver, _message);\n        return messageId;\n    }\n\n    /****************************************\n     * Receiver side (dest chain) functions *\n     ****************************************/\n\n    function executeMessage(\n        uint64 _srcChainId,\n        uint64 _nonce,\n        address _sender,\n        address _receiver,\n        bytes calldata _message,\n        bytes[] calldata _accountProof,\n        bytes[] calldata _storageProof\n    ) external nonReentrant returns (bool success) {\n        (bytes32 messageId, bytes32 slotKeyHash) = _getSlotAndMessageId(\n            _srcChainId,\n            _nonce,\n            _sender,\n            _receiver,\n            _message\n        );\n        _verifyAccountAndStorageProof(_srcChainId, messageId, slotKeyHash, _accountProof, _storageProof);\n        return _executeMessage(messageId, _srcChainId, _nonce, _sender, _receiver, _message);\n    }\n\n    function executeMessageWithZkProof(\n        uint64 _srcChainId,\n        uint64 _nonce,\n        address _sender,\n        address _receiver,\n        bytes calldata _message,\n        bytes calldata _zkProofData,\n        bytes calldata _blkVerifyInfo\n    ) external nonReentrant returns (bool success) {\n        (bytes32 messageId, bytes32 slotKeyHash) = _getSlotAndMessageId(\n            _srcChainId,\n            _nonce,\n            _sender,\n            _receiver,\n            _message\n        );\n        _verifyZkSlotValueProof(_srcChainId, messageId, slotKeyHash, _zkProofData, _blkVerifyInfo);\n        return _executeMessage(messageId, _srcChainId, _nonce, _sender, _receiver, _message);\n    }\n\n    function setLightClient(uint64 _chainId, address _lightClient) external onlyOwner {\n        lightClients[_chainId] = IEthereumLightClient(_lightClient);\n    }\n\n    function setSlotValueVerifier(address _slotValueVerifier) external onlyOwner {\n        slotValueVerifier = ISlotValueVerifier(_slotValueVerifier);\n    }\n\n    function setRemoteMessageBridge(uint64 _chainId, address _remoteMessageBridge) external onlyOwner {\n        remoteMessageBridges[_chainId] = _remoteMessageBridge;\n        remoteMessageBridgeHashes[_chainId] = keccak256(abi.encodePacked(_remoteMessageBridge));\n    }\n\n    function setPreExecuteMessageGasUsage(uint256 _usage) public onlyOwner {\n        preExecuteMessageGasUsage = _usage;\n    }\n\n    function getExecutionStateRootAndSlot(uint64 _chainId) public view returns (bytes32 root, uint64 slot) {\n        return lightClients[_chainId].optimisticExecutionStateRootAndSlot();\n    }\n\n    function _getSlotAndMessageId(\n        uint64 _srcChainId,\n        uint64 _nonce,\n        address _sender,\n        address _receiver,\n        bytes calldata _message\n    ) private view returns (bytes32 messageId, bytes32 slotKeyHash) {\n        messageId = MsgLib.computeMessageId(_nonce, _sender, _receiver, _srcChainId, uint64(block.chainid), _message);\n        require(receivedMessages[messageId] == MessageStatus.Null, \"MessageBridge: message already executed\");\n        slotKeyHash = keccak256(abi.encode(keccak256(abi.encode(_nonce, SENT_MESSAGES_STORAGE_SLOT))));\n    }\n\n    function _verifyAccountAndStorageProof(\n        uint64 _srcChainId,\n        bytes32 _messageId,\n        bytes32 _slotKeyHash,\n        bytes[] calldata _accountProof,\n        bytes[] calldata _storageProof\n    ) private view {\n        require(\n            _retrieveStorageRoot(_srcChainId, _accountProof) == keccak256(_storageProof[0]),\n            \"MessageBridge: invalid storage root\"\n        );\n        bytes memory proof = MerkleProofTree.read(_slotKeyHash, _storageProof);\n        require(bytes32(proof.toRlpItem().toUint()) == _messageId, \"MessageBridge: invalid message hash\");\n    }\n\n    function _retrieveStorageRoot(uint64 _srcChainId, bytes[] calldata _accountProof) private view returns (bytes32) {\n        // verify accountProof and get storageRoot\n        (bytes32 executionStateRoot, ) = getExecutionStateRootAndSlot(_srcChainId);\n        require(executionStateRoot != bytes32(0), \"MessageBridge: execution state root not found\");\n        require(executionStateRoot == keccak256(_accountProof[0]), \"MessageBridge: invalid account proof root\");\n\n        // get storageRoot\n        bytes memory accountInfo = MerkleProofTree.read(remoteMessageBridgeHashes[_srcChainId], _accountProof);\n        RLPReader.RLPItem[] memory items = accountInfo.toRlpItem().toList();\n        require(items.length == 4, \"MessageBridge: invalid account decoded from RLP\");\n        return bytes32(items[2].toUint());\n    }\n\n    function _verifyZkSlotValueProof(\n        uint64 _srcChainId,\n        bytes32 _messageId,\n        bytes32 _slotKeyHash,\n        bytes calldata _zkProofData,\n        bytes calldata _blkVerifyInfo\n    ) private view {\n        ISlotValueVerifier.SlotInfo memory slotInfo = slotValueVerifier.verifySlotValue(\n            _srcChainId,\n            _zkProofData,\n            _blkVerifyInfo\n        );\n        require(slotInfo.slotKeyHash == _slotKeyHash, \"MessageBridge: slot key not match\");\n        require(slotInfo.slotValue == _messageId, \"MessageBridge: slot value not match\");\n        require(slotInfo.addrHash == remoteMessageBridgeHashes[_srcChainId], \"MessageBridge: src contract not match\");\n    }\n\n    function _executeMessage(\n        bytes32 _messageId,\n        uint64 _srcChainId,\n        uint64 _nonce,\n        address _sender,\n        address _receiver,\n        bytes calldata _message\n    ) private returns (bool success) {\n        // execute message\n        bytes memory recieveCall = abi.encodeWithSelector(\n            IMessageReceiverApp.executeMessage.selector,\n            _srcChainId,\n            _sender,\n            _message,\n            msg.sender\n        );\n        uint256 gasLeftBeforeExecution = gasleft();\n        (bool ok, bytes memory res) = _receiver.call(recieveCall);\n        if (ok) {\n            success = abi.decode((res), (bool));\n        } else {\n            _handleExecutionRevert(_messageId, gasLeftBeforeExecution, res);\n        }\n        receivedMessages[_messageId] = success ? MessageStatus.Success : MessageStatus.Fail;\n        emit MessageExecuted(_messageId, _nonce, _srcChainId, _sender, _receiver, _message, success);\n        return success;\n    }\n\n    function _handleExecutionRevert(\n        bytes32 messageId,\n        uint256 _gasLeftBeforeExecution,\n        bytes memory _returnData\n    ) private {\n        uint256 gasLeftAfterExecution = gasleft();\n        uint256 maxTargetGasLimit = block.gaslimit - preExecuteMessageGasUsage;\n        if (_gasLeftBeforeExecution < maxTargetGasLimit && gasLeftAfterExecution <= _gasLeftBeforeExecution / 64) {\n            // if this happens, the execution must have not provided sufficient gas limit,\n            // then the tx should revert instead of recording a non-retryable failure status\n            // https://github.com/wolflo/evm-opcodes/blob/main/gas.md#aa-f-gas-to-send-with-call-operations\n            assembly {\n                invalid()\n            }\n        }\n        string memory revertMsg = MsgLib.checkRevertMsg(_returnData);\n        // otherwiase, emit revert message, return and mark the execution as failed (non-retryable)\n        emit MessageCallReverted(messageId, revertMsg);\n    }\n}\n"
    },
    "contracts/apps/message-bridge/mock/MockMessageBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../MessageBridge.sol\";\nimport \"../../../interfaces/IEthereumLightClient.sol\";\n\ncontract MockLightClient is IEthereumLightClient {\n    uint64 public latestSlot; // slot of latest known block\n    bytes32 public stateRoot; // slot => header\n\n    function submitHeader(uint64 slot, bytes32 _stateRoot) external {\n        latestSlot = slot;\n        stateRoot = _stateRoot;\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (stateRoot, latestSlot);\n    }\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (stateRoot, latestSlot);\n    }\n}\n\ncontract MockMessageBridge {\n    MessageBridge public messageBridge;\n    MockLightClient public lightClient;\n\n    function initialize(\n        uint64 slot,\n        address _messageBridgeAddress,\n        address _mockLightClient,\n        bytes32 _mockStateRoot\n    ) public {\n        messageBridge = MessageBridge(_messageBridgeAddress);\n        lightClient = MockLightClient(_mockLightClient);\n        lightClient.submitHeader(slot, _mockStateRoot);\n    }\n\n    function testExecutedMessage(\n        uint64 _srcChainId,\n        uint64 _nonce,\n        address _sender,\n        address _receiver,\n        bytes calldata _message,\n        bytes[] calldata accountProof,\n        bytes[] calldata storageProof\n    ) external returns (bool success) {\n        return\n            messageBridge.executeMessage(_srcChainId, _nonce, _sender, _receiver, _message, accountProof, storageProof);\n    }\n}\n"
    },
    "contracts/bvn/BVN.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {DataTypes as dt} from \"./DataTypes.sol\";\nimport \"./Staking.sol\";\n\n/**\n * @title Brevis Validator Network\n */\ncontract BVN {\n    using ECDSA for bytes32;\n\n    struct BrevisValidator {\n        address signer;\n        bytes bvnAddr;\n        uint256 deregisterTime;\n    }\n\n    struct SlashRecord {\n        address valAddr;\n        string reason;\n        uint64 timestamp;\n    }\n\n    Staking public immutable staking;\n    address[] public registeredValidators;\n    mapping(address => BrevisValidator) public brevisValidators; // valAddr -> BvnValidator\n    mapping(address => address) public signerVals; // signerAddr -> valAddr\n    mapping(uint64 => SlashRecord) public slashRecords; // nonce -> SlashRecord\n\n    event BrevisValidatorRegistered(address indexed valAddr, address signer, bytes bvnAddr);\n    event BrevisValidatorDeregistered(address indexed valAddr);\n    event BrevisValidatorSignerUpdated(address indexed valAddr, address prevSigner, address newSigner);\n    event Slash(address indexed valAddr, uint64 nonce, uint64 timestamp, string reason);\n\n    /**\n     * @param _staking address of Staking Contract\n     */\n    constructor(Staking _staking) {\n        staking = _staking;\n    }\n\n    /**\n     * @notice Join BVN\n     * @param _valAddr validator eth address\n     * @param _signer signer eth address\n     * @param _bvnAddr bvn address\n     */\n    function registerBrevisValidator(address _valAddr, address _signer, bytes calldata _bvnAddr) external {\n        dt.ValidatorStatus status = staking.getValidatorStatus(_valAddr);\n        require(status == dt.ValidatorStatus.Bonded, \"not bonded validator\");\n        require(_valAddr == msg.sender || _valAddr == staking.signerVals(msg.sender), \"unauthorized caller\");\n\n        require(signerVals[_signer] == address(0), \"signer already used\");\n        if (_signer != _valAddr) {\n            require(brevisValidators[_signer].deregisterTime == 0, \"signer is other validator\");\n        }\n        signerVals[_signer] = _valAddr;\n\n        BrevisValidator storage bv = brevisValidators[_valAddr];\n        require(bv.deregisterTime < block.timestamp, \"already registered validator\");\n        bv.signer = _signer;\n        bv.bvnAddr = _bvnAddr;\n        bv.deregisterTime = dt.MAX_INT;\n        registeredValidators.push(_valAddr);\n\n        staking.validatorNotice(_valAddr, \"register\", \"\");\n        emit BrevisValidatorRegistered(_valAddr, _signer, _bvnAddr);\n    }\n\n    function updateValidatorSigner(address _signer) external {\n        address valAddr = msg.sender;\n        BrevisValidator storage bv = brevisValidators[valAddr];\n        require(bv.deregisterTime != 0, \"unregistered validator\");\n        require(signerVals[_signer] == address(0), \"signer already used\");\n        if (_signer != valAddr) {\n            require(brevisValidators[_signer].deregisterTime == 0, \"signer is other validator\");\n        }\n        address prevSigner = bv.signer;\n        delete signerVals[bv.signer];\n        bv.signer = _signer;\n        signerVals[_signer] = valAddr;\n\n        staking.validatorNotice(valAddr, \"signer\", abi.encodePacked(_signer));\n        emit BrevisValidatorSignerUpdated(valAddr, prevSigner, _signer);\n    }\n\n    /**\n     * @notice Leave BVN\n     * @param _valAddr validator eth address\n     */\n    function deregisterBrevisValidator(address _valAddr) external {\n        BrevisValidator storage bv = brevisValidators[_valAddr];\n        require(bv.deregisterTime > block.timestamp, \"not registered validator\");\n        if (_valAddr != msg.sender && _valAddr != staking.signerVals(msg.sender) && bv.signer != msg.sender) {\n            // if not called by validator itself, require unbonded status\n            dt.ValidatorStatus status = staking.getValidatorStatus(_valAddr);\n            require(status == dt.ValidatorStatus.Unbonded, \"not unbonded validator\");\n        }\n        bv.deregisterTime = block.timestamp;\n        delete signerVals[bv.signer];\n\n        staking.validatorNotice(_valAddr, \"deregister\", \"\");\n        uint256 lastIndex = registeredValidators.length - 1;\n        for (uint256 i = 0; i < registeredValidators.length; i++) {\n            if (registeredValidators[i] == _valAddr) {\n                if (i < lastIndex) {\n                    registeredValidators[i] = registeredValidators[lastIndex];\n                }\n                registeredValidators.pop();\n                return;\n            }\n        }\n        revert(\"validator not found\"); // this should never happen\n    }\n\n    /**\n     * @notice Slash a validator\n     * @param _valAddr validator eth address\n     * @param _nonce slash nonce\n     * @param _timestamp slash triggered time\n     * @param _reason slash reason\n     * @param _sigs bvn signatures\n     */\n    function slash(\n        address _valAddr,\n        uint64 _nonce,\n        uint64 _timestamp,\n        string calldata _reason,\n        bytes[] calldata _sigs\n    ) external {\n        require(brevisValidators[_valAddr].deregisterTime > block.timestamp, \"not registered validator\");\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"Slash\"));\n        bytes32 slashHash = keccak256(abi.encodePacked(_valAddr, _nonce, _timestamp, _reason));\n        verifySignatures(abi.encodePacked(domain, slashHash), _sigs);\n\n        SlashRecord storage s = slashRecords[_nonce];\n        require(s.valAddr == address(0), \"used slash nonce\");\n        s.valAddr = _valAddr;\n        s.reason = _reason;\n        s.timestamp = _timestamp;\n        staking.validatorNotice(_valAddr, \"slash\", abi.encodePacked(_nonce));\n        emit Slash(_valAddr, _nonce, _timestamp, _reason);\n    }\n\n    function verifySignatures(bytes memory _msg, bytes[] calldata _sigs) public view returns (bool) {\n        bytes32 hash = keccak256(_msg).toEthSignedMessageHash();\n        uint256 signedTokens;\n        address prev = address(0);\n        uint256 quorum = (getBondedTokens() * 2) / 3 + 1;\n        for (uint256 i = 0; i < _sigs.length; i++) {\n            address signer = hash.recover(_sigs[i]);\n            require(signer > prev, \"signers not in ascending order\");\n            prev = signer;\n\n            address valAddr = signerVals[signer];\n            require(isBondedValidator(valAddr), \"not bonded validator\");\n            signedTokens += staking.getValidatorTokens(valAddr);\n            if (signedTokens >= quorum) {\n                return true;\n            }\n        }\n        revert(\"Quorum not reached\");\n    }\n\n    function getBondedTokens() public view returns (uint256) {\n        uint256 totalTokens;\n        for (uint32 i = 0; i < registeredValidators.length; i++) {\n            address valAddr = registeredValidators[i];\n            if (staking.isBondedValidator(valAddr)) {\n                totalTokens += staking.getValidatorTokens(valAddr);\n            }\n        }\n        return totalTokens;\n    }\n\n    function isRegisteredValidator(address _valAddr) public view returns (bool) {\n        return (brevisValidators[_valAddr].deregisterTime > block.timestamp);\n    }\n\n    function getRegisteredValidatorNum() public view returns (uint256) {\n        return registeredValidators.length;\n    }\n\n    function getRegisteredValidators() public view returns (address[] memory) {\n        address[] memory valaddrs = new address[](registeredValidators.length);\n        for (uint32 i = 0; i < registeredValidators.length; i++) {\n            valaddrs[i] = registeredValidators[i];\n        }\n        return valaddrs;\n    }\n\n    function isBondedValidator(address _valAddr) public view returns (bool) {\n        return (staking.isBondedValidator(_valAddr) && isRegisteredValidator(_valAddr));\n    }\n\n    function getBondedValidatorNum() public view returns (uint256) {\n        uint256 num;\n        for (uint32 i = 0; i < registeredValidators.length; i++) {\n            if (staking.isBondedValidator(registeredValidators[i])) {\n                num++;\n            }\n        }\n        return num;\n    }\n\n    function getBondedValidators() public view returns (address[] memory) {\n        uint256 valNum = getBondedValidatorNum();\n        address[] memory valaddrs = new address[](valNum);\n        uint256 j;\n        for (uint32 i = 0; i < registeredValidators.length; i++) {\n            if (staking.isBondedValidator(registeredValidators[i])) {\n                valaddrs[j] = registeredValidators[i];\n                j++;\n            }\n        }\n        return valaddrs;\n    }\n}\n"
    },
    "contracts/bvn/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nlibrary DataTypes {\n    uint256 constant STAKING_TOKEN_DECIMAL = 1e18;\n    uint256 constant MAX_INT = 2 ** 256 - 1;\n    uint256 constant COMMISSION_RATE_BASE = 10000; // 1 commissionRate means 0.01%\n    uint256 constant MAX_UNDELEGATION_ENTRIES = 10;\n    uint256 constant SLASH_FACTOR_DECIMAL = 1e6;\n\n    enum ValidatorStatus {\n        Null,\n        Unbonded,\n        Unbonding,\n        Bonded\n    }\n\n    enum ParamName {\n        ProposalDeposit,\n        VotingPeriod,\n        UnbondingPeriod,\n        MaxBondedValidators,\n        MinValidatorTokens,\n        MinSelfDelegation,\n        AdvanceNoticePeriod,\n        ValidatorBondInterval,\n        MaxSlashFactor\n    }\n\n    struct Undelegation {\n        uint256 shares;\n        uint256 creationBlock;\n    }\n\n    struct Undelegations {\n        mapping(uint256 => Undelegation) queue;\n        uint32 head;\n        uint32 tail;\n    }\n\n    struct Delegator {\n        uint256 shares;\n        Undelegations undelegations;\n    }\n\n    struct Validator {\n        ValidatorStatus status;\n        address signer;\n        uint256 tokens; // sum of all tokens delegated to this validator\n        uint256 shares; // sum of all delegation shares\n        uint256 undelegationTokens; // tokens being undelegated\n        uint256 undelegationShares; // shares of tokens being undelegated\n        mapping(address => Delegator) delegators;\n        uint256 minSelfDelegation;\n        uint64 bondBlock; // cannot become bonded before this block\n        uint64 unbondBlock; // cannot become unbonded before this block\n        uint64 commissionRate; // equal to real commission rate * COMMISSION_RATE_BASE\n    }\n\n    // used for external view output\n    struct ValidatorTokens {\n        address valAddr;\n        uint256 tokens;\n    }\n\n    // used for external view output\n    struct ValidatorInfo {\n        address valAddr;\n        ValidatorStatus status;\n        address signer;\n        uint256 tokens;\n        uint256 shares;\n        uint256 minSelfDelegation;\n        uint64 commissionRate;\n    }\n\n    // used for external view output\n    struct DelegatorInfo {\n        address valAddr;\n        uint256 tokens;\n        uint256 shares;\n        Undelegation[] undelegations;\n        uint256 undelegationTokens;\n        uint256 withdrawableUndelegationTokens;\n    }\n}\n"
    },
    "contracts/bvn/Govern.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {DataTypes as dt} from \"./DataTypes.sol\";\nimport \"./Staking.sol\";\n\n/**\n * @title Governance module for Staking contract\n */\ncontract Govern {\n    using SafeERC20 for IERC20;\n\n    Staking public immutable staking;\n    IERC20 public immutable stakingToken;\n\n    enum ProposalStatus {\n        Uninitiated,\n        Voting,\n        Closed\n    }\n\n    enum VoteOption {\n        Null,\n        Yes,\n        Abstain,\n        No\n    }\n\n    struct ParamProposal {\n        address proposer;\n        uint256 deposit;\n        uint256 voteDeadline;\n        dt.ParamName name;\n        uint256 newValue;\n        ProposalStatus status;\n        mapping(address => VoteOption) votes;\n    }\n\n    mapping(uint256 => ParamProposal) public paramProposals;\n    uint256 public nextParamProposalId;\n\n    uint256 public forfeiture;\n    address public immutable collector;\n\n    event CreateParamProposal(\n        uint256 proposalId,\n        address proposer,\n        uint256 deposit,\n        uint256 voteDeadline,\n        dt.ParamName name,\n        uint256 newValue\n    );\n    event VoteParam(uint256 proposalId, address voter, VoteOption vote);\n    event ConfirmParamProposal(uint256 proposalId, bool passed, dt.ParamName name, uint256 newValue);\n\n    constructor(Staking _staking, address _stakingTokenAddress, address _collector) {\n        staking = _staking;\n        stakingToken = IERC20(_stakingTokenAddress);\n        collector = _collector;\n    }\n\n    /**\n     * @notice Get the vote type of a voter on a parameter proposal\n     * @param _proposalId the proposal id\n     * @param _voter the voter address\n     * @return the vote type of the given voter on the given parameter proposal\n     */\n    function getParamProposalVote(uint256 _proposalId, address _voter) public view returns (VoteOption) {\n        return paramProposals[_proposalId].votes[_voter];\n    }\n\n    /**\n     * @notice Create a parameter proposal\n     * @param _name the key of this parameter\n     * @param _value the new proposed value of this parameter\n     */\n    function createParamProposal(dt.ParamName _name, uint256 _value) external {\n        ParamProposal storage p = paramProposals[nextParamProposalId];\n        nextParamProposalId = nextParamProposalId + 1;\n        address msgSender = msg.sender;\n        uint256 deposit = staking.getParamValue(dt.ParamName.ProposalDeposit);\n\n        p.proposer = msgSender;\n        p.deposit = deposit;\n        p.voteDeadline = block.number + staking.getParamValue(dt.ParamName.VotingPeriod);\n        p.name = _name;\n        p.newValue = _value;\n        p.status = ProposalStatus.Voting;\n\n        stakingToken.safeTransferFrom(msgSender, address(this), deposit);\n\n        emit CreateParamProposal(nextParamProposalId - 1, msgSender, deposit, p.voteDeadline, _name, _value);\n    }\n\n    /**\n     * @notice Vote for a parameter proposal with a specific type of vote\n     * @param _proposalId the id of the parameter proposal\n     * @param _vote the type of vote\n     */\n    function voteParam(uint256 _proposalId, VoteOption _vote) external {\n        address valAddr = msg.sender;\n        require(staking.getValidatorStatus(valAddr) == dt.ValidatorStatus.Bonded, \"Voter is not a bonded validator\");\n        ParamProposal storage p = paramProposals[_proposalId];\n        require(p.status == ProposalStatus.Voting, \"Invalid proposal status\");\n        require(block.number < p.voteDeadline, \"Vote deadline passed\");\n        require(p.votes[valAddr] == VoteOption.Null, \"Voter has voted\");\n        require(_vote != VoteOption.Null, \"Invalid vote\");\n\n        p.votes[valAddr] = _vote;\n\n        emit VoteParam(_proposalId, valAddr, _vote);\n    }\n\n    /**\n     * @notice Confirm a parameter proposal\n     * @param _proposalId the id of the parameter proposal\n     */\n    function confirmParamProposal(uint256 _proposalId) external {\n        uint256 yesVotes;\n        uint256 bondedTokens;\n        dt.ValidatorTokens[] memory validators = staking.getBondedValidatorsTokens();\n        for (uint32 i = 0; i < validators.length; i++) {\n            if (getParamProposalVote(_proposalId, validators[i].valAddr) == VoteOption.Yes) {\n                yesVotes += validators[i].tokens;\n            }\n            bondedTokens += validators[i].tokens;\n        }\n        bool passed = (yesVotes >= (bondedTokens * 2) / 3 + 1);\n\n        ParamProposal storage p = paramProposals[_proposalId];\n        require(p.status == ProposalStatus.Voting, \"Invalid proposal status\");\n        require(block.number >= p.voteDeadline, \"Vote deadline not reached\");\n\n        p.status = ProposalStatus.Closed;\n        if (passed) {\n            staking.setParamValue(p.name, p.newValue);\n            stakingToken.safeTransfer(p.proposer, p.deposit);\n        } else {\n            forfeiture += p.deposit;\n        }\n\n        emit ConfirmParamProposal(_proposalId, passed, p.name, p.newValue);\n    }\n\n    function collectForfeiture() external {\n        require(forfeiture > 0, \"Nothing to collect\");\n        stakingToken.safeTransfer(collector, forfeiture);\n        forfeiture = 0;\n    }\n}\n"
    },
    "contracts/bvn/libraries/Pb.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\n// runtime proto sol library\nlibrary Pb {\n    enum WireType {\n        Varint,\n        Fixed64,\n        LengthDelim,\n        StartGroup,\n        EndGroup,\n        Fixed32\n    }\n\n    struct Buffer {\n        uint256 idx; // the start index of next read. when idx=b.length, we're done\n        bytes b; // hold serialized proto msg, readonly\n    }\n\n    // create a new in-memory Buffer object from raw msg bytes\n    function fromBytes(bytes memory raw) internal pure returns (Buffer memory buf) {\n        buf.b = raw;\n        buf.idx = 0;\n    }\n\n    // whether there are unread bytes\n    function hasMore(Buffer memory buf) internal pure returns (bool) {\n        return buf.idx < buf.b.length;\n    }\n\n    // decode current field number and wiretype\n    function decKey(Buffer memory buf) internal pure returns (uint256 tag, WireType wiretype) {\n        uint256 v = decVarint(buf);\n        tag = v / 8;\n        wiretype = WireType(v & 7);\n    }\n\n    // count tag occurrences, return an array due to no memory map support\n    // have to create array for (maxtag+1) size. cnts[tag] = occurrences\n    // should keep buf.idx unchanged because this is only a count function\n    function cntTags(Buffer memory buf, uint256 maxtag) internal pure returns (uint256[] memory cnts) {\n        uint256 originalIdx = buf.idx;\n        cnts = new uint256[](maxtag + 1); // protobuf's tags are from 1 rather than 0\n        uint256 tag;\n        WireType wire;\n        while (hasMore(buf)) {\n            (tag, wire) = decKey(buf);\n            cnts[tag] += 1;\n            skipValue(buf, wire);\n        }\n        buf.idx = originalIdx;\n    }\n\n    // read varint from current buf idx, move buf.idx to next read, return the int value\n    function decVarint(Buffer memory buf) internal pure returns (uint256 v) {\n        bytes10 tmp; // proto int is at most 10 bytes (7 bits can be used per byte)\n        bytes memory bb = buf.b; // get buf.b mem addr to use in assembly\n        v = buf.idx; // use v to save one additional uint variable\n        assembly {\n            tmp := mload(add(add(bb, 32), v)) // load 10 bytes from buf.b[buf.idx] to tmp\n        }\n        uint256 b; // store current byte content\n        v = 0; // reset to 0 for return value\n        for (uint256 i = 0; i < 10; i++) {\n            assembly {\n                b := byte(i, tmp) // don't use tmp[i] because it does bound check and costs extra\n            }\n            v |= (b & 0x7F) << (i * 7);\n            if (b & 0x80 == 0) {\n                buf.idx += i + 1;\n                return v;\n            }\n        }\n        revert(); // i=10, invalid varint stream\n    }\n\n    // read length delimited field and return bytes\n    function decBytes(Buffer memory buf) internal pure returns (bytes memory b) {\n        uint256 len = decVarint(buf);\n        uint256 end = buf.idx + len;\n        require(end <= buf.b.length); // avoid overflow\n        b = new bytes(len);\n        bytes memory bufB = buf.b; // get buf.b mem addr to use in assembly\n        uint256 bStart;\n        uint256 bufBStart = buf.idx;\n        assembly {\n            bStart := add(b, 32)\n            bufBStart := add(add(bufB, 32), bufBStart)\n        }\n        for (uint256 i = 0; i < len; i += 32) {\n            assembly {\n                mstore(add(bStart, i), mload(add(bufBStart, i)))\n            }\n        }\n        buf.idx = end;\n    }\n\n    // return packed ints\n    function decPacked(Buffer memory buf) internal pure returns (uint256[] memory t) {\n        uint256 len = decVarint(buf);\n        uint256 end = buf.idx + len;\n        require(end <= buf.b.length); // avoid overflow\n        // array in memory must be init w/ known length\n        // so we have to create a tmp array w/ max possible len first\n        uint256[] memory tmp = new uint256[](len);\n        uint256 i = 0; // count how many ints are there\n        while (buf.idx < end) {\n            tmp[i] = decVarint(buf);\n            i++;\n        }\n        t = new uint256[](i); // init t with correct length\n        for (uint256 j = 0; j < i; j++) {\n            t[j] = tmp[j];\n        }\n        return t;\n    }\n\n    // move idx pass current value field, to beginning of next tag or msg end\n    function skipValue(Buffer memory buf, WireType wire) internal pure {\n        if (wire == WireType.Varint) {\n            decVarint(buf);\n        } else if (wire == WireType.LengthDelim) {\n            uint256 len = decVarint(buf);\n            buf.idx += len; // skip len bytes value data\n            require(buf.idx <= buf.b.length); // avoid overflow\n        } else {\n            revert();\n        } // unsupported wiretype\n    }\n\n    // type conversion help utils\n    function _bool(uint256 x) internal pure returns (bool v) {\n        return x != 0;\n    }\n\n    function _uint256(bytes memory b) internal pure returns (uint256 v) {\n        require(b.length <= 32); // b's length must be smaller than or equal to 32\n        assembly {\n            v := mload(add(b, 32))\n        } // load all 32bytes to v\n        v = v >> (8 * (32 - b.length)); // only first b.length is valid\n    }\n\n    function _address(bytes memory b) internal pure returns (address v) {\n        v = _addressPayable(b);\n    }\n\n    function _addressPayable(bytes memory b) internal pure returns (address payable v) {\n        require(b.length == 20);\n        //load 32bytes then shift right 12 bytes\n        assembly {\n            v := div(mload(add(b, 32)), 0x1000000000000000000000000)\n        }\n    }\n\n    function _bytes32(bytes memory b) internal pure returns (bytes32 v) {\n        require(b.length == 32);\n        assembly {\n            v := mload(add(b, 32))\n        }\n    }\n\n    // uint[] to uint8[]\n    function uint8s(uint256[] memory arr) internal pure returns (uint8[] memory t) {\n        t = new uint8[](arr.length);\n        for (uint256 i = 0; i < t.length; i++) {\n            t[i] = uint8(arr[i]);\n        }\n    }\n\n    function uint32s(uint256[] memory arr) internal pure returns (uint32[] memory t) {\n        t = new uint32[](arr.length);\n        for (uint256 i = 0; i < t.length; i++) {\n            t[i] = uint32(arr[i]);\n        }\n    }\n\n    function uint64s(uint256[] memory arr) internal pure returns (uint64[] memory t) {\n        t = new uint64[](arr.length);\n        for (uint256 i = 0; i < t.length; i++) {\n            t[i] = uint64(arr[i]);\n        }\n    }\n\n    function bools(uint256[] memory arr) internal pure returns (bool[] memory t) {\n        t = new bool[](arr.length);\n        for (uint256 i = 0; i < t.length; i++) {\n            t[i] = arr[i] != 0;\n        }\n    }\n}\n"
    },
    "contracts/bvn/libraries/PbStaking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// Code generated by protoc-gen-sol. DO NOT EDIT.\n// source: contracts/libraries/proto/staking.proto\npragma solidity ^0.8.18;\nimport \"./Pb.sol\";\n\nlibrary PbStaking {\n    using Pb for Pb.Buffer; // so we can call Pb funcs on Buffer obj\n\n    struct StakingReward {\n        address recipient; // tag: 1\n        uint256 cumulativeRewardAmount; // tag: 2\n    } // end struct StakingReward\n\n    function decStakingReward(bytes memory raw) internal pure returns (StakingReward memory m) {\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\n\n        uint256 tag;\n        Pb.WireType wire;\n        while (buf.hasMore()) {\n            (tag, wire) = buf.decKey();\n            if (false) {}\n            // solidity has no switch/case\n            else if (tag == 1) {\n                m.recipient = Pb._address(buf.decBytes());\n            } else if (tag == 2) {\n                m.cumulativeRewardAmount = Pb._uint256(buf.decBytes());\n            } else {\n                buf.skipValue(wire);\n            } // skip value of unknown tag\n        }\n    } // end decoder StakingReward\n\n    struct Slash {\n        address validator; // tag: 1\n        uint64 nonce; // tag: 2\n        uint64 slashFactor; // tag: 3\n        uint64 expireTime; // tag: 4\n        uint64 jailPeriod; // tag: 5\n        AcctAmtPair[] collectors; // tag: 6\n    } // end struct Slash\n\n    function decSlash(bytes memory raw) internal pure returns (Slash memory m) {\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\n\n        uint256[] memory cnts = buf.cntTags(6);\n        m.collectors = new AcctAmtPair[](cnts[6]);\n        cnts[6] = 0; // reset counter for later use\n\n        uint256 tag;\n        Pb.WireType wire;\n        while (buf.hasMore()) {\n            (tag, wire) = buf.decKey();\n            if (false) {}\n            // solidity has no switch/case\n            else if (tag == 1) {\n                m.validator = Pb._address(buf.decBytes());\n            } else if (tag == 2) {\n                m.nonce = uint64(buf.decVarint());\n            } else if (tag == 3) {\n                m.slashFactor = uint64(buf.decVarint());\n            } else if (tag == 4) {\n                m.expireTime = uint64(buf.decVarint());\n            } else if (tag == 5) {\n                m.jailPeriod = uint64(buf.decVarint());\n            } else if (tag == 6) {\n                m.collectors[cnts[6]] = decAcctAmtPair(buf.decBytes());\n                cnts[6]++;\n            } else {\n                buf.skipValue(wire);\n            } // skip value of unknown tag\n        }\n    } // end decoder Slash\n\n    struct AcctAmtPair {\n        address account; // tag: 1\n        uint256 amount; // tag: 2\n    } // end struct AcctAmtPair\n\n    function decAcctAmtPair(bytes memory raw) internal pure returns (AcctAmtPair memory m) {\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\n\n        uint256 tag;\n        Pb.WireType wire;\n        while (buf.hasMore()) {\n            (tag, wire) = buf.decKey();\n            if (false) {}\n            // solidity has no switch/case\n            else if (tag == 1) {\n                m.account = Pb._address(buf.decBytes());\n            } else if (tag == 2) {\n                m.amount = Pb._uint256(buf.decBytes());\n            } else {\n                buf.skipValue(wire);\n            } // skip value of unknown tag\n        }\n    } // end decoder AcctAmtPair\n}\n"
    },
    "contracts/bvn/SigsVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../safeguard/Ownable.sol\";\nimport \"../interfaces/ISigsVerifier.sol\";\n\n/**\n * @title Multi-sig verification and management functions for {Bridge}.\n */\ncontract SigsVerifier is Ownable, IBvnSigsVerifier {\n    using ECDSA for bytes32;\n\n    bytes32 public ssHash;\n    uint256 public triggerTime; // timestamp when last update was triggered\n\n    // reset can be called by the owner address for emergency recovery\n    uint256 public resetTime;\n    uint256 public noticePeriod; // advance notice period in seconds for reset\n    uint256 constant MAX_INT = 2 ** 256 - 1;\n\n    event SignersUpdated(address[] _signers, uint256[] _powers);\n\n    event ResetNotification(uint256 resetTime);\n\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers\n     * The sigs must be sorted by signer addresses in ascending order.\n     * @param _msg signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes memory _msg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) public view override {\n        verifySigs(keccak256(_msg), _sigs, _signers, _powers);\n    }\n\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers\n     * The sigs must be sorted by signer addresses in ascending order.\n     * @param _msgHash hash of signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes32 _msgHash,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) public view override {\n        bytes32 h = keccak256(abi.encodePacked(_signers, _powers));\n        require(ssHash == h, \"mismatch current signers\");\n        _verifySignedPowers(_msgHash.toEthSignedMessageHash(), _sigs, _signers, _powers);\n    }\n\n    /**\n     * @notice Update new signers.\n     * @param _newSigners sorted list of new signers\n     * @param _curPowers powers of new signers\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _curSigners sorted list of current signers\n     * @param _curPowers powers of current signers\n     */\n    function updateSigners(\n        uint256 _triggerTime,\n        address[] calldata _newSigners,\n        uint256[] calldata _newPowers,\n        bytes[] calldata _sigs,\n        address[] calldata _curSigners,\n        uint256[] calldata _curPowers\n    ) external {\n        // use trigger time for nonce protection, must be ascending\n        require(_triggerTime > triggerTime, \"trigger time is not increasing\");\n        // make sure triggerTime is not too large, as it cannot be decreased once set\n        require(_triggerTime < block.timestamp + 3600, \"trigger time is too large\");\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"UpdateSigners\"));\n        verifySigs(abi.encodePacked(domain, _triggerTime, _newSigners, _newPowers), _sigs, _curSigners, _curPowers);\n        _updateSigners(_newSigners, _newPowers);\n        triggerTime = _triggerTime;\n    }\n\n    /**\n     * @notice reset signers, only used for init setup and emergency recovery\n     */\n    function resetSigners(address[] calldata _signers, uint256[] calldata _powers) external onlyOwner {\n        require(block.timestamp > resetTime, \"not reach reset time\");\n        resetTime = MAX_INT;\n        _updateSigners(_signers, _powers);\n    }\n\n    function notifyResetSigners() external onlyOwner {\n        resetTime = block.timestamp + noticePeriod;\n        emit ResetNotification(resetTime);\n    }\n\n    function increaseNoticePeriod(uint256 period) external onlyOwner {\n        require(period > noticePeriod, \"notice period can only be increased\");\n        noticePeriod = period;\n    }\n\n    // separate from verifySigs func to avoid \"stack too deep\" issue\n    function _verifySignedPowers(\n        bytes32 _hash,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) private pure {\n        require(_signers.length == _powers.length, \"signers and powers length not match\");\n        uint256 totalPower; // sum of all signer.power\n        for (uint256 i = 0; i < _signers.length; i++) {\n            totalPower += _powers[i];\n        }\n        uint256 quorum = (totalPower * 2) / 3 + 1;\n\n        uint256 signedPower; // sum of signer powers who are in sigs\n        address prev = address(0);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _sigs.length; i++) {\n            address signer = _hash.recover(_sigs[i]);\n            require(signer > prev, \"signers not in ascending order\");\n            prev = signer;\n            // now find match signer add its power\n            while (signer > _signers[index]) {\n                index += 1;\n                require(index < _signers.length, \"signer not found\");\n            }\n            if (signer == _signers[index]) {\n                signedPower += _powers[index];\n            }\n            if (signedPower >= quorum) {\n                // return early to save gas\n                return;\n            }\n        }\n        revert(\"quorum not reached\");\n    }\n\n    function _updateSigners(address[] calldata _signers, uint256[] calldata _powers) private {\n        require(_signers.length == _powers.length, \"signers and powers length not match\");\n        address prev = address(0);\n        for (uint256 i = 0; i < _signers.length; i++) {\n            require(_signers[i] > prev, \"New signers not in ascending order\");\n            prev = _signers[i];\n        }\n        ssHash = keccak256(abi.encodePacked(_signers, _powers));\n        emit SignersUpdated(_signers, _powers);\n    }\n}\n"
    },
    "contracts/bvn/Staking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {DataTypes as dt} from \"./DataTypes.sol\";\nimport \"./libraries/PbStaking.sol\";\nimport \"../safeguard/Pauser.sol\";\nimport \"../safeguard/Whitelist.sol\";\n\n/**\n * @title A Staking contract shared by all external sidechains and apps\n */\ncontract Staking is Pauser, Whitelist {\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n\n    IERC20 public immutable STAKING_TOKEN;\n\n    uint256 public bondedTokens;\n    uint256 public nextBondBlock;\n    address[] public valAddrs;\n    address[] public bondedValAddrs;\n    mapping(address => dt.Validator) public validators; // key is valAddr\n    mapping(address => address) public signerVals; // signerAddr -> valAddr\n    mapping(uint256 => bool) public slashNonces;\n\n    mapping(dt.ParamName => uint256) public params;\n    address public govContract;\n    address public rewardContract;\n    uint256 public forfeiture;\n\n    /* Events */\n    event ValidatorNotice(address indexed valAddr, string key, bytes data, address from);\n    event ValidatorStatusUpdate(address indexed valAddr, dt.ValidatorStatus indexed status);\n    event DelegationUpdate(\n        address indexed valAddr,\n        address indexed delAddr,\n        uint256 valTokens,\n        uint256 delShares,\n        int256 tokenDiff\n    );\n    event Undelegated(address indexed valAddr, address indexed delAddr, uint256 amount);\n    event Slash(address indexed valAddr, uint64 nonce, uint256 slashAmt);\n    event SlashAmtCollected(address indexed recipient, uint256 amount);\n\n    /**\n     * @notice Staking constructor\n     * @param _stakingTokenAddress address of Staking Token Contract\n     * @param _proposalDeposit required deposit amount for a governance proposal\n     * @param _votingPeriod voting timeout for a governance proposal\n     * @param _unbondingPeriod the locking time for funds locked before withdrawn\n     * @param _maxBondedValidators the maximum number of bonded validators\n     * @param _minValidatorTokens the global minimum token amount requirement for bonded validator\n     * @param _minSelfDelegation minimal amount of self-delegated tokens\n     * @param _advanceNoticePeriod the wait time after the announcement and prior to the effective date of an update\n     * @param _validatorBondInterval min interval between bondValidator\n     * @param _maxSlashFactor maximal slashing factor (1e6 = 100%)\n     */\n    constructor(\n        address _stakingTokenAddress,\n        uint256 _proposalDeposit,\n        uint256 _votingPeriod,\n        uint256 _unbondingPeriod,\n        uint256 _maxBondedValidators,\n        uint256 _minValidatorTokens,\n        uint256 _minSelfDelegation,\n        uint256 _advanceNoticePeriod,\n        uint256 _validatorBondInterval,\n        uint256 _maxSlashFactor\n    ) {\n        STAKING_TOKEN = IERC20(_stakingTokenAddress);\n\n        params[dt.ParamName.ProposalDeposit] = _proposalDeposit;\n        params[dt.ParamName.VotingPeriod] = _votingPeriod;\n        params[dt.ParamName.UnbondingPeriod] = _unbondingPeriod;\n        params[dt.ParamName.MaxBondedValidators] = _maxBondedValidators;\n        params[dt.ParamName.MinValidatorTokens] = _minValidatorTokens;\n        params[dt.ParamName.MinSelfDelegation] = _minSelfDelegation;\n        params[dt.ParamName.AdvanceNoticePeriod] = _advanceNoticePeriod;\n        params[dt.ParamName.ValidatorBondInterval] = _validatorBondInterval;\n        params[dt.ParamName.MaxSlashFactor] = _maxSlashFactor;\n    }\n\n    receive() external payable {}\n\n    /*********************************\n     * External and Public Functions *\n     *********************************/\n\n    /**\n     * @notice Initialize a validator candidate\n     * @param _signer signer address\n     * @param _minSelfDelegation minimal amount of tokens staked by the validator itself\n     * @param _commissionRate the self-declaimed commission rate\n     */\n    function initializeValidator(\n        address _signer,\n        uint256 _minSelfDelegation,\n        uint64 _commissionRate\n    ) external whenNotPaused onlyWhitelisted {\n        address valAddr = msg.sender;\n        dt.Validator storage validator = validators[valAddr];\n        require(validator.status == dt.ValidatorStatus.Null, \"Validator is initialized\");\n        require(validators[_signer].status == dt.ValidatorStatus.Null, \"Signer is other validator\");\n        require(signerVals[valAddr] == address(0), \"Validator is other signer\");\n        require(signerVals[_signer] == address(0), \"Signer already used\");\n        require(_commissionRate <= dt.COMMISSION_RATE_BASE, \"Invalid commission rate\");\n        require(_minSelfDelegation >= params[dt.ParamName.MinSelfDelegation], \"Insufficient min self delegation\");\n        validator.signer = _signer;\n        validator.status = dt.ValidatorStatus.Unbonded;\n        validator.minSelfDelegation = _minSelfDelegation;\n        validator.commissionRate = _commissionRate;\n        valAddrs.push(valAddr);\n        signerVals[_signer] = valAddr;\n\n        delegate(valAddr, _minSelfDelegation);\n        emit ValidatorNotice(valAddr, \"init\", abi.encode(_signer, _minSelfDelegation, _commissionRate), address(0));\n    }\n\n    /**\n     * @notice Update validator signer address\n     * @param _signer signer address\n     */\n    function updateValidatorSigner(address _signer) external {\n        address valAddr = msg.sender;\n        dt.Validator storage validator = validators[valAddr];\n        require(validator.status != dt.ValidatorStatus.Null, \"Validator not initialized\");\n        require(signerVals[_signer] == address(0), \"Signer already used\");\n        if (_signer != valAddr) {\n            require(validators[_signer].status == dt.ValidatorStatus.Null, \"Signer is other validator\");\n        }\n\n        delete signerVals[validator.signer];\n        validator.signer = _signer;\n        signerVals[_signer] = valAddr;\n\n        emit ValidatorNotice(valAddr, \"signer\", abi.encode(_signer), address(0));\n    }\n\n    /**\n     * @notice Candidate claims to become a bonded validator\n     * @dev caller can be either validator owner or signer\n     */\n    function bondValidator() external {\n        address valAddr = msg.sender;\n        if (signerVals[msg.sender] != address(0)) {\n            valAddr = signerVals[msg.sender];\n        }\n        dt.Validator storage validator = validators[valAddr];\n        require(\n            validator.status == dt.ValidatorStatus.Unbonded || validator.status == dt.ValidatorStatus.Unbonding,\n            \"Invalid validator status\"\n        );\n        require(block.number >= validator.bondBlock, \"Bond block not reached\");\n        require(block.number >= nextBondBlock, \"Too frequent validator bond\");\n        nextBondBlock = block.number + params[dt.ParamName.ValidatorBondInterval];\n        require(hasMinRequiredTokens(valAddr, true), \"Not have min tokens\");\n\n        uint256 maxBondedValidators = params[dt.ParamName.MaxBondedValidators];\n        // if the number of validators has not reached the max_validator_num,\n        // add validator directly\n        if (bondedValAddrs.length < maxBondedValidators) {\n            _bondValidator(valAddr);\n            _decentralizationCheck(validator.tokens);\n            return;\n        }\n        // if the number of validators has already reached the max_validator_num,\n        // add validator only if its tokens is more than the current least bonded validator tokens\n        uint256 minTokens = dt.MAX_INT;\n        uint256 minTokensIndex;\n        for (uint256 i = 0; i < maxBondedValidators; i++) {\n            if (validators[bondedValAddrs[i]].tokens < minTokens) {\n                minTokensIndex = i;\n                minTokens = validators[bondedValAddrs[i]].tokens;\n                if (minTokens == 0) {\n                    break;\n                }\n            }\n        }\n        require(validator.tokens > minTokens, \"Insufficient tokens\");\n        _replaceBondedValidator(valAddr, minTokensIndex);\n        _decentralizationCheck(validator.tokens);\n    }\n\n    /**\n     * @notice Confirm validator status from Unbonding to Unbonded\n     * @param _valAddr the address of the validator\n     */\n    function confirmUnbondedValidator(address _valAddr) external {\n        dt.Validator storage validator = validators[_valAddr];\n        require(validator.status == dt.ValidatorStatus.Unbonding, \"Validator not unbonding\");\n        require(block.number >= validator.unbondBlock, \"Unbond block not reached\");\n\n        validator.status = dt.ValidatorStatus.Unbonded;\n        delete validator.unbondBlock;\n        emit ValidatorStatusUpdate(_valAddr, dt.ValidatorStatus.Unbonded);\n    }\n\n    /**\n     * @notice Delegate CELR tokens to a validator\n     * @dev Minimal amount per delegate operation is 1 CELR\n     * @param _valAddr validator to delegate\n     * @param _tokens the amount of delegated CELR tokens\n     */\n    function delegate(address _valAddr, uint256 _tokens) public whenNotPaused {\n        address delAddr = msg.sender;\n        require(_tokens >= dt.STAKING_TOKEN_DECIMAL, \"Minimal amount is 1 CELR\");\n\n        dt.Validator storage validator = validators[_valAddr];\n        require(validator.status != dt.ValidatorStatus.Null, \"Validator is not initialized\");\n        uint256 shares = _tokenToShare(_tokens, validator.tokens, validator.shares);\n\n        dt.Delegator storage delegator = validator.delegators[delAddr];\n        delegator.shares += shares;\n        validator.shares += shares;\n        validator.tokens += _tokens;\n        if (validator.status == dt.ValidatorStatus.Bonded) {\n            bondedTokens += _tokens;\n            _decentralizationCheck(validator.tokens);\n        }\n        STAKING_TOKEN.safeTransferFrom(delAddr, address(this), _tokens);\n        emit DelegationUpdate(_valAddr, delAddr, validator.tokens, delegator.shares, int256(_tokens));\n    }\n\n    /**\n     * @notice Undelegate shares from a validator\n     * @dev Tokens are delegated by the msgSender to the validator\n     * @param _valAddr the address of the validator\n     * @param _shares undelegate shares\n     */\n    function undelegateShares(address _valAddr, uint256 _shares) external {\n        require(_shares >= dt.STAKING_TOKEN_DECIMAL, \"Minimal amount is 1 share\");\n        dt.Validator storage validator = validators[_valAddr];\n        require(validator.status != dt.ValidatorStatus.Null, \"Validator is not initialized\");\n        uint256 tokens = _shareToToken(_shares, validator.tokens, validator.shares);\n        _undelegate(validator, _valAddr, tokens, _shares);\n    }\n\n    /**\n     * @notice Undelegate shares from a validator\n     * @dev Tokens are delegated by the msgSender to the validator\n     * @param _valAddr the address of the validator\n     * @param _tokens undelegate tokens\n     */\n    function undelegateTokens(address _valAddr, uint256 _tokens) external {\n        require(_tokens >= dt.STAKING_TOKEN_DECIMAL, \"Minimal amount is 1 CELR\");\n        dt.Validator storage validator = validators[_valAddr];\n        require(validator.status != dt.ValidatorStatus.Null, \"Validator is not initialized\");\n        uint256 shares = _tokenToShare(_tokens, validator.tokens, validator.shares);\n        _undelegate(validator, _valAddr, _tokens, shares);\n    }\n\n    /**\n     * @notice Complete pending undelegations from a validator\n     * @param _valAddr the address of the validator\n     */\n    function completeUndelegate(address _valAddr) external {\n        address delAddr = msg.sender;\n        dt.Validator storage validator = validators[_valAddr];\n        require(validator.status != dt.ValidatorStatus.Null, \"Validator is not initialized\");\n        dt.Delegator storage delegator = validator.delegators[delAddr];\n\n        uint256 unbondingPeriod = params[dt.ParamName.UnbondingPeriod];\n        bool isUnbonded = validator.status == dt.ValidatorStatus.Unbonded;\n        // for all pending undelegations\n        uint32 i;\n        uint256 undelegationShares;\n        for (i = delegator.undelegations.head; i < delegator.undelegations.tail; i++) {\n            if (isUnbonded || delegator.undelegations.queue[i].creationBlock + unbondingPeriod <= block.number) {\n                // complete undelegation when the validator becomes unbonded or\n                // the unbondingPeriod for the pending undelegation is up.\n                undelegationShares += delegator.undelegations.queue[i].shares;\n                delete delegator.undelegations.queue[i];\n                continue;\n            }\n            break;\n        }\n        delegator.undelegations.head = i;\n\n        require(undelegationShares > 0, \"No undelegation ready to be completed\");\n        uint256 tokens = _shareToToken(undelegationShares, validator.undelegationTokens, validator.undelegationShares);\n        validator.undelegationShares -= undelegationShares;\n        validator.undelegationTokens -= tokens;\n        STAKING_TOKEN.safeTransfer(delAddr, tokens);\n        emit Undelegated(_valAddr, delAddr, tokens);\n    }\n\n    /**\n     * @notice Update commission rate\n     * @param _newRate new commission rate\n     */\n    function updateCommissionRate(uint64 _newRate) external {\n        address valAddr = msg.sender;\n        dt.Validator storage validator = validators[valAddr];\n        require(validator.status != dt.ValidatorStatus.Null, \"Validator is not initialized\");\n        require(_newRate <= dt.COMMISSION_RATE_BASE, \"Invalid new rate\");\n        validator.commissionRate = _newRate;\n        emit ValidatorNotice(valAddr, \"commission\", abi.encode(_newRate), address(0));\n    }\n\n    /**\n     * @notice Update minimal self delegation value\n     * @param _minSelfDelegation minimal amount of tokens staked by the validator itself\n     */\n    function updateMinSelfDelegation(uint256 _minSelfDelegation) external {\n        address valAddr = msg.sender;\n        dt.Validator storage validator = validators[valAddr];\n        require(validator.status != dt.ValidatorStatus.Null, \"Validator is not initialized\");\n        require(_minSelfDelegation >= params[dt.ParamName.MinSelfDelegation], \"Insufficient min self delegation\");\n        if (_minSelfDelegation < validator.minSelfDelegation) {\n            require(validator.status != dt.ValidatorStatus.Bonded, \"Validator is bonded\");\n            validator.bondBlock = uint64(block.number + params[dt.ParamName.AdvanceNoticePeriod]);\n        }\n        validator.minSelfDelegation = _minSelfDelegation;\n        emit ValidatorNotice(valAddr, \"min-self-delegation\", abi.encode(_minSelfDelegation), address(0));\n    }\n\n    /**\n     * @notice Slash a validator and its delegators\n     * @param _slashRequest slash request bytes coded in protobuf\n     * @param _sigs list of validator signatures\n     */\n    function slash(bytes calldata _slashRequest, bytes[] calldata _sigs) external whenNotPaused {\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"Slash\"));\n        verifySignatures(abi.encodePacked(domain, _slashRequest), _sigs);\n\n        PbStaking.Slash memory request = PbStaking.decSlash(_slashRequest);\n        require(block.timestamp < request.expireTime, \"Slash expired\");\n        require(request.slashFactor <= dt.SLASH_FACTOR_DECIMAL, \"Invalid slash factor\");\n        require(request.slashFactor <= params[dt.ParamName.MaxSlashFactor], \"Exceed max slash factor\");\n        require(!slashNonces[request.nonce], \"Used slash nonce\");\n        slashNonces[request.nonce] = true;\n\n        address valAddr = request.validator;\n        dt.Validator storage validator = validators[valAddr];\n        require(\n            validator.status == dt.ValidatorStatus.Bonded || validator.status == dt.ValidatorStatus.Unbonding,\n            \"Invalid validator status\"\n        );\n\n        // slash delegated tokens\n        uint256 slashAmt = (validator.tokens * request.slashFactor) / dt.SLASH_FACTOR_DECIMAL;\n        validator.tokens -= slashAmt;\n        if (validator.status == dt.ValidatorStatus.Bonded) {\n            bondedTokens -= slashAmt;\n            if (request.jailPeriod > 0 || !hasMinRequiredTokens(valAddr, true)) {\n                _unbondValidator(valAddr);\n            }\n        }\n        if (validator.status == dt.ValidatorStatus.Unbonding && request.jailPeriod > 0) {\n            validator.bondBlock = uint64(block.number + request.jailPeriod);\n        }\n        emit DelegationUpdate(valAddr, address(0), validator.tokens, 0, -int256(slashAmt));\n\n        // slash pending undelegations\n        uint256 slashUndelegation = (validator.undelegationTokens * request.slashFactor) / dt.SLASH_FACTOR_DECIMAL;\n        validator.undelegationTokens -= slashUndelegation;\n        slashAmt += slashUndelegation;\n\n        uint256 collectAmt;\n        for (uint256 i = 0; i < request.collectors.length; i++) {\n            PbStaking.AcctAmtPair memory collector = request.collectors[i];\n            if (collectAmt + collector.amount > slashAmt) {\n                collector.amount = slashAmt - collectAmt;\n            }\n            if (collector.amount > 0) {\n                collectAmt += collector.amount;\n                if (collector.account == address(0)) {\n                    STAKING_TOKEN.safeTransfer(msg.sender, collector.amount);\n                    emit SlashAmtCollected(msg.sender, collector.amount);\n                } else {\n                    STAKING_TOKEN.safeTransfer(collector.account, collector.amount);\n                    emit SlashAmtCollected(collector.account, collector.amount);\n                }\n            }\n        }\n        forfeiture += slashAmt - collectAmt;\n        emit Slash(valAddr, request.nonce, slashAmt);\n    }\n\n    function collectForfeiture() external {\n        require(forfeiture > 0, \"Nothing to collect\");\n        STAKING_TOKEN.safeTransfer(rewardContract, forfeiture);\n        forfeiture = 0;\n    }\n\n    /**\n     * @notice Validator notice event, could be triggered by anyone\n     */\n    function validatorNotice(address _valAddr, string calldata _key, bytes calldata _data) external {\n        dt.Validator storage validator = validators[_valAddr];\n        require(validator.status != dt.ValidatorStatus.Null, \"Validator is not initialized\");\n        emit ValidatorNotice(_valAddr, _key, _data, msg.sender);\n    }\n\n    function setParamValue(dt.ParamName _name, uint256 _value) external {\n        require(msg.sender == govContract, \"Caller is not gov contract\");\n        if (_name == dt.ParamName.MaxBondedValidators) {\n            require(bondedValAddrs.length <= _value, \"invalid value\");\n        }\n        params[_name] = _value;\n    }\n\n    function setGovContract(address _addr) external onlyOwner {\n        govContract = _addr;\n    }\n\n    function setRewardContract(address _addr) external onlyOwner {\n        rewardContract = _addr;\n    }\n\n    /**\n     * @notice Set max slash factor\n     */\n    function setMaxSlashFactor(uint256 _maxSlashFactor) external onlyOwner {\n        params[dt.ParamName.MaxSlashFactor] = _maxSlashFactor;\n    }\n\n    /**\n     * @notice Owner drains tokens when the contract is paused\n     * @dev emergency use only\n     * @param _amount drained token amount\n     */\n    function drainToken(uint256 _amount) external whenPaused onlyOwner {\n        STAKING_TOKEN.safeTransfer(msg.sender, _amount);\n    }\n\n    /**************************\n     *  Public View Functions *\n     **************************/\n\n    /**\n     * @notice Validate if a message is signed by quorum tokens\n     * @param _msg signed message\n     * @param _sigs list of validator signatures\n     */\n    function verifySignatures(bytes memory _msg, bytes[] memory _sigs) public view returns (bool) {\n        bytes32 hash = keccak256(_msg).toEthSignedMessageHash();\n        uint256 signedTokens;\n        address prev = address(0);\n        uint256 quorum = getQuorumTokens();\n        for (uint256 i = 0; i < _sigs.length; i++) {\n            address signer = hash.recover(_sigs[i]);\n            require(signer > prev, \"Signers not in ascending order\");\n            prev = signer;\n            dt.Validator storage validator = validators[signerVals[signer]];\n            if (validator.status != dt.ValidatorStatus.Bonded) {\n                continue;\n            }\n            signedTokens += validator.tokens;\n            if (signedTokens >= quorum) {\n                return true;\n            }\n        }\n        revert(\"Quorum not reached\");\n    }\n\n    /**\n     * @notice Verifies that a message is signed by a quorum among the validators.\n     * @param _msg signed message\n     * @param _sigs the list of signatures\n     */\n    function verifySigs(bytes memory _msg, bytes[] calldata _sigs, address[] calldata, uint256[] calldata) public view {\n        require(verifySignatures(_msg, _sigs), \"Failed to verify sigs\");\n    }\n\n    /**\n     * @notice Get quorum amount of tokens\n     * @return the quorum amount\n     */\n    function getQuorumTokens() public view returns (uint256) {\n        return (bondedTokens * 2) / 3 + 1;\n    }\n\n    /**\n     * @notice Get validator info\n     * @param _valAddr the address of the validator\n     * @return Validator token amount\n     */\n    function getValidatorTokens(address _valAddr) public view returns (uint256) {\n        return validators[_valAddr].tokens;\n    }\n\n    /**\n     * @notice Get validator info\n     * @param _valAddr the address of the validator\n     * @return Validator status\n     */\n    function getValidatorStatus(address _valAddr) public view returns (dt.ValidatorStatus) {\n        return validators[_valAddr].status;\n    }\n\n    /**\n     * @notice Check the given address is a validator or not\n     * @param _addr the address to check\n     * @return the given address is a validator or not\n     */\n    function isBondedValidator(address _addr) public view returns (bool) {\n        return validators[_addr].status == dt.ValidatorStatus.Bonded;\n    }\n\n    /**\n     * @notice Get the number of validators\n     * @return the number of validators\n     */\n    function getValidatorNum() public view returns (uint256) {\n        return valAddrs.length;\n    }\n\n    /**\n     * @notice Get the number of bonded validators\n     * @return the number of bonded validators\n     */\n    function getBondedValidatorNum() public view returns (uint256) {\n        return bondedValAddrs.length;\n    }\n\n    /**\n     * @return addresses and token amounts of bonded validators\n     */\n    function getBondedValidatorsTokens() public view returns (dt.ValidatorTokens[] memory) {\n        dt.ValidatorTokens[] memory infos = new dt.ValidatorTokens[](bondedValAddrs.length);\n        for (uint256 i = 0; i < bondedValAddrs.length; i++) {\n            address valAddr = bondedValAddrs[i];\n            infos[i] = dt.ValidatorTokens(valAddr, validators[valAddr].tokens);\n        }\n        return infos;\n    }\n\n    /**\n     * @notice Check if min token requirements are met\n     * @param _valAddr the address of the validator\n     * @param _checkSelfDelegation check self delegation\n     */\n    function hasMinRequiredTokens(address _valAddr, bool _checkSelfDelegation) public view returns (bool) {\n        dt.Validator storage v = validators[_valAddr];\n        uint256 valTokens = v.tokens;\n        if (valTokens < params[dt.ParamName.MinValidatorTokens]) {\n            return false;\n        }\n        if (_checkSelfDelegation) {\n            uint256 selfDelegation = _shareToToken(v.delegators[_valAddr].shares, valTokens, v.shares);\n            if (selfDelegation < v.minSelfDelegation) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Get the delegator info of a specific validator\n     * @param _valAddr the address of the validator\n     * @param _delAddr the address of the delegator\n     * @return DelegatorInfo from the given validator\n     */\n    function getDelegatorInfo(address _valAddr, address _delAddr) public view returns (dt.DelegatorInfo memory) {\n        dt.Validator storage validator = validators[_valAddr];\n        dt.Delegator storage d = validator.delegators[_delAddr];\n        uint256 tokens = _shareToToken(d.shares, validator.tokens, validator.shares);\n\n        uint256 undelegationShares;\n        uint256 withdrawableUndelegationShares;\n        uint256 unbondingPeriod = params[dt.ParamName.UnbondingPeriod];\n        bool isUnbonded = validator.status == dt.ValidatorStatus.Unbonded;\n        uint256 len = d.undelegations.tail - d.undelegations.head;\n        dt.Undelegation[] memory undelegations = new dt.Undelegation[](len);\n        for (uint256 i = 0; i < len; i++) {\n            undelegations[i] = d.undelegations.queue[i + d.undelegations.head];\n            undelegationShares += undelegations[i].shares;\n            if (isUnbonded || undelegations[i].creationBlock + unbondingPeriod <= block.number) {\n                withdrawableUndelegationShares += undelegations[i].shares;\n            }\n        }\n        uint256 undelegationTokens = _shareToToken(\n            undelegationShares,\n            validator.undelegationTokens,\n            validator.undelegationShares\n        );\n        uint256 withdrawableUndelegationTokens = _shareToToken(\n            withdrawableUndelegationShares,\n            validator.undelegationTokens,\n            validator.undelegationShares\n        );\n\n        return\n            dt.DelegatorInfo(\n                _valAddr,\n                tokens,\n                d.shares,\n                undelegations,\n                undelegationTokens,\n                withdrawableUndelegationTokens\n            );\n    }\n\n    /**\n     * @notice Get the value of a specific uint parameter\n     * @param _name the key of this parameter\n     * @return the value of this parameter\n     */\n    function getParamValue(dt.ParamName _name) public view returns (uint256) {\n        return params[_name];\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    function _undelegate(dt.Validator storage validator, address _valAddr, uint256 _tokens, uint256 _shares) private {\n        address delAddr = msg.sender;\n        dt.Delegator storage delegator = validator.delegators[delAddr];\n        delegator.shares -= _shares;\n        validator.shares -= _shares;\n        validator.tokens -= _tokens;\n        if (validator.tokens != validator.shares && delegator.shares <= 2) {\n            // Remove residual share caused by rounding error when total shares and tokens are not equal\n            validator.shares -= delegator.shares;\n            delegator.shares = 0;\n        }\n        require(delegator.shares == 0 || delegator.shares >= dt.STAKING_TOKEN_DECIMAL, \"not enough remaining shares\");\n\n        if (validator.status == dt.ValidatorStatus.Unbonded) {\n            STAKING_TOKEN.safeTransfer(delAddr, _tokens);\n            emit Undelegated(_valAddr, delAddr, _tokens);\n            return;\n        } else if (validator.status == dt.ValidatorStatus.Bonded) {\n            bondedTokens -= _tokens;\n            if (!hasMinRequiredTokens(_valAddr, delAddr == _valAddr)) {\n                _unbondValidator(_valAddr);\n            }\n        }\n        require(\n            delegator.undelegations.tail - delegator.undelegations.head < dt.MAX_UNDELEGATION_ENTRIES,\n            \"Exceed max undelegation entries\"\n        );\n\n        uint256 undelegationShares = _tokenToShare(_tokens, validator.undelegationTokens, validator.undelegationShares);\n        validator.undelegationShares += undelegationShares;\n        validator.undelegationTokens += _tokens;\n        dt.Undelegation storage undelegation = delegator.undelegations.queue[delegator.undelegations.tail];\n        undelegation.shares = undelegationShares;\n        undelegation.creationBlock = block.number;\n        delegator.undelegations.tail++;\n\n        emit DelegationUpdate(_valAddr, delAddr, validator.tokens, delegator.shares, -int256(_tokens));\n    }\n\n    /**\n     * @notice Set validator to bonded\n     * @param _valAddr the address of the validator\n     */\n    function _setBondedValidator(address _valAddr) private {\n        dt.Validator storage validator = validators[_valAddr];\n        validator.status = dt.ValidatorStatus.Bonded;\n        delete validator.unbondBlock;\n        bondedTokens += validator.tokens;\n        emit ValidatorStatusUpdate(_valAddr, dt.ValidatorStatus.Bonded);\n    }\n\n    /**\n     * @notice Set validator to unbonding\n     * @param _valAddr the address of the validator\n     */\n    function _setUnbondingValidator(address _valAddr) private {\n        dt.Validator storage validator = validators[_valAddr];\n        validator.status = dt.ValidatorStatus.Unbonding;\n        validator.unbondBlock = uint64(block.number + params[dt.ParamName.UnbondingPeriod]);\n        bondedTokens -= validator.tokens;\n        emit ValidatorStatusUpdate(_valAddr, dt.ValidatorStatus.Unbonding);\n    }\n\n    /**\n     * @notice Bond a validator\n     * @param _valAddr the address of the validator\n     */\n    function _bondValidator(address _valAddr) private {\n        bondedValAddrs.push(_valAddr);\n        _setBondedValidator(_valAddr);\n    }\n\n    /**\n     * @notice Replace a bonded validator\n     * @param _valAddr the address of the new validator\n     * @param _index the index of the validator to be replaced\n     */\n    function _replaceBondedValidator(address _valAddr, uint256 _index) private {\n        _setUnbondingValidator(bondedValAddrs[_index]);\n        bondedValAddrs[_index] = _valAddr;\n        _setBondedValidator(_valAddr);\n    }\n\n    /**\n     * @notice Unbond a validator\n     * @param _valAddr validator to be removed\n     */\n    function _unbondValidator(address _valAddr) private {\n        uint256 lastIndex = bondedValAddrs.length - 1;\n        for (uint256 i = 0; i < bondedValAddrs.length; i++) {\n            if (bondedValAddrs[i] == _valAddr) {\n                if (i < lastIndex) {\n                    bondedValAddrs[i] = bondedValAddrs[lastIndex];\n                }\n                bondedValAddrs.pop();\n                _setUnbondingValidator(_valAddr);\n                return;\n            }\n        }\n        revert(\"Not bonded validator\");\n    }\n\n    /**\n     * @notice Check if one validator has too much power\n     * @param _valTokens token amounts of the validator\n     */\n    function _decentralizationCheck(uint256 _valTokens) private view {\n        uint256 bondedValNum = bondedValAddrs.length;\n        if (bondedValNum == 2 || bondedValNum == 3) {\n            require(_valTokens < getQuorumTokens(), \"Single validator should not have quorum tokens\");\n        } else if (bondedValNum > 3) {\n            require(_valTokens < bondedTokens / 3, \"Single validator should not have 1/3 tokens\");\n        }\n    }\n\n    /**\n     * @notice Convert token to share\n     */\n    function _tokenToShare(uint256 tokens, uint256 totalTokens, uint256 totalShares) private pure returns (uint256) {\n        if (totalTokens == 0) {\n            return tokens;\n        }\n        return (tokens * totalShares) / totalTokens;\n    }\n\n    /**\n     * @notice Convert share to token\n     */\n    function _shareToToken(uint256 shares, uint256 totalTokens, uint256 totalShares) private pure returns (uint256) {\n        if (totalShares == 0) {\n            return shares;\n        }\n        return (shares * totalTokens) / totalShares;\n    }\n}\n"
    },
    "contracts/bvn/StakingReward.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {DataTypes as dt} from \"./DataTypes.sol\";\nimport \"../safeguard/Pauser.sol\";\nimport \"./Staking.sol\";\n\n/**\n * @title A contract to hold and distribute CELR staking rewards.\n */\ncontract StakingReward is Pauser {\n    using SafeERC20 for IERC20;\n\n    Staking public immutable staking;\n\n    // recipient => CELR reward amount\n    mapping(address => uint256) public claimedRewardAmounts;\n\n    event StakingRewardClaimed(address indexed recipient, uint256 reward);\n    event StakingRewardContributed(address indexed contributor, uint256 contribution);\n\n    constructor(Staking _staking) {\n        staking = _staking;\n    }\n\n    /**\n     * @notice Claim reward\n     * @dev Here we use cumulative reward to make claim process idempotent\n     * @param _rewardRequest reward request bytes coded in protobuf\n     * @param _sigs list of validator signatures\n     */\n    function claimReward(bytes calldata _rewardRequest, bytes[] calldata _sigs) external whenNotPaused {\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"StakingReward\"));\n        staking.verifySignatures(abi.encodePacked(domain, _rewardRequest), _sigs);\n        PbStaking.StakingReward memory reward = PbStaking.decStakingReward(_rewardRequest);\n\n        uint256 cumulativeRewardAmount = reward.cumulativeRewardAmount;\n        uint256 newReward = cumulativeRewardAmount - claimedRewardAmounts[reward.recipient];\n        require(newReward > 0, \"No new reward\");\n        claimedRewardAmounts[reward.recipient] = cumulativeRewardAmount;\n        staking.STAKING_TOKEN().safeTransfer(reward.recipient, newReward);\n        emit StakingRewardClaimed(reward.recipient, newReward);\n    }\n\n    /**\n     * @notice Contribute CELR tokens to the reward pool\n     * @param _amount the amount of CELR token to contribute\n     */\n    function contributeToRewardPool(uint256 _amount) external whenNotPaused {\n        address contributor = msg.sender;\n        IERC20(staking.STAKING_TOKEN()).safeTransferFrom(contributor, address(this), _amount);\n\n        emit StakingRewardContributed(contributor, _amount);\n    }\n\n    /**\n     * @notice Owner drains CELR tokens when the contract is paused\n     * @dev emergency use only\n     * @param _amount drained CELR token amount\n     */\n    function drainToken(uint256 _amount) external whenPaused onlyOwner {\n        IERC20(staking.STAKING_TOKEN()).safeTransfer(msg.sender, _amount);\n    }\n}\n"
    },
    "contracts/bvn/Viewer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport {DataTypes as dt} from \"./DataTypes.sol\";\nimport \"./Staking.sol\";\n\n/**\n * @title Viewer of the staking contract\n * @notice Using a separate viewer contract to reduce staking contract size\n */\ncontract Viewer {\n    Staking public immutable staking;\n\n    constructor(Staking _staking) {\n        staking = _staking;\n    }\n\n    function getValidatorInfos() public view returns (dt.ValidatorInfo[] memory) {\n        uint256 valNum = staking.getValidatorNum();\n        dt.ValidatorInfo[] memory infos = new dt.ValidatorInfo[](valNum);\n        for (uint32 i = 0; i < valNum; i++) {\n            infos[i] = getValidatorInfo(staking.valAddrs(i));\n        }\n        return infos;\n    }\n\n    function getBondedValidatorInfos() public view returns (dt.ValidatorInfo[] memory) {\n        uint256 bondedValNum = staking.getBondedValidatorNum();\n        dt.ValidatorInfo[] memory infos = new dt.ValidatorInfo[](bondedValNum);\n        for (uint32 i = 0; i < bondedValNum; i++) {\n            infos[i] = getValidatorInfo(staking.bondedValAddrs(i));\n        }\n        return infos;\n    }\n\n    function getValidatorInfo(address _valAddr) public view returns (dt.ValidatorInfo memory) {\n        (\n            dt.ValidatorStatus status,\n            address signer,\n            uint256 tokens,\n            uint256 shares,\n            ,\n            ,\n            uint256 minSelfDelegation,\n            ,\n            ,\n            uint64 commissionRate\n        ) = staking.validators(_valAddr);\n        return\n            dt.ValidatorInfo({\n                valAddr: _valAddr,\n                status: status,\n                signer: signer,\n                tokens: tokens,\n                shares: shares,\n                minSelfDelegation: minSelfDelegation,\n                commissionRate: commissionRate\n            });\n    }\n\n    function getDelegatorInfos(address _delAddr) public view returns (dt.DelegatorInfo[] memory) {\n        uint256 valNum = staking.getValidatorNum();\n        dt.DelegatorInfo[] memory infos = new dt.DelegatorInfo[](valNum);\n        uint32 num = 0;\n        for (uint32 i = 0; i < valNum; i++) {\n            address valAddr = staking.valAddrs(i);\n            infos[i] = staking.getDelegatorInfo(valAddr, _delAddr);\n            if (infos[i].shares != 0 || infos[i].undelegationTokens != 0) {\n                num++;\n            }\n        }\n        dt.DelegatorInfo[] memory res = new dt.DelegatorInfo[](num);\n        uint32 j = 0;\n        for (uint32 i = 0; i < valNum; i++) {\n            if (infos[i].shares != 0 || infos[i].undelegationTokens != 0) {\n                res[j] = infos[i];\n                j++;\n            }\n        }\n        return res;\n    }\n\n    function getDelegatorTokens(address _delAddr) public view returns (uint256, uint256) {\n        dt.DelegatorInfo[] memory infos = getDelegatorInfos(_delAddr);\n        uint256 tokens;\n        uint256 undelegationTokens;\n        for (uint32 i = 0; i < infos.length; i++) {\n            tokens += infos[i].tokens;\n            undelegationTokens += infos[i].undelegationTokens;\n        }\n        return (tokens, undelegationTokens);\n    }\n\n    /**\n     * @notice Get the minimum staking pool of all bonded validators\n     * @return the minimum staking pool of all bonded validators\n     */\n    function getMinValidatorTokens() public view returns (uint256) {\n        uint256 bondedValNum = staking.getBondedValidatorNum();\n        if (bondedValNum < staking.params(dt.ParamName.MaxBondedValidators)) {\n            return 0;\n        }\n        uint256 minTokens = dt.MAX_INT;\n        for (uint256 i = 0; i < bondedValNum; i++) {\n            uint256 tokens = staking.getValidatorTokens(staking.bondedValAddrs(i));\n            if (tokens < minTokens) {\n                minTokens = tokens;\n                if (minTokens == 0) {\n                    return 0;\n                }\n            }\n        }\n        return minTokens;\n    }\n\n    function shouldBondValidator(address _valAddr) public view returns (bool) {\n        (dt.ValidatorStatus status, , uint256 tokens, , , , , uint64 bondBlock, , ) = staking.validators(_valAddr);\n        if (status == dt.ValidatorStatus.Null || status == dt.ValidatorStatus.Bonded) {\n            return false;\n        }\n        if (block.number < bondBlock) {\n            return false;\n        }\n        if (!staking.hasMinRequiredTokens(_valAddr, true)) {\n            return false;\n        }\n        if (tokens <= getMinValidatorTokens()) {\n            return false;\n        }\n        uint256 nextBondBlock = staking.nextBondBlock();\n        if (block.number < nextBondBlock) {\n            return false;\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/chunk-sync/BlockChunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IBlockChunks.sol\";\nimport \"../verifiers/interfaces/IZkpVerifier.sol\";\nimport \"../light-client-eth/interfaces/IAnchorBlocks.sol\";\nimport \"../safeguard/BrevisAccess.sol\";\n\nuint8 constant TREE_DEPTH = 7;\nuint32 constant NUM_LEAVES = 2 ** 7;\n\n// array indices for reading from the ZKP calldata\nuint32 constant PUBLIC_BYTES_START_IDX = 10 * 32; // the first 10 32bytes are groth16 proof (A/B/C/Commitment)\n\ncontract BlockChunks is IBlockChunks, BrevisAccess {\n    mapping(uint64 => address) public verifierAddresses; // chainid => snark verifier contract address\n    mapping(uint64 => address) public anchorBlockProviders; // chainid => anchorBlockProvider\n\n    // historicalRoots[chainId][startBlockNumber] is 0 unless (startBlockNumber % NUM_LEAVES == 0)\n    // historicalRoots[chainId][startBlockNumber] holds the hash of\n    //   prevHash || root || numFinal\n    // where\n    // - prevHash is the parent hash of block startBlockNumber\n    // - root is the partial Merkle root of blockhashes of block numbers\n    //   [startBlockNumber, startBlockNumber + NUM_LEAVES)\n    //   where unconfirmed block hashes are 0's\n    // - numFinal is the number of confirmed consecutive roots in [startBlockNumber, startBlockNumber + NUM_LEAVES)\n    mapping(uint64 => mapping(uint32 => bytes32)) internal _historicalRoots; // chainid => (startBlockNumber => root)\n\n    event UpdateVerifierAddress(uint64 chainId, address newAddress);\n    event UpdateAnchorBlockProvider(uint64 chainId, address newAddress);\n\n    function updateVerifierAddress(uint64 _chainId, address _verifierAddress) external onlyOwner {\n        verifierAddresses[_chainId] = _verifierAddress;\n        emit UpdateVerifierAddress(_chainId, _verifierAddress);\n    }\n\n    function updateAnchorBlockProvider(uint64 _chainId, address _provider) external onlyOwner {\n        anchorBlockProviders[_chainId] = _provider;\n        emit UpdateAnchorBlockProvider(_chainId, _provider);\n    }\n\n    function verifyRaw(uint64 chainId, bytes calldata proofData) private view returns (bool) {\n        require(verifierAddresses[chainId] != address(0), \"chain verifier not set\");\n        return (IZkpVerifier)(verifierAddresses[chainId]).verifyRaw(proofData);\n    }\n\n    function historicalRoots(uint64 chainId, uint32 startBlockNumber) public view returns (bytes32) {\n        return _historicalRoots[chainId][startBlockNumber];\n    }\n\n    // after the groth16 proof are the public fields chunkRoot, prevHash, endHash (each in two uint128 represented in 256 bits), startBlockNum, endBlockNum\n    function getBoundaryBlockData(\n        bytes calldata proofData\n    )\n        internal\n        pure\n        returns (bytes32 chunkRoot, bytes32 prevHash, bytes32 endHash, uint32 startBlockNum, uint32 endBlockNum)\n    {\n        chunkRoot = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 32 + 16:PUBLIC_BYTES_START_IDX + 2 * 32]))\n        );\n        prevHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 3 * 32 + 16:PUBLIC_BYTES_START_IDX + 4 * 32]))\n        );\n        endHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 4 * 32:PUBLIC_BYTES_START_IDX + 5 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 5 * 32 + 16:PUBLIC_BYTES_START_IDX + 6 * 32]))\n        );\n        startBlockNum = uint32(bytes4(proofData[PUBLIC_BYTES_START_IDX + 7 * 32 - 4:PUBLIC_BYTES_START_IDX + 7 * 32]));\n        endBlockNum = uint32(bytes4(proofData[PUBLIC_BYTES_START_IDX + 8 * 32 - 4:PUBLIC_BYTES_START_IDX + 8 * 32]));\n    }\n\n    // update blocks in the \"backward\" direction, anchoring on a \"recent\" end blockhash from anchor contract\n    // * startBlockNumber must be a multiple of NUM_LEAVES\n    // * for now always endBlockNumber = startBlockNumber + NUM_LEAVES - 1 (full update on every NUM_LEAVES blocks chunk)\n    function updateRecent(uint64 chainId, bytes calldata proofData) external onlyActiveProver {\n        (\n            bytes32 chunkRoot,\n            bytes32 prevHash,\n            bytes32 endHash,\n            uint32 startBlockNum,\n            uint32 endBlockNum\n        ) = getBoundaryBlockData(proofData);\n\n        require(endBlockNum == startBlockNum + NUM_LEAVES - 1, \"need 128 blks\");\n        require(startBlockNum % NUM_LEAVES == 0, \"need start from 128x\");\n\n        require(anchorBlockProviders[chainId] != address(0), \"chain anchor provider not set\");\n        require(IAnchorBlocks(anchorBlockProviders[chainId]).blocks(endBlockNum) == endHash, \"endHash not correct\");\n\n        require(verifyRaw(chainId, proofData), \"proof not valid\");\n\n        _historicalRoots[chainId][startBlockNum] = keccak256(abi.encodePacked(prevHash, chunkRoot, NUM_LEAVES));\n        emit UpdateEvent(chainId, startBlockNum, prevHash, chunkRoot, NUM_LEAVES);\n    }\n\n    // update older blocks in \"backwards\" direction, anchoring on more recent trusted blockhash\n    // must be batch of NUM_LEAVES blocks\n    function updateOld(\n        uint64 chainId,\n        bytes32 nextRoot,\n        uint32 nextNumFinal,\n        bytes calldata proofData\n    ) external onlyActiveProver {\n        (\n            bytes32 chunkRoot,\n            bytes32 prevHash,\n            bytes32 endHash,\n            uint32 startBlockNum,\n            uint32 endBlockNum\n        ) = getBoundaryBlockData(proofData);\n\n        require(startBlockNum % NUM_LEAVES == 0, \"need start from 128x\");\n        require(endBlockNum - startBlockNum == NUM_LEAVES - 1, \"need 128 blks\");\n\n        require(\n            historicalRoots(chainId, endBlockNum + 1) == keccak256(abi.encodePacked(endHash, nextRoot, nextNumFinal)),\n            \"endHash not correct\"\n        );\n        require(verifyRaw(chainId, proofData), \"proof not valid\");\n\n        _historicalRoots[chainId][startBlockNum] = keccak256(abi.encodePacked(prevHash, chunkRoot, NUM_LEAVES));\n        emit UpdateEvent(chainId, startBlockNum, prevHash, chunkRoot, NUM_LEAVES);\n    }\n\n    function isBlockHashValid(BlockHashWitness calldata witness) public view returns (bool) {\n        require(witness.claimedBlkHash != 0x0, \"claimedBlkHash not present\"); // \"Claimed block hash cannot be 0\"\n        uint32 side = witness.blkNum % NUM_LEAVES;\n        uint32 startBlockNumber = witness.blkNum - side;\n        bytes32 merkleRoot = historicalRoots(witness.chainId, startBlockNumber);\n        require(merkleRoot != 0, \"blk history not stored yet\"); // \"Merkle root must be stored already\"\n        // compute Merkle root of blockhash\n        bytes32 root = witness.claimedBlkHash;\n        for (uint8 depth = 0; depth < TREE_DEPTH; depth++) {\n            // 0 for left, 1 for right\n            if ((side >> depth) & 1 == 0) {\n                root = keccak256(abi.encodePacked(root, witness.merkleProof[depth]));\n            } else {\n                root = keccak256(abi.encodePacked(witness.merkleProof[depth], root));\n            }\n        }\n        return (merkleRoot == keccak256(abi.encodePacked(witness.prevHash, root, witness.numFinal)));\n    }\n}\n"
    },
    "contracts/chunk-sync/interfaces/IBlockChunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IBlockChunks {\n    // historicalRoots(chainId, startBlockNumber) is 0 unless (startBlockNumber % 128 == 0)\n    // historicalRoots(chainId, startBlockNumber) holds the hash of\n    //   prevHash || root || numFinal\n    // where\n    // - prevHash is the parent hash of block startBlockNumber\n    // - root is the partial Merkle root of blockhashes of block numbers\n    //   [startBlockNumber, startBlockNumber + 128)\n    //   where unconfirmed block hashes are 0's\n    // - numFinal is the number of confirmed consecutive roots in [startBlockNumber, startBlockNumber + 128)\n    function historicalRoots(uint64 chainId, uint32 startBlockNumber) external view returns (bytes32);\n\n    event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal);\n\n    struct BlockHashWitness {\n        uint64 chainId;\n        uint32 blkNum;\n        bytes32 claimedBlkHash;\n        bytes32 prevHash;\n        uint32 numFinal;\n        bytes32[7] merkleProof;\n    }\n\n    // update blocks in the \"backward\" direction, anchoring on a \"recent\" end blockhash from anchor contract\n    // * startBlockNumber must be a multiple of 128\n    // * for now always endBlockNumber = startBlockNumber + 127 (full update on every 128 blocks chunk)\n    function updateRecent(uint64 chainId, bytes calldata proofData) external;\n\n    // update older blocks in \"backwards\" direction, anchoring on more recent trusted blockhash\n    // must be batch of 128 blocks\n    function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes calldata proofData) external;\n\n    function isBlockHashValid(BlockHashWitness calldata witness) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IEthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IEthereumLightClient {\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n}\n"
    },
    "contracts/interfaces/ISigsVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IBvnSigsVerifier {\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msg signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes memory _msg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msgHash hash of signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes32 _msgHash,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n\n    struct SigInfo {\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n}\n\ninterface IAvsSigsVerifier {\n    struct BN254_G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[1] * i + X[0]\n    struct BN254_G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    struct NonSignerStakesAndSignature {\n        uint32[] nonSignerQuorumBitmapIndices; // is the indices of all nonsigner quorum bitmaps\n        BN254_G1Point[] nonSignerPubkeys; // is the G1 pubkeys of all nonsigners\n        BN254_G1Point[] quorumApks; // is the aggregate G1 pubkey of each quorum\n        BN254_G2Point apkG2; // is the aggregate G2 pubkey of all signers\n        BN254_G1Point sigma; // is the aggregate G1 signature of all signers\n        uint32[] quorumApkIndices; // is the indices of each quorum aggregate pubkey\n        uint32[] totalStakeIndices; // is the indices of each quorums total stake\n        uint32[][] nonSignerStakeIndices; // is the indices of each non signers stake within a quorum\n    }\n\n    struct SigInfo {\n        uint64 blockNum;\n        NonSignerStakesAndSignature params;\n    }\n\n    function verifySigs(bytes32 msgHash, uint64 blockNum, NonSignerStakesAndSignature calldata params) external view;\n}\n"
    },
    "contracts/interfaces/ISMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../verifiers/zk-verifiers/common/IVerifier.sol\";\n\ninterface ISMT {\n    struct SmtUpdate {\n        bytes32 newSmtRoot;\n        uint64 endBlockNum;\n        bytes32 endBlockHash;\n        bytes32 nextChunkMerkleRoot;\n        uint256[8] proof;\n        uint256[2] commit;\n        uint256[2] knowledgeProof;\n    }\n\n    function updateRoot(uint64 chainId, SmtUpdate memory u) external;\n\n    function isSmtRootValid(uint64 chainId, bytes32 smtRoot) external view returns (bool);\n}\n"
    },
    "contracts/lib/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity >=0.5.10 <0.9.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    },
    "contracts/lib/Utils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary Utils {\n    // https://ethereum.stackexchange.com/a/83577\n    // https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/base/Multicall.sol\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n"
    },
    "contracts/light-client-eth/AnchorBlocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IEthereumLightClient.sol\";\nimport \"./interfaces/IAnchorBlocks.sol\";\nimport \"./common/Helpers.sol\";\nimport \"./common/Constants.sol\";\nimport \"./common/Types.sol\";\nimport \"../safeguard/BrevisAccess.sol\";\n\nuint256 constant EXECUTION_BLOCK_LEFT_PREFIX_LEN = 4;\n\ncontract AnchorBlocks is IAnchorBlocks, BrevisAccess {\n    // BlockHashWitness is the RLP code that witnesses the generation of block hash given the ParentHash field\n    struct BlockHashWitness {\n        bytes left;\n        bytes right;\n    }\n\n    event AnchorBlockUpdated(uint256 blockNum, bytes32 blockHash);\n\n    IEthereumLightClient public lightClient;\n    // execution block number => execution block hash\n    mapping(uint256 => bytes32) public blocks;\n    uint256 public latestBlockNum;\n\n    constructor(address _lightClient) {\n        lightClient = IEthereumLightClient(_lightClient);\n    }\n\n    /// @notice Updates an \"anchor block\" of a specific block number to the contract state\n    function processUpdate(LightClientOptimisticUpdate memory hb) external {\n        (uint256 blockNum, bytes32 blockHash) = verifyHeadBlock(hb);\n        require(blockHash != bytes32(0), \"empty blockHash\");\n        doUpdate(blockNum, blockHash);\n    }\n\n    /// @notice Updates an \"anchor block\" of a specific block number to the contract state\n    /// @dev It is possible that an attested block doesn't collect enough sync committee signatures in its corresponding\n    /// signature slot and thus cannot be used in an anchor update. In that case, the updater can pick a later block\n    /// that has enough sigs, and supply a chainProof to show that the block they want to sync can chain to the head block.\n    function processUpdateWithChainProof(\n        LightClientOptimisticUpdate memory hb,\n        bytes32 blockHash,\n        BlockHashWitness[] memory chainProof\n    ) external onlyActiveProver {\n        require(chainProof.length > 0, \"invalid proof length\");\n        (uint256 headBlockNum, bytes32 headBlockHash) = verifyHeadBlock(hb);\n        uint256 blockNum = headBlockNum - chainProof.length;\n        verifyChainProof(blockHash, chainProof, headBlockHash);\n        doUpdate(blockNum, blockHash);\n    }\n\n    function verifyHeadBlock(LightClientOptimisticUpdate memory hb) private view returns (uint256, bytes32) {\n        require(hasSupermajority(hb.syncAggregate.participation), \"quorum not reached\");\n        verifyExecutionPayload(hb.attestedHeader);\n        lightClient.verifyCommitteeSignature(hb.signatureSlot, hb.attestedHeader.beacon, hb.syncAggregate);\n        HeaderWithExecution memory h = hb.attestedHeader;\n        uint256 blockNum = Helpers.revertEndian(uint256(h.execution.blockNumber.leaf));\n        return (blockNum, h.execution.blockHash.leaf);\n    }\n\n    function verifyExecutionPayload(HeaderWithExecution memory h) private pure {\n        bool valid = Helpers.isValidMerkleBranch(h.executionRoot, EXECUTION_PAYLOAD_ROOT_INDEX, h.beacon.bodyRoot);\n        require(valid, \"bad exec root proof\");\n        verifyMerkleProof(h.execution.blockNumber, EXECUTION_BLOCK_NUMBER_LOCAL_INDEX, h.executionRoot.leaf);\n        verifyMerkleProof(h.execution.blockHash, EXECUTION_BLOCK_HASH_LOCAL_INDEX, h.executionRoot.leaf);\n    }\n\n    function doUpdate(uint256 blockNum, bytes32 blockHash) private {\n        require(blocks[blockNum] == bytes32(0), \"block hash already exists\");\n        blocks[blockNum] = blockHash;\n        if (blockNum > latestBlockNum) {\n            latestBlockNum = blockNum;\n        }\n        emit AnchorBlockUpdated(blockNum, blockHash);\n    }\n\n    function verifyChainProof(\n        bytes32 blockHash,\n        BlockHashWitness[] memory chainProof,\n        bytes32 headBlockHash\n    ) private pure {\n        bytes32 h = blockHash;\n        for (uint256 i = 0; i < chainProof.length; i++) {\n            // small hack to save some RLP encoding:\n            // We only care about whether the given blockHash can somehow combine with something to hash into headBlockHash.\n            // The RLP oding of a block always has 3 bytes for total length prefix and 1 byte (0xa0) for bytes32's length\n            // prefix; and the ParentHash field is always the first element. So there are always 8 bytes preceding ParentHash.\n            require(chainProof[i].left.length == EXECUTION_BLOCK_LEFT_PREFIX_LEN, \"invalid left len\");\n            h = keccak256(bytes.concat(chainProof[i].left, h, chainProof[i].right));\n        }\n        require(h == headBlockHash, \"invalid chainProof\");\n    }\n\n    function verifyMerkleProof(LeafWithBranch memory proof, uint256 index, bytes32 root) private pure {\n        require(Helpers.isValidMerkleBranch(proof, index, root), \"bad proof\");\n    }\n\n    function hasSupermajority(uint64 participation) private pure returns (bool) {\n        return participation * 3 >= SYNC_COMMITTEE_SIZE * 2;\n    }\n\n    function setLightClient(address _lightClient) external onlyOwner {\n        lightClient = IEthereumLightClient(_lightClient);\n    }\n}\n"
    },
    "contracts/light-client-eth/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n// light client security params\nuint256 constant MIN_SYNC_COMMITTEE_PARTICIPANTS = 1;\nuint256 constant UPDATE_TIMEOUT = 86400;\n\n// beacon chain constants\nuint256 constant FINALIZED_ROOT_INDEX = 105;\nuint256 constant NEXT_SYNC_COMMITTEE_INDEX = 55;\nuint256 constant SYNC_COMMITTEE_SIZE = 512;\nuint64 constant SLOTS_PER_EPOCH = 32;\nuint64 constant EPOCHS_PER_SYNC_COMMITTEE_PERIOD = 256;\nbytes32 constant DOMAIN_SYNC_COMMITTEE = bytes32(uint256(0x07) << 248);\nuint256 constant SLOT_LENGTH_SECONDS = 12;\n\n// https://github.com/ethereum/consensus-specs/blob/dev/specs/capella/light-client/sync-protocol.md\n// beaconBodyRoot -> stateRoot gindex: 2 << 7 | 9 * 2 << 3 | 2\nuint256 constant EXECUTION_STATE_ROOT_INDEX = 402;\n// beaconBodyRoot -> blockHash gindex: 2 << 7 | 9 * 2 << 3 | 12\nuint256 constant EXECUTION_BLOCK_HASH_INDEX = 412;\n\n// the following indices are gindices counting from the executionPayloadRoot\n// beaconBodyRoot -> executionPayloadRoot gindex: 2 << 4 | 9\nuint256 constant EXECUTION_PAYLOAD_ROOT_INDEX = 25;\n// executionPayloadRoot -> stateRoot gindex: 2 << 4 | 2\nuint256 constant EXECUTION_STATE_ROOT_LOCAL_INDEX = 18;\n// executionPayloadRoot -> blockNumber gindex: 2 << 4 | 6\nuint256 constant EXECUTION_BLOCK_NUMBER_LOCAL_INDEX = 22;\n// executionPayloadRoot -> blockHash gindex: 2 << 4 | 12\nuint256 constant EXECUTION_BLOCK_HASH_LOCAL_INDEX = 28;\n"
    },
    "contracts/light-client-eth/common/Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./Types.sol\";\n\nlibrary Helpers {\n    function isValidMerkleBranch(LeafWithBranch memory lwb, uint256 index, bytes32 root) internal pure returns (bool) {\n        bytes32 restoredMerkleRoot = restoreMerkleRoot(lwb.leaf, lwb.branch, index);\n        return root == restoredMerkleRoot;\n    }\n\n    function isValidMerkleBranch(\n        bytes32 leaf,\n        bytes32[] memory branch,\n        uint256 index,\n        bytes32 root\n    ) internal pure returns (bool) {\n        bytes32 restoredMerkleRoot = restoreMerkleRoot(leaf, branch, index);\n        return root == restoredMerkleRoot;\n    }\n\n    function concatMerkleBranches(bytes32[] memory a, bytes32[] memory b) internal pure returns (bytes32[] memory) {\n        bytes32[] memory c = new bytes32[](a.length + b.length);\n        for (uint256 i = 0; i < a.length + b.length; i++) {\n            if (i < a.length) {\n                c[i] = a[i];\n            } else {\n                c[i] = b[i - a.length];\n            }\n        }\n        return c;\n    }\n\n    function restoreMerkleRoot(bytes32 leaf, bytes32[] memory branch, uint256 index) internal pure returns (bytes32) {\n        bytes32 value = leaf;\n        for (uint256 i = 0; i < branch.length; i++) {\n            if ((index / (2 ** i)) % 2 == 1) {\n                value = sha256(bytes.concat(branch[i], value));\n            } else {\n                value = sha256(bytes.concat(value, branch[i]));\n            }\n        }\n        return value;\n    }\n\n    function hashTreeRoot(BeaconBlockHeader memory header) internal pure returns (bytes32) {\n        bytes32 left = sha256(\n            bytes.concat(\n                sha256(bytes.concat(bytes32(revertEndian(header.slot)), bytes32(revertEndian(header.proposerIndex)))),\n                sha256(bytes.concat(header.parentRoot, header.stateRoot))\n            )\n        );\n        bytes32 right = sha256(\n            bytes.concat(\n                sha256(bytes.concat(header.bodyRoot, bytes32(0))),\n                sha256(bytes.concat(bytes32(0), bytes32(0)))\n            )\n        );\n        return sha256(bytes.concat(left, right));\n    }\n\n    function revertEndian(uint256 x) internal pure returns (uint256) {\n        uint256 res;\n        for (uint256 i = 0; i < 32; i++) {\n            res = (res << 8) | (x & 0xff);\n            x >>= 8;\n        }\n        return res;\n    }\n}\n"
    },
    "contracts/light-client-eth/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../verifiers/interfaces/IBeaconVerifier.sol\";\n\nstruct LightClientOptimisticUpdate {\n    // Header attested to by the sync committee\n    HeaderWithExecution attestedHeader;\n    // Sync committee aggregate signature participation & zk proof\n    SyncAggregate syncAggregate;\n    // Slot at which the aggregate signature was created (untrusted)\n    uint64 signatureSlot;\n}\n\nstruct LightClientUpdate {\n    // Header attested to by the sync committee\n    HeaderWithExecution attestedHeader;\n    HeaderWithExecution finalizedHeader;\n    // merkle branch from finalized beacon header root to attestedHeader.stateRoot\n    bytes32[] finalityBranch;\n    bytes32 nextSyncCommitteeRoot;\n    bytes32[] nextSyncCommitteeBranch;\n    bytes32 nextSyncCommitteePoseidonRoot;\n    IBeaconVerifier.Proof nextSyncCommitteeRootMappingProof;\n    // Sync committee aggregate signature participation & zk proof\n    SyncAggregate syncAggregate;\n    // Slot at which the aggregate signature was created (untrusted)\n    uint64 signatureSlot;\n}\n\nstruct HeaderWithExecution {\n    BeaconBlockHeader beacon;\n    ExecutionPayload execution;\n    // merkle branch from execution payload root to beacon block root\n    LeafWithBranch executionRoot;\n}\n\nfunction isEmpty(HeaderWithExecution memory header) pure returns (bool) {\n    return header.beacon.stateRoot == bytes32(0);\n}\n\n// only contains the fields we care about in execution payload\nstruct ExecutionPayload {\n    // merkle branch from execution state root to execution payload root\n    LeafWithBranch stateRoot;\n    // merkle branch from execution block hash to execution payload root\n    LeafWithBranch blockHash;\n    // merkle branch from execution block number to execution payload root\n    LeafWithBranch blockNumber;\n}\n\nfunction isEmpty(ExecutionPayload memory payload) pure returns (bool) {\n    return\n        payload.stateRoot.leaf == bytes32(0) &&\n        payload.blockHash.leaf == bytes32(0) &&\n        payload.blockNumber.leaf == bytes32(0);\n}\n\nstruct LeafWithBranch {\n    bytes32 leaf;\n    bytes32[] branch;\n}\n\nstruct BeaconBlockHeader {\n    uint64 slot;\n    uint64 proposerIndex;\n    bytes32 parentRoot;\n    bytes32 stateRoot;\n    bytes32 bodyRoot;\n}\n\nstruct SyncAggregate {\n    uint64 participation;\n    bytes32 poseidonRoot;\n    uint256 commitment;\n    IBeaconVerifier.Proof proof;\n}\n"
    },
    "contracts/light-client-eth/EthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IEthereumLightClient.sol\";\nimport \"./LightClientStore.sol\";\nimport \"./common/Helpers.sol\";\nimport \"./common/Constants.sol\";\nimport \"./common/Types.sol\";\nimport \"../safeguard/BrevisAccess.sol\";\n\ncontract EthereumLightClient is IEthereumLightClient, LightClientStore, BrevisAccess {\n    event OptimisticUpdate(uint256 slot, bytes32 executionStateRoot);\n    event FinalityUpdate(uint256 slot, bytes32 executionStateRoot);\n    event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot);\n    event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion);\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        uint64 _finalizedSlot,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    )\n        LightClientStore(\n            genesisTime,\n            genesisValidatorsRoot,\n            _forkEpochs,\n            _forkVersions,\n            _finalizedSlot,\n            syncCommitteeRoot,\n            syncCommitteePoseidonRoot,\n            _zkVerifier\n        )\n    {}\n\n    function latestFinalizedSlotAndCommitteeRoots()\n        external\n        view\n        returns (uint64 slot, bytes32 currentRoot, bytes32 nextRoot)\n    {\n        return (finalizedSlot, currentSyncCommitteeRoot, nextSyncCommitteeRoot);\n    }\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (optimisticExecutionStateRoot, optimisticSlot);\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (finalizedExecutionStateRoot, finalizedSlot);\n    }\n\n    function updateForkVersion(uint64 epoch, bytes4 forkVersion) external onlyOwner {\n        require(forkVersion != bytes4(0), \"bad fork version\");\n        forkEpochs.push(epoch);\n        forkVersions.push(forkVersion);\n        emit ForkVersionUpdated(epoch, forkVersion);\n    }\n\n    function processLightClientForceUpdate() external onlyOwner {\n        require(currentSlot() > finalizedSlot + UPDATE_TIMEOUT, \"timeout not passed\");\n        require(bestValidUpdate.attestedHeader.beacon.slot > 0, \"no best valid update\");\n\n        // Forced best update when the update timeout has elapsed.\n        // Because the apply logic waits for finalizedHeader.beacon.slot to indicate sync committee fin,\n        // the attestedHeader may be treated as finalizedHeader in extended periods of non-fin\n        // to guarantee progression into later sync committee periods according to isBetterUpdate().\n        if (bestValidUpdate.finalizedHeader.beacon.slot <= finalizedSlot) {\n            bestValidUpdate.finalizedHeader = bestValidUpdate.attestedHeader;\n        }\n        applyFinalityUpdate(bestValidUpdate);\n        delete bestValidUpdate;\n    }\n\n    function processLightClientUpdate(LightClientUpdate memory update) public onlyActiveProver {\n        bool quorumReached = hasSupermajority(update.syncAggregate.participation);\n        bool betterUpdate = isBetterUpdate(update, bestValidUpdate);\n        require(betterUpdate || quorumReached, \"quorum not reached\");\n        validateLightClientUpdate(update);\n\n        // Update the best update in case we have to force-update to it if the timeout elapses\n        if (betterUpdate) {\n            bestValidUpdate = update;\n        }\n        // Apply optimistic update\n        if (quorumReached && update.attestedHeader.beacon.slot > optimisticSlot) {\n            applyOptimisticUpdate(update);\n        }\n        // Apply finality update\n        if (\n            quorumReached &&\n            (update.finalizedHeader.beacon.slot > finalizedSlot ||\n                (hasNextSyncCommittee(update) && nextSyncCommitteeRoot == bytes32(0)))\n        ) {\n            applyFinalityUpdate(update);\n            delete bestValidUpdate;\n        }\n    }\n\n    function validateLightClientUpdate(LightClientUpdate memory update) private view {\n        // Verify sync committee has sufficient participants\n        require(update.syncAggregate.participation > MIN_SYNC_COMMITTEE_PARTICIPANTS, \"not enough participation\");\n        // Verify update does not skip a sync committee period\n        require(\n            currentSlot() > update.attestedHeader.beacon.slot &&\n                update.attestedHeader.beacon.slot > update.finalizedHeader.beacon.slot,\n            \"bad slot\"\n        );\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedSlot);\n\n        // Verify update is relavant\n        uint64 updateAttestedPeriod = computeSyncCommitteePeriodAtSlot(update.attestedHeader.beacon.slot);\n        bool updateHasNextSyncCommittee = nextSyncCommitteeRoot == bytes32(0) &&\n            hasNextSyncCommitteeProof(update) &&\n            updateAttestedPeriod == storePeriod;\n        // Since sync committee update prefers older header (see isBetterUpdate), an update either\n        // needs to have a newer header or it should have sync committee update.\n        require(\n            update.attestedHeader.beacon.slot > finalizedSlot || updateHasNextSyncCommittee,\n            \"bad att slot or committee\"\n        );\n\n        // Verify that the finalityBranch, if present, confirms finalizedHeader\n        // to match the finalized checkpoint root saved in the state of attestedHeader.\n        // Note that the genesis finalized checkpoint root is represented as a zero hash.\n        if (!hasFinalityProof(update)) {\n            require(isEmpty(update.finalizedHeader), \"no fin proof\");\n        } else {\n            // genesis block header\n            if (update.finalizedHeader.beacon.slot == 0) {\n                require(isEmpty(update.finalizedHeader), \"genesis header should be empty\");\n            } else {\n                bool isValidFinalityProof = Helpers.isValidMerkleBranch(\n                    Helpers.hashTreeRoot(update.finalizedHeader.beacon),\n                    update.finalityBranch,\n                    FINALIZED_ROOT_INDEX,\n                    update.attestedHeader.beacon.stateRoot\n                );\n                require(isValidFinalityProof, \"bad fin proof\");\n                verifyExecutionPayload(update.finalizedHeader, \"finalized\");\n            }\n        }\n\n        // Verify that the update's nextSyncCommittee, if present, actually is the next sync committee\n        // saved in the state of the update's attested header\n        if (!hasNextSyncCommitteeProof(update)) {\n            require(\n                update.nextSyncCommitteeRoot == bytes32(0) && update.nextSyncCommitteePoseidonRoot == bytes32(0),\n                \"no next sync committee proof\"\n            );\n        } else {\n            if (updateAttestedPeriod == storePeriod && nextSyncCommitteeRoot != bytes32(0)) {\n                require(update.nextSyncCommitteeRoot == nextSyncCommitteeRoot, \"bad next sync committee\");\n            }\n            bool validSyncCommitteeProof = Helpers.isValidMerkleBranch(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteeBranch,\n                NEXT_SYNC_COMMITTEE_INDEX,\n                update.attestedHeader.beacon.stateRoot\n            );\n            require(validSyncCommitteeProof, \"bad next sync committee proof\");\n            bool validCommitteeRootMappingProof = zkVerifier.verifySyncCommitteeRootMappingProof(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteePoseidonRoot,\n                update.nextSyncCommitteeRootMappingProof\n            );\n            require(validCommitteeRootMappingProof, \"bad next sync committee root mapping proof\");\n        }\n\n        // Verify optimistic execution payload\n        verifyExecutionPayload(update.attestedHeader, \"optimistic\");\n\n        // Verify sync committee signature ZK proof\n        verifyCommitteeSignature(update.signatureSlot, update.attestedHeader.beacon, update.syncAggregate);\n    }\n\n    function verifyCommitteeSignature(\n        uint64 signatureSlot,\n        BeaconBlockHeader memory header,\n        SyncAggregate memory syncAggregate\n    ) public view {\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedSlot);\n        uint64 updateSigPeriod = computeSyncCommitteePeriodAtSlot(signatureSlot);\n        if (nextSyncCommitteeRoot != bytes32(0)) {\n            require(updateSigPeriod == storePeriod || updateSigPeriod == storePeriod + 1, \"bad sig period 2\");\n        } else {\n            require(updateSigPeriod == storePeriod, \"bad sig period 1\");\n        }\n\n        bytes4 forkVersion = computeForkVersion(computeEpochAtSlot(signatureSlot));\n        bytes32 domain = computeDomain(forkVersion);\n        bytes32 signingRoot = computeSigningRoot(header, domain);\n        bytes32 activeSyncCommitteePoseidonRoot;\n        if (updateSigPeriod == storePeriod) {\n            require(currentSyncCommitteePoseidonRoot == syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = currentSyncCommitteePoseidonRoot;\n        } else {\n            require(nextSyncCommitteePoseidonRoot == syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n        }\n        require(\n            zkVerifier.verifySignatureProof(\n                signingRoot,\n                activeSyncCommitteePoseidonRoot,\n                syncAggregate.participation,\n                syncAggregate.commitment,\n                syncAggregate.proof\n            ),\n            \"bad bls sig proof\"\n        );\n    }\n\n    function verifyExecutionPayload(HeaderWithExecution memory h, string memory name) private pure {\n        ExecutionPayload memory exec = h.execution;\n        bool valid = Helpers.isValidMerkleBranch(h.executionRoot, EXECUTION_PAYLOAD_ROOT_INDEX, h.beacon.bodyRoot);\n        require(valid, string.concat(\"bad exec root proof \", name));\n        valid = Helpers.isValidMerkleBranch(exec.stateRoot, EXECUTION_STATE_ROOT_LOCAL_INDEX, h.executionRoot.leaf);\n        require(valid, string.concat(\"bad exec state root proof \", name));\n    }\n\n    function applyOptimisticUpdate(LightClientUpdate memory update) private {\n        HeaderWithExecution memory h = update.attestedHeader;\n        bytes32 stateRoot = h.execution.stateRoot.leaf;\n        optimisticExecutionStateRoot = stateRoot;\n        optimisticSlot = h.beacon.slot;\n        emit OptimisticUpdate(h.beacon.slot, stateRoot);\n    }\n\n    function applyFinalityUpdate(LightClientUpdate memory update) private {\n        uint64 updateSlot = update.finalizedHeader.beacon.slot;\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedSlot);\n        uint64 updateFinalizedPeriod = computeSyncCommitteePeriodAtSlot(updateSlot);\n        if (nextSyncCommitteeRoot == bytes32(0)) {\n            require(updateFinalizedPeriod == storePeriod, \"mismatch period\");\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        } else if (updateFinalizedPeriod == storePeriod + 1) {\n            currentSyncCommitteeRoot = nextSyncCommitteeRoot;\n            currentSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        }\n        bytes32 updateExecStateRoot = update.finalizedHeader.execution.stateRoot.leaf;\n        if (updateSlot > finalizedSlot) {\n            finalizedExecutionStateRoot = updateExecStateRoot;\n            finalizedSlot = updateSlot;\n            emit FinalityUpdate(updateSlot, updateExecStateRoot);\n            return;\n        }\n    }\n\n    /*\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#is_better_update\n     */\n    function isBetterUpdate(\n        LightClientUpdate memory newUpdate,\n        LightClientUpdate memory oldUpdate\n    ) private pure returns (bool) {\n        // Old update doesn't exist\n        if (oldUpdate.syncAggregate.participation == 0) {\n            return newUpdate.syncAggregate.participation > 0;\n        }\n\n        // Compare supermajority (> 2/3) sync committee participation\n        bool newHasSupermajority = hasSupermajority(newUpdate.syncAggregate.participation);\n        bool oldHasSupermajority = hasSupermajority(oldUpdate.syncAggregate.participation);\n        if (newHasSupermajority != oldHasSupermajority) {\n            // the new update is a better one if new has supermajority but old doesn't\n            return newHasSupermajority && !oldHasSupermajority;\n        }\n        if (!newHasSupermajority && newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            // a better update is the one with higher participation when both new and old doesn't have supermajority\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Compare presence of relevant sync committee\n        bool newHasSyncCommittee = hasRelavantSyncCommittee(newUpdate);\n        bool oldHasSyncCommittee = hasRelavantSyncCommittee(oldUpdate);\n        if (newHasSyncCommittee != oldHasSyncCommittee) {\n            return newHasSyncCommittee;\n        }\n\n        // Compare indication of any fin\n        bool newHasFinality = hasFinalityProof(newUpdate);\n        bool oldHasFinality = hasFinalityProof(oldUpdate);\n        if (newHasFinality != oldHasFinality) {\n            return newHasFinality;\n        }\n\n        // Compare sync committee fin\n        if (newHasFinality) {\n            bool newHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(newUpdate.finalizedHeader.beacon.slot) ==\n                computeSyncCommitteePeriodAtSlot(newUpdate.attestedHeader.beacon.slot);\n            bool oldHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(oldUpdate.finalizedHeader.beacon.slot) ==\n                computeSyncCommitteePeriodAtSlot(oldUpdate.attestedHeader.beacon.slot);\n            if (newHasCommitteeFinality != oldHasCommitteeFinality) {\n                return newHasCommitteeFinality;\n            }\n        }\n\n        // Tiebreaker 1: Sync committee participation beyond supermajority\n        if (newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Tiebreaker 2: Prefer older data (fewer changes to best)\n        if (newUpdate.attestedHeader.beacon.slot != oldUpdate.attestedHeader.beacon.slot) {\n            return newUpdate.attestedHeader.beacon.slot < oldUpdate.attestedHeader.beacon.slot;\n        }\n\n        return newUpdate.signatureSlot < oldUpdate.signatureSlot;\n    }\n\n    function hasRelavantSyncCommittee(LightClientUpdate memory update) private pure returns (bool) {\n        return\n            hasNextSyncCommitteeProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.beacon.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.signatureSlot);\n    }\n\n    function hasNextSyncCommitteeProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.nextSyncCommitteeBranch.length > 0;\n    }\n\n    function hasNextSyncCommittee(LightClientUpdate memory update) private pure returns (bool) {\n        return\n            hasNextSyncCommitteeProof(update) &&\n            hasFinalityProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.finalizedHeader.beacon.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.beacon.slot);\n    }\n\n    function hasFinalityProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.finalityBranch.length > 0;\n    }\n\n    function hasSupermajority(uint64 participation) private pure returns (bool) {\n        return participation * 3 >= SYNC_COMMITTEE_SIZE * 2;\n    }\n\n    function currentSlot() private view returns (uint64) {\n        return uint64((block.timestamp - GENESIS_TIME) / SLOT_LENGTH_SECONDS);\n    }\n\n    function computeForkVersion(uint64 epoch) private view returns (bytes4) {\n        for (uint256 i = forkVersions.length - 1; i >= 0; i--) {\n            if (epoch >= forkEpochs[i]) {\n                return forkVersions[i];\n            }\n        }\n        revert(\"fork versions not set\");\n    }\n\n    function computeSyncCommitteePeriodAtSlot(uint64 slot) private pure returns (uint64) {\n        return computeSyncCommitteePeriod(computeEpochAtSlot(slot));\n    }\n\n    function computeEpochAtSlot(uint64 slot) private pure returns (uint64) {\n        return slot / SLOTS_PER_EPOCH;\n    }\n\n    function computeSyncCommitteePeriod(uint64 epoch) private pure returns (uint64) {\n        return epoch / EPOCHS_PER_SYNC_COMMITTEE_PERIOD;\n    }\n\n    /**\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_domain\n     */\n    function computeDomain(bytes4 forkVersion) public view returns (bytes32) {\n        return DOMAIN_SYNC_COMMITTEE | (sha256(abi.encode(forkVersion, GENESIS_VALIDATOR_ROOT)) >> 32);\n    }\n\n    // computeDomain(forkVersion, genesisValidatorsRoot)\n    function computeSigningRoot(BeaconBlockHeader memory header, bytes32 domain) public pure returns (bytes32) {\n        return sha256(bytes.concat(Helpers.hashTreeRoot(header), domain));\n    }\n}\n"
    },
    "contracts/light-client-eth/interfaces/IAnchorBlocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IAnchorBlocks {\n    function blocks(uint256 blockNum) external view returns (bytes32);\n}\n"
    },
    "contracts/light-client-eth/interfaces/IEthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../common/Types.sol\";\n\ninterface IEthereumLightClient {\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n\n    // reverts if check fails\n    function verifyCommitteeSignature(\n        uint64 signatureSlot,\n        BeaconBlockHeader memory header,\n        SyncAggregate memory syncAggregate\n    ) external view;\n}\n"
    },
    "contracts/light-client-eth/LightClientStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./common/Types.sol\";\nimport \"../verifiers/interfaces/IBeaconVerifier.sol\";\n\nabstract contract LightClientStore {\n    // beacon chain genesis information\n    uint256 immutable GENESIS_TIME;\n    bytes32 immutable GENESIS_VALIDATOR_ROOT;\n\n    uint64 public finalizedSlot;\n    bytes32 public finalizedExecutionStateRoot;\n\n    uint64 public optimisticSlot;\n    bytes32 public optimisticExecutionStateRoot;\n\n    bytes32 public currentSyncCommitteeRoot;\n    bytes32 public currentSyncCommitteePoseidonRoot;\n    bytes32 public nextSyncCommitteeRoot;\n    bytes32 public nextSyncCommitteePoseidonRoot;\n\n    LightClientUpdate public bestValidUpdate;\n\n    // fork versions\n    uint64[] public forkEpochs;\n    bytes4[] public forkVersions;\n\n    // zk verifier\n    IBeaconVerifier public zkVerifier; // contract too big. need to move this one out\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        uint64 _finalizedSlot,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    ) {\n        GENESIS_TIME = genesisTime;\n        GENESIS_VALIDATOR_ROOT = genesisValidatorsRoot;\n        forkEpochs = _forkEpochs;\n        forkVersions = _forkVersions;\n        finalizedSlot = _finalizedSlot;\n        currentSyncCommitteeRoot = syncCommitteeRoot;\n        currentSyncCommitteePoseidonRoot = syncCommitteePoseidonRoot;\n        zkVerifier = IBeaconVerifier(_zkVerifier);\n    }\n}\n"
    },
    "contracts/light-client-eth/SameChainAnchorBlock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IAnchorBlocks.sol\";\nimport \"../safeguard/Ownable.sol\";\n\ncontract SameChainAnchorBlocks is IAnchorBlocks, Ownable {\n    function blocks(uint256 blockNum) external view returns (bytes32) {\n        return blockhash(blockNum);\n    }\n}\n"
    },
    "contracts/safeguard/BrevisAccess.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"./Pauser.sol\";\n\n// prover and pauser access control using a single map lookup\nabstract contract BrevisAccess is Pauser {\n    enum ProverState {\n        Null,\n        Active,\n        Paused\n    }\n    mapping(address => ProverState) public proverStates;\n    address[] public provers;\n\n    event ProverAdded(address account);\n    event ProverRemoved(address account);\n\n    modifier onlyProver() {\n        require(proverStates[msg.sender] != ProverState.Null, \"invalid prover\");\n        _;\n    }\n\n    modifier onlyActiveProver() {\n        require(proverStates[msg.sender] == ProverState.Active, \"invalid prover\");\n        _;\n    }\n\n    function addProvers(address[] memory _accounts) public onlyOwner {\n        ProverState state = paused() ? ProverState.Paused : ProverState.Active;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addProver(_accounts[i], state);\n        }\n    }\n\n    function removeProvers(address[] memory _accounts) public onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _removeProver(_accounts[i]);\n        }\n    }\n\n    function pause() public override onlyPauser {\n        _pause();\n        for (uint256 i = 0; i < provers.length; i++) {\n            proverStates[provers[i]] = ProverState.Paused;\n        }\n    }\n\n    function unpause() public override onlyPauser {\n        _unpause();\n        for (uint256 i = 0; i < provers.length; i++) {\n            proverStates[provers[i]] = ProverState.Active;\n        }\n    }\n\n    function numProvers() public view returns (uint256) {\n        return provers.length;\n    }\n\n    function isActiveProver(address _account) public view returns (bool) {\n        return proverStates[_account] == ProverState.Active;\n    }\n\n    function _addProver(address _account, ProverState _state) private {\n        require(proverStates[_account] == ProverState.Null, \"account is prover\");\n        provers.push(_account);\n        proverStates[_account] = _state;\n        emit ProverAdded(_account);\n    }\n\n    function _removeProver(address _account) private {\n        require(proverStates[_account] != ProverState.Null, \"account is not prover\");\n        uint256 lastIndex = provers.length - 1;\n        for (uint256 i = 0; i < provers.length; i++) {\n            if (provers[i] == _account) {\n                if (i < lastIndex) {\n                    provers[i] = provers[lastIndex];\n                }\n                provers.pop();\n                delete proverStates[_account];\n                emit ProverRemoved(_account);\n                return;\n            }\n        }\n        revert(\"prover not found\"); // this should never happen\n    }\n}\n"
    },
    "contracts/safeguard/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\n * This adds a normal func that setOwner if _owner is address(0). So we can't allow\n * renounceOwnership. So we can support Proxy based upgradable contract\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Only to be called by inherit contracts, in their init func called by Proxy\n     * we require _owner == address(0), which is only possible when it's a delegateCall\n     * because constructor sets _owner in contract state.\n     */\n    function initOwner() internal {\n        require(_owner == address(0), \"owner already set\");\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/safeguard/Pauser.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./Ownable.sol\";\n\nabstract contract Pauser is Ownable, Pausable {\n    mapping(address => bool) public pausers;\n    address[] public pauserList;\n\n    event PauserAdded(address account);\n    event PauserRemoved(address account);\n\n    constructor() {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"Caller is not pauser\");\n        _;\n    }\n\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return pausers[account];\n    }\n\n    function addPauser(address account) public onlyOwner {\n        _addPauser(account);\n    }\n\n    function addPausers(address[] memory accounts) public onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _addPauser(accounts[i]);\n        }\n    }\n\n    function removePauser(address account) public onlyOwner {\n        _removePauser(account);\n    }\n\n    function removePausers(address[] memory accounts) public onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _removePauser(accounts[i]);\n        }\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function numPausers() public view returns (uint256) {\n        return pauserList.length;\n    }\n\n    function _addPauser(address account) private {\n        require(!isPauser(account), \"Account is already pauser\");\n        pauserList.push(account);\n        pausers[account] = true;\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) private {\n        require(isPauser(account), \"Account is not pauser\");\n        uint256 lastIndex = pauserList.length - 1;\n        for (uint256 i = 0; i < pauserList.length; i++) {\n            if (pauserList[i] == account) {\n                if (i < lastIndex) {\n                    pauserList[i] = pauserList[lastIndex];\n                }\n                pauserList.pop();\n                pausers[account] = false;\n                emit PauserRemoved(account);\n                return;\n            }\n        }\n        revert(\"pauser not found\"); // this should never happen\n    }\n}\n"
    },
    "contracts/safeguard/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"./Ownable.sol\";\n\nabstract contract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n    bool public whitelistEnabled;\n\n    event WhitelistedAdded(address account);\n    event WhitelistedRemoved(address account);\n\n    modifier onlyWhitelisted() {\n        if (whitelistEnabled) {\n            require(isWhitelisted(msg.sender), \"Caller is not whitelisted\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Set whitelistEnabled\n     */\n    function setWhitelistEnabled(bool _whitelistEnabled) external onlyOwner {\n        whitelistEnabled = _whitelistEnabled;\n    }\n\n    /**\n     * @notice Add an account to whitelist\n     */\n    function addWhitelisted(address account) external onlyOwner {\n        require(!isWhitelisted(account), \"Already whitelisted\");\n        whitelist[account] = true;\n        emit WhitelistedAdded(account);\n    }\n\n    /**\n     * @notice Remove an account from whitelist\n     */\n    function removeWhitelisted(address account) external onlyOwner {\n        require(isWhitelisted(account), \"Not whitelisted\");\n        whitelist[account] = false;\n        emit WhitelistedRemoved(account);\n    }\n\n    /**\n     * @return is account whitelisted\n     */\n    function isWhitelisted(address account) public view returns (bool) {\n        return whitelist[account];\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/dummy/MyBrevisApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../../safeguard/Ownable.sol\";\n\ncontract MyBrevisApp is BrevisApp, Ownable {\n    event ReceiveProofResult(bytes32 vkHash, bytes32 outputHash, bool zkAttested);\n\n    constructor(address _brevisRequest) BrevisApp(_brevisRequest) {}\n\n    function handleProofResult(bytes32 _vkHash, bytes calldata _appCircuitOutput) internal override {\n        emit ReceiveProofResult(_vkHash, keccak256(_appCircuitOutput), true);\n    }\n\n    function handleOpProofResult(bytes32 _vkHash, bytes calldata _appCircuitOutput) internal override {\n        emit ReceiveProofResult(_vkHash, keccak256(_appCircuitOutput), false);\n    }\n\n    function setBrevisOpConfig(uint64 _challengeWindow, uint8 _sigOption) external onlyOwner {\n        brevisOpConfig = BrevisOpConfig(_challengeWindow, _sigOption);\n    }\n\n    function setBrevisRequest(address _brevisRequest) external onlyOwner {\n        brevisRequest = _brevisRequest;\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/slot/SlotValueExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../../safeguard/Ownable.sol\";\n\ncontract SlotValueExample is BrevisApp, Ownable {\n    event PastOwnerAttested(address contractAddr, address ownerAddr, uint64 blockNum);\n\n    bytes32 public vkHash;\n\n    constructor(address _brevisRequest) BrevisApp(_brevisRequest) {}\n\n    // BrevisQuery contract will call our callback once Brevis backend submits the proof.\n    // This method is called with once the proof is verified.\n    function handleProofResult(bytes32 _vkHash, bytes calldata _circuitOutput) internal override {\n        // We need to check if the verifying key that Brevis used to verify the proof\n        // generated by our circuit is indeed our designated verifying key. This proves\n        // that the _circuitOutput is authentic\n        require(vkHash == _vkHash, \"invalid vk\");\n        (address contractAddr, address ownerAddr, uint64 blockNum) = decodeOutput(_circuitOutput);\n        emit PastOwnerAttested(contractAddr, ownerAddr, blockNum);\n    }\n\n    // In guest circuit we have:\n    // api.OutputAddress(s.Contract)\n    // api.OutputAddress(owner)\n    // api.OutputUint(64, s.BlockNum)\n    function decodeOutput(bytes calldata o) internal pure returns (address, address, uint64) {\n        address contractAddr = address(bytes20(o[0:20]));\n        address ownerAddr = address(bytes20(o[20:40]));\n        uint64 blockNum = uint64(bytes8(o[40:48]));\n        return (contractAddr, ownerAddr, blockNum);\n    }\n\n    function setVkHash(bytes32 _vkHash) external onlyOwner {\n        vkHash = _vkHash;\n    }\n}\n"
    },
    "contracts/sdk/apps/examples/uniswap-volume/UniswapVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../framework/BrevisApp.sol\";\nimport \"../../../../safeguard/Ownable.sol\";\n\ncontract UniswapVolume is BrevisApp, Ownable {\n    event SwapVolumeAttested(address user, uint64 sinceBlockNum, uint256 volume);\n\n    bytes32 public vkHash;\n\n    constructor(address _brevisRequest) BrevisApp(_brevisRequest) {}\n\n    // BrevisQuery contract will call our callback once Brevis backend submits the proof.\n    function handleProofResult(bytes32 _vkHash, bytes calldata _circuitOutput) internal override {\n        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed\n        // our designated verifying key. This proves that the _circuitOutput is authentic\n        require(vkHash == _vkHash, \"invalid vk\");\n\n        (uint256 sumVolume, uint64 minBlockNum, address userAddr) = decodeOutput(_circuitOutput);\n\n        emit SwapVolumeAttested(userAddr, minBlockNum, sumVolume);\n    }\n\n    // In guest circuit we have:\n    // api.OutputUint256(Salt)\n    // api.OutputUint(248, sumVolume)\n    // api.OutputUint(64, minBlockNum)\n    // api.OutputAddress(c.UserAddr)\n    function decodeOutput(bytes calldata o) internal pure returns (uint256, uint64, address) {\n        uint256 sumVolume = uint256(bytes32(o[32:63])); // sumVolume is packed as a uint248 but we cast it to uint256 here\n        uint64 minBlockNum = uint64(bytes8(o[63:71])); // minBlockNum is uint64 (8 bytes) field in the output\n        address userAddr = address(bytes20(o[71:91])); // c.UserAddr is an address (20 bytes) field in the output\n        return (sumVolume, minBlockNum, userAddr);\n    }\n\n    function setVkHash(bytes32 _vkHash) external onlyOwner {\n        vkHash = _vkHash;\n    }\n}\n"
    },
    "contracts/sdk/apps/framework/BrevisApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n// App that accepts both ZK- and OP-attested results.\nabstract contract BrevisApp {\n    address public brevisRequest;\n\n    struct BrevisOpConfig {\n        uint64 challengeWindow;\n        uint8 sigOption; // bitmap to express expected sigs: bit 0 is bvn, bit 1 is avs\n    }\n    // default: disable OP, require bvn sig\n    BrevisOpConfig public brevisOpConfig = BrevisOpConfig(2 ** 64 - 1, 0x01);\n\n    modifier onlyBrevisRequest() {\n        require(msg.sender == brevisRequest, \"invalid caller\");\n        _;\n    }\n\n    constructor(address _brevisRequest) {\n        brevisRequest = _brevisRequest;\n    }\n\n    function handleProofResult(bytes32 _vkHash, bytes calldata _appCircuitOutput) internal virtual {\n        // to be overrided by custom app\n    }\n\n    function handleOpProofResult(bytes32 _vkHash, bytes calldata _appCircuitOutput) internal virtual {\n        // to be overrided by custom app\n    }\n\n    function brevisCallback(bytes32 _appVkHash, bytes calldata _appCircuitOutput) external onlyBrevisRequest {\n        handleProofResult(_appVkHash, _appCircuitOutput);\n    }\n\n    function brevisBatchCallback(\n        bytes32[] calldata _appVkHashes,\n        bytes[] calldata _appCircuitOutputs\n    ) external onlyBrevisRequest {\n        for (uint i = 0; i < _appVkHashes.length; i++) {\n            handleProofResult(_appVkHashes[i], _appCircuitOutputs[i]);\n        }\n    }\n\n    function applyBrevisOpResult(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appVkHash,\n        bytes32 _appCommitHash,\n        bytes calldata _appCircuitOutput\n    ) public {\n        (uint256 challengeWindow, uint8 sigOption) = _getBrevisConfig();\n        require(\n            IBrevisRequest(brevisRequest).validateOpAppData(\n                _proofId,\n                _nonce,\n                _appCommitHash,\n                _appVkHash,\n                challengeWindow,\n                sigOption\n            ),\n            \"data not ready to use\"\n        );\n        require(_appCommitHash == keccak256(_appCircuitOutput), \"invalid circuit output\");\n        handleOpProofResult(_appVkHash, _appCircuitOutput);\n    }\n\n    function applyBrevisOpResults(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appVkHashes,\n        bytes32[] calldata _appCommitHashes,\n        bytes[] calldata _appCircuitOutputs\n    ) external {\n        (uint256 challengeWindow, uint8 sigOption) = _getBrevisConfig();\n        require(\n            IBrevisRequest(brevisRequest).validateOpAppData(\n                _proofIds,\n                _nonces,\n                _appCommitHashes,\n                _appVkHashes,\n                challengeWindow,\n                sigOption\n            ),\n            \"data not ready to use\"\n        );\n        for (uint256 i = 0; i < _proofIds.length; i++) {\n            require(_appCommitHashes[i] == keccak256(_appCircuitOutputs[i]), \"invalid circuit output\");\n            handleOpProofResult(_appVkHashes[i], _appCircuitOutputs[i]);\n        }\n    }\n\n    function _getBrevisConfig() private view returns (uint256, uint8) {\n        BrevisOpConfig memory config = brevisOpConfig;\n        return (uint256(config.challengeWindow), config.sigOption);\n    }\n}\n\ninterface IBrevisRequest {\n    function validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint256 _appChallengeWindow,\n        uint8 _option\n    ) external view returns (bool);\n\n    function validateOpAppData(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        uint256 _appChallengeWindow,\n        uint8 _option\n    ) external view returns (bool);\n}\n"
    },
    "contracts/sdk/apps/framework/BrevisAppZkOnly.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n// App that only accepts ZK-attested results.\nabstract contract BrevisAppZkOnly {\n    address public brevisRequest;\n\n    modifier onlyBrevisRequest() {\n        require(msg.sender == brevisRequest, \"invalid caller\");\n        _;\n    }\n\n    constructor(address _brevisRequest) {\n        brevisRequest = _brevisRequest;\n    }\n\n    function handleProofResult(bytes32 _vkHash, bytes calldata _appCircuitOutput) internal virtual {\n        // to be overrided by custom app\n    }\n\n    function brevisCallback(bytes32 _appVkHash, bytes calldata _appCircuitOutput) external onlyBrevisRequest {\n        handleProofResult(_appVkHash, _appCircuitOutput);\n    }\n\n    function brevisBatchCallback(\n        bytes32[] calldata _appVkHashes,\n        bytes[] calldata _appCircuitOutputs\n    ) external onlyBrevisRequest {\n        for (uint i = 0; i < _appVkHashes.length; i++) {\n            handleProofResult(_appVkHashes[i], _appCircuitOutputs[i]);\n        }\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisAggProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/Lib.sol\";\nimport \"../../interfaces/ISMT.sol\";\nimport \"../../verifiers/interfaces/IZkpVerifier.sol\";\nimport \"../../safeguard/BrevisAccess.sol\";\n\ncontract BrevisAggProof is BrevisAccess {\n    uint32 constant PUBLIC_BYTES_START_IDX = 12 * 32; // the first 12 32bytes are groth16 proof (A/B/C/Commitment/CommitmentPOK)\n    uint8 constant TREE_DEPTH = 4;\n    uint256 constant LEAF_NODES_LEN = 2 ** TREE_DEPTH;\n\n    ISMT public smtContract;\n\n    mapping(bytes32 => bool) public merkleRoots;\n    mapping(uint64 => IZkpVerifier) public aggProofVerifierAddress;\n    event SmtContractUpdated(address smtContract);\n    event AggProofVerifierAddressesUpdated(uint64[] chainIds, IZkpVerifier[] newAddresses);\n\n    constructor(ISMT _smtContract) {\n        smtContract = _smtContract;\n    }\n\n    /*********************************\n     * External and Public Functions *\n     *********************************/\n\n    function submitAggProof(\n        uint64 _chainId,\n        bytes32[] calldata _proofIds,\n        bytes calldata _proofWithPubInputs\n    ) external onlyActiveProver {\n        IZkpVerifier verifier = aggProofVerifierAddress[_chainId];\n        require(address(verifier) != address(0), \"chain agg proof verifier not set\");\n        require(verifier.verifyRaw(_proofWithPubInputs), \"proof not valid\");\n\n        (bytes32 root, bytes32 commitHash) = unpack(_proofWithPubInputs);\n\n        uint dataLen = _proofIds.length;\n        bytes32[LEAF_NODES_LEN] memory rIds;\n        for (uint i = 0; i < dataLen; i++) {\n            rIds[i] = _proofIds[i];\n        }\n        // note, to align with circuit, rIds[dataLen] to rIds[LEAF_NODES_LEN - 1] filled with last real one\n        if (dataLen < LEAF_NODES_LEN) {\n            for (uint i = dataLen; i < LEAF_NODES_LEN; i++) {\n                rIds[i] = rIds[dataLen - 1];\n            }\n        }\n        require(keccak256(abi.encodePacked(rIds)) == commitHash, \"proofIds not right\");\n        merkleRoots[root] = true;\n    }\n\n    // validate all leaf nodes in the agg proof data\n    function validateAggProofData(uint64 _chainId, Brevis.ProofData[] calldata _proofDataArray) external view {\n        uint dataLen = _proofDataArray.length;\n        require(dataLen <= LEAF_NODES_LEN, \"size exceeds\");\n        bytes32[2 * LEAF_NODES_LEN - 1] memory hashes;\n        for (uint i = 0; i < dataLen; i++) {\n            require(smtContract.isSmtRootValid(_chainId, _proofDataArray[i].smtRoot), \"invalid smt root\");\n            hashes[i] = keccak256(\n                abi.encodePacked(\n                    _proofDataArray[i].commitHash,\n                    _proofDataArray[i].smtRoot,\n                    _proofDataArray[i].vkHash,\n                    _proofDataArray[i].appCommitHash,\n                    _proofDataArray[i].appVkHash\n                )\n            );\n        }\n        // note, hashes[dataLen] to hashes[LEAF_NODES_LEN - 1] filled with last real one\n        if (dataLen < LEAF_NODES_LEN) {\n            for (uint i = dataLen; i < LEAF_NODES_LEN; i++) {\n                hashes[i] = hashes[dataLen - 1];\n            }\n        }\n\n        uint shift = 0;\n        uint counter = LEAF_NODES_LEN;\n        while (counter > 0) {\n            for (uint i = 0; i < counter - 1; i += 2) {\n                hashes[shift + counter + i / 2] = keccak256(abi.encodePacked(hashes[shift + i], hashes[shift + i + 1]));\n            }\n            shift += counter;\n            counter /= 2;\n        }\n\n        require(merkleRoots[hashes[hashes.length - 1]], \"merkle root not exists\");\n    }\n\n    // validate a single leaf node in the agg proof data\n    function validateAggProofData(\n        uint64 _chainId,\n        Brevis.ProofData calldata _proofData,\n        bytes32 _merkleRoot,\n        bytes32[] calldata _merkleProof,\n        uint8 _nodeIndex\n    ) external view {\n        require(merkleRoots[_merkleRoot], \"merkle root not exists\");\n        require(smtContract.isSmtRootValid(_chainId, _proofData.smtRoot), \"invalid smt root\");\n\n        bytes32 proofDataHash = keccak256(\n            abi.encodePacked(\n                _proofData.commitHash,\n                _proofData.smtRoot,\n                _proofData.vkHash,\n                _proofData.appCommitHash,\n                _proofData.appVkHash\n            )\n        );\n        bytes32 root = proofDataHash;\n        for (uint8 depth = 0; depth < TREE_DEPTH; depth++) {\n            if ((_nodeIndex >> depth) & 1 == 0) {\n                root = keccak256(abi.encodePacked(root, _merkleProof[depth]));\n            } else {\n                root = keccak256(abi.encodePacked(_merkleProof[depth], root));\n            }\n        }\n        require(_merkleRoot == root, \"invalid data\");\n    }\n\n    // -------- owner functions --------\n\n    function updateSmtContract(ISMT _smtContract) public onlyOwner {\n        smtContract = _smtContract;\n        emit SmtContractUpdated(address(smtContract));\n    }\n\n    function updateAggProofVerifierAddresses(\n        uint64[] calldata _chainIds,\n        IZkpVerifier[] calldata _verifierAddresses\n    ) public onlyOwner {\n        require(_chainIds.length == _verifierAddresses.length, \"length not match\");\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            aggProofVerifierAddress[_chainIds[i]] = _verifierAddresses[i];\n        }\n        emit AggProofVerifierAddressesUpdated(_chainIds, _verifierAddresses);\n    }\n\n    /**********************************\n     * Internal and Private Functions *\n     **********************************/\n\n    function unpack(bytes calldata _proofWithPubInputs) internal pure returns (bytes32 merkleRoot, bytes32 commitHash) {\n        merkleRoot = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32]);\n        commitHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 32:PUBLIC_BYTES_START_IDX + 2 * 32]);\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisDispute.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./BrevisRequest.sol\";\nimport \"../interface/IBrevisDispute.sol\";\n\n// TODO: handle dispute fee\ncontract BrevisDispute is IBrevisDispute {\n    BrevisRequest immutable brevisRequest;\n\n    uint256 public challengeWindow;\n    uint256 public responseTimeout;\n    uint256 public depositAskForData;\n    uint256 public depositAskForProof;\n\n    mapping(bytes32 => Dispute) public disputes; // requestKey => Dispute\n\n    modifier onlyActiveProver() {\n        require(brevisRequest.isActiveProver(msg.sender), \"invalid prover\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(brevisRequest.owner() == msg.sender, \"invalid prover\");\n        _;\n    }\n\n    constructor(BrevisRequest _brevisRequest) {\n        brevisRequest = _brevisRequest;\n    }\n\n    function askForRequestData(bytes32 _proofId, uint64 _nonce) external payable {\n        require(msg.value > depositAskForData, \"insufficient deposit\");\n\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, uint64 timestamp, ) = brevisRequest.requests(requestKey);\n        require(status == RequestStatus.OpSubmitted, \"not in a disputable status\");\n        require(timestamp + challengeWindow > block.timestamp, \"pass challenge window\");\n        brevisRequest.setRequestStatus(requestKey, RequestStatus.OpDisputing);\n\n        Dispute storage dispute = disputes[requestKey];\n        dispute.status = DisputeStatus.WaitingForRequestData;\n        dispute.responseDeadline = block.timestamp + responseTimeout;\n        dispute.challenger = msg.sender;\n        dispute.deposit = msg.value;\n\n        emit AskFor(_proofId, _nonce, DisputeStatus.WaitingForRequestData, msg.sender);\n    }\n\n    function postRequestData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes[] calldata _data,\n        uint256 _index,\n        bool _done\n    ) external onlyActiveProver {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, , ) = brevisRequest.requests(requestKey);\n        require(status == RequestStatus.OpDisputing, \"invalid request status\");\n\n        Dispute storage dispute = disputes[requestKey];\n        require(dispute.status == DisputeStatus.WaitingForRequestData, \"invalid dispute status\");\n        RequestDataHash storage dataHash = dispute.requestDataHash;\n        require(dataHash.hashes.length == _index, \"invalid index\");\n        for (uint i = 0; i < _data.length; i++) {\n            dataHash.hashes.push(keccak256(_data[i]));\n        }\n        if (_done) {\n            dataHash.root = keccak256(abi.encodePacked(dataHash.hashes)); // todo: consider merkle\n            disputes[requestKey].status = DisputeStatus.RequestDataPosted;\n        }\n        emit RequestDataPosted(_proofId, _nonce, _data, _index, _done);\n    }\n\n    function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) external payable {\n        require(msg.value > depositAskForProof, \"insufficient deposit\");\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, uint64 timestamp, ) = brevisRequest.requests(requestKey);\n        require(timestamp + challengeWindow > block.timestamp, \"pass challenge window\");\n        brevisRequest.setRequestStatus(requestKey, RequestStatus.OpDisputing);\n\n        Dispute storage dispute = disputes[requestKey];\n        require(\n            status == RequestStatus.OpDisputing && dispute.status == DisputeStatus.RequestDataPosted,\n            \"invalid states\"\n        );\n\n        dispute.status = DisputeStatus.WaitingForDataAvailabilityProof;\n        dispute.responseDeadline = block.timestamp + responseTimeout;\n        dispute.challenger = msg.sender;\n        dispute.deposit = msg.value;\n\n        emit AskFor(_proofId, _nonce, DisputeStatus.WaitingForDataAvailabilityProof, msg.sender);\n    }\n\n    function postDataAvailabilityProof(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes calldata // proof\n    ) external onlyActiveProver {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, , ) = brevisRequest.requests(requestKey);\n        Dispute storage dispute = disputes[requestKey];\n        require(\n            status == RequestStatus.OpDisputing && dispute.status == DisputeStatus.WaitingForDataAvailabilityProof,\n            \"invalid states\"\n        );\n        disputes[requestKey].status = DisputeStatus.DataAvailabilityProofPosted;\n        // todo: validate proof\n\n        emit DataAvailabilityProofPosted(_proofId, _nonce);\n    }\n\n    function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) external payable {\n        require(msg.value > depositAskForProof, \"insufficient deposit\");\n\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, uint64 timestamp, ) = brevisRequest.requests(requestKey);\n        require(timestamp + challengeWindow > block.timestamp, \"pass challenge window\");\n        brevisRequest.setRequestStatus(requestKey, RequestStatus.OpDisputing);\n\n        Dispute storage dispute = disputes[requestKey];\n        require(\n            status == RequestStatus.OpSubmitted ||\n                (status == RequestStatus.OpDisputing && dispute.status != DisputeStatus.WaitingForDataValidityProof),\n            \"invalid states\"\n        );\n\n        dispute.status = DisputeStatus.WaitingForDataValidityProof;\n        dispute.responseDeadline = block.timestamp + responseTimeout;\n        dispute.challenger = msg.sender;\n        dispute.deposit = msg.value;\n\n        emit AskFor(_proofId, _nonce, DisputeStatus.WaitingForDataValidityProof, msg.sender);\n    }\n\n    function postDataValidityProof(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _chainId,\n        bytes calldata _proof\n    ) external onlyActiveProver {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, , ) = brevisRequest.requests(requestKey);\n        Dispute storage dispute = disputes[requestKey];\n        require(\n            status == RequestStatus.OpDisputing && dispute.status == DisputeStatus.WaitingForDataValidityProof,\n            \"invalid states\"\n        );\n\n        (bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash) = brevisRequest.brevisProof().submitProof(\n            _chainId,\n            _proof\n        );\n        require(_proofId == proofId, \"invalid proof: proofId\");\n        require(\n            brevisRequest.opdata(requestKey) == keccak256(abi.encodePacked(appCommitHash, appVkHash)),\n            \"invalid proof: appHash\"\n        );\n        brevisRequest.setRequestStatus(requestKey, RequestStatus.ZkAttested);\n        dispute.status = DisputeStatus.DataValidityProofPosted;\n\n        emit DataValidityProofProofPosted(_proofId, _nonce);\n    }\n\n    function getChallengeWindow() external view returns (uint256) {\n        return challengeWindow;\n    }\n\n    function getDisputeStatus(bytes32 _requestKey) external view returns (DisputeStatus) {\n        return disputes[_requestKey].status;\n    }\n\n    function getResponseDeadline(bytes32 _requestKey) external view returns (uint256) {\n        return disputes[_requestKey].responseDeadline;\n    }\n\n    // --------------------- owner functions ---------------------\n\n    function setChallengeWindow(uint256 _challengeWindow) external onlyOwner {\n        uint256 oldChallengeWindow = challengeWindow;\n        challengeWindow = _challengeWindow;\n        emit ChallengeWindowUpdated(oldChallengeWindow, _challengeWindow);\n    }\n\n    function setResponseTimeout(uint256 _responseTimeout) external onlyOwner {\n        uint256 oldResponseTimeout = responseTimeout;\n        responseTimeout = _responseTimeout;\n        emit ResponseTimeoutUpdated(oldResponseTimeout, _responseTimeout);\n    }\n\n    function setDisputeDeposits(uint256 _amtAskForData, uint256 _amtAskForProof) external onlyOwner {\n        depositAskForData = _amtAskForData;\n        depositAskForProof = _amtAskForProof;\n        emit DisputeDepositsUpdated(_amtAskForData, _amtAskForProof);\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./BrevisAggProof.sol\";\nimport \"../lib/Lib.sol\";\nimport \"../../interfaces/ISMT.sol\";\nimport \"../../verifiers/interfaces/IZkpVerifier.sol\";\n\ncontract BrevisProof is BrevisAggProof {\n    mapping(uint64 => IZkpVerifier) public verifierAddresses; // chainid => snark verifier contract address\n    mapping(bytes32 => bytes32) public proofs; // proofId => keccak256(abi.encodePacked(appCommitHash, appVkHash));\n    event VerifierAddressesUpdated(uint64[] chainIds, IZkpVerifier[] newAddresses);\n\n    constructor(ISMT _smtContract) BrevisAggProof(_smtContract) {}\n\n    // To support upgradable deployment.\n    // Can only be called once by Proxy via delegateCall, as initOwner will require _owner is 0.\n    function init(ISMT _smtContract) external {\n        initOwner();\n        smtContract = _smtContract;\n    }\n\n    /*********************************\n     * External and Public Functions *\n     *********************************/\n\n    function submitProof(\n        uint64 _chainId,\n        bytes calldata _proofWithPubInputs\n    ) external onlyActiveProver returns (bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash) {\n        require(verifyRaw(_chainId, _proofWithPubInputs), \"proof not valid\");\n        Brevis.ProofData memory data = unpackProofData(_proofWithPubInputs);\n\n        proofId = data.commitHash;\n        appCommitHash = data.appCommitHash;\n        appVkHash = data.appVkHash;\n        require(smtContract.isSmtRootValid(_chainId, data.smtRoot), \"smt root not valid\");\n        proofs[proofId] = keccak256(abi.encodePacked(appCommitHash, appVkHash));\n    }\n\n    function validateProofAppData(\n        bytes32 _proofId,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash\n    ) external view returns (bool) {\n        require(proofs[_proofId] == keccak256(abi.encodePacked(_appCommitHash, _appVkHash)), \"invalid data\");\n        return true;\n    }\n\n    // -------- owner functions --------\n\n    function updateVerifierAddress(\n        uint64[] calldata _chainIds,\n        IZkpVerifier[] calldata _verifierAddresses\n    ) public onlyOwner {\n        require(_chainIds.length == _verifierAddresses.length, \"length not match\");\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            verifierAddresses[_chainIds[i]] = _verifierAddresses[i];\n        }\n        emit VerifierAddressesUpdated(_chainIds, _verifierAddresses);\n    }\n\n    /**********************************\n     * Internal and Private Functions *\n     **********************************/\n\n    function unpackProofData(bytes calldata _proofWithPubInputs) internal pure returns (Brevis.ProofData memory data) {\n        data.commitHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32]);\n        data.smtRoot = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 32:PUBLIC_BYTES_START_IDX + 2 * 32]);\n        //data.vkHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32]);\n        data.appCommitHash = bytes32(\n            _proofWithPubInputs[PUBLIC_BYTES_START_IDX + 3 * 32:PUBLIC_BYTES_START_IDX + 4 * 32]\n        );\n        data.appVkHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 4 * 32:PUBLIC_BYTES_START_IDX + 5 * 32]);\n    }\n\n    function verifyRaw(uint64 _chainId, bytes calldata _proofWithPubInputs) private view returns (bool) {\n        IZkpVerifier verifier = verifierAddresses[_chainId];\n        require(address(verifier) != address(0), \"chain verifier not set\");\n        return verifier.verifyRaw(_proofWithPubInputs);\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./FeeVault.sol\";\nimport \"../interface/IBrevisRequest.sol\";\nimport \"../interface/IBrevisProof.sol\";\nimport \"../interface/IBrevisDispute.sol\";\nimport \"../interface/IBrevisApp.sol\";\nimport \"../lib/Lib.sol\";\nimport \"../../safeguard/BrevisAccess.sol\";\nimport \"../../interfaces/ISigsVerifier.sol\";\nimport \"../../lib/Utils.sol\";\n\ncontract BrevisRequest is IBrevisRequest, FeeVault, BrevisAccess {\n    // common workflow\n    IBrevisProof public brevisProof;\n    uint256 public requestTimeout;\n    mapping(bytes32 => Request) public requests; // requestKey => Request;\n    mapping(bytes32 => OnchainRequestInfo) public onchainRequests; // requestKey => OnchainRequestInfo\n\n    // optimistic workflow\n    IBvnSigsVerifier public bvnSigsVerifier;\n    IAvsSigsVerifier public avsSigsVerifier;\n    IBrevisDispute public brevisDispute;\n    string public baseDataURL;\n    mapping(bytes32 => bytes32) public opdata; // requestKey => keccak256(abi.encodePacked(appCommitHash, appVkHash))\n\n    uint8 constant OPT_IDX_SIG_BVN = 0;\n    uint8 constant OPT_IDX_SIG_AVS = 1;\n\n    constructor(\n        address _feeCollector,\n        IBrevisProof _brevisProof,\n        IBvnSigsVerifier _bvnSigsVerifier\n    ) FeeVault(_feeCollector) {\n        brevisProof = _brevisProof;\n        bvnSigsVerifier = _bvnSigsVerifier;\n    }\n\n    // To support upgradable deployment.\n    // Can only be called once by Proxy via delegateCall, as initOwner will require _owner is 0.\n    function init(\n        address _feeCollector,\n        IBrevisProof _brevisProof,\n        IBvnSigsVerifier _bvnSigsVerifier,\n        uint256 _requestTimeout\n    ) external {\n        initOwner();\n        feeCollector = _feeCollector;\n        brevisProof = _brevisProof;\n        bvnSigsVerifier = _bvnSigsVerifier;\n        requestTimeout = _requestTimeout;\n    }\n\n    /*********************************\n     * External and Public Functions *\n     *********************************/\n\n    function sendRequest(\n        bytes32 _proofId,\n        uint64 _nonce,\n        address _refundee,\n        Callback calldata _callback,\n        uint8 _option // bitmap 0: zk, 1: op bvn, 2: op avs, 3: op bvn and avs\n    ) external payable {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        RequestStatus status = requests[requestKey].status;\n        require(status == RequestStatus.Null, \"invalid status\");\n        _option = _option & 0x03; // binary 00000011\n        if (_option == 0) {\n            status == RequestStatus.ZkPending;\n        } else {\n            status = RequestStatus.OpPending;\n        }\n        requests[requestKey] = Request(status, uint64(block.timestamp), _option);\n\n        if (_refundee == address(0)) {\n            _refundee = msg.sender;\n        }\n        bytes32 feeHash = keccak256(abi.encodePacked(msg.value, _refundee));\n        onchainRequests[requestKey] = OnchainRequestInfo(feeHash, _callback);\n\n        emit RequestSent(_proofId, _nonce, _refundee, msg.value, _callback, _option);\n    }\n\n    function fulfillRequest(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _chainId,\n        bytes calldata _proof,\n        bytes calldata _appCircuitOutput,\n        address _callbackTarget\n    ) external onlyActiveProver {\n        (bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash) = brevisProof.submitProof(_chainId, _proof);\n        require(_proofId == proofId, \"invalid proofId\");\n\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        Request storage request = requests[requestKey];\n        RequestStatus status = request.status;\n        require(status == RequestStatus.ZkPending || status == RequestStatus.Null, \"invalid status\");\n        request.status = RequestStatus.ZkAttested;\n\n        if (_appCircuitOutput.length > 0) {\n            require(appCommitHash == keccak256(_appCircuitOutput), \"invalid circuit output\");\n        }\n        bool success = _brevisCallback(_callbackTarget, appVkHash, _appCircuitOutput, requestKey, status);\n        if (!success) {\n            emit RequestCallbackFailed(_proofId, _nonce);\n        }\n        emit RequestFulfilled(_proofId, _nonce);\n    }\n\n    // fulfill batch requests with aggProof\n    function fulfillRequests(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        uint64 _chainId,\n        bytes calldata _proof,\n        Brevis.ProofData[] calldata _proofDataArray,\n        bytes[] calldata _appCircuitOutputs,\n        address[] calldata _callbackTargets\n    ) external onlyActiveProver {\n        uint256 dataNum = _proofIds.length;\n        brevisProof.submitAggProof(_chainId, _proofIds, _proof);\n        brevisProof.validateAggProofData(_chainId, _proofDataArray);\n        require(_callbackTargets.length == 1 || _callbackTargets.length == dataNum, \"invalid callback length\");\n\n        uint256 numFulfilled;\n        for (uint256 i = 0; i < dataNum; i++) {\n            require(_proofDataArray[i].commitHash == _proofIds[i], \"invalid proofId\");\n            require(_proofDataArray[i].appCommitHash == keccak256(_appCircuitOutputs[i]), \"invalid circuit output\");\n\n            bytes32 requestKey = keccak256(abi.encodePacked(_proofIds[i], _nonces[i]));\n            Request storage request = requests[requestKey];\n            RequestStatus status = request.status;\n            if (status == RequestStatus.ZkPending || status == RequestStatus.Null) {\n                request.status = RequestStatus.ZkAttested;\n                numFulfilled++;\n                if (_callbackTargets.length > 1) {\n                    bool success = _brevisCallback(\n                        _callbackTargets[i],\n                        _proofDataArray[i].appVkHash,\n                        _appCircuitOutputs[i],\n                        requestKey,\n                        status\n                    );\n                    if (!success) {\n                        emit RequestCallbackFailed(_proofIds[i], _nonces[i]);\n                    }\n                } else if (status == RequestStatus.ZkPending) {\n                    Callback memory callback = onchainRequests[requestKey].callback;\n                    require(callback.target == _callbackTargets[0], \"callback mismatch\");\n                    require(callback.gas == 0, \"invalid gas for batch callback\");\n                }\n            }\n        }\n        require(numFulfilled > 0, \"no fulfilled requests\");\n        if (_callbackTargets.length == 1) {\n            bytes32[] memory appVkHashes = new bytes32[](_proofDataArray.length);\n            for (uint256 i = 0; i < appVkHashes.length; i++) {\n                appVkHashes[i] = _proofDataArray[i].appVkHash;\n            }\n            // If the call failed due any reason, anyone can trigger retry later by calling applyBrevisAggProof.\n            (bool success, ) = _callbackTargets[0].call(\n                abi.encodeWithSelector(IBrevisApp.brevisBatchCallback.selector, appVkHashes, _appCircuitOutputs)\n            );\n            if (!success) {\n                emit RequestsCallbackFailed(_proofIds, _nonces);\n            }\n        }\n        emit RequestsFulfilled(_proofIds, _nonces);\n    }\n\n    function increaseGasFee(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _addGas,\n        uint256 _currentFee,\n        address _refundee\n    ) external payable {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        RequestStatus status = requests[requestKey].status;\n        require(status == RequestStatus.ZkPending || status == RequestStatus.OpPending, \"invalid status\");\n\n        OnchainRequestInfo storage info = onchainRequests[requestKey];\n        require(info.feeHash == keccak256(abi.encodePacked(_currentFee, _refundee)), \"invalid input\");\n        uint256 newFee = _currentFee + msg.value;\n        info.feeHash == keccak256(abi.encodePacked(newFee, _refundee));\n        if (_addGas > 0) {\n            info.callback.gas += _addGas;\n        }\n        emit RequestFeeIncreased(_proofId, _nonce, info.callback.gas, newFee);\n    }\n\n    function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) external {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        Request memory request = requests[requestKey];\n        RequestStatus status = request.status;\n        require(status == RequestStatus.ZkPending || status == RequestStatus.OpPending, \"invalid status\");\n        require(block.timestamp > request.timestamp + requestTimeout);\n\n        bytes32 feeHash = onchainRequests[requestKey].feeHash;\n        require(feeHash == keccak256(abi.encodePacked(_amount, _refundee)), \"invalid input\");\n        (bool sent, ) = _refundee.call{value: _amount, gas: 50000}(\"\");\n        require(sent, \"send native failed\");\n        requests[requestKey].status = RequestStatus.Refunded;\n        emit RequestRefunded(_proofId, _nonce);\n    }\n\n    // --------------------- optimistic workflow functions ---------------------\n\n    function fulfillOpRequests(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        IBvnSigsVerifier.SigInfo calldata _bvnSigInfo,\n        IAvsSigsVerifier.SigInfo calldata _avsSigInfo\n    ) external onlyActiveProver {\n        uint8 option = 0;\n        require(_bvnSigInfo.sigs.length > 0 || _avsSigInfo.blockNum > 0, \"empty sigs\");\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"FulfillRequests\"));\n        bytes32 signedHash = keccak256(abi.encodePacked(domain, _proofIds, _nonces, _appCommitHashes, _appVkHashes));\n        if (_bvnSigInfo.sigs.length > 0) {\n            bvnSigsVerifier.verifySigs(signedHash, _bvnSigInfo.sigs, _bvnSigInfo.signers, _bvnSigInfo.powers);\n            option = _bitSet(option, OPT_IDX_SIG_BVN);\n        }\n        if (_avsSigInfo.blockNum > 0) {\n            avsSigsVerifier.verifySigs(signedHash, _avsSigInfo.blockNum, _avsSigInfo.params);\n            option = _bitSet(option, OPT_IDX_SIG_AVS);\n        }\n        _submitOpStates(_proofIds, _nonces, _appCommitHashes, _appVkHashes, option); // to avoid \"stack too deep\"\n        emit OpRequestsFulfilled(_proofIds, _nonces, _appCommitHashes, _appVkHashes);\n    }\n\n    function setRequestStatus(bytes32 requestKey, RequestStatus _status) external {\n        require(msg.sender == address(brevisDispute), \"invalid setter\");\n        requests[requestKey].status = _status;\n    }\n\n    // --------------------- app helper functions ---------------------\n\n    // apply proved data to a target contract\n    function applyBrevisProof(\n        bytes32 _proofId,\n        bytes32 _appVkHash,\n        bytes32 _appCommitHash,\n        bytes calldata _appCircuitOutput,\n        address _callbackTarget\n    ) external {\n        brevisProof.validateProofAppData(_proofId, _appCommitHash, _appVkHash);\n        require(_appCommitHash == keccak256(_appCircuitOutput), \"invalid circuit output\");\n        IBrevisApp(_callbackTarget).brevisCallback(_appVkHash, _appCircuitOutput);\n    }\n\n    // apply multiple proved data fulfilled through AggProof to a target contract\n    function applyBrevisAggProof(\n        uint64 _chainId,\n        Brevis.ProofData[] calldata _proofDataArray,\n        bytes[] calldata _appCircuitOutputs,\n        address[] calldata _callbackTargets\n    ) external {\n        uint256 dataNum = _proofDataArray.length;\n        brevisProof.validateAggProofData(_chainId, _proofDataArray);\n        for (uint256 i = 0; i < dataNum; i++) {\n            if (_callbackTargets[i] != address(0)) {\n                require(_proofDataArray[i].appCommitHash == keccak256(_appCircuitOutputs[i]), \"invalid circuit output\");\n                (bool success, bytes memory res) = _callbackTargets[i].call(\n                    abi.encodeWithSelector(\n                        IBrevisApp.brevisCallback.selector,\n                        _proofDataArray[i].appVkHash,\n                        _appCircuitOutputs[i]\n                    )\n                );\n                require(success, string.concat(Strings.toString(i), \":\", Utils.getRevertMsg(res)));\n            }\n        }\n    }\n\n    // apply single proved data fulfilled through AggProof to a target contract\n    function applyBrevisAggProof(\n        uint64 _chainId,\n        Brevis.ProofData calldata _proofData,\n        bytes32 _merkleRoot,\n        bytes32[] calldata _merkleProof,\n        uint8 _nodeIndex,\n        bytes calldata _appCircuitOutput,\n        address _callbackTarget\n    ) external {\n        brevisProof.validateAggProofData(_chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex);\n        require(_proofData.appCommitHash == keccak256(_appCircuitOutput), \"invalid circuit output\");\n        IBrevisApp(_callbackTarget).brevisCallback(_proofData.appVkHash, _appCircuitOutput);\n    }\n\n    // --------------------- owner functions ---------------------\n\n    function setRequestTimeout(uint256 _timeout) external onlyOwner {\n        uint256 oldTimeout = requestTimeout;\n        requestTimeout = _timeout;\n        emit RequestTimeoutUpdated(oldTimeout, _timeout);\n    }\n\n    function setBaseDataURL(string memory _url) external onlyOwner {\n        string memory oldURL = baseDataURL;\n        baseDataURL = _url;\n        emit BaseDataUrlUpdated(oldURL, _url);\n    }\n\n    function setBrevisProof(address _brevisProof) external onlyOwner {\n        address oldAddr = address(brevisProof);\n        brevisProof = IBrevisProof(_brevisProof);\n        emit BrevisProofUpdated(oldAddr, _brevisProof);\n    }\n\n    function setBrevisDispute(address _brevisDispute) external onlyOwner {\n        address oldAddr = address(brevisDispute);\n        brevisDispute = IBrevisDispute(_brevisDispute);\n        emit BrevisDisputeUpdated(oldAddr, _brevisDispute);\n    }\n\n    function setBvnSigsVerifier(address _bvnSigsVerifier) external onlyOwner {\n        address oldAddr = address(bvnSigsVerifier);\n        bvnSigsVerifier = IBvnSigsVerifier(_bvnSigsVerifier);\n        emit BvnSigsVerifierUpdated(oldAddr, _bvnSigsVerifier);\n    }\n\n    function setAvsSigsVerifier(address _avsSigsVerifier) external onlyOwner {\n        address oldAddr = address(avsSigsVerifier);\n        avsSigsVerifier = IAvsSigsVerifier(_avsSigsVerifier);\n        emit BvnSigsVerifierUpdated(oldAddr, _avsSigsVerifier);\n    }\n\n    // --------------------- view functions ---------------------\n\n    function queryRequestStatus(bytes32 _proofId, uint64 _nonce) external view returns (RequestStatus, uint8) {\n        return _queryRequestStatus(keccak256(abi.encodePacked(_proofId, _nonce)), brevisDispute.getChallengeWindow());\n    }\n\n    function queryRequestStatus(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint256 _challengeWindow\n    ) external view returns (RequestStatus, uint8) {\n        return _queryRequestStatus(keccak256(abi.encodePacked(_proofId, _nonce)), _challengeWindow);\n    }\n\n    function validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint8 _option\n    ) external view returns (bool) {\n        uint256 challengeWindow = brevisDispute.getChallengeWindow();\n        return _validateOpAppData(_proofId, _nonce, _appCommitHash, _appVkHash, challengeWindow, _option);\n    }\n\n    function validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint256 _challengeWindow,\n        uint8 _option\n    ) external view returns (bool) {\n        return _validateOpAppData(_proofId, _nonce, _appCommitHash, _appVkHash, _challengeWindow, _option);\n    }\n\n    function validateOpAppData(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        uint256 _challengeWindow,\n        uint8 _option\n    ) external view returns (bool) {\n        for (uint256 i = 0; i < _proofIds.length; i++) {\n            if (\n                !_validateOpAppData(\n                    _proofIds[i],\n                    _nonces[i],\n                    _appCommitHashes[i],\n                    _appVkHashes[i],\n                    _challengeWindow,\n                    _option\n                )\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function dataURL(bytes32 _proofId) external view returns (string memory) {\n        if (bytes(baseDataURL).length == 0) {\n            return \"\";\n        }\n        return string.concat(baseDataURL, Strings.toHexString(uint256(_proofId), 32));\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    function _brevisCallback(\n        address _callbackTarget,\n        bytes32 _appVkHash,\n        bytes calldata _appCircuitOutput,\n        bytes32 _requestKey,\n        RequestStatus _status\n    ) private returns (bool) {\n        uint256 gas;\n        if (_status == RequestStatus.ZkPending /* is onchain request*/) {\n            Callback memory callback = onchainRequests[_requestKey].callback;\n            require(callback.target == _callbackTarget, \"callback mismatch\");\n            gas = callback.gas;\n        }\n        if (_callbackTarget != address(0)) {\n            if (gas == 0) {\n                gas = gasleft();\n            }\n            // If the call failed due any reason, anyone can trigger retry later by calling applyBrevisProof.\n            (bool success, ) = _callbackTarget.call{gas: gas}(\n                abi.encodeWithSelector(IBrevisApp.brevisCallback.selector, _appVkHash, _appCircuitOutput)\n            );\n            if (!success) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _submitOpStates(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        uint8 option\n    ) private {\n        uint64 timestamp = uint64(block.timestamp);\n        for (uint i = 0; i < _proofIds.length; i++) {\n            bytes32 requestKey = keccak256(abi.encodePacked(_proofIds[i], _nonces[i]));\n            Request memory request = requests[requestKey];\n            if (request.status == RequestStatus.OpPending) {\n                require(request.option == option, \"insufficient types of sigs\");\n            } else {\n                require(request.status == RequestStatus.Null, \"invalid status\");\n            }\n            requests[requestKey] = Request(RequestStatus.OpSubmitted, timestamp, option);\n            opdata[requestKey] = keccak256(abi.encodePacked(_appCommitHashes[i], _appVkHashes[i]));\n        }\n    }\n\n    function _queryRequestStatus(\n        bytes32 _requestKey, // keccak256(abi.encodePacked(_proofId, _nonce))\n        uint256 _challengeWindow\n    ) private view returns (RequestStatus, uint8) {\n        Request memory request = requests[_requestKey];\n        if (request.status == RequestStatus.OpSubmitted) {\n            if (request.timestamp + _challengeWindow < block.timestamp) {\n                return (RequestStatus.OpAttested, request.option);\n            }\n        } else if (request.status == RequestStatus.OpDisputing) {\n            DisputeStatus dstatus = brevisDispute.getDisputeStatus(_requestKey);\n            if (dstatus == DisputeStatus.RequestDataPosted || dstatus == DisputeStatus.DataAvailabilityProofPosted) {\n                if (request.timestamp + _challengeWindow < block.timestamp) {\n                    return (RequestStatus.OpAttested, request.option);\n                }\n            } else if (brevisDispute.getResponseDeadline(_requestKey) < block.timestamp) {\n                // did not respond in time for WaitingForXXX\n                return (RequestStatus.OpDisputed, request.option);\n            }\n        }\n        return (request.status, request.option);\n    }\n\n    function _validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint256 _challengeWindow,\n        uint8 _option\n    ) private view returns (bool readyToUse) {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        require(opdata[requestKey] == keccak256(abi.encodePacked(_appCommitHash, _appVkHash)), \"invalid data\");\n        (RequestStatus status, uint8 option) = _queryRequestStatus(requestKey, _challengeWindow);\n        if (status == RequestStatus.OpAttested) {\n            return (_option & option) == _option;\n        } else if (status == RequestStatus.ZkAttested) {\n            return true;\n        }\n        return false;\n    }\n\n    function _bitSet(uint8 _value, uint8 _index) private pure returns (uint8) {\n        uint8 mask = uint8(1 << _index);\n        return _value | mask;\n    }\n}\n"
    },
    "contracts/sdk/core/FeeVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.18;\n\nimport \"../../safeguard/Ownable.sol\";\n\n/**\n * @title Allows the owner to set fee collector and allows fee collectors to collect fees\n */\ncontract FeeVault is Ownable {\n    address public feeCollector;\n\n    event FeeCollected(uint256 amount, address receiver);\n    event FeeCollectorUpdated(address from, address to);\n\n    constructor(address _feeCollector) {\n        feeCollector = _feeCollector;\n    }\n\n    modifier onlyFeeCollector() {\n        require(msg.sender == feeCollector, \"not fee collector\");\n        _;\n    }\n\n    function collectFee(uint256 _amount, address _to) external onlyFeeCollector {\n        (bool sent, ) = _to.call{value: _amount, gas: 50000}(\"\");\n        require(sent, \"send native failed\");\n        emit FeeCollected(_amount, _to);\n    }\n\n    function setFeeCollector(address _feeCollector) external onlyOwner {\n        address oldFeeCollector = feeCollector;\n        feeCollector = _feeCollector;\n        emit FeeCollectorUpdated(oldFeeCollector, _feeCollector);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/sdk/interface/IBrevisApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IBrevisApp {\n    function brevisCallback(bytes32 _appVkHash, bytes calldata _appCircuitOutput) external;\n\n    function brevisBatchCallback(bytes32[] calldata _appVkHashs, bytes[] calldata _appCircuitOutputs) external;\n}\n"
    },
    "contracts/sdk/interface/IBrevisDispute.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./IBrevisTypes.sol\";\n\ninterface IBrevisDispute is IBrevisTypes {\n    event AskFor(bytes32 indexed proofId, uint64 nonce, DisputeStatus status, address from);\n    event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done);\n    event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce);\n    event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce);\n\n    event ChallengeWindowUpdated(uint256 from, uint256 to);\n    event ResponseTimeoutUpdated(uint256 from, uint256 to);\n    event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof);\n\n    function askForRequestData(bytes32 _proofId, uint64 _nonce) external payable;\n\n    function postRequestData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes[] calldata _requestData,\n        uint256 _index,\n        bool _done\n    ) external;\n\n    function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) external payable;\n\n    function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes calldata _proof) external;\n\n    function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) external payable;\n\n    function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes calldata _proof) external;\n\n    function getChallengeWindow() external view returns (uint256);\n\n    function getDisputeStatus(bytes32 _requestKey) external view returns (DisputeStatus);\n\n    function getResponseDeadline(bytes32 _requestKey) external view returns (uint256);\n}\n"
    },
    "contracts/sdk/interface/IBrevisProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/Lib.sol\";\n\ninterface IBrevisProof {\n    function submitProof(\n        uint64 _chainId,\n        bytes calldata _proofWithPubInputs\n    ) external returns (bytes32 requestId, bytes32 appCommitHash, bytes32 appVkHash);\n\n    function validateProofAppData(\n        bytes32 _requestId,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash\n    ) external view returns (bool);\n\n    function submitAggProof(\n        uint64 _chainId,\n        bytes32[] calldata _requestIds,\n        bytes calldata _proofWithPubInputs\n    ) external;\n\n    function validateAggProofData(uint64 _chainId, Brevis.ProofData[] calldata _proofDataArray) external view;\n\n    function validateAggProofData(\n        uint64 _chainId,\n        Brevis.ProofData calldata _proofData,\n        bytes32 _merkleRoot,\n        bytes32[] calldata _merkleProof,\n        uint8 _nodeIndex\n    ) external view;\n}\n"
    },
    "contracts/sdk/interface/IBrevisRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./IBrevisTypes.sol\";\nimport \"../lib/Lib.sol\";\nimport \"../../interfaces/ISigsVerifier.sol\";\n\ninterface IBrevisRequest is IBrevisTypes {\n    // todo: reduce event fields\n    event RequestSent(bytes32 proofId, uint64 nonce, address refundee, uint256 fee, Callback callback, uint8 option);\n\n    event RequestFulfilled(bytes32 proofId, uint64 nonce);\n    event RequestsFulfilled(bytes32[] proofIds, uint64[] nonces);\n    event OpRequestsFulfilled(bytes32[] proofIds, uint64[] nonces, bytes32[] appCommitHashes, bytes32[] appVkHashes);\n\n    event RequestRefunded(bytes32 proofId, uint64 nonce);\n    event RequestCallbackFailed(bytes32 proofId, uint64 nonce);\n    event RequestsCallbackFailed(bytes32[] proofIds, uint64[] nonces);\n    event RequestFeeIncreased(bytes32 proofId, uint64 nonce, uint256 gas, uint256 fee);\n\n    event RequestTimeoutUpdated(uint256 from, uint256 to);\n    event BaseDataUrlUpdated(string from, string to);\n    event BrevisProofUpdated(address from, address to);\n    event BrevisDisputeUpdated(address from, address to);\n    event BvnSigsVerifierUpdated(address from, address to);\n    event AvsSigsVerifierUpdated(address from, address to);\n\n    function sendRequest(\n        bytes32 _proofId,\n        uint64 _nonce,\n        address _refundee,\n        Callback calldata _callback,\n        uint8 _option // bitmap 0: zk, 1: op bvn, 2: op avs, 3: op bvn and avs\n    ) external payable;\n\n    function fulfillRequest(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _chainId,\n        bytes calldata _proof,\n        bytes calldata _appCircuitOutput,\n        address _callbackTarget\n    ) external;\n\n    function fulfillRequests(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        uint64 _chainId,\n        bytes calldata _proof,\n        Brevis.ProofData[] calldata _proofDataArray,\n        bytes[] calldata _appCircuitOutputs,\n        address[] calldata _callbackTargets\n    ) external;\n\n    function fulfillOpRequests(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        IBvnSigsVerifier.SigInfo calldata _bvnSigInfo,\n        IAvsSigsVerifier.SigInfo calldata _eigenSigInfo\n    ) external;\n\n    function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) external;\n\n    function increaseGasFee(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _addGas,\n        uint256 _currentFee,\n        address _refundee\n    ) external payable;\n\n    function queryRequestStatus(bytes32 _proofId, uint64 _nonce) external view returns (RequestStatus, uint8);\n\n    function queryRequestStatus(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint256 _appChallengeWindow\n    ) external view returns (RequestStatus, uint8);\n\n    function validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint8 _option\n    ) external view returns (bool);\n\n    function validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint256 _appChallengeWindow,\n        uint8 _option\n    ) external view returns (bool);\n\n    function validateOpAppData(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        uint256 _appChallengeWindow,\n        uint8 _option\n    ) external view returns (bool);\n\n    function dataURL(bytes32 _proofId) external view returns (string memory);\n}\n"
    },
    "contracts/sdk/interface/IBrevisTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IBrevisTypes {\n    enum RequestStatus {\n        Null,\n        ZkPending,\n        ZkAttested,\n        OpPending,\n        OpSubmitted,\n        OpDisputing,\n        OpDisputed,\n        OpAttested,\n        Refunded\n    }\n\n    struct Request {\n        RequestStatus status;\n        uint64 timestamp;\n        uint8 option;\n    }\n\n    struct OnchainRequestInfo {\n        bytes32 feeHash; // keccak256(abi.encodePacked(amount, refundee))\n        Callback callback;\n    }\n\n    struct Callback {\n        address target;\n        uint64 gas;\n    }\n\n    enum DisputeStatus {\n        Null,\n        WaitingForRequestData,\n        RequestDataPosted,\n        WaitingForDataAvailabilityProof,\n        DataAvailabilityProofPosted,\n        WaitingForDataValidityProof,\n        DataValidityProofPosted\n    }\n\n    struct RequestDataHash {\n        bytes32[] hashes;\n        bytes32 root;\n    }\n\n    struct Dispute {\n        DisputeStatus status;\n        address challenger;\n        RequestDataHash requestDataHash;\n        uint256 responseDeadline;\n        uint256 deposit;\n    }\n}\n"
    },
    "contracts/sdk/lib/Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../lib/RLPReader.sol\";\n\nlibrary Brevis {\n    // retrieved from proofData, to align the logs with circuit...\n    struct ProofData {\n        bytes32 commitHash;\n        bytes32 vkHash;\n        bytes32 appCommitHash; // zk-program computing circuit commit hash\n        bytes32 appVkHash; // zk-program computing circuit Verify Key hash\n        bytes32 smtRoot;\n    }\n\n    struct ProofAppData {\n        bytes32 appCommitHash;\n        bytes32 appVkHash;\n    }\n}\n\nlibrary Tx {\n    using RLPReader for bytes;\n    using RLPReader for uint;\n    using RLPReader for RLPReader.RLPItem;\n\n    struct TxInfo {\n        uint64 chainId;\n        uint64 nonce;\n        uint256 gasTipCap;\n        uint256 gasFeeCap;\n        uint256 gas;\n        address to;\n        uint256 value;\n        bytes data;\n        address from; // calculate from V R S\n    }\n\n    // support DynamicFeeTxType for now\n    function decodeTx(bytes calldata txRaw) public pure returns (TxInfo memory info) {\n        uint8 txType = uint8(txRaw[0]);\n        require(txType == 2, \"not a DynamicFeeTxType\");\n\n        bytes memory rlpData = txRaw[1:];\n        RLPReader.RLPItem[] memory values = rlpData.toRlpItem().toList();\n        info.chainId = uint64(values[0].toUint());\n        info.nonce = uint64(values[1].toUint());\n        info.gasTipCap = values[2].toUint();\n        info.gasFeeCap = values[3].toUint();\n        info.gas = values[4].toUint();\n        info.to = values[5].toAddress();\n        info.value = values[6].toUint();\n        info.data = values[7].toBytes();\n\n        (uint8 v, bytes32 r, bytes32 s) = (\n            uint8(values[9].toUint()),\n            bytes32(values[10].toBytes()),\n            bytes32(values[11].toBytes())\n        );\n        // remove r,s,v and adjust length field\n        bytes memory unsignedTxRaw;\n        uint16 unsignedTxRawDataLength;\n        uint8 prefix = uint8(txRaw[1]);\n        uint8 lenBytes = prefix - 0xf7; // assume lenBytes won't larger than 2, means the tx rlp data size won't exceed 2^16\n        if (lenBytes == 1) {\n            unsignedTxRawDataLength = uint8(bytes1(txRaw[2:3])) - 67; //67 is the bytes of r,s,v\n        } else {\n            unsignedTxRawDataLength = uint16(bytes2(txRaw[2:2 + lenBytes])) - 67;\n        }\n        if (unsignedTxRawDataLength <= 55) {\n            unsignedTxRaw = abi.encodePacked(txRaw[:2], txRaw[3:txRaw.length - 67]);\n            unsignedTxRaw[1] = bytes1(0xc0 + uint8(unsignedTxRawDataLength));\n        } else {\n            if (unsignedTxRawDataLength <= 255) {\n                unsignedTxRaw = abi.encodePacked(\n                    txRaw[0],\n                    bytes1(0xf8),\n                    bytes1(uint8(unsignedTxRawDataLength)),\n                    txRaw[2 + lenBytes:txRaw.length - 67]\n                );\n            } else {\n                unsignedTxRaw = abi.encodePacked(\n                    txRaw[0],\n                    bytes1(0xf9),\n                    bytes2(unsignedTxRawDataLength),\n                    txRaw[2 + lenBytes:txRaw.length - 67]\n                );\n            }\n        }\n        info.from = recover(keccak256(unsignedTxRaw), r, s, v);\n    }\n\n    function recover(bytes32 message, bytes32 r, bytes32 s, uint8 v) internal pure returns (address) {\n        if (v < 27) {\n            v += 27;\n        }\n        return ecrecover(message, v, r, s);\n    }\n}\n"
    },
    "contracts/smt/SMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../light-client-eth/interfaces/IAnchorBlocks.sol\";\nimport \"../interfaces/ISMT.sol\";\nimport \"../safeguard/BrevisAccess.sol\";\n\ncontract SMT is ISMT, BrevisAccess {\n    event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum, uint64 chainId);\n    event AnchorProviderUpdated(uint64 chainId, address anchorProvider);\n    event VerifierUpdated(uint64 chainId, address verifier);\n\n    mapping(uint64 => IAnchorBlocks) public anchorProviders;\n    mapping(uint64 => IVerifier) public verifiers;\n\n    mapping(uint64 => mapping(bytes32 => bool)) public smtRoots;\n    mapping(uint64 => bytes32) public latestRoots;\n\n    constructor(\n        uint64[] memory _chainIds,\n        address[] memory _anchorProviders,\n        address[] memory _verifiers,\n        bytes32[] memory _initRoots\n    ) {\n        require(_chainIds.length == _anchorProviders.length, \"len mismatch\");\n        require(_chainIds.length == _verifiers.length, \"len mismatch\");\n        require(_chainIds.length == _initRoots.length, \"len mismatch\");\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            uint64 chid = _chainIds[i];\n            anchorProviders[chid] = IAnchorBlocks(_anchorProviders[i]);\n            verifiers[chid] = IVerifier(_verifiers[i]);\n            smtRoots[chid][_initRoots[i]] = true;\n            latestRoots[chid] = _initRoots[i];\n        }\n    }\n\n    function getLatestRoot(uint64 chainId) public view returns (bytes32) {\n        return latestRoots[chainId];\n    }\n\n    function isSmtRootValid(uint64 chainId, bytes32 smtRoot) public view returns (bool) {\n        return smtRoots[chainId][smtRoot];\n    }\n\n    function updateRoot(uint64 chainId, SmtUpdate memory u) external onlyActiveProver {\n        // If nextChunkMerkleRoot is empty, it means the zk proof bypasses checking if the updated chunk anchors to a known chunk.\n        // Instead, the responsibility of checking the validity of endBlockHash is deferred to this contract.\n        if (u.nextChunkMerkleRoot == 0) {\n            IAnchorBlocks anchorProvider = anchorProviders[chainId];\n            require(address(anchorProvider) != address(0), \"unknown anchor provider\");\n            bytes32 anchorHash = anchorProvider.blocks(u.endBlockNum);\n            require(anchorHash == u.endBlockHash, \"anchor check failed\");\n        }\n        bytes32 root = latestRoots[chainId];\n        bool success = verifyProof(chainId, root, u);\n        require(success, \"invalid zk proof\");\n\n        smtRoots[chainId][u.newSmtRoot] = true;\n        latestRoots[chainId] = u.newSmtRoot;\n        emit SmtRootUpdated(u.newSmtRoot, u.endBlockNum, chainId);\n    }\n\n    function verifyProof(uint64 chainId, bytes32 oldSmtRoot, SmtUpdate memory u) private view returns (bool) {\n        IVerifier verifier = verifiers[chainId];\n        require(address(verifier) != address(0), \"no verifier for chainId\");\n\n        uint256[9] memory input;\n        uint256 m = 1 << 128;\n        input[0] = uint256(oldSmtRoot) >> 128;\n        input[1] = uint256(oldSmtRoot) % m;\n        input[2] = uint256(u.newSmtRoot) >> 128;\n        input[3] = uint256(u.newSmtRoot) % m;\n        input[4] = uint256(u.endBlockHash) >> 128;\n        input[5] = uint256(u.endBlockHash) % m;\n        input[6] = u.endBlockNum;\n        input[7] = uint256(u.nextChunkMerkleRoot) >> 128;\n        input[8] = uint256(u.nextChunkMerkleRoot) % m;\n\n        return verifier.verifyProof(u.proof, u.commit, u.knowledgeProof, input);\n    }\n\n    function setAnchorProvider(uint64 chainId, address anchorProvider) external onlyOwner {\n        anchorProviders[chainId] = IAnchorBlocks(anchorProvider);\n        emit AnchorProviderUpdated(chainId, anchorProvider);\n    }\n\n    function setVerifier(uint64 chainId, address verifier) external onlyOwner {\n        verifiers[chainId] = IVerifier(verifier);\n        emit VerifierUpdated(chainId, verifier);\n    }\n}\n"
    },
    "contracts/smt/TestSMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../light-client-eth/interfaces/IAnchorBlocks.sol\";\nimport \"../interfaces/ISMT.sol\";\nimport \"./SMT.sol\";\n\ncontract TestSMT is SMT {\n    constructor(\n        uint64[] memory _chainIds,\n        address[] memory _anchorProviders,\n        address[] memory _verifiers,\n        bytes32[] memory _initRoots\n    ) SMT(_chainIds, _anchorProviders, _verifiers, _initRoots) {}\n\n    // function for testing convenience\n    function addRootForTesting(uint64 chainId, bytes32 newRoot, uint64 endBlockNum) external onlyOwner {\n        smtRoots[chainId][newRoot] = true;\n        latestRoots[chainId] = newRoot;\n        emit SmtRootUpdated(newRoot, endBlockNum, chainId);\n    }\n}\n"
    },
    "contracts/verifiers/interfaces/IBeaconVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IBeaconVerifier {\n    struct Proof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[2] commitment;\n    }\n\n    function verifySignatureProof(\n        bytes32 signingRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        uint256 participation,\n        uint256 commitment,\n        Proof memory p\n    ) external view returns (bool);\n\n    function verifySyncCommitteeRootMappingProof(\n        bytes32 sszRoot,\n        bytes32 poseidonRoot,\n        Proof memory p\n    ) external view returns (bool);\n}\n"
    },
    "contracts/verifiers/interfaces/IReceiptVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IReceiptVerifier {\n    struct ReceiptInfo {\n        bool success;\n        uint64 chainId;\n        bytes32 blkHash;\n        uint32 blkNum;\n        uint64 blkTime;\n        LogInfo[] logs;\n        // TODO: add transaction index\n    }\n\n    struct LogInfo {\n        address addr;\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // reverts if not verified\n    // - receiptRaw: signed dynamic fee receipt rlp encode data\n    // - proofData: receipt proof data\n    // - auxiBlkVerifyInfo: auxiliary info for blk verify in chunk sync contract\n    function verifyReceipt(\n        bytes calldata receiptRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external view returns (ReceiptInfo memory receiptInfo);\n\n    // verifyReceipt and emit event\n    function verifyReceiptAndLog(\n        bytes calldata receiptRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external returns (ReceiptInfo memory receiptInfo);\n}\n"
    },
    "contracts/verifiers/interfaces/ISlotValueVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface ISlotValueVerifier {\n    struct SlotInfo {\n        uint64 chainId;\n        bytes32 addrHash;\n        bytes32 blkHash;\n        bytes32 slotKeyHash;\n        bytes32 slotValue;\n        uint32 blkNum;\n    }\n\n    /**\n     * @notice Called by dApp contracts to verify a slot value\n     * @param chainId The source chain ID for which the proof data was generated\n     * @param proofData Groth16 proof data, with the appended public inputs.\n     * @param blkVerifyInfo Data passed to the BlockSyncer to validate the block in the source chain.\n     */\n    function verifySlotValue(\n        uint64 chainId,\n        bytes calldata proofData,\n        bytes calldata blkVerifyInfo\n    ) external view returns (SlotInfo memory slotInfo);\n}\n"
    },
    "contracts/verifiers/interfaces/ITxVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface ITxVerifier {\n    struct TxInfo {\n        uint64 chainId;\n        uint64 nonce;\n        uint256 gasTipCap;\n        uint256 gasFeeCap;\n        uint256 gas;\n        address to;\n        uint256 value;\n        bytes data;\n        address from; // calculate from V R S\n        uint32 blkNum;\n        bytes32 blkHash;\n        uint64 blkTime;\n    }\n\n    // reverts if not verified\n    // - txRaw: signed dynamic fee tx rlp encode data\n    // - proofData: tx proof data\n    // - auxiBlkVerifyInfo: auxiliary info for blk verify in chunk sync contract\n    function verifyTx(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external view returns (TxInfo memory txInfo);\n\n    // verifyTx and emit event\n    function verifyTxAndLog(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external returns (TxInfo memory info);\n}\n"
    },
    "contracts/verifiers/interfaces/IZkpVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IZkpVerifier {\n    function verifyRaw(bytes calldata proofData) external view returns (bool r);\n}\n"
    },
    "contracts/verifiers/ReceiptVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/RLPReader.sol\";\nimport \"./interfaces/IReceiptVerifier.sol\";\nimport \"./interfaces/IZkpVerifier.sol\";\nimport \"../chunk-sync/interfaces/IBlockChunks.sol\";\nimport \"../safeguard/Ownable.sol\";\n\ncontract ReceiptVerifier is IReceiptVerifier, Ownable {\n    using RLPReader for bytes;\n    using RLPReader for uint;\n    using RLPReader for RLPReader.RLPItem;\n\n    uint32 constant PUBLIC_BYTES_START_IDX = 10 * 32; // the first 10 32bytes are groth16 proof (A/B/C/Commitment)\n\n    // retrieved from proofData, to align the fields with circuit...\n    struct ProofData {\n        bytes32 leafHash;\n        bytes32 blkHash;\n        uint32 blkNum;\n        uint64 blkTime;\n        uint64 chainId;\n        bytes leafRlpPrefix; // not public input\n    }\n\n    mapping(uint64 => address) public verifierAddresses; // chainid => snark verifier contract address\n    address public blockChunks;\n\n    event UpdateVerifierAddress(uint64 chainId, address newAddress);\n    event UpdateBlockChunks(address newAddress);\n    event VerifiedReceipt(uint64 chainId, bytes32 receiptHash);\n\n    constructor(address _blockChunks) {\n        blockChunks = _blockChunks;\n    }\n\n    function updateVerifierAddress(uint64 _chainId, address _verifierAddress) external onlyOwner {\n        verifierAddresses[_chainId] = _verifierAddress;\n        emit UpdateVerifierAddress(_chainId, _verifierAddress);\n    }\n\n    function updateBlockChunks(address _blockChunks) external onlyOwner {\n        blockChunks = _blockChunks;\n        emit UpdateBlockChunks(_blockChunks);\n    }\n\n    function verifyReceiptAndLog(\n        bytes calldata receiptRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external returns (ReceiptInfo memory info) {\n        info = verifyReceipt(receiptRaw, proofData, auxiBlkVerifyInfo);\n        // TODO, will emit <chain_id, block_num, tx_index> instead\n        emit VerifiedReceipt(info.chainId, keccak256(receiptRaw));\n    }\n\n    function verifyReceipt(\n        bytes calldata receiptRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) public view returns (ReceiptInfo memory info) {\n        ProofData memory data = getProofData(proofData);\n        require(verifyRaw(data.chainId, proofData), \"proof not valid\");\n        bytes memory leafRlp = bytes.concat(data.leafRlpPrefix, receiptRaw);\n        bytes32 leafHash = keccak256(leafRlp);\n        require(leafHash == data.leafHash, \"leafHash not match\");\n\n        (bytes32 prevHash, uint32 numFinal, bytes32[7] memory merkleProof) = getFromAuxiBlkVerifyInfo(\n            auxiBlkVerifyInfo\n        );\n\n        IBlockChunks.BlockHashWitness memory witness = IBlockChunks.BlockHashWitness({\n            chainId: data.chainId,\n            blkNum: data.blkNum,\n            claimedBlkHash: data.blkHash,\n            prevHash: prevHash,\n            numFinal: numFinal,\n            merkleProof: merkleProof\n        });\n        require(IBlockChunks(blockChunks).isBlockHashValid(witness), \"invalid blkHash\");\n\n        info = decodeReceipt(receiptRaw);\n        info.blkHash = data.blkHash;\n        info.blkTime = data.blkTime;\n        info.blkNum = data.blkNum;\n        info.chainId = data.chainId;\n    }\n\n    function getFromAuxiBlkVerifyInfo(\n        bytes calldata auxiBlkVerifyInfo\n    ) internal pure returns (bytes32 prevHash, uint32 numFinal, bytes32[7] memory merkleProof) {\n        require(auxiBlkVerifyInfo.length == 8 * 32 + 4, \"incorrect auxiBlkVerifyInfo\");\n\n        prevHash = bytes32(auxiBlkVerifyInfo[:32]);\n        numFinal = uint32(bytes4(auxiBlkVerifyInfo[32:36]));\n        for (uint8 idx = 0; idx < 6; idx++) {\n            merkleProof[idx] = bytes32(auxiBlkVerifyInfo[36 + 32 * idx:36 + 32 * (idx + 1)]);\n        }\n        merkleProof[6] = bytes32(auxiBlkVerifyInfo[36 + 32 * 6:36 + 32 * (6 + 1)]);\n    }\n\n    // support DynamicFeeTxType for now\n    function decodeReceipt(bytes calldata receiptRaw) public pure returns (ReceiptInfo memory info) {\n        uint8 txType = uint8(receiptRaw[0]);\n        require(txType == 2, \"not a DynamicFeeTxType\");\n        bytes memory rlpData = receiptRaw[1:];\n        RLPReader.RLPItem[] memory values = rlpData.toRlpItem().toList();\n        if (bytes1(values[0].toBytes()) == 0x01) {\n            info.success = true;\n        }\n\n        RLPReader.RLPItem[] memory rlpLogs = values[3].toList();\n        LogInfo[] memory logInfos = new LogInfo[](rlpLogs.length);\n        for (uint8 i = 0; i < rlpLogs.length; i++) {\n            RLPReader.RLPItem[] memory log = rlpLogs[i].toList();\n            //let one = log[0].toBytes();\n            logInfos[i].addr = log[0].toAddress();\n            RLPReader.RLPItem[] memory topics = log[1].toList();\n            logInfos[i].topics = new bytes32[](topics.length);\n            for (uint8 j = 0; j < topics.length; j++) {\n                logInfos[i].topics[j] = bytes32(topics[j].toBytes());\n            }\n            logInfos[i].data = log[2].toBytes();\n        }\n        info.logs = logInfos;\n    }\n\n    function verifyRaw(uint64 chainId, bytes calldata proofData) private view returns (bool) {\n        require(verifierAddresses[chainId] != address(0), \"chain verifier not set\");\n        return (IZkpVerifier)(verifierAddresses[chainId]).verifyRaw(proofData);\n    }\n\n    function getProofData(bytes calldata proofData) internal pure returns (ProofData memory data) {\n        data.leafHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 32 + 16:PUBLIC_BYTES_START_IDX + 2 * 32]))\n        );\n        data.blkHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 3 * 32 + 16:PUBLIC_BYTES_START_IDX + 4 * 32]))\n        );\n        data.blkNum = uint32(bytes4(proofData[PUBLIC_BYTES_START_IDX + 5 * 32 - 4:PUBLIC_BYTES_START_IDX + 5 * 32]));\n        data.blkTime = uint64(bytes8(proofData[PUBLIC_BYTES_START_IDX + 6 * 32 - 8:PUBLIC_BYTES_START_IDX + 6 * 32]));\n        // not public input\n        data.chainId = uint64(bytes8(proofData[PUBLIC_BYTES_START_IDX + 6 * 32:PUBLIC_BYTES_START_IDX + 6 * 32 + 8]));\n        data.leafRlpPrefix = bytes(proofData[PUBLIC_BYTES_START_IDX + 6 * 32 + 8:]);\n    }\n}\n"
    },
    "contracts/verifiers/SlotValueVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./interfaces/ISlotValueVerifier.sol\";\nimport \"./interfaces/IZkpVerifier.sol\";\nimport \"../chunk-sync/interfaces/IBlockChunks.sol\";\nimport \"../safeguard/Ownable.sol\";\n\ncontract SlotValueVerifier is ISlotValueVerifier, Ownable {\n    uint32 constant PUBLIC_BYTES_START_IDX = 10 * 32;\n\n    // retrieved from proofData, to align the fields with circuit...\n    struct ProofData {\n        bytes32 blkHash;\n        bytes32 addrHash;\n        bytes32 slotKeyHash;\n        bytes32 slotValue;\n        uint32 blkNum;\n    }\n\n    mapping(uint64 => address) public verifierAddresses; // chainid => snark verifier contract address\n    address public BlockChunks;\n\n    event UpdateVerifierAddress(uint64 chainId, address newAddress);\n    event UpdateBlockChunks(address newAddress);\n\n    constructor(address _blocChunks) {\n        BlockChunks = _blocChunks;\n    }\n\n    function updateVerifierAddress(uint64 _chainId, address _verifierAddress) external onlyOwner {\n        verifierAddresses[_chainId] = _verifierAddress;\n        emit UpdateVerifierAddress(_chainId, _verifierAddress);\n    }\n\n    function updateBlockChunks(address _BlockChunks) external onlyOwner {\n        BlockChunks = _BlockChunks;\n        emit UpdateBlockChunks(_BlockChunks);\n    }\n\n    function verifySlotValue(\n        uint64 chainId,\n        bytes calldata proofData,\n        bytes calldata blkVerifyInfo\n    ) external view returns (SlotInfo memory slotInfo) {\n        require(verifyRaw(chainId, proofData));\n\n        (bytes32 prevHash, uint32 numFinal, bytes32[7] memory merkleProof) = getFromBlkVerifyInfo(blkVerifyInfo);\n        ProofData memory data = getProofData(proofData);\n\n        IBlockChunks.BlockHashWitness memory witness = IBlockChunks.BlockHashWitness({\n            chainId: chainId,\n            blkNum: data.blkNum,\n            claimedBlkHash: data.blkHash,\n            prevHash: prevHash,\n            numFinal: numFinal,\n            merkleProof: merkleProof\n        });\n        require(IBlockChunks(BlockChunks).isBlockHashValid(witness), \"invalid blkHash\");\n\n        slotInfo.chainId = chainId;\n        slotInfo.blkHash = data.blkHash;\n        slotInfo.addrHash = data.addrHash;\n        slotInfo.blkNum = data.blkNum;\n        slotInfo.slotKeyHash = data.slotKeyHash;\n        slotInfo.slotValue = data.slotValue;\n    }\n\n    function verifyRaw(uint64 chainId, bytes calldata proofData) private view returns (bool) {\n        require(verifierAddresses[chainId] != address(0), \"chain verifier not set\");\n        return (IZkpVerifier)(verifierAddresses[chainId]).verifyRaw(proofData);\n    }\n\n    function getFromBlkVerifyInfo(\n        bytes calldata blkVerifyInfo\n    ) internal pure returns (bytes32 prevHash, uint32 numFinal, bytes32[7] memory merkleProof) {\n        require(blkVerifyInfo.length == 8 * 32 + 4, \"incorrect blkVerifyInfo\");\n        prevHash = bytes32(blkVerifyInfo[:32]);\n        numFinal = uint32(bytes4(blkVerifyInfo[32:36]));\n\n        for (uint8 idx = 0; idx < 6; idx++) {\n            merkleProof[idx] = bytes32(blkVerifyInfo[36 + 32 * idx:36 + 32 * (idx + 1)]);\n        }\n\n        merkleProof[6] = bytes32(blkVerifyInfo[36 + 32 * 6:36 + 32 * (6 + 1)]);\n    }\n\n    // groth16 proof + public inputs\n    // public inputs:\n    //  block hash\n    //  contractAddrHash\n    //  slot key\n    //  slot value\n    //  block number\n    function getProofData(bytes calldata proofData) internal pure returns (ProofData memory data) {\n        data.blkHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 32 + 16:PUBLIC_BYTES_START_IDX + 2 * 32]))\n        );\n        data.addrHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 3 * 32 + 16:PUBLIC_BYTES_START_IDX + 4 * 32]))\n        );\n        data.slotKeyHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 4 * 32:PUBLIC_BYTES_START_IDX + 5 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 5 * 32 + 16:PUBLIC_BYTES_START_IDX + 6 * 32]))\n        );\n        data.slotValue = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 6 * 32:PUBLIC_BYTES_START_IDX + 7 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 7 * 32 + 16:PUBLIC_BYTES_START_IDX + 8 * 32]))\n        );\n        data.blkNum = uint32(bytes4(proofData[PUBLIC_BYTES_START_IDX + 9 * 32 - 4:PUBLIC_BYTES_START_IDX + 9 * 32]));\n    }\n}\n"
    },
    "contracts/verifiers/TxVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/RLPReader.sol\";\nimport \"./interfaces/ITxVerifier.sol\";\nimport \"./interfaces/IZkpVerifier.sol\";\nimport \"../chunk-sync/interfaces/IBlockChunks.sol\";\nimport \"../safeguard/Ownable.sol\";\n\ncontract TxVerifier is ITxVerifier, Ownable {\n    using RLPReader for bytes;\n    using RLPReader for uint;\n    using RLPReader for RLPReader.RLPItem;\n\n    uint32 constant PUBLIC_BYTES_START_IDX = 10 * 32; // the first 10 32bytes are groth16 proof (A/B/C/Commitment)\n\n    // retrieved from proofData, to align the fields with circuit...\n    struct ProofData {\n        bytes32 leafHash;\n        bytes32 blkHash;\n        uint32 blkNum;\n        uint64 blkTime;\n        bytes leafRlpPrefix;\n    }\n\n    mapping(uint64 => address) public verifierAddresses; // chainid => snark verifier contract address\n    address public blockChunks;\n\n    event UpdateVerifierAddress(uint64 chainId, address newAddress);\n    event UpdateBlockChunks(address newAddress);\n    event VerifiedTx(uint64 chainId, bytes32 txHash);\n\n    constructor(address _blockChunks) {\n        blockChunks = _blockChunks;\n    }\n\n    function updateVerifierAddress(uint64 _chainId, address _verifierAddress) external onlyOwner {\n        verifierAddresses[_chainId] = _verifierAddress;\n        emit UpdateVerifierAddress(_chainId, _verifierAddress);\n    }\n\n    function updateBlockChunks(address _blockChunks) external onlyOwner {\n        blockChunks = _blockChunks;\n        emit UpdateBlockChunks(_blockChunks);\n    }\n\n    function verifyTxAndLog(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external returns (TxInfo memory info) {\n        info = verifyTx(txRaw, proofData, auxiBlkVerifyInfo);\n        emit VerifiedTx(info.chainId, keccak256(txRaw));\n    }\n\n    function verifyTx(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) public view returns (TxInfo memory info) {\n        info = decodeTx(txRaw);\n        require(verifyRaw(info.chainId, proofData), \"proof not valid\");\n        ProofData memory data = getProofData(proofData);\n        bytes memory leafRlp = bytes.concat(data.leafRlpPrefix, txRaw);\n        bytes32 leafHash = keccak256(leafRlp);\n        require(leafHash == data.leafHash, \"leafHash not match\");\n\n        (bytes32 prevHash, uint32 numFinal, bytes32[7] memory merkleProof) = getFromAuxiBlkVerifyInfo(\n            auxiBlkVerifyInfo\n        );\n\n        IBlockChunks.BlockHashWitness memory witness = IBlockChunks.BlockHashWitness({\n            chainId: info.chainId,\n            blkNum: data.blkNum,\n            claimedBlkHash: data.blkHash,\n            prevHash: prevHash,\n            numFinal: numFinal,\n            merkleProof: merkleProof\n        });\n        require(IBlockChunks(blockChunks).isBlockHashValid(witness), \"invalid blkHash\");\n\n        info.blkHash = data.blkHash;\n        info.blkTime = data.blkTime;\n        info.blkNum = data.blkNum;\n    }\n\n    function getFromAuxiBlkVerifyInfo(\n        bytes calldata auxiBlkVerifyInfo\n    ) internal pure returns (bytes32 prevHash, uint32 numFinal, bytes32[7] memory merkleProof) {\n        require(auxiBlkVerifyInfo.length == 8 * 32 + 4, \"incorrect auxiBlkVerifyInfo\");\n\n        prevHash = bytes32(auxiBlkVerifyInfo[:32]);\n        numFinal = uint32(bytes4(auxiBlkVerifyInfo[32:36]));\n        for (uint8 idx = 0; idx < 6; idx++) {\n            merkleProof[idx] = bytes32(auxiBlkVerifyInfo[36 + 32 * idx:36 + 32 * (idx + 1)]);\n        }\n        merkleProof[6] = bytes32(auxiBlkVerifyInfo[36 + 32 * 6:36 + 32 * (6 + 1)]);\n    }\n\n    // support DynamicFeeTxType for now\n    function decodeTx(bytes calldata txRaw) public pure returns (TxInfo memory info) {\n        uint8 txType = uint8(txRaw[0]);\n        require(txType == 2, \"not a DynamicFeeTxType\");\n\n        bytes memory rlpData = txRaw[1:];\n        RLPReader.RLPItem[] memory values = rlpData.toRlpItem().toList();\n        info.chainId = uint64(values[0].toUint());\n        info.nonce = uint64(values[1].toUint());\n        info.gasTipCap = values[2].toUint();\n        info.gasFeeCap = values[3].toUint();\n        info.gas = values[4].toUint();\n        info.to = values[5].toAddress();\n        info.value = values[6].toUint();\n        info.data = values[7].toBytes();\n\n        (uint8 v, bytes32 r, bytes32 s) = (\n            uint8(values[9].toUint()),\n            bytes32(values[10].toBytes()),\n            bytes32(values[11].toBytes())\n        );\n        // remove r,s,v and adjust length field\n        bytes memory unsignedTxRaw;\n        uint16 unsignedTxRawDataLength;\n        uint8 prefix = uint8(txRaw[1]);\n        uint8 lenBytes = prefix - 0xf7; // assume lenBytes won't larger than 2, means the tx rlp data size won't exceed 2^16\n        if (lenBytes == 1) {\n            unsignedTxRawDataLength = uint8(bytes1(txRaw[2:3])) - 67; //67 is the bytes of r,s,v\n        } else {\n            unsignedTxRawDataLength = uint16(bytes2(txRaw[2:2 + lenBytes])) - 67;\n        }\n        if (unsignedTxRawDataLength <= 55) {\n            unsignedTxRaw = abi.encodePacked(txRaw[:2], txRaw[3:txRaw.length - 67]);\n            unsignedTxRaw[1] = bytes1(0xc0 + uint8(unsignedTxRawDataLength));\n        } else {\n            if (unsignedTxRawDataLength <= 255) {\n                unsignedTxRaw = abi.encodePacked(\n                    txRaw[0],\n                    bytes1(0xf8),\n                    bytes1(uint8(unsignedTxRawDataLength)),\n                    txRaw[2 + lenBytes:txRaw.length - 67]\n                );\n            } else {\n                unsignedTxRaw = abi.encodePacked(\n                    txRaw[0],\n                    bytes1(0xf9),\n                    bytes2(unsignedTxRawDataLength),\n                    txRaw[2 + lenBytes:txRaw.length - 67]\n                );\n            }\n        }\n        info.from = recover(keccak256(unsignedTxRaw), r, s, v);\n    }\n\n    function recover(bytes32 message, bytes32 r, bytes32 s, uint8 v) internal pure returns (address) {\n        if (v < 27) {\n            v += 27;\n        }\n        return ecrecover(message, v, r, s);\n    }\n\n    function verifyRaw(uint64 chainId, bytes calldata proofData) private view returns (bool) {\n        require(verifierAddresses[chainId] != address(0), \"chain verifier not set\");\n        return (IZkpVerifier)(verifierAddresses[chainId]).verifyRaw(proofData);\n    }\n\n    function getProofData(bytes calldata proofData) internal pure returns (ProofData memory data) {\n        data.leafHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 32 + 16:PUBLIC_BYTES_START_IDX + 2 * 32]))\n        );\n        data.blkHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 3 * 32 + 16:PUBLIC_BYTES_START_IDX + 4 * 32]))\n        );\n        data.blkNum = uint32(bytes4(proofData[PUBLIC_BYTES_START_IDX + 5 * 32 - 4:PUBLIC_BYTES_START_IDX + 5 * 32]));\n        data.blkTime = uint64(bytes8(proofData[PUBLIC_BYTES_START_IDX + 6 * 32 - 8:PUBLIC_BYTES_START_IDX + 6 * 32]));\n        // not public input\n        data.leafRlpPrefix = bytes(proofData[PUBLIC_BYTES_START_IDX + 6 * 32:]);\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/common/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IVerifier {\n    function verifyProof(\n        uint256[8] calldata proof,\n        uint256[2] calldata commit,\n        uint256[2] calldata knowledgeProof,\n        uint256[9] calldata input\n    ) external view returns (bool r);\n}\n"
    },
    "contracts/verifiers/zk-verifiers/SMTUpdateSD18CD7ForOpVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract SMTUpdateCircuitProofOnOpVerifier {\n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 15419906342546775518056107071206082363336491762605521910208413869208927134694;\n    uint256 constant ALPHA_Y = 8925206659625855244561366728843285323744854262045895593028094624373620731922;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 11215850788231168341298441616563847207476572509165490513874803298212456302963;\n    uint256 constant BETA_NEG_X_1 = 8238279398116533936998213301569180178754815422316673139943232388076301667239;\n    uint256 constant BETA_NEG_Y_0 = 21832070218819376232664150960538222039779319910810640357249292304324844753485;\n    uint256 constant BETA_NEG_Y_1 = 9645998624345071248952629980493114216707576571248096877536647337508115727673;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 10601238188791374550285170434453601938335804995266934091716139317125293638278;\n    uint256 constant GAMMA_NEG_X_1 = 13677398231709499629906376603684156136667816516228700490473454800982690413108;\n    uint256 constant GAMMA_NEG_Y_0 = 17041542147468964349964039722920041227280608734181340612910512772859614705745;\n    uint256 constant GAMMA_NEG_Y_1 = 12907952842297082648757487550998246103074200984829304277298928430029071100637;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 8232190889596979213738055480496452392103977043528541478688126078314412227487;\n    uint256 constant DELTA_NEG_X_1 = 1065931679919289878696551123315192093061984499916404628172416994815927094095;\n    uint256 constant DELTA_NEG_Y_0 = 12552350698181263435179086441908958505534872197386922161059078318191731336963;\n    uint256 constant DELTA_NEG_Y_1 = 6511382691711036021804729349675340256940372423678254876986120440897243279309;\n    // Pedersen G point in G2 in powers of i\n    uint256 constant PEDERSEN_G_X_0 = 18805755783857632130494169760142971459211085766908956007665772744607805349331;\n    uint256 constant PEDERSEN_G_X_1 = 6577130346294027956106129016242575755376501376806793281099727040898065194630;\n    uint256 constant PEDERSEN_G_Y_0 = 3063828328789064990096030216023403162709221064383189238160145907411059445654;\n    uint256 constant PEDERSEN_G_Y_1 = 3518510766686242646084167009169793143410416394108769285506541954245359469430;\n\n    // Pedersen GRootSigmaNeg point in G2 in powers of i\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_0 =\n        20573844106836851216683495680715692316448816169379645474552662784955401807782;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_1 =\n        10173198368954426359560222122775027390195584468790431924474000180170482567391;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_0 =\n        8933462681644689232793574626123804034150276190704931603444382781462281429595;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_1 =\n        17690363985422853860548334460761950515160248144161805124506500282167531442429;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 17781150640532246683478288430048881803672435485525463173154420895146090513125;\n    uint256 constant CONSTANT_Y = 16641756872356175845605867643980429319093093385697558171090848764055531414861;\n    uint256 constant PUB_0_X = 21762954875859522910283083606892400572088600507337073996229569604242842249270;\n    uint256 constant PUB_0_Y = 19663976138561437876960571951888052852491438808124896768715500012952888092467;\n    uint256 constant PUB_1_X = 1282725618717198352780293692830891443025482340068889157440025831574202963944;\n    uint256 constant PUB_1_Y = 5141998626009341098281690417433558725725706726366284990672385112933672017322;\n    uint256 constant PUB_2_X = 1240446175031511932337110215869561493021210843231095144396369783697007421678;\n    uint256 constant PUB_2_Y = 6097377749748449085475680060974341379881798127128503720246824284984211576709;\n    uint256 constant PUB_3_X = 7697944521653177457169858557057282285863319527054233090334250110271583519921;\n    uint256 constant PUB_3_Y = 7468913458484340056196103603113691168882715555713943918188547289763943605351;\n    uint256 constant PUB_4_X = 14709897161989503194601316482911961165234009336256324577023792817414900623418;\n    uint256 constant PUB_4_Y = 4749531004971325732649341235206855488889769848132077726737632639652670873328;\n    uint256 constant PUB_5_X = 4382497355660004011670078123988761997560027829055718786348255676075333012297;\n    uint256 constant PUB_5_Y = 12909374075361927801637650590989430487973660002571842025096047421198361103419;\n    uint256 constant PUB_6_X = 3045310679983037167284855434152608108004309361015643912970003163614423182850;\n    uint256 constant PUB_6_Y = 3855115339596168614477475672569798808024932255699838809951164243482027405378;\n    uint256 constant PUB_7_X = 9759470637889957138632189878058376019817094047617385414100630665386579435922;\n    uint256 constant PUB_7_Y = 18723926700666823905805244351111906954741145157310895366231249412894474043073;\n    uint256 constant PUB_8_X = 7834429028994559907616029020492869687127296893521648940777211614458493363574;\n    uint256 constant PUB_8_Y = 8246737296674016630208054535734405751622077371125335638920262402621189665145;\n    uint256 constant PUB_9_X = 16292799440761393277617698507073614168294446014741578359675905806367574298656;\n    uint256 constant PUB_9_Y = 11592802447601385600742313198658048780149326795010307963294046197593644867387;\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(\n        uint256[9] calldata input,\n        uint256 publicCommit,\n        uint256[2] calldata commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s := calldataload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s := calldataload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_2_X)\n            mstore(add(g, 0x20), PUB_2_Y)\n            s := calldataload(add(input, 64))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_3_X)\n            mstore(add(g, 0x20), PUB_3_Y)\n            s := calldataload(add(input, 96))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_4_X)\n            mstore(add(g, 0x20), PUB_4_Y)\n            s := calldataload(add(input, 128))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_5_X)\n            mstore(add(g, 0x20), PUB_5_Y)\n            s := calldataload(add(input, 160))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_6_X)\n            mstore(add(g, 0x20), PUB_6_Y)\n            s := calldataload(add(input, 192))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_7_X)\n            mstore(add(g, 0x20), PUB_7_Y)\n            s := calldataload(add(input, 224))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_8_X)\n            mstore(add(g, 0x20), PUB_8_Y)\n            s := calldataload(add(input, 256))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_9_X)\n            mstore(add(g, 0x20), PUB_9_Y)\n\n            s := calldataload(add(input, 288))\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := calldataload(commit)\n            mstore(g, s) // save commit[0]\n            s := calldataload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Verify an uncompressed Groth16 proof.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\n    /// of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyProof(\n        uint256[8] calldata proof,\n        uint256[2] calldata commit,\n        uint256[2] calldata knowledgeProof,\n        uint256[9] calldata input\n    ) public view returns (bool) {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commit[0], commit[1]))) % MOD_R;\n        (uint256 x, uint256 y) = publicInputMSM(input, inputFr, commit);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n            // Copy points (A, B, C) to memory. They are already in correct encoding.\n            // This is pairing e(A, B) and G1 of e(C, -δ).\n            calldatacopy(f, proof, 0x100)\n\n            // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n            // OPT: This could be better done using a single codecopy, but\n            //      Solidity (unlike standalone Yul) doesn't provide a way to\n            //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := calldataload(commit)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := calldataload(add(commit, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), PEDERSEN_G_Y_0)\n\n            c := calldataload(knowledgeProof)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := calldataload(add(knowledgeProof, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), PEDERSEN_GROOTSIGMANEG_X_1)\n            mstore(add(f, 0x420), PEDERSEN_GROOTSIGMANEG_X_0)\n            mstore(add(f, 0x440), PEDERSEN_GROOTSIGMANEG_Y_1)\n            mstore(add(f, 0x460), PEDERSEN_GROOTSIGMANEG_Y_0)\n\n            // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n            // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}