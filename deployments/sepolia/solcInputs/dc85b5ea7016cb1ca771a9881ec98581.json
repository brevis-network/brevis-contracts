{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/ISMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../verifiers/zk-verifiers/common/IVerifier.sol\";\n\ninterface ISMT {\n    struct SmtUpdate {\n        bytes32 newSmtRoot;\n        uint64 endBlockNum;\n        bytes32 endBlockHash;\n        bytes32 nextChunkMerkleRoot;\n        bytes32 circuitDigest;\n        uint256[8] proof;\n        uint256[2] commit;\n        uint256[2] knowledgeProof;\n    }\n\n    function updateRoot(uint64 chainId, SmtUpdate memory u) external;\n\n    function isSmtRootValid(uint64 chainId, bytes32 smtRoot) external view returns (bool);\n}\n"
    },
    "contracts/light-client-eth/interfaces/IAnchorBlocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IAnchorBlocks {\n    function blocks(uint256 blockNum) external view returns (bytes32);\n}\n"
    },
    "contracts/safeguard/BrevisAccess.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"./Pauser.sol\";\n\n// prover and pauser access control using a single map lookup\nabstract contract BrevisAccess is Pauser {\n    enum ProverState {\n        Null,\n        Active,\n        Paused\n    }\n    mapping(address => ProverState) public proverStates;\n    address[] public provers;\n\n    event ProverAdded(address account);\n    event ProverRemoved(address account);\n\n    modifier onlyProver() {\n        require(proverStates[msg.sender] != ProverState.Null, \"invalid prover\");\n        _;\n    }\n\n    modifier onlyActiveProver() {\n        require(proverStates[msg.sender] == ProverState.Active, \"invalid prover\");\n        _;\n    }\n\n    function addProvers(address[] memory _accounts) public onlyOwner {\n        ProverState state = paused() ? ProverState.Paused : ProverState.Active;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addProver(_accounts[i], state);\n        }\n    }\n\n    function removeProvers(address[] memory _accounts) public onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _removeProver(_accounts[i]);\n        }\n    }\n\n    function pause() public override onlyPauser {\n        _pause();\n        for (uint256 i = 0; i < provers.length; i++) {\n            proverStates[provers[i]] = ProverState.Paused;\n        }\n    }\n\n    function unpause() public override onlyPauser {\n        _unpause();\n        for (uint256 i = 0; i < provers.length; i++) {\n            proverStates[provers[i]] = ProverState.Active;\n        }\n    }\n\n    function numProvers() public view returns (uint256) {\n        return provers.length;\n    }\n\n    function isActiveProver(address _account) public view returns (bool) {\n        return proverStates[_account] == ProverState.Active;\n    }\n\n    function _addProver(address _account, ProverState _state) private {\n        require(proverStates[_account] == ProverState.Null, \"account is prover\");\n        provers.push(_account);\n        proverStates[_account] = _state;\n        emit ProverAdded(_account);\n    }\n\n    function _removeProver(address _account) private {\n        require(proverStates[_account] != ProverState.Null, \"account is not prover\");\n        uint256 lastIndex = provers.length - 1;\n        for (uint256 i = 0; i < provers.length; i++) {\n            if (provers[i] == _account) {\n                if (i < lastIndex) {\n                    provers[i] = provers[lastIndex];\n                }\n                provers.pop();\n                delete proverStates[_account];\n                emit ProverRemoved(_account);\n                return;\n            }\n        }\n        revert(\"prover not found\"); // this should never happen\n    }\n}\n"
    },
    "contracts/safeguard/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\n * This adds a normal func that setOwner if _owner is address(0). So we can't allow\n * renounceOwnership. So we can support Proxy based upgradable contract\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Only to be called by inherit contracts, in their init func called by Proxy\n     * we require _owner == address(0), which is only possible when it's a delegateCall\n     * because constructor sets _owner in contract state.\n     */\n    function initOwner() internal {\n        require(_owner == address(0), \"owner already set\");\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/safeguard/Pauser.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./Ownable.sol\";\n\nabstract contract Pauser is Ownable, Pausable {\n    mapping(address => bool) public pausers;\n    address[] public pauserList;\n\n    event PauserAdded(address account);\n    event PauserRemoved(address account);\n\n    constructor() {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"Caller is not pauser\");\n        _;\n    }\n\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return pausers[account];\n    }\n\n    function addPauser(address account) public onlyOwner {\n        _addPauser(account);\n    }\n\n    function addPausers(address[] memory accounts) public onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _addPauser(accounts[i]);\n        }\n    }\n\n    function removePauser(address account) public onlyOwner {\n        _removePauser(account);\n    }\n\n    function removePausers(address[] memory accounts) public onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _removePauser(accounts[i]);\n        }\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function numPausers() public view returns (uint256) {\n        return pauserList.length;\n    }\n\n    function _addPauser(address account) private {\n        require(!isPauser(account), \"Account is already pauser\");\n        pauserList.push(account);\n        pausers[account] = true;\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) private {\n        require(isPauser(account), \"Account is not pauser\");\n        uint256 lastIndex = pauserList.length - 1;\n        for (uint256 i = 0; i < pauserList.length; i++) {\n            if (pauserList[i] == account) {\n                if (i < lastIndex) {\n                    pauserList[i] = pauserList[lastIndex];\n                }\n                pauserList.pop();\n                pausers[account] = false;\n                emit PauserRemoved(account);\n                return;\n            }\n        }\n        revert(\"pauser not found\"); // this should never happen\n    }\n}\n"
    },
    "contracts/smt/SMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../light-client-eth/interfaces/IAnchorBlocks.sol\";\nimport \"../interfaces/ISMT.sol\";\nimport \"../safeguard/BrevisAccess.sol\";\n\ncontract SMT is ISMT, BrevisAccess {\n    event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum, uint64 chainId);\n    event AnchorProviderUpdated(uint64 chainId, address anchorProvider);\n    event VerifierUpdated(uint64 chainId, address verifier);\n    event CircuitDigestUpdated(bytes32 circuitDigest);\n\n    mapping(uint64 => IAnchorBlocks) public anchorProviders;\n    mapping(uint64 => IVerifier) public verifiers;\n\n    mapping(uint64 => mapping(bytes32 => bool)) public smtRoots;\n    mapping(uint64 => bytes32) public latestRoots;\n    bytes32 public circuitDigest; \n\n    constructor(\n        uint64[] memory _chainIds,\n        address[] memory _anchorProviders,\n        address[] memory _verifiers,\n        bytes32[] memory _initRoots\n    ) {\n        require(_chainIds.length == _anchorProviders.length, \"len mismatch\");\n        require(_chainIds.length == _verifiers.length, \"len mismatch\");\n        require(_chainIds.length == _initRoots.length, \"len mismatch\");\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            uint64 chid = _chainIds[i];\n            anchorProviders[chid] = IAnchorBlocks(_anchorProviders[i]);\n            verifiers[chid] = IVerifier(_verifiers[i]);\n            smtRoots[chid][_initRoots[i]] = true;\n            latestRoots[chid] = _initRoots[i];\n        }\n    }\n\n    function getLatestRoot(uint64 chainId) public view returns (bytes32) {\n        return latestRoots[chainId];\n    }\n\n    function isSmtRootValid(uint64 chainId, bytes32 smtRoot) public view returns (bool) {\n        return smtRoots[chainId][smtRoot];\n    }\n\n    function updateRoot(uint64 chainId, SmtUpdate memory u) external onlyActiveProver {\n        // If nextChunkMerkleRoot is empty, it means the zk proof bypasses checking if the updated chunk anchors to a known chunk.\n        // Instead, the responsibility of checking the validity of endBlockHash is deferred to this contract.\n        if (u.nextChunkMerkleRoot == 0) {\n            IAnchorBlocks anchorProvider = anchorProviders[chainId];\n            require(address(anchorProvider) != address(0), \"unknown anchor provider\");\n            bytes32 anchorHash = anchorProvider.blocks(u.endBlockNum);\n            require(anchorHash == u.endBlockHash, \"anchor check failed\");\n        }\n        bytes32 root = latestRoots[chainId];\n        bool success = verifyProof(chainId, root, u);\n        require(success, \"invalid zk proof\");\n\n        smtRoots[chainId][u.newSmtRoot] = true;\n        latestRoots[chainId] = u.newSmtRoot;\n        emit SmtRootUpdated(u.newSmtRoot, u.endBlockNum, chainId);\n    }\n\n    function verifyProof(uint64 chainId, bytes32 oldSmtRoot, SmtUpdate memory u) private view returns (bool) {\n        IVerifier verifier = verifiers[chainId];\n        require(address(verifier) != address(0), \"no verifier for chainId\");\n        require(circuitDigest == u.circuitDigest, \"not valid circuit digest\");\n        uint256[9] memory input;\n        uint256 m = 1 << 128;\n        input[0] = uint256(u.endBlockHash) >> 128;\n        input[1] = uint256(u.endBlockHash) % m;\n        input[2] = uint256(u.newSmtRoot) >> 128;\n        input[3] = uint256(u.newSmtRoot) % m;\n        input[4] = uint256(oldSmtRoot) >> 128;\n        input[5] = uint256(oldSmtRoot) % m;\n        input[6] = uint256(u.nextChunkMerkleRoot) >> 128;\n        input[7] = uint256(u.nextChunkMerkleRoot) % m;\n        input[8] = uint256(u.circuitDigest);\n\n        return verifier.verifyProof(u.proof, u.commit, u.knowledgeProof, input);\n    }\n\n    function setAnchorProvider(uint64 chainId, address anchorProvider) external onlyOwner {\n        anchorProviders[chainId] = IAnchorBlocks(anchorProvider);\n        emit AnchorProviderUpdated(chainId, anchorProvider);\n    }\n\n    function setVerifier(uint64 chainId, address verifier) external onlyOwner {\n        verifiers[chainId] = IVerifier(verifier);\n        emit VerifierUpdated(chainId, verifier);\n    }\n\n    function setCircuitDigest(bytes32 _circuitDigest) external onlyOwner {\n        circuitDigest = _circuitDigest;\n        emit CircuitDigestUpdated(_circuitDigest);\n    }\n}\n"
    },
    "contracts/smt/TestSMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../light-client-eth/interfaces/IAnchorBlocks.sol\";\nimport \"../interfaces/ISMT.sol\";\nimport \"./SMT.sol\";\n\ncontract TestSMT is SMT {\n    constructor(\n        uint64[] memory _chainIds,\n        address[] memory _anchorProviders,\n        address[] memory _verifiers,\n        bytes32[] memory _initRoots\n    ) SMT(_chainIds, _anchorProviders, _verifiers, _initRoots) {}\n\n    // function for testing convenience\n    function addRootForTesting(uint64 chainId, bytes32 newRoot, uint64 endBlockNum) external onlyOwner {\n        smtRoots[chainId][newRoot] = true;\n        latestRoots[chainId] = newRoot;\n        emit SmtRootUpdated(newRoot, endBlockNum, chainId);\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/BrevisPlonky2SmtVerifier.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract BrevisPlonky2SmtVerifier {\n\n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 16674961759665994220547130734498453246698070037530669858372207333033413731417;\n    uint256 constant ALPHA_Y = 6911200766160494893801835071078730894862166751034428332209087625882296445779;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 13536139394958172751503139069743787749621840250547110104493403742374108935707;\n    uint256 constant BETA_NEG_X_1 = 11102837187904135625307413435026641709334584381137979686243311919180292671054;\n    uint256 constant BETA_NEG_Y_0 = 19281487587562212498559570188845144433402594574027000624914936059133234223423;\n    uint256 constant BETA_NEG_Y_1 = 17611956866946945035550581180406869113463861394727221366079877437664543098877;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 21869970720403837836069105727101561984556504927398890797700572961963940142289;\n    uint256 constant GAMMA_NEG_X_1 = 7544179524898651400069274552044174190409119042279917191311868152460077682305;\n    uint256 constant GAMMA_NEG_Y_0 = 12856443559481956347081353006362994975852738789507196674370306840658653257049;\n    uint256 constant GAMMA_NEG_Y_1 = 4478417527849754235590126751372660101209283862196605753220162666566931926943;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 12098390187342850307928066710647009228852240446256104708800865653532999029045;\n    uint256 constant DELTA_NEG_X_1 = 10431018757232294932556939298326165116713515602022172882197940894146795786503;\n    uint256 constant DELTA_NEG_Y_0 = 5120875434737626216784267985855285017748455788325473709943354377044785625163;\n    uint256 constant DELTA_NEG_Y_1 = 1958951624994736526402023784513889484287569177130777677778703607272513892644;\n    // Pedersen G point in G2 in powers of i\n    uint256 constant PEDERSEN_G_X_0 = 826033962502871230897580264308244787159166898709172352520187721374310347388;\n    uint256 constant PEDERSEN_G_X_1 = 12191498427084538501516628373400886973061774287739661186360639951220493389336;\n    uint256 constant PEDERSEN_G_Y_0 = 8301927948889305299480981445298038817487602530230158851481344098749294196585;\n    uint256 constant PEDERSEN_G_Y_1 = 551589694187369368634779053507897402385062756812904326828804113502236084014;\n\n    // Pedersen GRootSigmaNeg point in G2 in powers of i\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_0 = 53088002417291775537396221051538852792197848029404100186591642007161959558;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_1 = 19597848842672933074920327560258496468956192541553850947563758766440996493825;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_0 = 21281875887759119483749454663188117767572918313930107894411064290445209611126;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_1 = 17821642346953516826973884048231142870757796204350980410923780265981668669722;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 11298226711337283265623225420392962314677983160850350677780306256965363185765;\n    uint256 constant CONSTANT_Y = 19390214609591030827409202807579621835341439761287131574418912055959718659320;\n    uint256 constant PUB_0_X = 4727097145600381236806120067307325398528191313491549634977635893644021683559;\n    uint256 constant PUB_0_Y = 11416361546466942010610812918915277800585013812287682943269895630397313718831;\n    uint256 constant PUB_1_X = 2047781801787210790592861692310046375079548499331683350083246018498450631793;\n    uint256 constant PUB_1_Y = 16027790840917191274906797614313124689470390247755734579711689514678588705211;\n    uint256 constant PUB_2_X = 3039595374727551288315942479059853256435422514515502555918406897265306383703;\n    uint256 constant PUB_2_Y = 946624788817616749061208863705590356042887026973746249130514096854398477352;\n    uint256 constant PUB_3_X = 15709547050805490599617595727091539700764579549235046736482096076662263101896;\n    uint256 constant PUB_3_Y = 16681093520223380980565245528725261820842770529145676901047654983389895283715;\n    uint256 constant PUB_4_X = 7194416977522373011498892601168884854908622535213901989498503901408707449288;\n    uint256 constant PUB_4_Y = 5424780462303510647845173136156091472328154741121247118686143152337934526278;\n    uint256 constant PUB_5_X = 12849770793102164046204718836242697731134077607861195978948765224911295139726;\n    uint256 constant PUB_5_Y = 17712002664714174793341340199425248738748949917478885917339103718039572768504;\n    uint256 constant PUB_6_X = 10055676369244820830413644682274790480176004878497730318485060809101201665500;\n    uint256 constant PUB_6_Y = 3892684337234939573729175222957138946216495163644321189142798681215468324629;\n    uint256 constant PUB_7_X = 19444660026385905296832289034106198244544978011357669627332830631858041575852;\n    uint256 constant PUB_7_Y = 1395506953562601961281229497383323023196617908979281282953781112293183016764;\n    uint256 constant PUB_8_X = 3589249598293801584017034223971150770827122339578275141251315121795895984278;\n    uint256 constant PUB_8_Y = 7477874028623432168804359929799228491761628203964820274549738291193101874108;\n    uint256 constant PUB_9_X = 14283258596850447985882708107497645287945627775297713821349003560770479546383;\n    uint256 constant PUB_9_Y = 842054409955375638287186478016001710940078223708979150795490581269581020258;\n\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(\n        uint256[9] memory input,\n        uint256 publicCommit,\n        uint256[2] memory commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s := mload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s := mload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_2_X)\n            mstore(add(g, 0x20), PUB_2_Y)\n            s := mload(add(input, 64))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_3_X)\n            mstore(add(g, 0x20), PUB_3_Y)\n            s := mload(add(input, 96))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_4_X)\n            mstore(add(g, 0x20), PUB_4_Y)\n            s := mload(add(input, 128))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_5_X)\n            mstore(add(g, 0x20), PUB_5_Y)\n            s := mload(add(input, 160))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_6_X)\n            mstore(add(g, 0x20), PUB_6_Y)\n\n            s := mload(add(input, 192))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_7_X)\n            mstore(add(g, 0x20), PUB_7_Y)\n\n            s := mload(add(input, 224))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_8_X)\n            mstore(add(g, 0x20), PUB_8_Y)\n\n            s := mload(add(input, 256))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_9_X)\n            mstore(add(g, 0x20), PUB_9_Y)\n\n            s := mload(add(input, 288))\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := mload(commit)\n            mstore(g, s) // save commit[0]\n            s := mload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Verify an uncompressed Groth16 proof.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\n    /// of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyProof(\n        uint256[8] memory proof,\n        uint256[2] memory commitment,\n        uint256[2] memory commitmentPOK,\n        uint256[9] memory input\n    ) public view returns (bool) {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commitment[0], commitment[1]))) % MOD_R;\n        (uint256 x, uint256 y) = publicInputMSM(input, inputFr, commitment);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n\n        uint256 a0 = proof[0];\n        uint256 a1 = proof[1];\n        uint256 b00 = proof[2];\n        uint256 b01 = proof[3];\n        uint256 b10 = proof[4];\n        uint256 b11 = proof[5];\n        uint256 c0 = proof[6];\n        uint256 c1 = proof[7];\n\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n        // Copy points (A, B, C) to memory. They are already in correct encoding.\n        // This is pairing e(A, B) and G1 of e(C, -δ).\n            mstore(f, a0)\n            mstore(add(f, 0x20), a1)\n            mstore(add(f, 0x40), b00)\n            mstore(add(f, 0x60), b01)\n            mstore(add(f, 0x80), b10)\n            mstore(add(f, 0xa0), b11)\n            mstore(add(f, 0xc0), c0)\n            mstore(add(f, 0xe0), c1)\n\n        // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n        // OPT: This could be better done using a single codecopy, but\n        //      Solidity (unlike standalone Yul) doesn't provide a way to\n        //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := mload(commitment)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := mload(add(commitment, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), PEDERSEN_G_Y_0)\n\n            c := mload(commitmentPOK)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := mload(add(commitmentPOK, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), PEDERSEN_GROOTSIGMANEG_X_1)\n            mstore(add(f, 0x420), PEDERSEN_GROOTSIGMANEG_X_0)\n            mstore(add(f, 0x440), PEDERSEN_GROOTSIGMANEG_Y_1)\n            mstore(add(f, 0x460), PEDERSEN_GROOTSIGMANEG_Y_0)\n\n        // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n        // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n        return success;\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/common/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IVerifier {\n    function verifyProof(\n        uint256[8] calldata proof,\n        uint256[2] calldata commit,\n        uint256[2] calldata knowledgeProof,\n        uint256[9] calldata input\n    ) external view returns (bool r);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}