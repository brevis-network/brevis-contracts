{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/external/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IDynamicFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\n\n/// @notice The dynamic fee manager determines fees for pools\n/// @dev note that this pool is only called if the PoolKey fee value is equal to the DYNAMIC_FEE magic value\ninterface IDynamicFeeManager {\n    function getFee(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata data)\n        external\n        returns (uint24);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IFees.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.19;\n\nimport {Currency} from \"../types/Currency.sol\";\n\ninterface IFees {\n    /// @notice Thrown when the protocol fee denominator is less than 4. Also thrown when the static or dynamic fee on a pool is exceeds 100%.\n    error FeeTooLarge();\n    /// @notice Thrown when not enough gas is provided to look up the protocol fee\n    error ProtocolFeeCannotBeFetched();\n\n    event ProtocolFeeControllerUpdated(address protocolFeeController);\n\n    /// @notice Returns the minimum denominator for the protocol fee, which restricts it to a maximum of 25%\n    function MIN_PROTOCOL_FEE_DENOMINATOR() external view returns (uint8);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    function protocolFeesAccrued(Currency) external view returns (uint256);\n\n    /// @notice Given a hook and a currency address, returns the fees accrued\n    function hookFeesAccrued(address, Currency) external view returns (uint256);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IHookFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\n/// @notice The interface for setting a fee on swap or fee on withdraw to the hook\n/// @dev This callback is only made if the Fee.HOOK_SWAP_FEE_FLAG or Fee.HOOK_WITHDRAW_FEE_FLAG in set in the pool's key.fee.\ninterface IHookFeeManager {\n    /// @notice Gets the fee a hook can take at swap/withdraw. Upper bits used for swap and lower bits for withdraw.\n    /// @param key The pool key\n    /// @return The hook fees for swapping (upper bits set) and withdrawing (lower bits set).\n    function getHookFees(PoolKey calldata key) external view returns (uint24);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IHooks.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\n\n/// @notice The PoolManager contract decides whether to invoke specific hooks by inspecting the leading bits\n/// of the hooks contract address. For example, a 1 bit in the first bit of the address will\n/// cause the 'before swap' hook to be invoked. See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(\n        address sender,\n        PoolKey calldata key,\n        uint160 sqrtPriceX96,\n        int24 tick,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before a position is modified\n    /// @param sender The initial msg.sender for the modify position call\n    /// @param key The key for the pool\n    /// @param params The parameters for modifying the position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeModifyPosition(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyPositionParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after a position is modified\n    /// @param sender The initial msg.sender for the modify position call\n    /// @param key The key for the pool\n    /// @param params The parameters for modifying the position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterModifyPosition(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyPositionParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the locker (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {Pool} from \"../libraries/Pool.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IHooks} from \"./IHooks.sol\";\nimport {IFees} from \"./IFees.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {Position} from \"../libraries/Position.sol\";\n\ninterface IPoolManager is IFees, IERC1155 {\n    /// @notice Thrown when currencies touched has exceeded max of 256\n    error MaxCurrenciesTouched();\n\n    /// @notice Thrown when a currency is not netted out after a lock\n    error CurrencyNotSettled();\n\n    /// @notice Thrown when a function is called by an address that is not the current locker\n    /// @param locker The current locker\n    error LockedBy(address locker);\n\n    /// @notice The ERC1155 being deposited is not the Uniswap ERC1155\n    error NotPoolManagerToken();\n\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n    error TickSpacingTooLarge();\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n    error TickSpacingTooSmall();\n\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n    error CurrenciesInitializedOutOfOrder();\n\n    /// @notice Emitted when a new pool is initialized\n    /// @param id The abi encoded hash of the pool key struct for the new pool\n    /// @param currency0 The first currency of the pool by address sort order\n    /// @param currency1 The second currency of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\n    event Initialize(\n        PoolId indexed id,\n        Currency indexed currency0,\n        Currency indexed currency1,\n        uint24 fee,\n        int24 tickSpacing,\n        IHooks hooks\n    );\n\n    /// @notice Emitted when a liquidity position is modified\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that modified the pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidityDelta The amount of liquidity that was added or removed\n    event ModifyPosition(\n        PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta\n    );\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param amount0 The delta of the currency0 balance of the pool\n    /// @param amount1 The delta of the currency1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        int128 amount0,\n        int128 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick,\n        uint24 fee\n    );\n\n    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFees);\n\n    event HookFeeUpdated(PoolId indexed id, uint24 hookFees);\n\n    /// @notice Returns the constant representing the maximum tickSpacing for an initialized pool key\n    function MAX_TICK_SPACING() external view returns (int24);\n\n    /// @notice Returns the constant representing the minimum tickSpacing for an initialized pool key\n    function MIN_TICK_SPACING() external view returns (int24);\n\n    /// @notice Get the current value in slot0 of the given pool\n    function getSlot0(PoolId id)\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees);\n\n    /// @notice Get the current value of liquidity of the given pool\n    function getLiquidity(PoolId id) external view returns (uint128 liquidity);\n\n    /// @notice Get the current value of liquidity for the specified pool and position\n    function getLiquidity(PoolId id, address owner, int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (uint128 liquidity);\n\n    /// @notice Get the position struct for a specified pool and position\n    function getPosition(PoolId id, address owner, int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (Position.Info memory position);\n\n    /// @notice Returns the reserves for a given ERC20 currency\n    function reservesOf(Currency currency) external view returns (uint256);\n\n    /// @notice Contains data about pool lockers.\n    struct LockData {\n        /// @notice The current number of active lockers\n        uint128 length;\n        /// @notice The total number of nonzero deltas over all active + completed lockers\n        uint128 nonzeroDeltaCount;\n    }\n\n    /// @notice Returns the locker in the ith position of the locker queue.\n    function getLock(uint256 i) external view returns (address locker);\n\n    /// @notice Returns lock data\n    function lockData() external view returns (uint128 length, uint128 nonzeroDeltaCount);\n\n    /// @notice Initialize the state for a given pool ID\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96, bytes calldata hookData)\n        external\n        returns (int24 tick);\n\n    /// @notice Get the current delta for a locker in the given currency\n    /// @param locker The address of the locker\n    /// @param currency The currency for which to lookup the delta\n    function currencyDelta(address locker, Currency currency) external view returns (int256);\n\n    /// @notice All operations go through this function\n    /// @param data Any data to pass to the callback, via `ILockCallback(msg.sender).lockCallback(data)`\n    /// @return The data returned by the call to `ILockCallback(msg.sender).lockCallback(data)`\n    function lock(bytes calldata data) external returns (bytes memory);\n\n    struct ModifyPositionParams {\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // how to modify the liquidity\n        int256 liquidityDelta;\n    }\n\n    /// @notice Modify the position for the given pool\n    function modifyPosition(PoolKey memory key, ModifyPositionParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    struct SwapParams {\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swap against the given pool\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Donate the given currency amounts to the pool with the given pool key\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Can also be used as a mechanism for _free_ flash loans\n    function take(Currency currency, address to, uint256 amount) external;\n\n    /// @notice Called by the user to move value into ERC1155 balance\n    function mint(Currency token, address to, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    function settle(Currency token) external payable returns (uint256 paid);\n\n    /// @notice Sets the protocol's swap and withdrawal fees for the given pool\n    /// Protocol fees are always a portion of a fee that is owed. If that underlying fee is 0, no protocol fees will accrue even if it is set to > 0.\n    function setProtocolFees(PoolKey memory key) external;\n\n    /// @notice Sets the hook's swap and withdrawal fees for the given pool\n    function setHookFees(PoolKey memory key) external;\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to sload\n    /// @return value The value of the slot as bytes32\n    function extsload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to start sloading from\n    /// @param nSlots Number of slots to load into return value\n    /// @return value The value of the sload-ed slots concatenated as dynamic bytes\n    function extsload(bytes32 slot, uint256 nSlots) external view returns (bytes memory value);\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            if (x >= 0x100000000000000000000000000000000) {\n                x >>= 128;\n                r += 128;\n            }\n            if (x >= 0x10000000000000000) {\n                x >>= 64;\n                r += 64;\n            }\n            if (x >= 0x100000000) {\n                x >>= 32;\n                r += 32;\n            }\n            if (x >= 0x10000) {\n                x >>= 16;\n                r += 16;\n            }\n            if (x >= 0x100) {\n                x >>= 8;\n                r += 8;\n            }\n            if (x >= 0x10) {\n                x >>= 4;\n                r += 4;\n            }\n            if (x >= 0x4) {\n                x >>= 2;\n                r += 2;\n            }\n            if (x >= 0x2) r += 1;\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            r = 255;\n            if (x & type(uint128).max > 0) {\n                r -= 128;\n            } else {\n                x >>= 128;\n            }\n            if (x & type(uint64).max > 0) {\n                r -= 64;\n            } else {\n                x >>= 64;\n            }\n            if (x & type(uint32).max > 0) {\n                r -= 32;\n            } else {\n                x >>= 32;\n            }\n            if (x & type(uint16).max > 0) {\n                r -= 16;\n            } else {\n                x >>= 16;\n            }\n            if (x & type(uint8).max > 0) {\n                r -= 8;\n            } else {\n                x >>= 8;\n            }\n            if (x & 0xf > 0) {\n                r -= 4;\n            } else {\n                x >>= 4;\n            }\n            if (x & 0x3 > 0) {\n                r -= 2;\n            } else {\n                x >>= 2;\n            }\n            if (x & 0x1 > 0) r -= 1;\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/FeeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nlibrary FeeLibrary {\n    uint24 public constant STATIC_FEE_MASK = 0x0FFFFF;\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000; // 1000\n    uint24 public constant HOOK_SWAP_FEE_FLAG = 0x400000; // 0100\n    uint24 public constant HOOK_WITHDRAW_FEE_FLAG = 0x200000; // 0010\n\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\n        return self & DYNAMIC_FEE_FLAG != 0;\n    }\n\n    function hasHookSwapFee(uint24 self) internal pure returns (bool) {\n        return self & HOOK_SWAP_FEE_FLAG != 0;\n    }\n\n    function hasHookWithdrawFee(uint24 self) internal pure returns (bool) {\n        return self & HOOK_WITHDRAW_FEE_FLAG != 0;\n    }\n\n    function isStaticFeeTooLarge(uint24 self) internal pure returns (bool) {\n        return self & STATIC_FEE_MASK >= 1000000;\n    }\n\n    function getStaticFee(uint24 self) internal pure returns (uint24) {\n        return self & STATIC_FEE_MASK;\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/FixedPoint128.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/Hooks.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {FeeLibrary} from \"../libraries/FeeLibrary.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the leading bits of the address that\n/// the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x9000000000000000000000000000000000000000\n/// has leading bits '1001' which would cause the 'before initialize' and 'after modify position' hooks to be used.\nlibrary Hooks {\n    using FeeLibrary for uint24;\n\n    uint256 internal constant BEFORE_INITIALIZE_FLAG = 1 << 159;\n    uint256 internal constant AFTER_INITIALIZE_FLAG = 1 << 158;\n    uint256 internal constant BEFORE_MODIFY_POSITION_FLAG = 1 << 157;\n    uint256 internal constant AFTER_MODIFY_POSITION_FLAG = 1 << 156;\n    uint256 internal constant BEFORE_SWAP_FLAG = 1 << 155;\n    uint256 internal constant AFTER_SWAP_FLAG = 1 << 154;\n    uint256 internal constant BEFORE_DONATE_FLAG = 1 << 153;\n    uint256 internal constant AFTER_DONATE_FLAG = 1 << 152;\n\n    struct Calls {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeModifyPosition;\n        bool afterModifyPosition;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n    }\n\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\n    /// @param hooks The address of the hooks contract\n    error HookAddressNotValid(address hooks);\n\n    /// @notice Hook did not return its selector\n    error InvalidHookResponse();\n\n    /// @notice Utility function intended to be used in hook constructors to ensure\n    /// the deployed hooks address causes the intended hooks to be called\n    /// @param calls The hooks that are intended to be called\n    /// @dev calls param is memory as the function will be called from constructors\n    function validateHookAddress(IHooks self, Calls memory calls) internal pure {\n        if (\n            calls.beforeInitialize != shouldCallBeforeInitialize(self)\n                || calls.afterInitialize != shouldCallAfterInitialize(self)\n                || calls.beforeModifyPosition != shouldCallBeforeModifyPosition(self)\n                || calls.afterModifyPosition != shouldCallAfterModifyPosition(self)\n                || calls.beforeSwap != shouldCallBeforeSwap(self) || calls.afterSwap != shouldCallAfterSwap(self)\n                || calls.beforeDonate != shouldCallBeforeDonate(self) || calls.afterDonate != shouldCallAfterDonate(self)\n        ) {\n            revert HookAddressNotValid(address(self));\n        }\n    }\n\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\n    /// @param hook The hook to verify\n    function isValidHookAddress(IHooks hook, uint24 fee) internal pure returns (bool) {\n        // If there is no hook contract set, then fee cannot be dynamic and there cannot be a hook fee on swap or withdrawal.\n        return address(hook) == address(0)\n            ? !fee.isDynamicFee() && !fee.hasHookSwapFee() && !fee.hasHookWithdrawFee()\n            : (\n                uint160(address(hook)) >= AFTER_DONATE_FLAG || fee.isDynamicFee() || fee.hasHookSwapFee()\n                    || fee.hasHookWithdrawFee()\n            );\n    }\n\n    function shouldCallBeforeInitialize(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_INITIALIZE_FLAG != 0;\n    }\n\n    function shouldCallAfterInitialize(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_INITIALIZE_FLAG != 0;\n    }\n\n    function shouldCallBeforeModifyPosition(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_MODIFY_POSITION_FLAG != 0;\n    }\n\n    function shouldCallAfterModifyPosition(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_MODIFY_POSITION_FLAG != 0;\n    }\n\n    function shouldCallBeforeSwap(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_SWAP_FLAG != 0;\n    }\n\n    function shouldCallAfterSwap(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_SWAP_FLAG != 0;\n    }\n\n    function shouldCallBeforeDonate(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_DONATE_FLAG != 0;\n    }\n\n    function shouldCallAfterDonate(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_DONATE_FLAG != 0;\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {TickBitmap} from \"./TickBitmap.sol\";\nimport {Position} from \"./Position.sol\";\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\nimport {SwapMath} from \"./SwapMath.sol\";\nimport {BalanceDelta, toBalanceDelta} from \"../types/BalanceDelta.sol\";\n\nlibrary Pool {\n    using SafeCast for *;\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => Position.Info);\n    using Position for Position.Info;\n\n    /// @notice Thrown when tickLower is not below tickUpper\n    /// @param tickLower The invalid tickLower\n    /// @param tickUpper The invalid tickUpper\n    error TicksMisordered(int24 tickLower, int24 tickUpper);\n\n    /// @notice Thrown when tickLower is less than min tick\n    /// @param tickLower The invalid tickLower\n    error TickLowerOutOfBounds(int24 tickLower);\n\n    /// @notice Thrown when tickUpper exceeds max tick\n    /// @param tickUpper The invalid tickUpper\n    error TickUpperOutOfBounds(int24 tickUpper);\n\n    /// @notice For the tick spacing, the tick has too much liquidity\n    error TickLiquidityOverflow(int24 tick);\n\n    /// @notice Thrown when interacting with an uninitialized tick that must be initialized\n    /// @param tick The uninitialized tick\n    error TickNotInitialized(int24 tick);\n\n    /// @notice Thrown when trying to initalize an already initialized pool\n    error PoolAlreadyInitialized();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    /// @notice Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit\n    /// @param sqrtPriceCurrentX96 The invalid, already surpassed sqrtPriceLimitX96\n    /// @param sqrtPriceLimitX96 The surpassed price limit\n    error PriceLimitAlreadyExceeded(uint160 sqrtPriceCurrentX96, uint160 sqrtPriceLimitX96);\n\n    /// @notice Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range\n    /// @param sqrtPriceLimitX96 The invalid, out-of-bounds sqrtPriceLimitX96\n    error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);\n\n    /// @notice Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers\n    error NoLiquidityToReceiveFees();\n\n    /// Each uint24 variable packs both the swap fees and the withdraw fees represented as integer denominators (1/x). The upper 12 bits are the swap fees, and the lower 12 bits\n    /// are the withdraw fees. For swap fees, the upper 6 bits are the fee for trading 1 for 0, and the lower 6 are for 0 for 1 and are taken as a percentage of the lp swap fee.\n    /// For withdraw fees the upper 6 bits are the fee on amount1, and the lower 6 are for amount0 and are taken as a percentage of the principle amount of the underlying position.\n    /// bits          24 22 20 18 16 14 12 10 8  6  4  2  0\n    ///               |    swapFees     |   withdrawFees  |\n    ///               ┌────────┬────────┬────────┬────────┐\n    /// protocolFees: | 1->0   |  0->1  |  fee1  |  fee0  |\n    /// hookFees:     | 1->0   |  0->1  |  fee1  |  fee0  |\n    ///               └────────┴────────┴────────┴────────┘\n    struct Slot0 {\n        // the current price\n        uint160 sqrtPriceX96;\n        // the current tick\n        int24 tick;\n        uint24 protocolFees;\n        uint24 hookFees;\n    }\n    // 24 bits left!\n\n    // info stored for each initialized individual tick\n    struct TickInfo {\n        // the total position liquidity that references this tick\n        uint128 liquidityGross;\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n        int128 liquidityNet;\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint256 feeGrowthOutside0X128;\n        uint256 feeGrowthOutside1X128;\n    }\n\n    /// @dev The state of a pool\n    struct State {\n        Slot0 slot0;\n        uint256 feeGrowthGlobal0X128;\n        uint256 feeGrowthGlobal1X128;\n        uint128 liquidity;\n        mapping(int24 => TickInfo) ticks;\n        mapping(int16 => uint256) tickBitmap;\n        mapping(bytes32 => Position.Info) positions;\n    }\n\n    /// @dev Common checks for valid tick inputs.\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        if (tickLower >= tickUpper) revert TicksMisordered(tickLower, tickUpper);\n        if (tickLower < TickMath.MIN_TICK) revert TickLowerOutOfBounds(tickLower);\n        if (tickUpper > TickMath.MAX_TICK) revert TickUpperOutOfBounds(tickUpper);\n    }\n\n    function initialize(State storage self, uint160 sqrtPriceX96, uint24 protocolFees, uint24 hookFees)\n        internal\n        returns (int24 tick)\n    {\n        if (self.slot0.sqrtPriceX96 != 0) revert PoolAlreadyInitialized();\n\n        tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n\n        self.slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick, protocolFees: protocolFees, hookFees: hookFees});\n    }\n\n    function getSwapFee(uint24 feesStorage) internal pure returns (uint16) {\n        return uint16(feesStorage >> 12);\n    }\n\n    function getWithdrawFee(uint24 feesStorage) internal pure returns (uint16) {\n        return uint16(feesStorage & 0xFFF);\n    }\n\n    function setProtocolFees(State storage self, uint24 protocolFees) internal {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        self.slot0.protocolFees = protocolFees;\n    }\n\n    function setHookFees(State storage self, uint24 hookFees) internal {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        self.slot0.hookFees = hookFees;\n    }\n\n    struct ModifyPositionParams {\n        // the address that owns the position\n        address owner;\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // any change in liquidity\n        int128 liquidityDelta;\n        // the spacing between ticks\n        int24 tickSpacing;\n    }\n\n    struct ModifyPositionState {\n        bool flippedLower;\n        uint128 liquidityGrossAfterLower;\n        bool flippedUpper;\n        uint128 liquidityGrossAfterUpper;\n        uint256 feeGrowthInside0X128;\n        uint256 feeGrowthInside1X128;\n    }\n\n    struct FeeAmounts {\n        uint256 feeForProtocol0;\n        uint256 feeForProtocol1;\n        uint256 feeForHook0;\n        uint256 feeForHook1;\n    }\n\n    /// @dev Effect changes to a position in a pool\n    /// @param params the position details and the change to the position's liquidity to effect\n    /// @return result the deltas of the token balances of the pool\n    function modifyPosition(State storage self, ModifyPositionParams memory params)\n        internal\n        returns (BalanceDelta result, FeeAmounts memory fees)\n    {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        checkTicks(params.tickLower, params.tickUpper);\n\n        uint256 feesOwed0;\n        uint256 feesOwed1;\n        {\n            ModifyPositionState memory state;\n            // if we need to update the ticks, do it\n\n            if (params.liquidityDelta != 0) {\n                (state.flippedLower, state.liquidityGrossAfterLower) =\n                    updateTick(self, params.tickLower, params.liquidityDelta, false);\n                (state.flippedUpper, state.liquidityGrossAfterUpper) =\n                    updateTick(self, params.tickUpper, params.liquidityDelta, true);\n\n                if (params.liquidityDelta > 0) {\n                    uint128 maxLiquidityPerTick = tickSpacingToMaxLiquidityPerTick(params.tickSpacing);\n                    if (state.liquidityGrossAfterLower > maxLiquidityPerTick) {\n                        revert TickLiquidityOverflow(params.tickLower);\n                    }\n                    if (state.liquidityGrossAfterUpper > maxLiquidityPerTick) {\n                        revert TickLiquidityOverflow(params.tickUpper);\n                    }\n                }\n\n                if (state.flippedLower) {\n                    self.tickBitmap.flipTick(params.tickLower, params.tickSpacing);\n                }\n                if (state.flippedUpper) {\n                    self.tickBitmap.flipTick(params.tickUpper, params.tickSpacing);\n                }\n            }\n\n            (state.feeGrowthInside0X128, state.feeGrowthInside1X128) =\n                getFeeGrowthInside(self, params.tickLower, params.tickUpper);\n\n            (feesOwed0, feesOwed1) = self.positions.get(params.owner, params.tickLower, params.tickUpper).update(\n                params.liquidityDelta, state.feeGrowthInside0X128, state.feeGrowthInside1X128\n            );\n\n            // clear any tick data that is no longer needed\n            if (params.liquidityDelta < 0) {\n                if (state.flippedLower) {\n                    clearTick(self, params.tickLower);\n                }\n                if (state.flippedUpper) {\n                    clearTick(self, params.tickUpper);\n                }\n            }\n        }\n\n        if (params.liquidityDelta != 0) {\n            if (self.slot0.tick < params.tickLower) {\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\n                // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it\n                result = result\n                    + toBalanceDelta(\n                        SqrtPriceMath.getAmount0Delta(\n                            TickMath.getSqrtRatioAtTick(params.tickLower),\n                            TickMath.getSqrtRatioAtTick(params.tickUpper),\n                            params.liquidityDelta\n                        ).toInt128(),\n                        0\n                    );\n            } else if (self.slot0.tick < params.tickUpper) {\n                result = result\n                    + toBalanceDelta(\n                        SqrtPriceMath.getAmount0Delta(\n                            self.slot0.sqrtPriceX96, TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta\n                        ).toInt128(),\n                        SqrtPriceMath.getAmount1Delta(\n                            TickMath.getSqrtRatioAtTick(params.tickLower), self.slot0.sqrtPriceX96, params.liquidityDelta\n                        ).toInt128()\n                    );\n\n                self.liquidity = params.liquidityDelta < 0\n                    ? self.liquidity - uint128(-params.liquidityDelta)\n                    : self.liquidity + uint128(params.liquidityDelta);\n            } else {\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\n                // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it\n                result = result\n                    + toBalanceDelta(\n                        0,\n                        SqrtPriceMath.getAmount1Delta(\n                            TickMath.getSqrtRatioAtTick(params.tickLower),\n                            TickMath.getSqrtRatioAtTick(params.tickUpper),\n                            params.liquidityDelta\n                        ).toInt128()\n                    );\n            }\n        }\n\n        if (params.liquidityDelta < 0 && getWithdrawFee(self.slot0.hookFees) > 0) {\n            // Only take fees if the hook withdraw fee is set and the liquidity is being removed.\n            fees = _calculateExternalFees(self, result);\n\n            // Amounts are balances owed to the pool. When negative, they represent the balance a user can take.\n            // Since protocol and hook fees are extracted on the balance a user can take\n            // they are owed (added) back to the pool where they are kept to be collected by the fee recipients.\n            result = result\n                + toBalanceDelta(\n                    fees.feeForHook0.toInt128() + fees.feeForProtocol0.toInt128(),\n                    fees.feeForHook1.toInt128() + fees.feeForProtocol1.toInt128()\n                );\n        }\n\n        // Fees earned from LPing are removed from the pool balance.\n        result = result - toBalanceDelta(feesOwed0.toInt128(), feesOwed1.toInt128());\n    }\n\n    function _calculateExternalFees(State storage self, BalanceDelta result)\n        internal\n        view\n        returns (FeeAmounts memory fees)\n    {\n        int128 amount0 = result.amount0();\n        int128 amount1 = result.amount1();\n\n        Slot0 memory slot0Cache = self.slot0;\n        uint24 hookFees = slot0Cache.hookFees;\n        uint24 protocolFees = slot0Cache.protocolFees;\n\n        uint16 hookFee0 = getWithdrawFee(hookFees) % 64;\n        uint16 hookFee1 = getWithdrawFee(hookFees) >> 6;\n\n        uint16 protocolFee0 = getWithdrawFee(protocolFees) % 64;\n        uint16 protocolFee1 = getWithdrawFee(protocolFees) >> 6;\n\n        if (amount0 < 0 && hookFee0 > 0) {\n            fees.feeForHook0 = uint128(-amount0) / hookFee0;\n        }\n        if (amount1 < 0 && hookFee1 > 0) {\n            fees.feeForHook1 = uint128(-amount1) / hookFee1;\n        }\n\n        // A protocol fee is only applied if the hook fee is applied.\n        if (protocolFee0 > 0 && fees.feeForHook0 > 0) {\n            fees.feeForProtocol0 = fees.feeForHook0 / protocolFee0;\n            fees.feeForHook0 -= fees.feeForProtocol0;\n        }\n\n        if (protocolFee1 > 0 && fees.feeForHook1 > 0) {\n            fees.feeForProtocol1 = fees.feeForHook1 / protocolFee1;\n            fees.feeForHook1 -= fees.feeForProtocol1;\n        }\n\n        return fees;\n    }\n\n    struct SwapCache {\n        // liquidity at the beginning of the swap\n        uint128 liquidityStart;\n        // the protocol fee for the input token\n        uint16 protocolFee;\n        // the hook fee for the input token\n        uint16 hookFee;\n    }\n\n    // the top level state of the swap, the results of which are recorded in storage at the end\n    struct SwapState {\n        // the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        // the amount already swapped out/in of the output/input asset\n        int256 amountCalculated;\n        // current sqrt(price)\n        uint160 sqrtPriceX96;\n        // the tick associated with the current price\n        int24 tick;\n        // the global fee growth of the input token\n        uint256 feeGrowthGlobalX128;\n        // the current liquidity in range\n        uint128 liquidity;\n    }\n\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint160 sqrtPriceStartX96;\n        // the next tick to swap to from the current tick in the swap direction\n        int24 tickNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // sqrt(price) for the next tick (1/0)\n        uint160 sqrtPriceNextX96;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n    }\n\n    struct SwapParams {\n        uint24 fee;\n        int24 tickSpacing;\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @dev Executes a swap against the state, and returns the amount deltas of the pool\n    function swap(State storage self, SwapParams memory params)\n        internal\n        returns (BalanceDelta result, uint256 feeForProtocol, uint256 feeForHook, SwapState memory state)\n    {\n        if (params.amountSpecified == 0) revert SwapAmountCannotBeZero();\n\n        Slot0 memory slot0Start = self.slot0;\n        if (slot0Start.sqrtPriceX96 == 0) revert PoolNotInitialized();\n        if (params.zeroForOne) {\n            if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96) {\n                revert PriceLimitAlreadyExceeded(slot0Start.sqrtPriceX96, params.sqrtPriceLimitX96);\n            }\n            if (params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_RATIO) {\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\n            }\n        } else {\n            if (params.sqrtPriceLimitX96 <= slot0Start.sqrtPriceX96) {\n                revert PriceLimitAlreadyExceeded(slot0Start.sqrtPriceX96, params.sqrtPriceLimitX96);\n            }\n            if (params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_RATIO) {\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\n            }\n        }\n\n        SwapCache memory cache = SwapCache({\n            liquidityStart: self.liquidity,\n            protocolFee: params.zeroForOne\n                ? (getSwapFee(slot0Start.protocolFees) % 64)\n                : (getSwapFee(slot0Start.protocolFees) >> 6),\n            hookFee: params.zeroForOne ? (getSwapFee(slot0Start.hookFees) % 64) : (getSwapFee(slot0Start.hookFees) >> 6)\n        });\n\n        bool exactInput = params.amountSpecified > 0;\n\n        state = SwapState({\n            amountSpecifiedRemaining: params.amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            feeGrowthGlobalX128: params.zeroForOne ? self.feeGrowthGlobal0X128 : self.feeGrowthGlobal1X128,\n            liquidity: cache.liquidityStart\n        });\n\n        StepComputations memory step;\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != params.sqrtPriceLimitX96) {\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) =\n                self.tickBitmap.nextInitializedTickWithinOneWord(state.tick, params.tickSpacing, params.zeroForOne);\n\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            } else if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            // get the price for the next tick\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n                state.sqrtPriceX96,\n                (\n                    params.zeroForOne\n                        ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96\n                        : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96\n                ) ? params.sqrtPriceLimitX96 : step.sqrtPriceNextX96,\n                state.liquidity,\n                state.amountSpecifiedRemaining,\n                params.fee\n            );\n\n            if (exactInput) {\n                // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\n                unchecked {\n                    state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\n                }\n                state.amountCalculated = state.amountCalculated - step.amountOut.toInt256();\n            } else {\n                unchecked {\n                    state.amountSpecifiedRemaining += step.amountOut.toInt256();\n                }\n                state.amountCalculated = state.amountCalculated + (step.amountIn + step.feeAmount).toInt256();\n            }\n\n            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n            if (cache.protocolFee > 0) {\n                // A: calculate the amount of the fee that should go to the protocol\n                uint256 delta = step.feeAmount / cache.protocolFee;\n                // A: subtract it from the regular fee and add it to the protocol fee\n                unchecked {\n                    step.feeAmount -= delta;\n                    feeForProtocol += delta;\n                }\n            }\n\n            if (cache.hookFee > 0) {\n                // step.feeAmount has already been updated to account for the protocol fee\n                uint256 delta = step.feeAmount / cache.hookFee;\n                unchecked {\n                    step.feeAmount -= delta;\n                    feeForHook += delta;\n                }\n            }\n\n            // update global fee tracker\n            if (state.liquidity > 0) {\n                unchecked {\n                    state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\n                }\n            }\n\n            // shift tick if we reached the next price\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                // if the tick is initialized, run the tick transition\n                if (step.initialized) {\n                    int128 liquidityNet = Pool.crossTick(\n                        self,\n                        step.tickNext,\n                        (params.zeroForOne ? state.feeGrowthGlobalX128 : self.feeGrowthGlobal0X128),\n                        (params.zeroForOne ? self.feeGrowthGlobal1X128 : state.feeGrowthGlobalX128)\n                    );\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\n                    // safe because liquidityNet cannot be type(int128).min\n                    unchecked {\n                        if (params.zeroForOne) liquidityNet = -liquidityNet;\n                    }\n\n                    state.liquidity = liquidityNet < 0\n                        ? state.liquidity - uint128(-liquidityNet)\n                        : state.liquidity + uint128(liquidityNet);\n                }\n\n                unchecked {\n                    state.tick = params.zeroForOne ? step.tickNext - 1 : step.tickNext;\n                }\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        (self.slot0.sqrtPriceX96, self.slot0.tick) = (state.sqrtPriceX96, state.tick);\n\n        // update liquidity if it changed\n        if (cache.liquidityStart != state.liquidity) self.liquidity = state.liquidity;\n\n        // update fee growth global\n        if (params.zeroForOne) {\n            self.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n        } else {\n            self.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n        }\n\n        unchecked {\n            if (params.zeroForOne == exactInput) {\n                result = toBalanceDelta(\n                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128(),\n                    state.amountCalculated.toInt128()\n                );\n            } else {\n                result = toBalanceDelta(\n                    state.amountCalculated.toInt128(),\n                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128()\n                );\n            }\n        }\n    }\n\n    /// @notice Donates the given amount of currency0 and currency1 to the pool\n    function donate(State storage state, uint256 amount0, uint256 amount1) internal returns (BalanceDelta delta) {\n        if (state.liquidity == 0) revert NoLiquidityToReceiveFees();\n        delta = toBalanceDelta(amount0.toInt128(), amount1.toInt128());\n        unchecked {\n            if (amount0 > 0) {\n                state.feeGrowthGlobal0X128 += FullMath.mulDiv(amount0, FixedPoint128.Q128, state.liquidity);\n            }\n            if (amount1 > 0) {\n                state.feeGrowthGlobal1X128 += FullMath.mulDiv(amount1, FixedPoint128.Q128, state.liquidity);\n            }\n        }\n    }\n\n    /// @notice Retrieves fee growth data\n    /// @param self The Pool state struct\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function getFeeGrowthInside(State storage self, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\n    {\n        TickInfo storage lower = self.ticks[tickLower];\n        TickInfo storage upper = self.ticks[tickUpper];\n        int24 tickCurrent = self.slot0.tick;\n\n        unchecked {\n            if (tickCurrent < tickLower) {\n                feeGrowthInside0X128 = lower.feeGrowthOutside0X128 - upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 = lower.feeGrowthOutside1X128 - upper.feeGrowthOutside1X128;\n            } else if (tickCurrent >= tickUpper) {\n                feeGrowthInside0X128 = upper.feeGrowthOutside0X128 - lower.feeGrowthOutside0X128;\n                feeGrowthInside1X128 = upper.feeGrowthOutside1X128 - lower.feeGrowthOutside1X128;\n            } else {\n                feeGrowthInside0X128 =\n                    self.feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128 - upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    self.feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128 - upper.feeGrowthOutside1X128;\n            }\n        }\n    }\n\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The tick that will be updated\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n    /// @return liquidityGrossAfter The total amount of  liquidity for all positions that references the tick after the update\n    function updateTick(State storage self, int24 tick, int128 liquidityDelta, bool upper)\n        internal\n        returns (bool flipped, uint128 liquidityGrossAfter)\n    {\n        TickInfo storage info = self.ticks[tick];\n\n        uint128 liquidityGrossBefore;\n        int128 liquidityNetBefore;\n        assembly {\n            // load first slot of info which contains liquidityGross and liquidityNet packed\n            // where the top 128 bits are liquidityNet and the bottom 128 bits are liquidityGross\n            let liquidity := sload(info.slot)\n            // slice off top 128 bits of liquidity (liquidityNet) to get just liquidityGross\n            liquidityGrossBefore := shr(128, shl(128, liquidity))\n            // shift right 128 bits to get just liquidityNet\n            liquidityNetBefore := shr(128, liquidity)\n        }\n\n        liquidityGrossAfter = liquidityDelta < 0\n            ? liquidityGrossBefore - uint128(-liquidityDelta)\n            : liquidityGrossBefore + uint128(liquidityDelta);\n\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n        if (liquidityGrossBefore == 0) {\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n            if (tick <= self.slot0.tick) {\n                info.feeGrowthOutside0X128 = self.feeGrowthGlobal0X128;\n                info.feeGrowthOutside1X128 = self.feeGrowthGlobal1X128;\n            }\n        }\n\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n        int128 liquidityNet = upper ? liquidityNetBefore - liquidityDelta : liquidityNetBefore + liquidityDelta;\n        assembly {\n            // liquidityGrossAfter and liquidityNet are packed in the first slot of `info`\n            // So we can store them with a single sstore by packing them ourselves first\n            sstore(\n                info.slot,\n                // bitwise OR to pack liquidityGrossAfter and liquidityNet\n                or(\n                    // liquidityGross is in the low bits, upper bits are already 0\n                    liquidityGrossAfter,\n                    // shift liquidityNet to take the upper bits and lower bits get filled with 0\n                    shl(128, liquidityNet)\n                )\n            )\n        }\n    }\n\n    /// @notice Derives max liquidity per tick from given tick spacing\n    /// @dev Executed within the pool constructor\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n    /// @return The max liquidity per tick\n    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {\n        unchecked {\n            return uint128(\n                (type(uint128).max * uint256(int256(tickSpacing)))\n                    / uint256(int256(TickMath.MAX_TICK * 2 + tickSpacing))\n            );\n        }\n    }\n\n    /// @notice Clears tick data\n    /// @param self The mapping containing all initialized tick information for initialized ticks\n    /// @param tick The tick that will be cleared\n    function clearTick(State storage self, int24 tick) internal {\n        delete self.ticks[tick];\n    }\n\n    /// @notice Transitions to next tick as needed by price movement\n    /// @param self The Pool state struct\n    /// @param tick The destination tick of the transition\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n    function crossTick(State storage self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128)\n        internal\n        returns (int128 liquidityNet)\n    {\n        unchecked {\n            TickInfo storage info = self.ticks[tick];\n            info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;\n            info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;\n            liquidityNet = info.liquidityNet;\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/Position.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\n\n/// @title Position\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\n/// @dev Positions store additional state for tracking fees owed to the position\nlibrary Position {\n    /// @notice Cannot update a position with no liquidity\n    error CannotUpdateEmptyPosition();\n\n    // info stored for each user's position\n    struct Info {\n        // the amount of liquidity owned by this position\n        uint128 liquidity;\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n    }\n\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\n    /// @param self The mapping containing all user positions\n    /// @param owner The address of the position owner\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return position The position info struct of the given owners' position\n    function get(mapping(bytes32 => Info) storage self, address owner, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (Position.Info storage position)\n    {\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\n    }\n\n    /// @notice Credits accumulated fees to a user's position\n    /// @param self The individual position to update\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\n    /// @param feeGrowthInside0X128 The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries\n    /// @param feeGrowthInside1X128 The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries\n    /// @return feesOwed0 The amount of currency0 owed to the position owner\n    /// @return feesOwed1 The amount of currency1 owed to the position owner\n    function update(\n        Info storage self,\n        int128 liquidityDelta,\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128\n    ) internal returns (uint256 feesOwed0, uint256 feesOwed1) {\n        Info memory _self = self;\n\n        uint128 liquidityNext;\n        if (liquidityDelta == 0) {\n            if (_self.liquidity == 0) revert CannotUpdateEmptyPosition(); // disallow pokes for 0 liquidity positions\n            liquidityNext = _self.liquidity;\n        } else {\n            liquidityNext = liquidityDelta < 0\n                ? _self.liquidity - uint128(-liquidityDelta)\n                : _self.liquidity + uint128(liquidityDelta);\n        }\n\n        // calculate accumulated fees. overflow in the subtraction of fee growth is expected\n        unchecked {\n            feesOwed0 = FullMath.mulDiv(\n                feeGrowthInside0X128 - _self.feeGrowthInside0LastX128, _self.liquidity, FixedPoint128.Q128\n            );\n            feesOwed1 = FullMath.mulDiv(\n                feeGrowthInside1X128 - _self.feeGrowthInside1LastX128, _self.liquidity, FixedPoint128.Q128\n            );\n        }\n\n        // update the position\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y <= uint256(type(int256).max));\n        z = int256(y);\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(uint256 y) internal pure returns (int128 z) {\n        require(y <= uint128(type(int128).max));\n        z = int128(int256(y));\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/SqrtPriceMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {UnsafeMath} from \"./UnsafeMath.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of currency0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of currency0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product;\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1) {\n                        // always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                    }\n                }\n            }\n            // denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of currency1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of currency1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            return uint160(sqrtPX96 - quotient);\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\n    /// @return sqrtQX96 The price after adding the input amount to currency0 or currency1\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\n        internal\n        pure\n        returns (uint160 sqrtQX96)\n    {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\n    /// @param zeroForOne Whether the amount out is currency0 or currency1\n    /// @return sqrtQX96 The price after removing the output amount of currency0 or currency1\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\n        internal\n        pure\n        returns (uint160 sqrtQX96)\n    {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of currency0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount0)\n    {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n            require(sqrtRatioAX96 > 0);\n\n            return roundUp\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), sqrtRatioAX96)\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return roundUp\n            ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n            : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Helper that gets signed currency0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256 amount0)\n    {\n        unchecked {\n            return liquidity < 0\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed currency1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256 amount1)\n    {\n        unchecked {\n            return liquidity < 0\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/SwapMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\n        unchecked {\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n            bool exactIn = amountRemaining >= 0;\n\n            if (exactIn) {\n                uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n                if (amountRemainingLessFee >= amountIn) {\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\n                } else {\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                        sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne\n                    );\n                }\n            } else {\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n                if (uint256(-amountRemaining) >= amountOut) {\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\n                } else {\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                        sqrtRatioCurrentX96, liquidity, uint256(-amountRemaining), zeroForOne\n                    );\n                }\n            }\n\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n            // get the input/output amounts\n            if (zeroForOne) {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n            } else {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n            }\n\n            // cap the output amount to not exceed the remaining output amount\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\n                amountOut = uint256(-amountRemaining);\n            }\n\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n                // we didn't reach the target, so take the remainder of the maximum input as fee\n                feeAmount = uint256(amountRemaining) - amountIn;\n            } else {\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/TickBitmap.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n    /// @notice Thrown when the tick is not enumerated by the tick spacing\n    /// @param tick the invalid tick\n    /// @param tickSpacing The tick spacing of the pool\n    error TickMisaligned(int24 tick, int24 tickSpacing);\n\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\n        unchecked {\n            wordPos = int16(tick >> 8);\n            bitPos = uint8(int8(tick % 256));\n        }\n    }\n\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n    /// @param self The mapping in which to flip the tick\n    /// @param tick The tick to flip\n    /// @param tickSpacing The spacing between usable ticks\n    function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal {\n        unchecked {\n            if (tick % tickSpacing != 0) revert TickMisaligned(tick, tickSpacing); // ensure that the tick is spaced\n            (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\n            uint256 mask = 1 << bitPos;\n            self[wordPos] ^= mask;\n        }\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param self The mapping in which to compute the next initialized tick\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) internal view returns (int24 next, bool initialized) {\n        unchecked {\n            int24 compressed = tick / tickSpacing;\n            if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n            if (lte) {\n                (int16 wordPos, uint8 bitPos) = position(compressed);\n                // all the 1s at or to the right of the current bitPos\n                uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\n                    : (compressed - int24(uint24(bitPos))) * tickSpacing;\n            } else {\n                // start from the word of the next tick, since the current tick state doesn't matter\n                (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n                // all the 1s at or to the left of the bitPos\n                uint256 mask = ~((1 << bitPos) - 1);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\n                    : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @notice Thrown when the tick passed to #getSqrtRatioAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick();\n    /// @notice Thrown when the ratio passed to #getTickAtSqrtRatio does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtRatio();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert InvalidTick();\n\n            uint256 ratio =\n                absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert InvalidSqrtRatio();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            assembly {\n                z := add(div(x, y), gt(mod(x, y), 0))\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/types/BalanceDelta.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        balanceDelta :=\n            or(shl(128, _amount0), and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff, _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    return toBalanceDelta(a.amount0() + b.amount0(), a.amount1() + b.amount1());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    return toBalanceDelta(a.amount0() - b.amount0(), a.amount1() - b.amount1());\n}\n\nlibrary BalanceDeltaLibrary {\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            _amount0 := shr(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            _amount1 := balanceDelta\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/types/Currency.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, equals as ==} for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    using CurrencyLibrary for Currency;\n\n    /// @notice Thrown when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Thrown when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    Currency public constant NATIVE = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // implementation from\n        // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\n\n        bool success;\n        if (currency.isNative()) {\n            assembly {\n                // Transfer the ETH and store if it succeeded or not.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n\n            if (!success) revert NativeTransferFailed();\n        } else {\n            assembly {\n                // We'll write our calldata to this slot below, but restore it later.\n                let memPointer := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(4, to) // Append the \"to\" argument.\n                mstore(36, amount) // Append the \"amount\" argument.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                        // Counterintuitively, this call() must be positioned after the or() in the\n                        // surrounding and() because and() evaluates its arguments from right to left.\n                        call(gas(), currency, 0, 0, 68, 0, 32)\n                    )\n\n                mstore(0x60, 0) // Restore the zero slot to zero.\n                mstore(0x40, memPointer) // Restore the memPointer.\n            }\n\n            if (!success) revert ERC20TransferFailed();\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isNative()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isNative()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isNative(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/types/PoolId.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId) {\n        return PoolId.wrap(keccak256(abi.encode(poolKey)));\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/types/PoolKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.19;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool swap fee, capped at 1_000_000. The upper 4 bits determine if the hook sets any fees.\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"
    },
    "contracts/apps/demo-receipt-tx/VerifyNumberEvent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../verifiers/interfaces/IReceiptVerifier.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\ncontract VerifyNumberEvent is Ownable {\n    IReceiptVerifier public receiptVerifier;\n    mapping(uint64 => address) public srcContract;\n    bytes32 constant eventTopic = keccak256(bytes(\"SendNumber(address,uint256)\"));\n\n    event VerifiedNumber(uint64 chainId, uint64 blknum, address from, uint256 number);\n\n    constructor(IReceiptVerifier _receiptVerifier) {\n        receiptVerifier = _receiptVerifier;\n    }\n\n    function submitNumberReceiptProof(\n        bytes calldata _receipt,\n        bytes calldata _proof,\n        bytes calldata _auxiBlkVerifyInfo\n    ) external {\n        // retrieve verified event\n        IReceiptVerifier.ReceiptInfo memory receiptInfo = receiptVerifier.verifyReceiptAndLog(\n            _receipt,\n            _proof,\n            _auxiBlkVerifyInfo\n        );\n        IReceiptVerifier.LogInfo memory log = receiptInfo.logs[0];\n\n        // compare expected and verified values\n        require(receiptInfo.success, \"tx failed\");\n        require(log.addr == srcContract[receiptInfo.chainId], \"invalid sender contract\");\n        require(log.topics[0] == eventTopic, \"invalid event\");\n\n        // decode event data\n        address from = address(bytes20(BytesLib.slice(log.data, 12, 20)));\n        uint256 number = uint256(bytes32(BytesLib.slice(log.data, 32, 32)));\n        emit VerifiedNumber(receiptInfo.chainId, receiptInfo.blkNum, from, number);\n    }\n\n    function setReceiptVerifier(IReceiptVerifier _receiptVerifier) external onlyOwner {\n        receiptVerifier = _receiptVerifier;\n    }\n\n    function setSrcContract(uint64 _chainId, address _contract) external onlyOwner {\n        srcContract[_chainId] = _contract;\n    }\n}\n"
    },
    "contracts/apps/demo-receipt-tx/VerifyNumberTx.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../verifiers/interfaces/ITxVerifier.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\ncontract VerifyNumberTx is Ownable {\n    ITxVerifier public txVerifier;\n    mapping(uint64 => address) public srcContract;\n    bytes4 constant funcSelector = bytes4(keccak256(bytes(\"sendNumber(uint256)\")));\n\n    event VerifiedNumber(uint64 chainId, uint64 blknum, address from, uint256 number);\n\n    constructor(ITxVerifier _txVerifier) {\n        txVerifier = _txVerifier;\n    }\n\n    function submitNumberTxProof(\n        bytes calldata _tx,\n        bytes calldata _proof,\n        bytes calldata _auxiBlkVerifyInfo\n    ) external {\n        ITxVerifier.TxInfo memory txInfo = txVerifier.verifyTxAndLog(_tx, _proof, _auxiBlkVerifyInfo);\n        require(txInfo.to == srcContract[txInfo.chainId], \"invalid sender contract\");\n        uint256 number = decodeCalldata(txInfo.data);\n        emit VerifiedNumber(txInfo.chainId, txInfo.blkNum, txInfo.from, number);\n    }\n\n    function decodeCalldata(bytes memory _data) private pure returns (uint256 number) {\n        bytes4 method;\n        assembly {\n            method := mload(add(_data, 32))\n        }\n        require(method == funcSelector, \"wrong method\");\n        bytes memory argdata = BytesLib.slice(_data, 4, _data.length - 4);\n        number = abi.decode(argdata, (uint256));\n    }\n\n    function setReceiptVerifier(ITxVerifier _txVerifier) external onlyOwner {\n        txVerifier = _txVerifier;\n    }\n\n    function setSrcContract(uint64 _chainId, address _contract) external onlyOwner {\n        srcContract[_chainId] = _contract;\n    }\n}\n"
    },
    "contracts/apps/demo-tx-uniswap-amount/libraries/Commands.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol\npragma solidity >=0.8.0;\n\n/// @title Commands\n/// @notice Command Flags used to decode commands\nlibrary Commands {\n    // Masks to extract certain bits of commands\n    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\n\n    // Command Types. Maximum supported command at this moment is 0x3f.\n\n    // Command Types where value<0x08, executed in the first nested-if block\n    uint256 constant V3_SWAP_EXACT_IN = 0x00;\n    uint256 constant V3_SWAP_EXACT_OUT = 0x01;\n    uint256 constant PERMIT2_TRANSFER_FROM = 0x02;\n    uint256 constant PERMIT2_PERMIT_BATCH = 0x03;\n    uint256 constant SWEEP = 0x04;\n    uint256 constant TRANSFER = 0x05;\n    uint256 constant PAY_PORTION = 0x06;\n    // COMMAND_PLACEHOLDER = 0x07;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant FIRST_IF_BOUNDARY = 0x08;\n\n    // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block\n    uint256 constant V2_SWAP_EXACT_IN = 0x08;\n    uint256 constant V2_SWAP_EXACT_OUT = 0x09;\n    uint256 constant PERMIT2_PERMIT = 0x0a;\n    uint256 constant WRAP_ETH = 0x0b;\n    uint256 constant UNWRAP_WETH = 0x0c;\n    uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;\n    uint256 constant BALANCE_CHECK_ERC20 = 0x0e;\n    // COMMAND_PLACEHOLDER = 0x0f;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant SECOND_IF_BOUNDARY = 0x10;\n\n    // Command Types where 0x10<=value<0x18, executed in the third nested-if block\n    uint256 constant SEAPORT_V1_5 = 0x10;\n    uint256 constant LOOKS_RARE_V2 = 0x11;\n    uint256 constant NFTX = 0x12;\n    uint256 constant CRYPTOPUNKS = 0x13;\n    // 0x14;\n    uint256 constant OWNER_CHECK_721 = 0x15;\n    uint256 constant OWNER_CHECK_1155 = 0x16;\n    uint256 constant SWEEP_ERC721 = 0x17;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant THIRD_IF_BOUNDARY = 0x18;\n\n    // Command Types where 0x18<=value<=0x1f, executed in the final nested-if block\n    uint256 constant X2Y2_721 = 0x18;\n    uint256 constant SUDOSWAP = 0x19;\n    uint256 constant NFT20 = 0x1a;\n    uint256 constant X2Y2_1155 = 0x1b;\n    uint256 constant FOUNDATION = 0x1c;\n    uint256 constant SWEEP_ERC1155 = 0x1d;\n    uint256 constant ELEMENT_MARKET = 0x1e;\n    // COMMAND_PLACEHOLDER = 0x1f;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant FOURTH_IF_BOUNDARY = 0x20;\n\n    // Command Types where 0x20<=value\n    uint256 constant SEAPORT_V1_4 = 0x20;\n    uint256 constant EXECUTE_SUB_PLAN = 0x21;\n    uint256 constant APPROVE_ERC20 = 0x22;\n    // COMMAND_PLACEHOLDER for 0x23 to 0x3f (all unused)\n}\n"
    },
    "contracts/apps/demo-tx-uniswap-amount/libraries/Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// from https://github.com/Uniswap/v3-periphery\npragma solidity >=0.8.0;\n\nlibrary Path {\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path) internal pure returns (address tokenA, address tokenB, uint24 fee) {\n        tokenA = toAddress(path, 0);\n        fee = toUint24(path, ADDR_SIZE);\n        tokenB = toAddress(path, NEXT_OFFSET);\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3, \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n"
    },
    "contracts/apps/demo-tx-uniswap-amount/UniswapAmount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./libraries/Commands.sol\";\nimport \"./libraries/Path.sol\";\nimport \"../../verifiers/interfaces/ITxVerifier.sol\";\n\ninterface IBrevisUniNFT {\n    function mint(address to) external;\n}\n\ncontract UniswapAmount is Ownable {\n    ITxVerifier public txVerifier;\n\n    mapping(uint64 => address) public universalRouter; // chainId -> router address\n    mapping(uint64 => address) public weth; // chainId -> WETH address\n    mapping(uint64 => address) public usdc; // chainId -> USDC address\n    mapping(uint64 => uint8) usdcDecimal; // chainId -> USDC decimal\n\n    bytes4 private executeSelector = bytes4(keccak256(bytes(\"execute(bytes,bytes[],uint256)\")));\n    bytes4 private executeNoDealineSelector = bytes4(keccak256(bytes(\"execute(bytes,bytes[])\")));\n\n    enum TierName {\n        Null,\n        Stone,\n        Bronze,\n        Silver,\n        Gold,\n        Platinum,\n        Diamond\n    }\n    mapping(TierName => address) public tierNFTs;\n    mapping(address => TierName) public userTier; // user -> tier\n\n    event VerifiedSwap(uint64 chainId, address trader, uint64 timestamp, uint256 usdcAmount, TierName tier);\n\n    constructor(ITxVerifier _txVerifier) {\n        txVerifier = _txVerifier;\n    }\n\n    function submitUniswapTxProof(\n        bytes calldata _tx,\n        bytes calldata _proof,\n        bytes calldata _auxiBlkVerifyInfo\n    ) external {\n        ITxVerifier.TxInfo memory txInfo = txVerifier.verifyTxAndLog(_tx, _proof, _auxiBlkVerifyInfo);\n        require(txInfo.to == universalRouter[txInfo.chainId], \"invalid to address\");\n        require(userTier[txInfo.from] == TierName.Null, \"swap already proved for this user\");\n\n        (uint256 amount, TierName tier) = usdcSwapAmount(txInfo.chainId, txInfo.data);\n        userTier[txInfo.from] = tier;\n        IBrevisUniNFT(tierNFTs[tier]).mint(txInfo.from);\n\n        emit VerifiedSwap(txInfo.chainId, txInfo.from, txInfo.blkTime, amount, tier);\n    }\n\n    function setUniversalRouter(uint64 _chainId, address _router) external onlyOwner {\n        universalRouter[_chainId] = _router;\n    }\n\n    function setWETH(uint64 _chainId, address _weth) external onlyOwner {\n        weth[_chainId] = _weth;\n    }\n\n    function setUSDC(uint64 _chainId, address _usdc, uint8 _decimal) external onlyOwner {\n        usdc[_chainId] = _usdc;\n        usdcDecimal[_chainId] = _decimal;\n    }\n\n    function setTierNFTs(TierName[] calldata _names, address[] calldata _nfts) external onlyOwner {\n        require(_names.length == _nfts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _names.length; i++) {\n            tierNFTs[_names[i]] = _nfts[i];\n        }\n    }\n\n    function setTxVerifier(ITxVerifier _txVerifier) external onlyOwner {\n        txVerifier = _txVerifier;\n    }\n\n    function usdcSwapAmount(uint64 _chainId, bytes memory _data) public view returns (uint256 amount, TierName tier) {\n        bytes4 method;\n        assembly {\n            method := mload(add(_data, 32))\n        }\n        require(method == executeSelector || method == executeNoDealineSelector, \"wrong method\");\n        bytes memory argdata = BytesLib.slice(_data, 4, _data.length - 4);\n        (bytes memory commands, bytes[] memory inputs, ) = abi.decode(argdata, (bytes, bytes[], uint256));\n        // assume tx succeeded, so no need to check deadline or command/input length match\n\n        uint256 command = uint8(commands[0] & Commands.COMMAND_TYPE_MASK);\n        bytes memory input;\n        if (command == Commands.WRAP_ETH || command == Commands.PERMIT2_PERMIT) {\n            command = uint8(commands[1] & Commands.COMMAND_TYPE_MASK);\n            input = inputs[1];\n        } else {\n            input = inputs[0];\n        }\n        require(command == Commands.V3_SWAP_EXACT_IN || command == Commands.V3_SWAP_EXACT_OUT, \"unsupported command\");\n        (, uint256 amountA, uint256 amountB, bytes memory path, ) = abi.decode(\n            input,\n            (address, uint256, uint256, bytes, bool)\n        );\n        (address tokenA, address tokenB, ) = Path.decodeFirstPool(path);\n        if (tokenA == weth[_chainId]) {\n            require(tokenB == usdc[_chainId], \"unsupported pair\");\n            amount = amountB;\n        } else if (tokenA == usdc[_chainId]) {\n            require(tokenB == weth[_chainId], \"unsupported pair\");\n            amount = amountA;\n        } else {\n            revert(\"unsupported pair\");\n        }\n        require(amount > 0, \"zero usdc amount\");\n        tier = getAmountTier(_chainId, amount);\n    }\n\n    function getAmountTier(uint64 _chainId, uint256 _amount) private view returns (TierName tier) {\n        uint256 decimal = 10 ** usdcDecimal[_chainId];\n        if (_amount >= 1000000 * decimal) {\n            return TierName.Diamond;\n        } else if (_amount >= 100000 * decimal) {\n            return TierName.Platinum;\n        } else if (_amount >= 10000 * decimal) {\n            return TierName.Gold;\n        } else if (_amount >= 1000 * decimal) {\n            return TierName.Silver;\n        } else if (_amount >= 100 * decimal) {\n            return TierName.Bronze;\n        }\n        return TierName.Stone;\n    }\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-sum/IUniswapSumVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IUniswapSumVolume {\n    function getAttestedSwapSumVolume(address swapper) external view returns (uint256 volume);\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-sum/UniswapSumVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../../interfaces/ISMT.sol\";\nimport \"../../../verifiers/interfaces/IZkpVerifier.sol\";\nimport \"./IUniswapSumVolume.sol\";\n\ncontract UniswapSumVolume is Ownable, IUniswapSumVolume {\n    // retrieved from proofData, to align the fields with circuit...\n    struct ProofData {\n        address recipient;\n        uint256 volume;\n        bytes32 smtRoot;\n        uint256 length;\n        uint256 cPub;\n        uint256 vkHash;\n    }\n\n    uint256[6] public batchTierVkHashes;\n    uint32 constant PUBLIC_BYTES_START_IDX = 10 * 32; // the first 10 32bytes are groth16 proof (A/B/C/Commitment)\n\n    mapping(address => uint256) public volumes;\n    mapping(uint64 => address) public verifierAddresses; // chainid => snark verifier contract address\n\n    ISMT public smtContract;\n\n    event UpdateVerifierAddress(uint64 chainId, address newAddress);\n    event UpdateSmtContract(ISMT smtContract);\n    event SumVolume(address user, uint64 fromChain, uint256 volume);\n\n    constructor(ISMT _smtContract) {\n        smtContract = _smtContract;\n    }\n\n    function submitUniswapSumVolumeProof(uint64 _chainId, bytes calldata _proof) external {\n        require(verifyRaw(_chainId, _proof), \"proof not valid\");\n\n        ProofData memory data = getProofData(_proof);\n        require(data.volume > 0, \"volume should be larger than 0\");\n        require(data.vkHash > 0, \"vkHash should be larger than 0\");\n        require(isIn(data.vkHash), \"vkHash is not valid\");\n        require(volumes[data.recipient] == 0, \"already proved for this user\");\n        require(smtContract.isSmtRootValid(_chainId, data.smtRoot), \"smt root not valid\");\n\n        volumes[data.recipient] = data.volume;\n        emit SumVolume(data.recipient, _chainId, data.volume);\n    }\n\n    function isIn(uint256 vkHash) internal view returns (bool exists) {\n        exists = false;\n        for (uint256 i = 0; i < 6; i++) {\n            if (vkHash == batchTierVkHashes[i]) {\n                exists = true;\n                break;\n            }\n        }\n    }\n\n    function verifyRaw(uint64 chainId, bytes calldata proofData) private view returns (bool) {\n        require(verifierAddresses[chainId] != address(0), \"chain verifier not set\");\n        return (IZkpVerifier)(verifierAddresses[chainId]).verifyRaw(proofData);\n    }\n\n    function getProofData(bytes calldata _proofData) internal pure returns (ProofData memory data) {\n        data.cPub = uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32]));\n        data.recipient = address(bytes20(_proofData[PUBLIC_BYTES_START_IDX + 32 + 12:PUBLIC_BYTES_START_IDX + 2 * 32]));\n        data.volume = uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32]));\n        data.smtRoot = bytes32(\n            (uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX + 3 * 32:PUBLIC_BYTES_START_IDX + 4 * 32])) << 128) |\n                uint128(bytes16(_proofData[PUBLIC_BYTES_START_IDX + 4 * 32 + 16:PUBLIC_BYTES_START_IDX + 5 * 32]))\n        );\n        data.length = uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX + 5 * 32:PUBLIC_BYTES_START_IDX + 6 * 32]));\n        data.vkHash = uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX + 6 * 32:PUBLIC_BYTES_START_IDX + 7 * 32]));\n    }\n\n    function updateSmtContract(ISMT _smtContract) external onlyOwner {\n        smtContract = _smtContract;\n        emit UpdateSmtContract(smtContract);\n    }\n\n    function updateVerifierAddress(uint64 _chainId, address _verifierAddress) external onlyOwner {\n        verifierAddresses[_chainId] = _verifierAddress;\n        emit UpdateVerifierAddress(_chainId, _verifierAddress);\n    }\n\n    function getAttestedSwapSumVolume(address swapper) external view returns (uint256) {\n        return volumes[swapper];\n    }\n\n    function setBatchTierVkHashes(bytes calldata hashes) external onlyOwner {\n        uint256 len = hashes.length / 32;\n        require(len <= 6, \"exceeds max tiers\");\n        for (uint256 i = 0; i < len; i++) {\n            batchTierVkHashes[i] = uint256(bytes32(hashes[i * 32:(i + 1) * 32]));\n        }\n    }\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-v4-hook/BaseFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IPoolManager} from \"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\";\nimport {Hooks} from \"@uniswap/v4-core/contracts/libraries/Hooks.sol\";\n\nabstract contract BaseFactory {\n    /// @notice zero out all but the first byte of the address which is all 1's\n    uint160 public constant UNISWAP_FLAG_MASK = 0xff << 152;\n\n    // Uniswap hook contracts must have specific flags encoded in the first byte of their address\n    address public immutable TargetPrefix;\n\n    constructor(address _targetPrefix) {\n        TargetPrefix = _targetPrefix;\n    }\n\n    function deploy(IPoolManager poolManager, bytes32 salt) public virtual returns (address);\n\n    function mineDeploy(IPoolManager poolManager) external returns (address) {\n        return mineDeploy(poolManager, 0);\n    }\n\n    function mineDeploy(IPoolManager poolManager, uint256 startSalt) public returns (address) {\n        bytes32 salt = mineSalt(poolManager, startSalt);\n        return deploy(poolManager, salt);\n    }\n\n    function mineSalt(IPoolManager poolManager, uint256 startSalt) public view returns (bytes32 salt) {\n        uint256 endSalt = uint256(startSalt) + 1000;\n        unchecked {\n            for (uint256 i = startSalt; i < endSalt; ++i) {\n                salt = bytes32(i);\n                address hookAddress = _computeHookAddress(poolManager, salt);\n\n                if (_isPrefix(hookAddress)) {\n                    return salt;\n                }\n            }\n            revert(\"Failed to find a salt\");\n        }\n    }\n\n    function _computeHookAddress(IPoolManager poolManager, bytes32 salt) internal view returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, _hashBytecode(poolManager)));\n        return address(uint160(uint256(hash)));\n    }\n\n    /// @dev The implementing contract must override this function to return the bytecode hash of its contract\n    /// For example, the CounterHook contract would return:\n    /// bytecodeHash = keccak256(abi.encodePacked(type(CounterHook).creationCode, abi.encode(poolManager)));\n    function _hashBytecode(IPoolManager poolManager) internal pure virtual returns (bytes32 bytecodeHash);\n\n    function _isPrefix(address _address) internal view returns (bool) {\n        // zero out all but the first byte of the address\n        address actualPrefix = address(uint160(_address) & UNISWAP_FLAG_MASK);\n        return actualPrefix == TargetPrefix;\n    }\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-v4-hook/BaseHook.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Hooks} from \"@uniswap/v4-core/contracts/libraries/Hooks.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\";\nimport {IHooks} from \"@uniswap/v4-core/contracts/interfaces/IHooks.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/contracts/types/BalanceDelta.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/contracts/types/PoolKey.sol\";\n\nabstract contract BaseHook is IHooks, Ownable {\n    error NotPoolManager();\n    error NotSelf();\n    error InvalidPool();\n    error LockFailure();\n    error HookNotImplemented();\n    error MustUseDynamicFee();\n\n    /// @notice The address of the pool manager\n    IPoolManager public immutable poolManager;\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n        validateHookAddress(this);\n    }\n\n    /// @dev Only the pool manager may call this function\n    modifier poolManagerOnly() {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n        _;\n    }\n\n    /// @dev Only this address may call this function\n    modifier selfOnly() {\n        if (msg.sender != address(this)) revert NotSelf();\n        _;\n    }\n\n    /// @dev Only pools with hooks set to this contract may call this function\n    modifier onlyValidPools(IHooks hooks) {\n        if (hooks != this) revert InvalidPool();\n        _;\n    }\n\n    function getHooksCalls() public pure virtual returns (Hooks.Calls memory);\n\n    // this function is virtual so that we can override it during testing,\n    // which allows us to deploy an implementation to any address\n    // and then etch the bytecode into the correct address\n    function validateHookAddress(BaseHook _this) internal pure virtual {\n        Hooks.validateHookAddress(_this, getHooksCalls());\n    }\n\n    function lockAcquired(bytes calldata data) external virtual poolManagerOnly returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).call(data);\n        if (success) return returnData;\n        if (returnData.length == 0) revert LockFailure();\n        // if the call failed, bubble up the reason\n        /// @solidity memory-safe-assembly\n        assembly {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function beforeInitialize(address, PoolKey calldata, uint160, bytes calldata) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterInitialize(\n        address,\n        PoolKey calldata,\n        uint160,\n        int24,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function beforeModifyPosition(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyPositionParams calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterModifyPosition(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyPositionParams calldata,\n        BalanceDelta,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function beforeSwap(\n        address,\n        PoolKey calldata,\n        IPoolManager.SwapParams calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterSwap(\n        address,\n        PoolKey calldata,\n        IPoolManager.SwapParams calldata,\n        BalanceDelta,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function beforeDonate(\n        address,\n        PoolKey calldata,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterDonate(\n        address,\n        PoolKey calldata,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-v4-hook/MockUniswapSumVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ncontract MockUniswapSumVolume {\n    function getAttestedSwapSumVolume(address) external pure returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-v4-hook/TierHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Hooks} from \"@uniswap/v4-core/contracts/libraries/Hooks.sol\";\nimport {IHookFeeManager} from \"@uniswap/v4-core/contracts/interfaces/IHookFeeManager.sol\";\nimport {IDynamicFeeManager} from \"@uniswap/v4-core/contracts/interfaces/IDynamicFeeManager.sol\";\nimport {FeeLibrary} from \"@uniswap/v4-core/contracts/libraries/FeeLibrary.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/contracts/types/BalanceDelta.sol\";\nimport {PoolId, PoolIdLibrary} from \"@uniswap/v4-core/contracts/types/PoolId.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/contracts/types/PoolKey.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\";\nimport {BaseHook} from \"./BaseHook.sol\";\nimport {BaseFactory} from \"./BaseFactory.sol\";\nimport {UniswapSumVolume} from \"../uniswap-sum/UniswapSumVolume.sol\";\nimport {IUniswapSumVolume} from \"../uniswap-sum/IUniswapSumVolume.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TierHook is BaseHook, IHookFeeManager, IDynamicFeeManager {\n    using FeeLibrary for uint24;\n    using PoolIdLibrary for PoolKey;\n\n    address public sumVolumeAddress;\n\n    event UpdateSumVolumeAddress(address newAddress);\n    event Swap(PoolId indexed id, address indexed sender, int128 amount0, int128 amount1);\n\n    uint256 internal constant TIER_NONE = 0;\n    uint256 internal constant TIER_SILVER = 1;\n    uint256 internal constant TIER_GOLD = 2;\n\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    function getHooksCalls() public pure override returns (Hooks.Calls memory) {\n        return\n            Hooks.Calls({\n                beforeInitialize: true,\n                afterInitialize: false,\n                beforeModifyPosition: false,\n                afterModifyPosition: false,\n                beforeSwap: false,\n                afterSwap: true,\n                beforeDonate: false,\n                afterDonate: false\n            });\n    }\n\n    /// @notice The interface for setting a fee on swap or fee on withdraw to the hook\n    /// @dev This callback is only made if the Fee.HOOK_SWAP_FEE_FLAG or Fee.HOOK_WITHDRAW_FEE_FLAG in set in the pool's key.fee.\n    function getHookFees(PoolKey calldata) external pure returns (uint24 fee) {\n        // Swap fee is upper bits.\n        // 20% fee as 85 = hex55 which is 5 in both directions. 1/5 = 20%\n        // Withdraw fee is lower bits\n        // 33% fee as 51 = hex33 which is 3 in both directions. 1/3 = 33%\n        fee = 0x5533;\n    }\n\n    function getHookWithdrawFee(PoolKey calldata key) external view returns (uint8 fee) {}\n\n    function beforeInitialize(\n        address,\n        PoolKey calldata key,\n        uint160,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        if (!key.fee.isDynamicFee()) revert MustUseDynamicFee();\n        return BaseHook.beforeInitialize.selector;\n    }\n\n    function afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata,\n        BalanceDelta delta,\n        bytes calldata\n    ) external override returns (bytes4 selector) {\n        emit Swap(key.toId(), tx.origin, delta.amount0(), delta.amount1());\n\n        selector = BaseHook.afterSwap.selector;\n    }\n\n    function updateSumVolumeAddress(address _sumVolumeAddress) external onlyOwner {\n        sumVolumeAddress = _sumVolumeAddress;\n        emit UpdateSumVolumeAddress(_sumVolumeAddress);\n    }\n\n    function senderTier(address _sender) internal view returns (uint256) {\n        uint256 existingVolume = (IUniswapSumVolume)(sumVolumeAddress).getAttestedSwapSumVolume(_sender); //  uint256(sumVolume.volumes[address(0)]);\n\n        // existingVolume uses 6 as decimals. 1000000000 means $1000\n        if (existingVolume > 1000000000) {\n            return TIER_GOLD;\n        } else if (existingVolume > 0) {\n            return TIER_SILVER;\n        }\n        return TIER_NONE;\n    }\n\n    function getFeeBySwapper(address swapper) external view returns (uint24) {\n        return calcFee(swapper);\n    }\n\n    // invoke by PoolManager contract\n    function getFee(\n        address,\n        PoolKey calldata,\n        IPoolManager.SwapParams calldata,\n        bytes calldata\n    ) external view returns (uint24) {\n        return calcFee(tx.origin);\n    }\n\n    function calcFee(address user) internal view returns (uint24) {\n        uint256 tier = senderTier(user);\n        uint24 fee = 10000;\n        if (tier == TIER_GOLD) {\n            fee = fee / 2;\n        } else if (tier == TIER_SILVER) {\n            fee = (fee * 4) / 5;\n        }\n        return fee;\n    }\n}\n\ncontract TierFactory is BaseFactory, Ownable {\n    constructor() BaseFactory(address(uint160(Hooks.BEFORE_INITIALIZE_FLAG | Hooks.AFTER_SWAP_FLAG))) {}\n\n    function deploy(IPoolManager poolManager, bytes32 salt) public override returns (address) {\n        return address(new TierHook{salt: salt}(poolManager));\n    }\n\n    function _hashBytecode(IPoolManager poolManager) internal pure override returns (bytes32 bytecodeHash) {\n        bytecodeHash = keccak256(abi.encodePacked(type(TierHook).creationCode, abi.encode(poolManager)));\n    }\n\n    function updateHookSumVolumeAddress(TierHook _tierHook, address _sumVolumeAddress) public onlyOwner {\n        _tierHook.updateSumVolumeAddress(_sumVolumeAddress);\n    }\n}\n"
    },
    "contracts/interfaces/ISMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../verifiers/zk-verifiers/common/IVerifier.sol\";\n\ninterface ISMT {\n    struct SmtUpdate {\n        bytes32 newSmtRoot;\n        uint64 endBlockNum;\n        bytes32 endBlockHash;\n        bytes32 nextChunkMerkleRoot;\n        IVerifier.Proof proof;\n        bytes32 commitPub;\n    }\n\n    function updateRoot(uint64 chainId, SmtUpdate memory u) external;\n\n    function isSmtRootValid(uint64 chainId, bytes32 smtRoot) external view returns (bool);\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/CrossChain.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IApplication.sol\";\nimport \"./interfaces/ICrossChain.sol\";\nimport \"./interfaces/ITendermintLightClient.sol\";\nimport \"./lib/Bytes.sol\";\nimport \"./lib/Memory.sol\";\nimport \"./lib/Tendermint.sol\";\nimport \"./lib/ics23/ics23.sol\";\nimport \"./Initializable.sol\";\nimport \"./System.sol\";\nimport {PROOFS_PROTO_GLOBAL_ENUMS, CommitmentProof, ProofSpec, InnerSpec, LeafOp, InnerOp} from \"./lib/proto/Proofs.sol\";\n\ncontract CrossChain is Initializable, ICrossChain {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for TmHeader.Data;\n    using TendermintHelper for ConsensusState.Data;\n    using TendermintHelper for ValidatorSet.Data;\n\n    // constant variables\n    string public constant STORE_NAME = \"ibc\";\n    uint256 public constant CROSS_CHAIN_KEY_PREFIX = 0x01006000; // last 6 bytes\n    uint8 public constant SYN_PACKAGE = 0x00;\n    uint8 public constant ACK_PACKAGE = 0x01;\n    uint8 public constant FAIL_ACK_PACKAGE = 0x02;\n    uint256 public constant INIT_BATCH_SIZE = 50;\n\n    // governable parameters\n    uint256 public batchSizeForOracle;\n\n    //state variables\n    uint256 public previousTxHeight;\n    uint256 public txCounter;\n    int64 public oracleSequence;\n    mapping(uint8 => address) public channelHandlerContractMap;\n    mapping(address => mapping(uint8 => bool)) public registeredContractChannelMap;\n    mapping(uint8 => uint64) public channelSendSequenceMap;\n    mapping(uint8 => uint64) public channelReceiveSequenceMap;\n    System private system;\n\n    struct ChannelInit {\n        uint8 channelId;\n        uint64 sequence;\n    }\n\n    ProofSpec.Data private _tmProofSpec =\n        ProofSpec.Data({\n            leaf_spec: LeafOp.Data({\n                hash: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256,\n                prehash_key: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.NO_HASH,\n                prehash_value: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256,\n                length: PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.VAR_PROTO,\n                prefix: hex\"00028cc3f922\"\n            }),\n            inner_spec: InnerSpec.Data({\n                child_order: getTmChildOrder(),\n                child_size: 32,\n                min_prefix_length: 1,\n                max_prefix_length: 128,\n                empty_child: abi.encodePacked(),\n                hash: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256\n            }),\n            min_depth: 0,\n            max_depth: 0\n        });\n\n    // event\n    event CrossChainPackage(\n        uint16 chainId,\n        uint64 indexed oracleSequence,\n        uint64 indexed packageSequence,\n        uint8 indexed channelId,\n        bytes payload\n    );\n    event ReceivedPackage(uint8 packageType, uint64 indexed packageSequence, uint8 indexed channelId);\n    event UnsupportedPackage(uint64 indexed packageSequence, uint8 indexed channelId, bytes payload);\n    event UnexpectedRevertInPackageHandler(address indexed contractAddr, string reason);\n    event UnexpectedFailureAssertionInPackageHandler(address indexed contractAddr, bytes lowLevelData);\n\n    modifier sequenceInOrder(uint64 _sequence, uint8 _channelID) {\n        uint64 expectedSequence = channelReceiveSequenceMap[_channelID];\n        require(_sequence == expectedSequence, \"sequence not in order\");\n\n        channelReceiveSequenceMap[_channelID] = expectedSequence + 1;\n        _;\n    }\n\n    modifier blockSynced(uint64 _height) {\n        require(\n            ITendermintLightClient(system.tmLightClient()).isHeaderSynced(_height),\n            \"light client not sync the block yet\"\n        );\n        _;\n    }\n\n    modifier channelSupported(uint8 _channelID) {\n        require(channelHandlerContractMap[_channelID] != address(0x0), \"channel is not supported\");\n        _;\n    }\n\n    modifier onlyRegisteredContractChannel(uint8 channelId) {\n        require(\n            registeredContractChannelMap[msg.sender][channelId],\n            \"the contract and channel have not been registered\"\n        );\n        _;\n    }\n\n    // | length   | prefix | sourceChainID| destinationChainID | channelID | sequence |\n    // | 32 bytes | 1 byte | 2 bytes      | 2 bytes            |  1 bytes  | 8 bytes  |\n    function generateKey(uint64 _sequence, uint8 _channelID) internal pure returns (bytes memory) {\n        uint256 fullCROSS_CHAIN_KEY_PREFIX = CROSS_CHAIN_KEY_PREFIX | _channelID;\n        bytes memory key = new bytes(14);\n\n        uint256 ptr;\n        assembly {\n            ptr := add(key, 14)\n        }\n        assembly {\n            mstore(ptr, _sequence)\n        }\n        ptr -= 8;\n        assembly {\n            mstore(ptr, fullCROSS_CHAIN_KEY_PREFIX)\n        }\n        ptr -= 6;\n        assembly {\n            mstore(ptr, 14)\n        }\n        return key;\n    }\n\n    function init(address _system, ChannelInit[] memory receiveChannelInit) external onlyUninitialized {\n        system = System(_system);\n        require(system.bscValidatorSet() != address(0), \"system uninitialized\");\n\n        channelHandlerContractMap[system.STAKING_CHANNEL_ID()] = system.bscValidatorSet();\n        registeredContractChannelMap[system.bscValidatorSet()][system.STAKING_CHANNEL_ID()] = true;\n\n        batchSizeForOracle = INIT_BATCH_SIZE;\n\n        oracleSequence = -1;\n        previousTxHeight = 0;\n        txCounter = 0;\n\n        for (uint256 i = 0; i < receiveChannelInit.length; i++) {\n            ChannelInit memory channelInit = receiveChannelInit[i];\n            channelReceiveSequenceMap[channelInit.channelId] = channelInit.sequence;\n        }\n\n        _initialized = true;\n    }\n\n    function encodePayload(\n        uint8 packageType,\n        uint256 relayFee,\n        bytes memory msgBytes\n    ) public pure returns (bytes memory) {\n        uint256 payloadLength = msgBytes.length + 33;\n        bytes memory payload = new bytes(payloadLength);\n        uint256 ptr;\n        assembly {\n            ptr := payload\n        }\n        ptr += 33;\n\n        assembly {\n            mstore(ptr, relayFee)\n        }\n\n        ptr -= 32;\n        assembly {\n            mstore(ptr, packageType)\n        }\n\n        ptr -= 1;\n        assembly {\n            mstore(ptr, payloadLength)\n        }\n\n        ptr += 65;\n        (uint256 src, ) = Memory.fromBytes(msgBytes);\n        Memory.copy(src, ptr, msgBytes.length);\n\n        return payload;\n    }\n\n    // | type   | relayFee   |package  |\n    // | 1 byte | 32 bytes   | bytes    |\n    function decodePayloadHeader(bytes memory payload) internal pure returns (bool, uint8, uint256, bytes memory) {\n        if (payload.length < 33) {\n            return (false, 0, 0, new bytes(0));\n        }\n\n        uint256 ptr;\n        assembly {\n            ptr := payload\n        }\n\n        uint8 packageType;\n        ptr += 1;\n        assembly {\n            packageType := mload(ptr)\n        }\n\n        uint256 relayFee;\n        ptr += 32;\n        assembly {\n            relayFee := mload(ptr)\n        }\n\n        ptr += 32;\n        bytes memory msgBytes = new bytes(payload.length - 33);\n        (uint256 dst, ) = Memory.fromBytes(msgBytes);\n        Memory.copy(ptr, dst, payload.length - 33);\n\n        return (true, packageType, relayFee, msgBytes);\n    }\n\n    function handlePackage(\n        bytes calldata payload,\n        bytes calldata proof,\n        uint64 height,\n        uint64 packageSequence,\n        uint8 channelId\n    )\n        external\n        onlyInitialized\n        sequenceInOrder(packageSequence, channelId)\n        blockSynced(height)\n        channelSupported(channelId)\n    {\n        require(msg.sender == system.relayer(), \"not relayer\");\n\n        bytes memory payloadLocal = payload; // fix error: stack too deep, try removing local variables\n        bytes memory proofLocal = proof; // fix error: stack too deep, try removing local variables\n        // TODO: Enable after BSC switches to ics-23 proofs\n        // require(\n        //     verifyMembership(\n        //         proofLocal,\n        //         ITendermintLightClient(system.tmLightClient()).getAppHash(height).toBytes(),\n        //         \"\",\n        //         bytes(generateKey(packageSequence, channelId))),\n        //         payloadLocal\n        //     )\n        // );\n\n        uint8 channelIdLocal = channelId; // fix error: stack too deep, try removing local variables\n        (bool success, uint8 packageType, , bytes memory msgBytes) = decodePayloadHeader(payloadLocal);\n        if (!success) {\n            emit UnsupportedPackage(packageSequence, channelIdLocal, payloadLocal);\n            return;\n        }\n        emit ReceivedPackage(packageType, packageSequence, channelIdLocal);\n        if (packageType == SYN_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleSynPackage(channelIdLocal, msgBytes) returns (\n                bytes memory responsePayload\n            ) {\n                if (responsePayload.length != 0) {\n                    sendPackage(\n                        channelSendSequenceMap[channelIdLocal],\n                        channelIdLocal,\n                        encodePayload(ACK_PACKAGE, 0, responsePayload)\n                    );\n                    channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                }\n            } catch Error(string memory reason) {\n                sendPackage(\n                    channelSendSequenceMap[channelIdLocal],\n                    channelIdLocal,\n                    encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n                );\n                channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                sendPackage(\n                    channelSendSequenceMap[channelIdLocal],\n                    channelIdLocal,\n                    encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n                );\n                channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        } else if (packageType == ACK_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleAckPackage(channelIdLocal, msgBytes) {} catch Error(\n                string memory reason\n            ) {\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        } else if (packageType == FAIL_ACK_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleFailAckPackage(channelIdLocal, msgBytes) {} catch Error(\n                string memory reason\n            ) {\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        }\n    }\n\n    function sendPackage(uint64 packageSequence, uint8 channelId, bytes memory payload) internal {\n        if (block.number > previousTxHeight) {\n            oracleSequence++;\n            txCounter = 1;\n            previousTxHeight = block.number;\n        } else {\n            txCounter++;\n            if (txCounter > batchSizeForOracle) {\n                oracleSequence++;\n                txCounter = 1;\n            }\n        }\n        emit CrossChainPackage(system.bscChainID(), uint64(oracleSequence), packageSequence, channelId, payload);\n    }\n\n    function sendSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes,\n        uint256 relayFee\n    ) external override onlyInitialized onlyRegisteredContractChannel(channelId) {\n        uint64 sendSequence = channelSendSequenceMap[channelId];\n        sendPackage(sendSequence, channelId, encodePayload(SYN_PACKAGE, relayFee, msgBytes));\n        sendSequence++;\n        channelSendSequenceMap[channelId] = sendSequence;\n    }\n\n    function getTmChildOrder() internal pure returns (int32[] memory) {\n        int32[] memory childOrder = new int32[](2);\n        childOrder[0] = 0;\n        childOrder[1] = 1;\n\n        return childOrder;\n    }\n\n    function verifyMembership(\n        bytes memory proof,\n        bytes memory root,\n        bytes memory prefix,\n        bytes memory slot,\n        bytes memory expectedValue\n    ) internal view returns (bool) {\n        CommitmentProof.Data memory commitmentProof = CommitmentProof.decode(proof);\n\n        Ics23.VerifyMembershipError vCode = Ics23.verifyMembership(\n            _tmProofSpec,\n            root,\n            commitmentProof,\n            slot,\n            expectedValue\n        );\n\n        return vCode == Ics23.VerifyMembershipError.None;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/Ed25519Verifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nlibrary Pairing {\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n\ncontract Ed25519Verifier {\n    using Pairing for *;\n\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(16537564926561257518103578528440315215453761258292367362288728531966371995874),\n            uint256(17745573146004211534248579212526935789334969204993357645263388924661264974187)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(18681724724964420256656295617462445194520232343683657023020438565197998259673),\n                uint256(12193837689525487485139416036830252517228166559922434453026243184766751424223)\n            ],\n            [\n                uint256(1142689458690077585879713419885020952718961581248594394197708921155425831615),\n                uint256(21176592749741182389767016778519001156128344286592614375719960199144776585881)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(19799290104465580933750348548810731188007606239377683243716104715153013203241),\n                uint256(11029356377690007782073139603897274721732913650225177555357052135977173817932)\n            ],\n            [\n                uint256(14853413044533073822755393458984382667328640010571213879456567827440818416559),\n                uint256(1410171095280489347779850966561512432991607061868962673896369110725284404185)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(14033331354156232558698818931400566889727401262494703861181881854810319611656),\n                uint256(1803778019251118312050232705802652879152144501576771122000761003085527364548)\n            ],\n            [\n                uint256(19177018991900245360077248204991378509575348272931358571227777389261756980021),\n                uint256(13491338816347045964487197971132020169975241104757177444019867803073686189354)\n            ]\n        );\n    }\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[57] calldata input\n    ) public view returns (bool r) {\n        Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(9462447710939432742848424196697728822687813011479891122131648160830275921458); // vk.K[0].X\n        vk_x.Y = uint256(11473376488241810165831757536366836850027784981839089792021378256861687455964); // vk.K[0].Y\n        mul_input[0] = uint256(2648510173551830043068139172354933052408112984889271406750039349551232576549); // vk.K[1].X\n        mul_input[1] = uint256(12122054635554892818275346487442913112730051679642997892313491753063522521582); // vk.K[1].Y\n        mul_input[2] = input[0];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(7061394255936047678059253317568688117856036320639226956214975754160049295333); // vk.K[2].X\n        mul_input[1] = uint256(14145671141784595839380141874940651481054054987062620771942604522524338984737); // vk.K[2].Y\n        mul_input[2] = input[1];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(8218011998118573873686464766508340825013181970169509029207170044008261486193); // vk.K[3].X\n        mul_input[1] = uint256(4808589679893008233603109916014512606401750471929338771914335778004460444360); // vk.K[3].Y\n        mul_input[2] = input[2];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(6078662146959222742143128212552101384988335461422265821062667538426926541518); // vk.K[4].X\n        mul_input[1] = uint256(14225787497847862685225784260006515346740700745306082959617044081310626314439); // vk.K[4].Y\n        mul_input[2] = input[3];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(15225699490833575811570520695447458343846017972639836494871931441485526096787); // vk.K[5].X\n        mul_input[1] = uint256(15569415315038112005525705058718435821481109166559557245122292405605719408925); // vk.K[5].Y\n        mul_input[2] = input[4];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(3942281303299556918937442887343925623486733341136969568571582227745440173807); // vk.K[6].X\n        mul_input[1] = uint256(4138173571813503741513576149284418571266189111210058243046675207337729400955); // vk.K[6].Y\n        mul_input[2] = input[5];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(723953850260184913681651686455204823265776604606646409438367197633827064461); // vk.K[7].X\n        mul_input[1] = uint256(20977669267739599281940138230527850695064911563027213490970977450491160080036); // vk.K[7].Y\n        mul_input[2] = input[6];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(15017582390282569744856651205092622236708068694757044392807758501545223739943); // vk.K[8].X\n        mul_input[1] = uint256(1265991120483539619897036121722423769988535691692111441020055552301420911354); // vk.K[8].Y\n        mul_input[2] = input[7];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(5221873433181937410686676698706306071488292331003715940336123836669316677478); // vk.K[9].X\n        mul_input[1] = uint256(14426879645470087966651542997861483039122804778202333350123336907198495445103); // vk.K[9].Y\n        mul_input[2] = input[8];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        mul_input[0] = uint256(20573069687094669083259174171204052569713827743866845162450148699057547764918); // vk.K[10].X\n        mul_input[1] = uint256(19125182916367006002072229187347273947735042422948150051314675975432464674658); // vk.K[10].Y\n        mul_input[2] = input[9];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[10] * input[9]\n        mul_input[0] = uint256(653108268157101410313141643706313813985558592438699399282213422712029889715); // vk.K[11].X\n        mul_input[1] = uint256(920655015136053252820652067829010626746362759835559920517492343709532195466); // vk.K[11].Y\n        mul_input[2] = input[10];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[11] * input[10]\n        mul_input[0] = uint256(20917639943585713768528304284726936606521085966431546157561891168025022757887); // vk.K[12].X\n        mul_input[1] = uint256(8262496391990750367129442871845474963121866167295779784485121209123609128682); // vk.K[12].Y\n        mul_input[2] = input[11];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[12] * input[11]\n        mul_input[0] = uint256(21382382741426387778276445265980446660720522906365157168723787305555966928178); // vk.K[13].X\n        mul_input[1] = uint256(20304725605418784279352839016897739647529600560330484467516988594075783844854); // vk.K[13].Y\n        mul_input[2] = input[12];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[13] * input[12]\n        mul_input[0] = uint256(6205744815043738292440949022257329596826099473730575848275490097888497842377); // vk.K[14].X\n        mul_input[1] = uint256(14621389881302722659870997782918885566955239423536368018214245647671237084390); // vk.K[14].Y\n        mul_input[2] = input[13];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[14] * input[13]\n        mul_input[0] = uint256(15814307705747507442630842462045602926477319899462506430805053181751486077929); // vk.K[15].X\n        mul_input[1] = uint256(20719845899119367288065102841494811826814842176184748936398855427173476589603); // vk.K[15].Y\n        mul_input[2] = input[14];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[15] * input[14]\n        mul_input[0] = uint256(13115514590566800662313134167308526149064497604562804026503299495382170121521); // vk.K[16].X\n        mul_input[1] = uint256(1332307969280655731716061244811863427539380178344062557717239827752566800649); // vk.K[16].Y\n        mul_input[2] = input[15];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[16] * input[15]\n        mul_input[0] = uint256(21831548148156992003553031892913267462010789037401082515443630438407722663969); // vk.K[17].X\n        mul_input[1] = uint256(6734282036223126997206695046254381537591284089119495472525380311105692037149); // vk.K[17].Y\n        mul_input[2] = input[16];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[17] * input[16]\n        mul_input[0] = uint256(19824054054568150451544715245329533752342566872920996747743887644800176138756); // vk.K[18].X\n        mul_input[1] = uint256(17444883232483823314330637172782524563336237772974332017836978912923943288044); // vk.K[18].Y\n        mul_input[2] = input[17];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[18] * input[17]\n        mul_input[0] = uint256(11203846533369587519929291820435945242235455090413432458828659220572895771832); // vk.K[19].X\n        mul_input[1] = uint256(16148158018136729384412794294904585957329060422316919194693060478106477584261); // vk.K[19].Y\n        mul_input[2] = input[18];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[19] * input[18]\n        mul_input[0] = uint256(21371926577928441304164289543024513366951022486217703908520862772671592138220); // vk.K[20].X\n        mul_input[1] = uint256(18107932227339892218168366645185506844179114579625951614458742714985063933868); // vk.K[20].Y\n        mul_input[2] = input[19];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[20] * input[19]\n        mul_input[0] = uint256(2078836125811363606455079208654269542518183191401138318514557936552194691549); // vk.K[21].X\n        mul_input[1] = uint256(20289036517453961776720656852506924474500493189617637737320825721964408623696); // vk.K[21].Y\n        mul_input[2] = input[20];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[21] * input[20]\n        mul_input[0] = uint256(20684528615338806451021356191176017140605638913507543305045224022571493583399); // vk.K[22].X\n        mul_input[1] = uint256(3903056905414345066553250327072636225389082733080503032794283501727725353966); // vk.K[22].Y\n        mul_input[2] = input[21];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[22] * input[21]\n        mul_input[0] = uint256(13854622650680331791998959936965711435732154320243563610773598319176375507733); // vk.K[23].X\n        mul_input[1] = uint256(1293023507593941743631670346894908106668220179131184101706263206018361614455); // vk.K[23].Y\n        mul_input[2] = input[22];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[23] * input[22]\n        mul_input[0] = uint256(3806178131996244443364939020206141693542459073159601454749540496458558677609); // vk.K[24].X\n        mul_input[1] = uint256(11373982291360652938998008416691951950539326147900435417838815437650728107752); // vk.K[24].Y\n        mul_input[2] = input[23];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[24] * input[23]\n        mul_input[0] = uint256(2956423360991834768742742798077214208812640276852161493833529280831095074781); // vk.K[25].X\n        mul_input[1] = uint256(1036790067266635965218530400023441211296511606457139237137911024262932772523); // vk.K[25].Y\n        mul_input[2] = input[24];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[25] * input[24]\n        mul_input[0] = uint256(3522982602799278288450494299627381578769489328186449628808472144237402446412); // vk.K[26].X\n        mul_input[1] = uint256(13124545182856888320922946645561369145471456600466254299605996043152521299609); // vk.K[26].Y\n        mul_input[2] = input[25];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[26] * input[25]\n        mul_input[0] = uint256(10203021712642579290406260398074627148768959317126130666994877932179153487975); // vk.K[27].X\n        mul_input[1] = uint256(19220206362979524452868254497284191194377622625329987254755474419246348464504); // vk.K[27].Y\n        mul_input[2] = input[26];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[27] * input[26]\n        mul_input[0] = uint256(13656479319858575241396965583832757201969209361023293619085267873236508281324); // vk.K[28].X\n        mul_input[1] = uint256(18653894887361004227161091206020531090371042692329436200109497793456818170297); // vk.K[28].Y\n        mul_input[2] = input[27];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[28] * input[27]\n        mul_input[0] = uint256(20667457304256598973369559213600706490691854322307004623522066355950536986052); // vk.K[29].X\n        mul_input[1] = uint256(10166524048179842305027932295420555626140631584017768928975471213820747864954); // vk.K[29].Y\n        mul_input[2] = input[28];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[29] * input[28]\n        mul_input[0] = uint256(14451586832169158165406346103518705733160542436336769287947890488919305713536); // vk.K[30].X\n        mul_input[1] = uint256(15677358351240766490224933957331428778606486522363230169083418720895728674937); // vk.K[30].Y\n        mul_input[2] = input[29];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[30] * input[29]\n        mul_input[0] = uint256(8815343788891391302884218656640023092689342750375488785771313089418754129780); // vk.K[31].X\n        mul_input[1] = uint256(13009618795398702701706372843804296988960880281370027843016246576371783417574); // vk.K[31].Y\n        mul_input[2] = input[30];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[31] * input[30]\n        mul_input[0] = uint256(7794542304670317906972413815443657110555785749184277557959662453473304832135); // vk.K[32].X\n        mul_input[1] = uint256(13613183423982157012686848485088999158423912294590394357601874166998596036708); // vk.K[32].Y\n        mul_input[2] = input[31];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[32] * input[31]\n        mul_input[0] = uint256(13829063270265614122932776384418402417255253559219713892264763147960420595663); // vk.K[33].X\n        mul_input[1] = uint256(1394492787369205690940389079323334412434996525623614329408676573910762151803); // vk.K[33].Y\n        mul_input[2] = input[32];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[33] * input[32]\n        mul_input[0] = uint256(13250480124160751683662026425319692126614649754704623898304284468074453566914); // vk.K[34].X\n        mul_input[1] = uint256(5842667319974085537473375237026886465714130878203887186671280383692949371367); // vk.K[34].Y\n        mul_input[2] = input[33];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[34] * input[33]\n        mul_input[0] = uint256(4244396663084445939427850030230353204559612848770696182862006916130063961075); // vk.K[35].X\n        mul_input[1] = uint256(5567117583761251190183987315357290694204768312790348596534705058755423324166); // vk.K[35].Y\n        mul_input[2] = input[34];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[35] * input[34]\n        mul_input[0] = uint256(16468214890309010196842237213567005731971554524310253342503592222181911831216); // vk.K[36].X\n        mul_input[1] = uint256(13015440355627709680447076370593216495840212097545614001751347318260304962870); // vk.K[36].Y\n        mul_input[2] = input[35];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[36] * input[35]\n        mul_input[0] = uint256(1710502514829787762068790998518593585732164832507101474241328558660469459552); // vk.K[37].X\n        mul_input[1] = uint256(6641523787174944064207070430739280224248149581740606756642107112326594132092); // vk.K[37].Y\n        mul_input[2] = input[36];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[37] * input[36]\n        mul_input[0] = uint256(13873688322349022545411654259743538242310790895509577137595893668751435535182); // vk.K[38].X\n        mul_input[1] = uint256(2743144454147776739466147084712345009024223781055121185226575029717710864182); // vk.K[38].Y\n        mul_input[2] = input[37];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[38] * input[37]\n        mul_input[0] = uint256(5515207890157998771775835819329897799964342326708529575708915192914192717763); // vk.K[39].X\n        mul_input[1] = uint256(6830846512538057603246995968366818367160206190590285682644456335384380744224); // vk.K[39].Y\n        mul_input[2] = input[38];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[39] * input[38]\n        mul_input[0] = uint256(12084319035206948715397631350220429569745624512314143843439943565130003131475); // vk.K[40].X\n        mul_input[1] = uint256(19823940921149166526761280180611360195654754479337467436765527950957403100421); // vk.K[40].Y\n        mul_input[2] = input[39];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[40] * input[39]\n        mul_input[0] = uint256(1707966742483292923663665240004271093118893352464133867701833789750341568293); // vk.K[41].X\n        mul_input[1] = uint256(2059830066597637963266616577934465643861703524384620495213365657208172372127); // vk.K[41].Y\n        mul_input[2] = input[40];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[41] * input[40]\n        mul_input[0] = uint256(4335683960535202743801100378397366667909285456099227829020337934512681970900); // vk.K[42].X\n        mul_input[1] = uint256(7163760264613823569250071408872840488100394969233714572137432343600611323243); // vk.K[42].Y\n        mul_input[2] = input[41];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[42] * input[41]\n        mul_input[0] = uint256(18579130060975771189412379077269037710625635418528267671299513425013575199707); // vk.K[43].X\n        mul_input[1] = uint256(7413439674648248746853580336851465886481116161464911636828558414649648473619); // vk.K[43].Y\n        mul_input[2] = input[42];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[43] * input[42]\n        mul_input[0] = uint256(16042514199832592968247672418295024202640592240955629633937928114942675433499); // vk.K[44].X\n        mul_input[1] = uint256(9176210646934564968216912647498279795139899070579664859952976743279140133749); // vk.K[44].Y\n        mul_input[2] = input[43];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[44] * input[43]\n        mul_input[0] = uint256(4605826036674863045915848920224687279865356012358913781882485214370608375866); // vk.K[45].X\n        mul_input[1] = uint256(16433469797022838005221089589473953566885756258639853768294415623922164207114); // vk.K[45].Y\n        mul_input[2] = input[44];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[45] * input[44]\n        mul_input[0] = uint256(21291606718216838223612806394353023159167853021188903625675694115824239986243); // vk.K[46].X\n        mul_input[1] = uint256(13861976516244796326502185111204736567218465632382198677006716558365310272234); // vk.K[46].Y\n        mul_input[2] = input[45];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[46] * input[45]\n        mul_input[0] = uint256(13608539239013691835986711410119733227388008030702193689279242935664405256689); // vk.K[47].X\n        mul_input[1] = uint256(21464993448394658273854216484684266808321160947909209851055873325887050492293); // vk.K[47].Y\n        mul_input[2] = input[46];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[47] * input[46]\n        mul_input[0] = uint256(14508762627123999549076601587501227009682636970076636367483491513461822793735); // vk.K[48].X\n        mul_input[1] = uint256(13086806823222303647760776079580932758835172518633536905189386855031527005867); // vk.K[48].Y\n        mul_input[2] = input[47];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[48] * input[47]\n        mul_input[0] = uint256(19620443629871450449905318328661357670363144885276650727854684127004979439411); // vk.K[49].X\n        mul_input[1] = uint256(13512145302109135260648622069026293634594965443783681487284540332451024150941); // vk.K[49].Y\n        mul_input[2] = input[48];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[49] * input[48]\n        mul_input[0] = uint256(20059550415468532205827328714175420183638104824341229821332085226225097782116); // vk.K[50].X\n        mul_input[1] = uint256(12050042602361465175864197068892829808531398334073641526653775817012796904920); // vk.K[50].Y\n        mul_input[2] = input[49];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[50] * input[49]\n        mul_input[0] = uint256(13306511629433317473594641621219799176423215443967411203563081150777664297203); // vk.K[51].X\n        mul_input[1] = uint256(675454852156663320769111000409074913392067853038809175892444203322319080285); // vk.K[51].Y\n        mul_input[2] = input[50];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[51] * input[50]\n        mul_input[0] = uint256(12076096047127155639652324319628370078197547570757038002713853288385847397853); // vk.K[52].X\n        mul_input[1] = uint256(20063073818109035475283913336465472637670645911136973171672153316960017020047); // vk.K[52].Y\n        mul_input[2] = input[51];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[52] * input[51]\n        mul_input[0] = uint256(7070926176971266168429945375853092488155813841418560246899144119253540102350); // vk.K[53].X\n        mul_input[1] = uint256(18608632252819735218114751983460803259577541150988320712643403458973379890618); // vk.K[53].Y\n        mul_input[2] = input[52];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[53] * input[52]\n        mul_input[0] = uint256(8787738969091605771927429510050738225462363969120867850034866515919420616153); // vk.K[54].X\n        mul_input[1] = uint256(280860041417881042842953968111093793049575926737744905886029164850711931023); // vk.K[54].Y\n        mul_input[2] = input[53];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[54] * input[53]\n        mul_input[0] = uint256(17470729458746471811553625923859580633403777304482076029136929287269138561286); // vk.K[55].X\n        mul_input[1] = uint256(11077695780520668039728878524992441159739768910332004302025495828550310823044); // vk.K[55].Y\n        mul_input[2] = input[54];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[55] * input[54]\n        mul_input[0] = uint256(18820732662126470829529155830450341599504017356119489964316929892787212659148); // vk.K[56].X\n        mul_input[1] = uint256(18398462213470099652091858533789910876899706114418611429055433371437676169588); // vk.K[56].Y\n        mul_input[2] = input[55];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[56] * input[55]\n        mul_input[0] = uint256(10979958723839781582509983389549268556375745246890018812028152329350660809099); // vk.K[57].X\n        mul_input[1] = uint256(8614377901484706884530978841565040782347190141813157341928120361805065861265); // vk.K[57].Y\n        mul_input[2] = input[56];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[57] * input[56]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/Initializable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nabstract contract Initializable {\n    bool internal _initialized;\n\n    modifier onlyUninitialized() {\n        require(!_initialized, \"already initialized\");\n        _;\n    }\n\n    modifier onlyInitialized() {\n        require(_initialized, \"not initialized\");\n        _;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/interfaces/IApplication.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface IApplication {\n    /**\n     * @dev Handle syn package\n     */\n    function handleSynPackage(uint8 channelId, bytes calldata msgBytes) external returns (bytes memory responsePayload);\n\n    /**\n     * @dev Handle ack package\n     */\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n\n    /**\n     * @dev Handle fail ack package\n     */\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/interfaces/ICrossChain.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface ICrossChain {\n    /**\n     * @dev Send package to Binance Chain\n     */\n    function sendSynPackage(uint8 channelId, bytes calldata msgBytes, uint256 relayFee) external;\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/interfaces/ITendermintLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface ITendermintLightClient {\n    function isHeaderSynced(uint64 height) external view returns (bool);\n\n    function getAppHash(uint64 height) external view returns (bytes32);\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nlibrary Bytes {\n    function toBytes32(bytes memory bz) internal pure returns (bytes32 ret) {\n        require(bz.length == 32, \"Bytes: toBytes32 invalid size\");\n        assembly {\n            ret := mload(add(bz, 32))\n        }\n    }\n\n    function toBytes(bytes32 data) public pure returns (bytes memory) {\n        return abi.encodePacked(data);\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64 ret) {\n        require(_bytes.length >= _start + 8, \"Bytes: toUint64 out of bounds\");\n        assembly {\n            ret := mload(add(add(_bytes, 0x8), _start))\n        }\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"Bytes: toUint256 out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAddress(bytes memory _bytes) internal pure returns (address addr) {\n        // convert last 20 bytes of keccak hash (bytes32) to address\n        bytes32 hash = keccak256(_bytes);\n        assembly {\n            mstore(0, hash)\n            addr := mload(0)\n        }\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/crypto/MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../proto/TendermintHelper.sol\";\nimport {SimpleValidator, Validator} from \"../proto/TendermintLight.sol\";\n\nlibrary MerkleTree {\n    /**\n     * @dev returns empty hash\n     */\n    function emptyHash() internal pure returns (bytes32) {\n        return sha256(abi.encode());\n    }\n\n    /**\n     * @dev returns tmhash(0x00 || leaf)\n     *\n     */\n    function leafHash(bytes memory leaf) internal pure returns (bytes32) {\n        uint8 leafPrefix = 0x00;\n        return sha256(abi.encodePacked(leafPrefix, leaf));\n    }\n\n    /**\n     * @dev returns tmhash(0x01 || left || right)\n     */\n    function innerHash(bytes32 leaf, bytes32 right) internal pure returns (bytes32) {\n        uint8 innerPrefix = 0x01;\n        return sha256(abi.encodePacked(innerPrefix, leaf, right));\n    }\n\n    /**\n     * @dev returns the largest power of 2 less than length\n     *\n     * TODO: This function can be optimized with bit shifting approach:\n     * https://www.baeldung.com/java-largest-power-of-2-less-than-number\n     */\n    function getSplitPoint(uint256 input) internal pure returns (uint256) {\n        require(input > 1, \"MerkleTree: invalid input\");\n\n        uint256 result = 1;\n        for (uint256 i = input - 1; i > 1; i--) {\n            if ((i & (i - 1)) == 0) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev computes a Merkle tree where the leaves are validators, in the provided order\n     * Follows RFC-6962\n     */\n    function merkleRootHash(\n        Validator.Data[] memory validators,\n        uint256 start,\n        uint256 total\n    ) internal pure returns (bytes32) {\n        if (total == 0) {\n            return emptyHash();\n        } else if (total == 1) {\n            bytes memory encodedValidator = SimpleValidator.encode(\n                TendermintHelper.toSimpleValidator(validators[start])\n            );\n            return leafHash(encodedValidator);\n        } else {\n            uint256 k = getSplitPoint(total);\n            bytes32 left = merkleRootHash(validators, start, k); // validators[:k]\n            bytes32 right = merkleRootHash(validators, start + k, total - k); // validators[k:]\n            return innerHash(left, right);\n        }\n    }\n\n    /**\n     * @dev computes a Merkle tree where the leaves are the byte slice in the provided order\n     * Follows RFC-6962\n     */\n    function merkleRootHash(bytes[14] memory validators, uint256 start, uint256 total) internal pure returns (bytes32) {\n        if (total == 0) {\n            return emptyHash();\n        } else if (total == 1) {\n            return leafHash(validators[start]);\n        } else {\n            uint256 k = getSplitPoint(total);\n            bytes32 left = merkleRootHash(validators, start, k); // validators[:k]\n            bytes32 right = merkleRootHash(validators, start + k, total - k); // validators[k:]\n            return innerHash(left, right);\n        }\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/ics23/ics23.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {BatchProof, CompressedBatchProof, CommitmentProof, ProofSpec, ExistenceProof, NonExistenceProof} from \"../proto/Proofs.sol\";\nimport {Compress} from \"./ics23Compress.sol\";\nimport {Proof} from \"./ics23Proof.sol\";\nimport {Ops} from \"./ics23Ops.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary Ics23 {\n    enum VerifyMembershipError {\n        None,\n        ExistenceProofIsNil,\n        ProofVerify\n    }\n\n    // verifyMembership, throws an exception in case anything goes wrong\n    function verifyMembership(\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        CommitmentProof.Data memory proof,\n        bytes memory key,\n        bytes memory value\n    ) internal pure returns (VerifyMembershipError) {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        ExistenceProof.Data memory exiProof = getExistProofForKey(decoProof, key);\n\n        //require(ExistenceProof.isNil(exiProof) == false); // dev: getExistProofForKey not available\n        if (ExistenceProof.isNil(exiProof)) return VerifyMembershipError.ExistenceProofIsNil;\n        Proof.VerifyExistenceError vCode = Proof.verify(exiProof, spec, commitmentRoot, key, value);\n        if (vCode != Proof.VerifyExistenceError.None) return VerifyMembershipError.ProofVerify;\n\n        return VerifyMembershipError.None;\n    }\n\n    enum VerifyNonMembershipError {\n        None,\n        NonExistenceProofIsNil,\n        ProofVerify\n    }\n\n    function verifyNonMembership(\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        CommitmentProof.Data memory proof,\n        bytes memory key\n    ) internal pure returns (VerifyNonMembershipError) {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        NonExistenceProof.Data memory nonProof = getNonExistProofForKey(decoProof, key);\n        //require(NonExistenceProof.isNil(nonProof) == false); // dev: getNonExistProofForKey not available\n        if (NonExistenceProof.isNil(nonProof)) return VerifyNonMembershipError.NonExistenceProofIsNil;\n        Proof.VerifyNonExistenceError vCode = Proof.verify(nonProof, spec, commitmentRoot, key);\n        if (vCode != Proof.VerifyNonExistenceError.None) return VerifyNonMembershipError.ProofVerify;\n\n        return VerifyNonMembershipError.None;\n    }\n\n    /* -- temporarily disabled as they are not covered by unit tests\n    struct BatchItem {\n        bytes key;\n        bytes value;\n    }\n    function batchVerifyMembership(ProofSpec.Data memory spec, bytes memory commitmentRoot, CommitmentProof.Data memory proof, BatchItem[] memory items ) internal pure {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        for (uint i = 0; i < items.length; i++) {\n            verifyMembership(spec, commitmentRoot, decoProof, items[i].key, items[i].value);\n        }\n    }\n\n    function batchVerifyNonMembership(ProofSpec.Data memory spec, bytes memory commitmentRoot, CommitmentProof.Data memory proof, bytes[] memory keys ) internal pure {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        for (uint i = 0; i < keys.length; i++) {\n            verifyNonMembership(spec, commitmentRoot, decoProof, keys[i]);\n        }\n    }\n*/\n\n    // private\n    function getExistProofForKey(\n        CommitmentProof.Data memory proof,\n        bytes memory key\n    ) private pure returns (ExistenceProof.Data memory) {\n        if (ExistenceProof.isNil(proof.exist) == false) {\n            if (BytesLib.equal(proof.exist.key, key) == true) {\n                return proof.exist;\n            }\n        } else if (BatchProof.isNil(proof.batch) == false) {\n            for (uint256 i = 0; i < proof.batch.entries.length; i++) {\n                if (\n                    ExistenceProof.isNil(proof.batch.entries[i].exist) == false &&\n                    BytesLib.equal(proof.batch.entries[i].exist.key, key)\n                ) {\n                    return proof.batch.entries[i].exist;\n                }\n            }\n        }\n        return ExistenceProof.nil();\n    }\n\n    function getNonExistProofForKey(\n        CommitmentProof.Data memory proof,\n        bytes memory key\n    ) private pure returns (NonExistenceProof.Data memory) {\n        if (NonExistenceProof.isNil(proof.nonexist) == false) {\n            if (isLeft(proof.nonexist.left, key) && isRight(proof.nonexist.right, key)) {\n                return proof.nonexist;\n            }\n        } else if (BatchProof.isNil(proof.batch) == false) {\n            for (uint256 i = 0; i < proof.batch.entries.length; i++) {\n                if (\n                    NonExistenceProof.isNil(proof.batch.entries[i].nonexist) == false &&\n                    isLeft(proof.batch.entries[i].nonexist.left, key) &&\n                    isRight(proof.batch.entries[i].nonexist.right, key)\n                ) {\n                    return proof.batch.entries[i].nonexist;\n                }\n            }\n        }\n        return NonExistenceProof.nil();\n    }\n\n    function isLeft(ExistenceProof.Data memory left, bytes memory key) private pure returns (bool) {\n        // ExistenceProof.isNil does not work\n        return ExistenceProof._empty(left) || Ops.compare(left.key, key) < 0;\n    }\n\n    function isRight(ExistenceProof.Data memory right, bytes memory key) private pure returns (bool) {\n        // ExistenceProof.isNil does not work\n        return ExistenceProof._empty(right) || Ops.compare(right.key, key) > 0;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/ics23/ics23Compress.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {InnerOp, ExistenceProof, NonExistenceProof, CommitmentProof, CompressedBatchEntry, CompressedBatchProof, CompressedExistenceProof, BatchEntry, BatchProof} from \"../proto/Proofs.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nlibrary Compress {\n    function decompress(CommitmentProof.Data memory proof) internal pure returns (CommitmentProof.Data memory) {\n        //CompressedBatchProof.isNil() does not work\n        if (CompressedBatchProof._empty(proof.compressed) == true) {\n            return proof;\n        }\n        return\n            CommitmentProof.Data({\n                exist: ExistenceProof.nil(),\n                nonexist: NonExistenceProof.nil(),\n                batch: BatchProof.Data({entries: decompress(proof.compressed)}),\n                compressed: CompressedBatchProof.nil()\n            });\n    }\n\n    // private\n    function decompress(CompressedBatchProof.Data memory proof) private pure returns (BatchEntry.Data[] memory) {\n        BatchEntry.Data[] memory entries = new BatchEntry.Data[](proof.entries.length);\n        for (uint256 i = 0; i < proof.entries.length; i++) {\n            entries[i] = decompressEntry(proof.entries[i], proof.lookup_inners);\n        }\n        return entries;\n    }\n\n    function decompressEntry(\n        CompressedBatchEntry.Data memory entry,\n        InnerOp.Data[] memory lookup\n    ) private pure returns (BatchEntry.Data memory) {\n        //CompressedExistenceProof.isNil does not work\n        if (CompressedExistenceProof._empty(entry.exist) == false) {\n            return BatchEntry.Data({exist: decompressExist(entry.exist, lookup), nonexist: NonExistenceProof.nil()});\n        }\n        return\n            BatchEntry.Data({\n                exist: ExistenceProof.nil(),\n                nonexist: NonExistenceProof.Data({\n                    key: entry.nonexist.key,\n                    left: decompressExist(entry.nonexist.left, lookup),\n                    right: decompressExist(entry.nonexist.right, lookup)\n                })\n            });\n    }\n\n    function decompressExist(\n        CompressedExistenceProof.Data memory proof,\n        InnerOp.Data[] memory lookup\n    ) private pure returns (ExistenceProof.Data memory) {\n        if (CompressedExistenceProof._empty(proof)) {\n            return ExistenceProof.nil();\n        }\n        ExistenceProof.Data memory decoProof = ExistenceProof.Data({\n            key: proof.key,\n            value: proof.value,\n            leaf: proof.leaf,\n            path: new InnerOp.Data[](proof.path.length)\n        });\n        for (uint256 i = 0; i < proof.path.length; i++) {\n            require(proof.path[i] >= 0); // dev: proof.path < 0\n            uint256 step = SafeCast.toUint256(proof.path[i]);\n            require(step < lookup.length); // dev: step >= lookup.length\n            decoProof.path[i] = lookup[step];\n        }\n        return decoProof;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/ics23/ics23Ops.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {LeafOp, InnerOp, PROOFS_PROTO_GLOBAL_ENUMS, ProofSpec} from \"../proto/Proofs.sol\";\nimport {ProtoBufRuntime} from \"../proto/ProtoBufRuntime.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary Ops {\n    bytes constant empty = new bytes(0);\n\n    enum ApplyLeafOpError {\n        None,\n        KeyLength,\n        ValueLength,\n        DoHash,\n        PrepareLeafData\n    }\n\n    // LeafOp operations\n    function applyOp(\n        LeafOp.Data memory leafOp,\n        bytes memory key,\n        bytes memory value\n    ) internal pure returns (bytes memory, ApplyLeafOpError) {\n        //require(key.length > 0); // dev: Leaf op needs key\n        if (key.length == 0) return (empty, ApplyLeafOpError.KeyLength);\n        //require(value.length > 0); // dev: Leaf op needs value\n        if (value.length == 0) return (empty, ApplyLeafOpError.ValueLength);\n        (bytes memory pKey, PrepareLeafDataError pCode1) = prepareLeafData(leafOp.prehash_key, leafOp.length, key);\n        if (pCode1 != PrepareLeafDataError.None) return (empty, ApplyLeafOpError.PrepareLeafData);\n        (bytes memory pValue, PrepareLeafDataError pCode2) = prepareLeafData(\n            leafOp.prehash_value,\n            leafOp.length,\n            value\n        );\n        if (pCode2 != PrepareLeafDataError.None) return (empty, ApplyLeafOpError.PrepareLeafData);\n        bytes memory data = abi.encodePacked(leafOp.prefix, pKey, pValue);\n        (bytes memory hashed, DoHashError hCode) = doHash(leafOp.hash, data);\n        if (hCode != DoHashError.None) return (empty, ApplyLeafOpError.DoHash);\n        return (hashed, ApplyLeafOpError.None);\n    }\n\n    enum PrepareLeafDataError {\n        None,\n        DoHash,\n        DoLengthOp\n    }\n\n    // preapare leaf data for encoding\n    function prepareLeafData(\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hashOp,\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp lenOp,\n        bytes memory data\n    ) internal pure returns (bytes memory, PrepareLeafDataError) {\n        (bytes memory hased, DoHashError hCode) = doHashOrNoop(hashOp, data);\n        if (hCode != DoHashError.None) return (empty, PrepareLeafDataError.DoHash);\n        (bytes memory res, DoLengthOpError lCode) = doLengthOp(lenOp, hased);\n        if (lCode != DoLengthOpError.None) return (empty, PrepareLeafDataError.DoLengthOp);\n\n        return (res, PrepareLeafDataError.None);\n    }\n\n    enum CheckAgainstSpecError {\n        None,\n        Hash,\n        PreHashKey,\n        PreHashValue,\n        Length,\n        MinPrefixLength,\n        HasPrefix,\n        MaxPrefixLength\n    }\n\n    function checkAgainstSpec(\n        LeafOp.Data memory leafOp,\n        ProofSpec.Data memory spec\n    ) internal pure returns (CheckAgainstSpecError) {\n        require(leafOp.hash == spec.leaf_spec.hash, \"checkAgainstSpec for LeafOp - Unexpected HashOp\"); // dev: checkAgainstSpec for LeafOp - Unexpected HashOp\n        if (leafOp.hash != spec.leaf_spec.hash) return CheckAgainstSpecError.Hash;\n        require(\n            leafOp.prehash_key == spec.leaf_spec.prehash_key,\n            \"checkAgainstSpec for LeafOp - Unexpected PrehashKey\"\n        ); // dev: checkAgainstSpec for LeafOp - Unexpected PrehashKey\n        if (leafOp.prehash_key != spec.leaf_spec.prehash_key) return CheckAgainstSpecError.PreHashKey;\n        require(\n            leafOp.prehash_value == spec.leaf_spec.prehash_value,\n            \"checkAgainstSpec for LeafOp - Unexpected PrehashValue\"\n        ); // dev: checkAgainstSpec for LeafOp - Unexpected PrehashValue\");\n        if (leafOp.prehash_value != spec.leaf_spec.prehash_value) return CheckAgainstSpecError.PreHashValue;\n        require(leafOp.length == spec.leaf_spec.length, \"checkAgainstSpec for LeafOp - Unexpected lengthOp\"); // dev: checkAgainstSpec for LeafOp - Unexpected lengthOp\n        if (leafOp.length != spec.leaf_spec.length) return CheckAgainstSpecError.Length;\n        bool hasprefix = hasPrefix(leafOp.prefix, spec.leaf_spec.prefix);\n        require(hasprefix, \"checkAgainstSpec for LeafOp - Leaf Prefix doesn't start with\"); // dev: checkAgainstSpec for LeafOp - Leaf Prefix doesn't start with\n        if (hasprefix == false) return CheckAgainstSpecError.HasPrefix;\n\n        return CheckAgainstSpecError.None;\n    }\n\n    enum ApplyInnerOpError {\n        None,\n        ChildLength,\n        DoHash\n    }\n\n    // InnerOp operations\n    function applyOp(\n        InnerOp.Data memory innerOp,\n        bytes memory child\n    ) internal pure returns (bytes memory, ApplyInnerOpError) {\n        //require(child.length > 0); // dev: Inner op needs child value\n        if (child.length == 0) return (empty, ApplyInnerOpError.ChildLength);\n        bytes memory preImage = abi.encodePacked(innerOp.prefix, child, innerOp.suffix);\n        (bytes memory hashed, DoHashError code) = doHash(innerOp.hash, preImage);\n        if (code != DoHashError.None) return (empty, ApplyInnerOpError.DoHash);\n\n        return (hashed, ApplyInnerOpError.None);\n    }\n\n    function checkAgainstSpec(\n        InnerOp.Data memory innerOp,\n        ProofSpec.Data memory spec\n    ) internal pure returns (CheckAgainstSpecError) {\n        // require(innerOp.hash == spec.inner_spec.hash, \"checkAgainstSpec for InnerOp - Unexpected HashOp\"); // dev: checkAgainstSpec for InnerOp - Unexpected HashOp\n        if (innerOp.hash != spec.inner_spec.hash) return CheckAgainstSpecError.Hash;\n        uint256 minPrefixLength = SafeCast.toUint256(spec.inner_spec.min_prefix_length);\n        // require(innerOp.prefix.length >= minPrefixLength, \"InnerOp prefix too short\"); // dev: InnerOp prefix too short\n        if (innerOp.prefix.length < minPrefixLength) return CheckAgainstSpecError.MinPrefixLength;\n        bytes memory leafPrefix = spec.leaf_spec.prefix;\n        bool hasprefix = hasPrefix(innerOp.prefix, leafPrefix);\n        // require(hasprefix == false, \"Inner Prefix starts with wrong value\"); // dev: Inner Prefix starts with wrong value\n        if (hasprefix) return CheckAgainstSpecError.HasPrefix;\n        uint256 childSize = SafeCast.toUint256(spec.inner_spec.child_size);\n        uint256 maxLeftChildBytes = (spec.inner_spec.child_order.length - 1) * childSize;\n        uint256 maxPrefixLength = SafeCast.toUint256(spec.inner_spec.max_prefix_length);\n        // require(innerOp.prefix.length <= maxPrefixLength + maxLeftChildBytes, \"InnerOp prefix too long\"); // dev: InnerOp prefix too long\n        if (innerOp.prefix.length > maxPrefixLength + maxLeftChildBytes) return CheckAgainstSpecError.MaxPrefixLength;\n\n        return CheckAgainstSpecError.None;\n    }\n\n    function doHashOrNoop(\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hashOp,\n        bytes memory preImage\n    ) internal pure returns (bytes memory, DoHashError) {\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.NO_HASH) {\n            return (preImage, DoHashError.None);\n        }\n        return doHash(hashOp, preImage);\n    }\n\n    enum DoHashError {\n        None,\n        Sha512,\n        Sha512_256,\n        Unsupported\n    }\n\n    function doHash(\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hashOp,\n        bytes memory preImage\n    ) internal pure returns (bytes memory, DoHashError) {\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256) {\n            return (abi.encodePacked(sha256(preImage)), DoHashError.None);\n        }\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.KECCAK) {\n            return (abi.encodePacked(keccak256(preImage)), DoHashError.None);\n        }\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.RIPEMD160) {\n            return (abi.encodePacked(ripemd160(preImage)), DoHashError.None);\n        }\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.BITCOIN) {\n            bytes memory tmp = abi.encodePacked(sha256(preImage));\n            return (abi.encodePacked(ripemd160(tmp)), DoHashError.None);\n        }\n        //require(hashOp != PROOFS_PROTO_GLOBAL_ENUMS.HashOp.Sha512); // dev: SHA512 not supported\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA512) {\n            return (empty, DoHashError.Sha512);\n        }\n        //require(hashOp != PROOFS_PROTO_GLOBAL_ENUMS.HashOp.Sha512_256); // dev: SHA512_256 not supported\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA512_256) {\n            return (empty, DoHashError.Sha512_256);\n        }\n        //revert(); // dev: Unsupported hashOp\n        return (empty, DoHashError.Unsupported);\n    }\n\n    function compare(bytes memory a, bytes memory b) internal pure returns (int256) {\n        uint256 minLen = Math.min(a.length, b.length);\n        for (uint256 i = 0; i < minLen; i++) {\n            if (uint8(a[i]) < uint8(b[i])) {\n                return -1;\n            } else if (uint8(a[i]) > uint8(b[i])) {\n                return 1;\n            }\n        }\n        if (a.length > minLen) {\n            return 1;\n        }\n        if (b.length > minLen) {\n            return -1;\n        }\n        return 0;\n    }\n\n    // private\n    enum DoLengthOpError {\n        None,\n        Require32DataLength,\n        Require64DataLength,\n        Unsupported\n    }\n\n    function doLengthOp(\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp lenOp,\n        bytes memory data\n    ) private pure returns (bytes memory, DoLengthOpError) {\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.NO_PREFIX) {\n            return (data, DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.VAR_PROTO) {\n            uint256 sz = ProtoBufRuntime._sz_varint(data.length);\n            bytes memory encoded = new bytes(sz);\n            ProtoBufRuntime._encode_varint(data.length, 32, encoded);\n            return (abi.encodePacked(encoded, data), DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.REQUIRE_32_BYTES) {\n            //require(data.length == 32); // dev: data.length != 32\n            if (data.length != 32) return (empty, DoLengthOpError.Require32DataLength);\n\n            return (data, DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.REQUIRE_64_BYTES) {\n            //require(data.length == 64); // dev: data.length != 64\"\n            if (data.length != 64) return (empty, DoLengthOpError.Require64DataLength);\n\n            return (data, DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.FIXED32_LITTLE) {\n            uint32 size = SafeCast.toUint32(data.length);\n            // maybe some assembly here to make it faster\n            bytes4 sizeB = bytes4(size);\n            bytes memory littleE = new bytes(4);\n            //unfolding for loop is cheaper\n            littleE[0] = sizeB[3];\n            littleE[1] = sizeB[2];\n            littleE[2] = sizeB[1];\n            littleE[3] = sizeB[0];\n            return (abi.encodePacked(littleE, data), DoLengthOpError.None);\n        }\n        //revert(); // dev: Unsupported lenOp\n        return (empty, DoLengthOpError.Unsupported);\n    }\n\n    function hasPrefix(bytes memory element, bytes memory prefix) private pure returns (bool) {\n        if (prefix.length == 0) {\n            return true;\n        }\n        if (prefix.length > element.length) {\n            return false;\n        }\n        bytes memory slice = BytesLib.slice(element, 0, prefix.length);\n        return BytesLib.equal(prefix, slice);\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/ics23/ics23Proof.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {LeafOp, CompressedBatchProof, ExistenceProof, NonExistenceProof, BatchEntry, BatchProof, ProofSpec, InnerOp, InnerSpec, CommitmentProof} from \"../proto/Proofs.sol\";\nimport {Ops} from \"./ics23Ops.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {Compress} from \"./ics23Compress.sol\";\nimport {Ops} from \"./ics23Ops.sol\";\n\nlibrary Proof {\n    bytes constant empty = new bytes(0);\n\n    enum VerifyExistenceError {\n        None,\n        KeyNotMatching,\n        ValueNotMatching,\n        CheckSpec,\n        CalculateRoot,\n        RootNotMatching\n    }\n\n    // ExistenceProof\n    function verify(\n        ExistenceProof.Data memory proof,\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        bytes memory key,\n        bytes memory value\n    ) internal pure returns (VerifyExistenceError) {\n        //require(BytesLib.equal(proof.key, key)); // dev: Provided key doesn't match proof\n        bool keyMatch = BytesLib.equal(proof.key, key);\n        if (keyMatch == false) return VerifyExistenceError.KeyNotMatching;\n        //require(BytesLib.equal(proof.value, value)); // dev: Provided value doesn't match proof\n        bool valueMatch = BytesLib.equal(proof.value, value);\n        if (valueMatch == false) return VerifyExistenceError.ValueNotMatching;\n        CheckAgainstSpecError cCode = checkAgainstSpec(proof, spec);\n        if (cCode != CheckAgainstSpecError.None) return VerifyExistenceError.CheckSpec;\n        (bytes memory root, CalculateRootError rCode) = calculateRoot(proof);\n        if (rCode != CalculateRootError.None) return VerifyExistenceError.CalculateRoot;\n        //require(BytesLib.equal(root, commitmentRoot)); // dev: Calculated root doesn't match provided root\n        bool rootMatch = BytesLib.equal(root, commitmentRoot);\n        if (rootMatch == false) return VerifyExistenceError.RootNotMatching;\n\n        return VerifyExistenceError.None;\n    }\n\n    enum CalculateRootError {\n        None,\n        LeafNil,\n        LeafOp,\n        PathOp,\n        BatchEntriesLength,\n        BatchEntryEmpty,\n        EmptyProof\n    }\n\n    function calculateRoot(ExistenceProof.Data memory proof) internal pure returns (bytes memory, CalculateRootError) {\n        //require(LeafOp.isNil(proof.leaf) == false); // dev: Existence Proof needs defined LeafOp\n        if (LeafOp.isNil(proof.leaf)) return (empty, CalculateRootError.LeafNil);\n        (bytes memory root, Ops.ApplyLeafOpError lCode) = Ops.applyOp(proof.leaf, proof.key, proof.value);\n        if (lCode != Ops.ApplyLeafOpError.None) return (empty, CalculateRootError.LeafOp);\n        for (uint256 i = 0; i < proof.path.length; i++) {\n            Ops.ApplyInnerOpError iCode;\n            (root, iCode) = Ops.applyOp(proof.path[i], root);\n            if (iCode != Ops.ApplyInnerOpError.None) return (empty, CalculateRootError.PathOp);\n        }\n\n        return (root, CalculateRootError.None);\n    }\n\n    enum CheckAgainstSpecError {\n        None,\n        EmptyLeaf,\n        OpsCheckAgainstSpec,\n        InnerOpsDepthTooShort,\n        InnerOpsDepthTooLong\n    }\n\n    function checkAgainstSpec(\n        ExistenceProof.Data memory proof,\n        ProofSpec.Data memory spec\n    ) internal pure returns (CheckAgainstSpecError) {\n        // LeafOp.isNil does not work\n        //require(LeafOp._empty(proof.leaf) == false); // dev: Existence Proof needs defined LeafOp\n        if (LeafOp._empty(proof.leaf)) return CheckAgainstSpecError.EmptyLeaf;\n        Ops.CheckAgainstSpecError cCode = Ops.checkAgainstSpec(proof.leaf, spec);\n        if (cCode != Ops.CheckAgainstSpecError.None) return CheckAgainstSpecError.OpsCheckAgainstSpec;\n        if (spec.min_depth > 0) {\n            bool innerOpsDepthTooShort = proof.path.length < SafeCast.toUint256(int256(spec.min_depth));\n            //require(innerOpsDepthTooShort == false); // dev: InnerOps depth too short\n            if (innerOpsDepthTooShort) return CheckAgainstSpecError.InnerOpsDepthTooShort;\n        }\n        if (spec.max_depth > 0) {\n            bool innerOpsDepthTooLong = proof.path.length > SafeCast.toUint256(int256(spec.max_depth));\n            //require(innerOpsDepthTooLong == false); // dev: InnerOps depth too long\n            if (innerOpsDepthTooLong) return CheckAgainstSpecError.InnerOpsDepthTooLong;\n        }\n        for (uint256 i = 0; i < proof.path.length; i++) {\n            Ops.CheckAgainstSpecError cCode = Ops.checkAgainstSpec(proof.path[i], spec);\n            if (cCode != Ops.CheckAgainstSpecError.None) return CheckAgainstSpecError.OpsCheckAgainstSpec;\n        }\n    }\n\n    enum VerifyNonExistenceError {\n        None,\n        VerifyLeft,\n        VerifyRight,\n        LeftAndRightKeyEmpty,\n        RightKeyRange,\n        LeftKeyRange,\n        RightProofLeftMost,\n        LeftProofRightMost,\n        IsLeftNeighbor\n    }\n\n    // NonExistenceProof\n    function verify(\n        NonExistenceProof.Data memory proof,\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        bytes memory key\n    ) internal pure returns (VerifyNonExistenceError) {\n        bytes memory leftKey;\n        bytes memory rightKey;\n        // ExistenceProof.isNil does not work\n        if (ExistenceProof._empty(proof.left) == false) {\n            VerifyExistenceError eCode = verify(proof.left, spec, commitmentRoot, proof.left.key, proof.left.value);\n            if (eCode != VerifyExistenceError.None) return VerifyNonExistenceError.VerifyLeft;\n\n            leftKey = proof.left.key;\n        }\n        if (ExistenceProof._empty(proof.right) == false) {\n            VerifyExistenceError eCode = verify(proof.right, spec, commitmentRoot, proof.right.key, proof.right.value);\n            if (eCode != VerifyExistenceError.None) return VerifyNonExistenceError.VerifyRight;\n\n            rightKey = proof.right.key;\n        }\n        // If both proofs are missing, this is not a valid proof\n        //require(leftKey.length > 0 || rightKey.length > 0); // dev: both left and right proofs missing\n        if (leftKey.length == 0 && rightKey.length == 0) return VerifyNonExistenceError.LeftAndRightKeyEmpty;\n        // Ensure in valid range\n        if (rightKey.length > 0 && Ops.compare(key, rightKey) >= 0) {\n            //require(Ops.compare(key, rightKey) < 0); // dev: key is not left of right proof\n            return VerifyNonExistenceError.RightKeyRange;\n        }\n        if (leftKey.length > 0 && Ops.compare(key, leftKey) <= 0) {\n            //require(Ops.compare(key, leftKey) > 0); // dev: key is not right of left proof\n            return VerifyNonExistenceError.LeftKeyRange;\n        }\n        if (leftKey.length == 0) {\n            //require(isLeftMost(spec.inner_spec, proof.right.path)); // dev: left proof missing, right proof must be left-most\n            if (isLeftMost(spec.inner_spec, proof.right.path) == false)\n                return VerifyNonExistenceError.RightProofLeftMost;\n        } else if (rightKey.length == 0) {\n            //require(isRightMost(spec.inner_spec, proof.left.path)); // dev: isRightMost: right proof missing, left proof must be right-most\n            if (isRightMost(spec.inner_spec, proof.left.path) == false)\n                return VerifyNonExistenceError.LeftProofRightMost;\n        } else {\n            //require(isLeftNeighbor(spec.inner_spec, proof.left.path, proof.right.path)); // dev: isLeftNeighbor: right proof missing, left proof must be right-most\n            bool isLeftNeigh = isLeftNeighbor(spec.inner_spec, proof.left.path, proof.right.path);\n            if (isLeftNeigh == false) return VerifyNonExistenceError.IsLeftNeighbor;\n        }\n\n        return VerifyNonExistenceError.None;\n    }\n\n    function calculateRoot(\n        NonExistenceProof.Data memory proof\n    ) internal pure returns (bytes memory, CalculateRootError) {\n        if (ExistenceProof._empty(proof.left) == false) {\n            return calculateRoot(proof.left);\n        }\n        if (ExistenceProof._empty(proof.right) == false) {\n            return calculateRoot(proof.right);\n        }\n        //revert(); // dev: Nonexistence proof has empty Left and Right proof\n        return (empty, CalculateRootError.EmptyProof);\n    }\n\n    // commitment proof\n    function calculateRoot(CommitmentProof.Data memory proof) internal pure returns (bytes memory, CalculateRootError) {\n        if (ExistenceProof._empty(proof.exist) == false) {\n            return calculateRoot(proof.exist);\n        }\n        if (NonExistenceProof._empty(proof.nonexist) == false) {\n            return calculateRoot(proof.nonexist);\n        }\n        if (BatchProof._empty(proof.batch) == false) {\n            //require(proof.batch.entries.length > 0); // dev: batch proof has no entry\n            if (proof.batch.entries.length == 0) return (empty, CalculateRootError.BatchEntriesLength);\n            //require(BatchEntry._empty(proof.batch.entries[0]) == false); // dev: batch proof has empty entry\n            if (BatchEntry._empty(proof.batch.entries[0])) return (empty, CalculateRootError.BatchEntryEmpty);\n            if (ExistenceProof._empty(proof.batch.entries[0].exist) == false) {\n                return calculateRoot(proof.batch.entries[0].exist);\n            }\n            if (NonExistenceProof._empty(proof.batch.entries[0].nonexist) == false) {\n                return calculateRoot(proof.batch.entries[0].nonexist);\n            }\n        }\n        if (CompressedBatchProof._empty(proof.compressed) == false) {\n            return calculateRoot(Compress.decompress(proof));\n        }\n        //revert(); // dev: calculateRoot(CommitmentProof) empty proof\n        return (empty, CalculateRootError.EmptyProof);\n    }\n\n    // private\n    function isLeftMost(InnerSpec.Data memory spec, InnerOp.Data[] memory path) private pure returns (bool) {\n        (uint256 minPrefix, uint256 maxPrefix, uint256 suffix, GetPaddingError gCode) = getPadding(spec, 0);\n        if (gCode != GetPaddingError.None) return false;\n        for (uint256 i = 0; i < path.length; i++) {\n            if (hasPadding(path[i], minPrefix, maxPrefix, suffix) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function isRightMost(InnerSpec.Data memory spec, InnerOp.Data[] memory path) private pure returns (bool) {\n        uint256 last = spec.child_order.length - 1;\n        (uint256 minPrefix, uint256 maxPrefix, uint256 suffix, GetPaddingError gCode) = getPadding(spec, last);\n        if (gCode != GetPaddingError.None) return false;\n        for (uint256 i = 0; i < path.length; i++) {\n            if (hasPadding(path[i], minPrefix, maxPrefix, suffix) == false) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function isLeftStep(\n        InnerSpec.Data memory spec,\n        InnerOp.Data memory left,\n        InnerOp.Data memory right\n    ) private pure returns (bool) {\n        (uint256 leftIdx, OrderFromPaddingError lCode) = orderFromPadding(spec, left);\n        if (lCode != OrderFromPaddingError.None) return false;\n        (uint256 rightIdx, OrderFromPaddingError rCode) = orderFromPadding(spec, right);\n        if (lCode != OrderFromPaddingError.None) return false;\n        if (rCode != OrderFromPaddingError.None) return false;\n\n        return rightIdx == leftIdx + 1;\n    }\n\n    function isLeftNeighbor(\n        InnerSpec.Data memory spec,\n        InnerOp.Data[] memory left,\n        InnerOp.Data[] memory right\n    ) private pure returns (bool) {\n        uint256 leftIdx = left.length - 1;\n        uint256 rightIdx = right.length - 1;\n        while (leftIdx >= 0 && rightIdx >= 0) {\n            if (\n                BytesLib.equal(left[leftIdx].prefix, right[rightIdx].prefix) &&\n                BytesLib.equal(left[leftIdx].suffix, right[rightIdx].suffix)\n            ) {\n                leftIdx -= 1;\n                rightIdx -= 1;\n                continue;\n            }\n            break;\n        }\n        if (isLeftStep(spec, left[leftIdx], right[rightIdx]) == false) {\n            return false;\n        }\n        // slicing does not work for ``memory`` types\n        if (isRightMost(spec, sliceInnerOps(left, 0, leftIdx)) == false) {\n            return false;\n        }\n        if (isLeftMost(spec, sliceInnerOps(right, 0, rightIdx)) == false) {\n            return false;\n        }\n        return true;\n    }\n\n    enum OrderFromPaddingError {\n        None,\n        NotFound,\n        GetPadding\n    }\n\n    function orderFromPadding(\n        InnerSpec.Data memory spec,\n        InnerOp.Data memory op\n    ) private pure returns (uint256, OrderFromPaddingError) {\n        uint256 maxBranch = spec.child_order.length;\n        for (uint256 branch = 0; branch < maxBranch; branch++) {\n            (uint256 minp, uint256 maxp, uint256 suffix, GetPaddingError gCode) = getPadding(spec, branch);\n            if (gCode != GetPaddingError.None) return (0, OrderFromPaddingError.GetPadding);\n            if (hasPadding(op, minp, maxp, suffix) == true) return (branch, OrderFromPaddingError.None);\n        }\n        //revert(); // dev: Cannot find any valid spacing for this node\n        return (0, OrderFromPaddingError.NotFound);\n    }\n\n    enum GetPaddingError {\n        None,\n        GetPosition\n    }\n\n    function getPadding(\n        InnerSpec.Data memory spec,\n        uint256 branch\n    ) private pure returns (uint256 minPrefix, uint256 maxPrefix, uint256 suffix, GetPaddingError) {\n        uint256 uChildSize = SafeCast.toUint256(spec.child_size);\n        (uint256 idx, GetPositionError gCode) = getPosition(spec.child_order, branch);\n        if (gCode != GetPositionError.None) return (0, 0, 0, GetPaddingError.GetPosition);\n        uint256 prefix = idx * uChildSize;\n        minPrefix = prefix + SafeCast.toUint256(spec.min_prefix_length);\n        maxPrefix = prefix + SafeCast.toUint256(spec.max_prefix_length);\n        suffix = (spec.child_order.length - 1 - idx) * uChildSize;\n\n        return (minPrefix, maxPrefix, suffix, GetPaddingError.None);\n    }\n\n    enum GetPositionError {\n        None,\n        BranchLength,\n        NoFound\n    }\n\n    function getPosition(int32[] memory order, uint256 branch) private pure returns (uint256, GetPositionError) {\n        //require(branch < order.length); // dev: invalid branch\n        if (branch >= order.length) return (0, GetPositionError.BranchLength);\n        for (uint256 i = 0; i < order.length; i++) {\n            if (SafeCast.toUint256(order[i]) == branch) return (i, GetPositionError.None);\n        }\n        //revert(); // dev: branch not found in order\n        return (0, GetPositionError.NoFound);\n    }\n\n    function hasPadding(\n        InnerOp.Data memory op,\n        uint256 minPrefix,\n        uint256 maxPrefix,\n        uint256 suffix\n    ) private pure returns (bool) {\n        if (op.prefix.length < minPrefix) return false;\n        if (op.prefix.length > maxPrefix) return false;\n        return op.suffix.length == suffix;\n    }\n\n    function sliceInnerOps(\n        InnerOp.Data[] memory array,\n        uint256 start,\n        uint256 end\n    ) private pure returns (InnerOp.Data[] memory) {\n        InnerOp.Data[] memory slice = new InnerOp.Data[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            slice[i] = array[i];\n        }\n        return slice;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/Memory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nlibrary Memory {\n    // Size of a word, in bytes.\n    uint256 internal constant WORD_SIZE = 32;\n    // Size of the header of a 'bytes' array.\n    uint256 internal constant BYTES_HEADER_SIZE = 32;\n    // Address of the free memory pointer.\n    uint256 internal constant FREE_MEM_PTR = 0x40;\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\n    // bytes starting at 'addr2'.\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\n    function equals(uint256 addr, uint256 addr2, uint256 len) internal pure returns (bool equal) {\n        assembly {\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\n        }\n    }\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\n    // the first 'len' bytes will be compared.\n    // Requires that 'bts.length >= len'\n    function equals(uint256 addr, uint256 len, bytes memory bts) internal pure returns (bool equal) {\n        require(bts.length >= len);\n        uint256 addr2;\n        assembly {\n            addr2 := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n        return equals(addr, addr2, len);\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\n    // This function does not check the or destination, it only copies\n    // the bytes.\n    function copy(uint256 src, uint256 dest, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_SIZE;\n            src += WORD_SIZE;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    // Returns a memory pointer to the provided bytes array.\n    function ptr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := bts\n        }\n    }\n\n    // Returns a memory pointer to the data portion of the provided bytes array.\n    function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n    }\n\n    // This function does the same as 'dataPtr(bytes memory)', but will also return the\n    // length of the provided bytes array.\n    function fromBytes(bytes memory bts) internal pure returns (uint256 addr, uint256 len) {\n        len = bts.length;\n        assembly {\n            addr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n    }\n\n    // Creates a 'bytes memory' variable from the memory address 'addr', with the\n    // length 'len'. The function will allocate new memory for the bytes array, and\n    // the 'len bytes starting at 'addr' will be copied into that new memory.\n    function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) {\n        bts = new bytes(len);\n        uint256 btsptr;\n        assembly {\n            btsptr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n        copy(addr, btsptr, len);\n    }\n\n    // Get the word stored at memory address 'addr' as a 'uint'.\n    function toUint(uint256 addr) internal pure returns (uint256 n) {\n        assembly {\n            n := mload(addr)\n        }\n    }\n\n    // Get the word stored at memory address 'addr' as a 'bytes32'.\n    function toBytes32(uint256 addr) internal pure returns (bytes32 bts) {\n        assembly {\n            bts := mload(addr)\n        }\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/Encoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./ProtoBufRuntime.sol\";\n\nlibrary Encoder {\n    uint64 private constant _MAX_UINT64 = 0xFFFFFFFFFFFFFFFF;\n\n    function cdcEncode(string memory item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_lendelim(bytes(item).length);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (bytes(item).length > 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    function cdcEncode(bytes memory item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_lendelim(item.length);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (item.length > 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    function cdcEncode(int64 item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_int64(item);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (item != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // TODO: Can we make this cheaper?\n    // https://docs.soliditylang.org/en/v0.6.5/types.html#allocating-memory-arrays\n    function encodeDelim(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length < _MAX_UINT64, \"Encoder: out of bounds (uint64)\");\n\n        uint64 length = uint64(input.length);\n        uint256 additionalEstimated = ProtoBufRuntime._sz_uint64(length);\n\n        bytes memory delimitedPrefix = new bytes(additionalEstimated);\n        uint256 delimitedPrefixLen = ProtoBufRuntime._encode_uint64(length, 32, delimitedPrefix);\n\n        assembly {\n            mstore(delimitedPrefix, delimitedPrefixLen)\n        }\n\n        // concatenate buffers\n        return abi.encodePacked(delimitedPrefix, input);\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/GoogleProtobufAny.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\nimport \"./ProtoBufRuntime.sol\";\n\nlibrary GoogleProtobufAny {\n    //struct definition\n    struct Data {\n        string type_url;\n        bytes value;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_type_url(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_type_url(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        //\n        // if `r` is NULL, then only counting the number of fields.\n        //\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.type_url = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        //\n        // if `r` is NULL, then only counting the number of fields.\n        //\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ProtoBufRuntime._encode_string(r.type_url, pointer, bs);\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.type_url).length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        return e;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.type_url = input.type_url;\n        output.value = input.value;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n//library Any\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/Proofs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"./ProtoBufRuntime.sol\";\nimport \"./GoogleProtobufAny.sol\";\n\nlibrary ExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        bytes value;\n        LeafOp.Data leaf;\n        InnerOp.Data[] path;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.path = new InnerOp.Data[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_leaf(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LeafOp.Data memory x, uint256 sz) = _decode_LeafOp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.leaf = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_path(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (InnerOp.Data memory x, uint256 sz) = _decode_InnerOp(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.path[r.path.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LeafOp(uint256 p, bytes memory bs) internal pure returns (LeafOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LeafOp.Data memory r, ) = LeafOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_InnerOp(uint256 p, bytes memory bs) internal pure returns (InnerOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (InnerOp.Data memory r, ) = InnerOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n        if (r.value.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LeafOp._encode_nested(r.leaf, pointer, bs);\n\n        if (r.path.length != 0) {\n            for (i = 0; i < r.path.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += InnerOp._encode_nested(r.path[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(LeafOp._estimate(r.leaf));\n        for (i = 0; i < r.path.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(InnerOp._estimate(r.path[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        if (r.value.length != 0) {\n            return false;\n        }\n\n        if (r.path.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        output.value = input.value;\n        LeafOp.store(input.leaf, output.leaf);\n\n        for (uint256 i4 = 0; i4 < input.path.length; i4++) {\n            output.path.push(input.path[i4]);\n        }\n    }\n\n    //array helpers for Path\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addPath(Data memory self, InnerOp.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        InnerOp.Data[] memory tmp = new InnerOp.Data[](self.path.length + 1);\n        for (uint256 i = 0; i < self.path.length; i++) {\n            tmp[i] = self.path[i];\n        }\n        tmp[self.path.length] = value;\n        self.path = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ExistenceProof\n\nlibrary NonExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        ExistenceProof.Data left;\n        ExistenceProof.Data right;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_left(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_right(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_left(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.left = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_right(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.right = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ExistenceProof.Data memory r, ) = ExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.left, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.right, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.left));\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.right));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        ExistenceProof.store(input.left, output.left);\n        ExistenceProof.store(input.right, output.right);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library NonExistenceProof\n\nlibrary CommitmentProof {\n    //struct definition\n    struct Data {\n        ExistenceProof.Data exist;\n        NonExistenceProof.Data nonexist;\n        BatchProof.Data batch;\n        CompressedBatchProof.Data compressed;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_exist(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nonexist(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_batch(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_compressed(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_exist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.exist = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nonexist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (NonExistenceProof.Data memory x, uint256 sz) = _decode_NonExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nonexist = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_batch(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BatchProof.Data memory x, uint256 sz) = _decode_BatchProof(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.batch = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_compressed(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedBatchProof.Data memory x, uint256 sz) = _decode_CompressedBatchProof(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.compressed = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ExistenceProof.Data memory r, ) = ExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_NonExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (NonExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (NonExistenceProof.Data memory r, ) = NonExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BatchProof(uint256 p, bytes memory bs) internal pure returns (BatchProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BatchProof.Data memory r, ) = BatchProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedBatchProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedBatchProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedBatchProof.Data memory r, ) = CompressedBatchProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.exist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += NonExistenceProof._encode_nested(r.nonexist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BatchProof._encode_nested(r.batch, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedBatchProof._encode_nested(r.compressed, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.exist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(NonExistenceProof._estimate(r.nonexist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(BatchProof._estimate(r.batch));\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedBatchProof._estimate(r.compressed));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        ExistenceProof.store(input.exist, output.exist);\n        NonExistenceProof.store(input.nonexist, output.nonexist);\n        BatchProof.store(input.batch, output.batch);\n        CompressedBatchProof.store(input.compressed, output.compressed);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CommitmentProof\n\nlibrary LeafOp {\n    //struct definition\n    struct Data {\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hash;\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp prehash_key;\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp prehash_value;\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp length;\n        bytes prefix;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[6] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_prehash_key(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_prehash_value(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_length(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_prefix(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prehash_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.prehash_key = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prehash_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.prehash_value = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_length(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_LengthOp(tmp);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.length = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prefix(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.prefix = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.hash) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_hash = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash);\n            pointer += ProtoBufRuntime._encode_enum(_enum_hash, pointer, bs);\n        }\n        if (uint256(r.prehash_key) != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_prehash_key = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_key);\n            pointer += ProtoBufRuntime._encode_enum(_enum_prehash_key, pointer, bs);\n        }\n        if (uint256(r.prehash_value) != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_prehash_value = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_value);\n            pointer += ProtoBufRuntime._encode_enum(_enum_prehash_value, pointer, bs);\n        }\n        if (uint256(r.length) != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_length = PROOFS_PROTO_GLOBAL_ENUMS.encode_LengthOp(r.length);\n            pointer += ProtoBufRuntime._encode_enum(_enum_length, pointer, bs);\n        }\n        if (r.prefix.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.prefix, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash));\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_key));\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_value));\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_LengthOp(r.length));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.prefix.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.hash) != 0) {\n            return false;\n        }\n\n        if (uint256(r.prehash_key) != 0) {\n            return false;\n        }\n\n        if (uint256(r.prehash_value) != 0) {\n            return false;\n        }\n\n        if (uint256(r.length) != 0) {\n            return false;\n        }\n\n        if (r.prefix.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        output.prehash_key = input.prehash_key;\n        output.prehash_value = input.prehash_value;\n        output.length = input.length;\n        output.prefix = input.prefix;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library LeafOp\n\nlibrary InnerOp {\n    //struct definition\n    struct Data {\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hash;\n        bytes prefix;\n        bytes suffix;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_prefix(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_suffix(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prefix(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.prefix = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_suffix(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.suffix = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.hash) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_hash = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash);\n            pointer += ProtoBufRuntime._encode_enum(_enum_hash, pointer, bs);\n        }\n        if (r.prefix.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.prefix, pointer, bs);\n        }\n        if (r.suffix.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.suffix, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.prefix.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.suffix.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.hash) != 0) {\n            return false;\n        }\n\n        if (r.prefix.length != 0) {\n            return false;\n        }\n\n        if (r.suffix.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        output.prefix = input.prefix;\n        output.suffix = input.suffix;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library InnerOp\n\nlibrary ProofSpec {\n    //struct definition\n    struct Data {\n        LeafOp.Data leaf_spec;\n        InnerSpec.Data inner_spec;\n        int32 max_depth;\n        int32 min_depth;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_leaf_spec(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_inner_spec(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_max_depth(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_min_depth(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_leaf_spec(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LeafOp.Data memory x, uint256 sz) = _decode_LeafOp(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.leaf_spec = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_inner_spec(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (InnerSpec.Data memory x, uint256 sz) = _decode_InnerSpec(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.inner_spec = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_depth(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.max_depth = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_min_depth(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.min_depth = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LeafOp(uint256 p, bytes memory bs) internal pure returns (LeafOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LeafOp.Data memory r, ) = LeafOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_InnerSpec(uint256 p, bytes memory bs) internal pure returns (InnerSpec.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (InnerSpec.Data memory r, ) = InnerSpec._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LeafOp._encode_nested(r.leaf_spec, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += InnerSpec._encode_nested(r.inner_spec, pointer, bs);\n\n        if (r.max_depth != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.max_depth, pointer, bs);\n        }\n        if (r.min_depth != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.min_depth, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(LeafOp._estimate(r.leaf_spec));\n        e += 1 + ProtoBufRuntime._sz_lendelim(InnerSpec._estimate(r.inner_spec));\n        e += 1 + ProtoBufRuntime._sz_int32(r.max_depth);\n        e += 1 + ProtoBufRuntime._sz_int32(r.min_depth);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.max_depth != 0) {\n            return false;\n        }\n\n        if (r.min_depth != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        LeafOp.store(input.leaf_spec, output.leaf_spec);\n        InnerSpec.store(input.inner_spec, output.inner_spec);\n        output.max_depth = input.max_depth;\n        output.min_depth = input.min_depth;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ProofSpec\n\nlibrary InnerSpec {\n    //struct definition\n    struct Data {\n        int32[] child_order;\n        int32 child_size;\n        int32 min_prefix_length;\n        int32 max_prefix_length;\n        bytes empty_child;\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[7] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_child_order(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_child_size(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_min_prefix_length(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_max_prefix_length(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_empty_child(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.child_order = new int32[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_child_order(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_child_size(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_min_prefix_length(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_max_prefix_length(pointer, bs, nil(), counters);\n            } else if (fieldId == 5) {\n                pointer += _read_empty_child(pointer, bs, nil(), counters);\n            } else if (fieldId == 6) {\n                pointer += _read_hash(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_child_order(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.child_order[r.child_order.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_child_size(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.child_size = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_min_prefix_length(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.min_prefix_length = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_prefix_length(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.max_prefix_length = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_empty_child(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.empty_child = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.hash = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.child_order.length != 0) {\n            for (i = 0; i < r.child_order.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n                pointer += ProtoBufRuntime._encode_int32(r.child_order[i], pointer, bs);\n            }\n        }\n        if (r.child_size != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.child_size, pointer, bs);\n        }\n        if (r.min_prefix_length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.min_prefix_length, pointer, bs);\n        }\n        if (r.max_prefix_length != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.max_prefix_length, pointer, bs);\n        }\n        if (r.empty_child.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.empty_child, pointer, bs);\n        }\n        if (uint256(r.hash) != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_hash = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash);\n            pointer += ProtoBufRuntime._encode_enum(_enum_hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.child_order.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_int32(r.child_order[i]);\n        }\n        e += 1 + ProtoBufRuntime._sz_int32(r.child_size);\n        e += 1 + ProtoBufRuntime._sz_int32(r.min_prefix_length);\n        e += 1 + ProtoBufRuntime._sz_int32(r.max_prefix_length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.empty_child.length);\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.child_order.length != 0) {\n            return false;\n        }\n\n        if (r.child_size != 0) {\n            return false;\n        }\n\n        if (r.min_prefix_length != 0) {\n            return false;\n        }\n\n        if (r.max_prefix_length != 0) {\n            return false;\n        }\n\n        if (r.empty_child.length != 0) {\n            return false;\n        }\n\n        if (uint256(r.hash) != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.child_order = input.child_order;\n        output.child_size = input.child_size;\n        output.min_prefix_length = input.min_prefix_length;\n        output.max_prefix_length = input.max_prefix_length;\n        output.empty_child = input.empty_child;\n        output.hash = input.hash;\n    }\n\n    //array helpers for ChildOrder\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addChildOrder(Data memory self, int32 value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        int32[] memory tmp = new int32[](self.child_order.length + 1);\n        for (uint256 i = 0; i < self.child_order.length; i++) {\n            tmp[i] = self.child_order[i];\n        }\n        tmp[self.child_order.length] = value;\n        self.child_order = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library InnerSpec\n\nlibrary BatchProof {\n    //struct definition\n    struct Data {\n        BatchEntry.Data[] entries;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[2] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.entries = new BatchEntry.Data[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_entries(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[2] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BatchEntry.Data memory x, uint256 sz) = _decode_BatchEntry(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.entries[r.entries.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BatchEntry(uint256 p, bytes memory bs) internal pure returns (BatchEntry.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BatchEntry.Data memory r, ) = BatchEntry._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.entries.length != 0) {\n            for (i = 0; i < r.entries.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += BatchEntry._encode_nested(r.entries[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.entries.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(BatchEntry._estimate(r.entries[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.entries.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.entries.length; i1++) {\n            output.entries.push(input.entries[i1]);\n        }\n    }\n\n    //array helpers for Entries\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addEntries(Data memory self, BatchEntry.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        BatchEntry.Data[] memory tmp = new BatchEntry.Data[](self.entries.length + 1);\n        for (uint256 i = 0; i < self.entries.length; i++) {\n            tmp[i] = self.entries[i];\n        }\n        tmp[self.entries.length] = value;\n        self.entries = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BatchProof\n\nlibrary BatchEntry {\n    //struct definition\n    struct Data {\n        ExistenceProof.Data exist;\n        NonExistenceProof.Data nonexist;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_exist(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nonexist(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_exist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.exist = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nonexist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (NonExistenceProof.Data memory x, uint256 sz) = _decode_NonExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nonexist = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ExistenceProof.Data memory r, ) = ExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_NonExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (NonExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (NonExistenceProof.Data memory r, ) = NonExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.exist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += NonExistenceProof._encode_nested(r.nonexist, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.exist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(NonExistenceProof._estimate(r.nonexist));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        ExistenceProof.store(input.exist, output.exist);\n        NonExistenceProof.store(input.nonexist, output.nonexist);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BatchEntry\n\nlibrary CompressedBatchProof {\n    //struct definition\n    struct Data {\n        CompressedBatchEntry.Data[] entries;\n        InnerOp.Data[] lookup_inners;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_lookup_inners(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.entries = new CompressedBatchEntry.Data[](counters[1]);\n        r.lookup_inners = new InnerOp.Data[](counters[2]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_lookup_inners(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_entries(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedBatchEntry.Data memory x, uint256 sz) = _decode_CompressedBatchEntry(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.entries[r.entries.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_lookup_inners(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (InnerOp.Data memory x, uint256 sz) = _decode_InnerOp(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.lookup_inners[r.lookup_inners.length - counters[2]] = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedBatchEntry(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedBatchEntry.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedBatchEntry.Data memory r, ) = CompressedBatchEntry._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_InnerOp(uint256 p, bytes memory bs) internal pure returns (InnerOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (InnerOp.Data memory r, ) = InnerOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.entries.length != 0) {\n            for (i = 0; i < r.entries.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += CompressedBatchEntry._encode_nested(r.entries[i], pointer, bs);\n            }\n        }\n        if (r.lookup_inners.length != 0) {\n            for (i = 0; i < r.lookup_inners.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += InnerOp._encode_nested(r.lookup_inners[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.entries.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(CompressedBatchEntry._estimate(r.entries[i]));\n        }\n        for (i = 0; i < r.lookup_inners.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(InnerOp._estimate(r.lookup_inners[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.entries.length != 0) {\n            return false;\n        }\n\n        if (r.lookup_inners.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.entries.length; i1++) {\n            output.entries.push(input.entries[i1]);\n        }\n\n        for (uint256 i2 = 0; i2 < input.lookup_inners.length; i2++) {\n            output.lookup_inners.push(input.lookup_inners[i2]);\n        }\n    }\n\n    //array helpers for Entries\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addEntries(Data memory self, CompressedBatchEntry.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        CompressedBatchEntry.Data[] memory tmp = new CompressedBatchEntry.Data[](self.entries.length + 1);\n        for (uint256 i = 0; i < self.entries.length; i++) {\n            tmp[i] = self.entries[i];\n        }\n        tmp[self.entries.length] = value;\n        self.entries = tmp;\n    }\n\n    //array helpers for LookupInners\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addLookupInners(Data memory self, InnerOp.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        InnerOp.Data[] memory tmp = new InnerOp.Data[](self.lookup_inners.length + 1);\n        for (uint256 i = 0; i < self.lookup_inners.length; i++) {\n            tmp[i] = self.lookup_inners[i];\n        }\n        tmp[self.lookup_inners.length] = value;\n        self.lookup_inners = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedBatchProof\n\nlibrary CompressedBatchEntry {\n    //struct definition\n    struct Data {\n        CompressedExistenceProof.Data exist;\n        CompressedNonExistenceProof.Data nonexist;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_exist(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nonexist(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_exist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedExistenceProof.Data memory x, uint256 sz) = _decode_CompressedExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.exist = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nonexist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedNonExistenceProof.Data memory x, uint256 sz) = _decode_CompressedNonExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nonexist = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedExistenceProof.Data memory r, ) = CompressedExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedNonExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedNonExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedNonExistenceProof.Data memory r, ) = CompressedNonExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedExistenceProof._encode_nested(r.exist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedNonExistenceProof._encode_nested(r.nonexist, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedExistenceProof._estimate(r.exist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedNonExistenceProof._estimate(r.nonexist));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        CompressedExistenceProof.store(input.exist, output.exist);\n        CompressedNonExistenceProof.store(input.nonexist, output.nonexist);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedBatchEntry\n\nlibrary CompressedExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        bytes value;\n        LeafOp.Data leaf;\n        int32[] path;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.path = new int32[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_leaf(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LeafOp.Data memory x, uint256 sz) = _decode_LeafOp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.leaf = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_path(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.path[r.path.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LeafOp(uint256 p, bytes memory bs) internal pure returns (LeafOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LeafOp.Data memory r, ) = LeafOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n        if (r.value.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LeafOp._encode_nested(r.leaf, pointer, bs);\n\n        if (r.path.length != 0) {\n            for (i = 0; i < r.path.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n                pointer += ProtoBufRuntime._encode_int32(r.path[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(LeafOp._estimate(r.leaf));\n        for (i = 0; i < r.path.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_int32(r.path[i]);\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        if (r.value.length != 0) {\n            return false;\n        }\n\n        if (r.path.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        output.value = input.value;\n        LeafOp.store(input.leaf, output.leaf);\n        output.path = input.path;\n    }\n\n    //array helpers for Path\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addPath(Data memory self, int32 value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        int32[] memory tmp = new int32[](self.path.length + 1);\n        for (uint256 i = 0; i < self.path.length; i++) {\n            tmp[i] = self.path[i];\n        }\n        tmp[self.path.length] = value;\n        self.path = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedExistenceProof\n\nlibrary CompressedNonExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        CompressedExistenceProof.Data left;\n        CompressedExistenceProof.Data right;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_left(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_right(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_left(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedExistenceProof.Data memory x, uint256 sz) = _decode_CompressedExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.left = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_right(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedExistenceProof.Data memory x, uint256 sz) = _decode_CompressedExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.right = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedExistenceProof.Data memory r, ) = CompressedExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedExistenceProof._encode_nested(r.left, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedExistenceProof._encode_nested(r.right, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedExistenceProof._estimate(r.left));\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedExistenceProof._estimate(r.right));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        CompressedExistenceProof.store(input.left, output.left);\n        CompressedExistenceProof.store(input.right, output.right);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedNonExistenceProof\n\nlibrary PROOFS_PROTO_GLOBAL_ENUMS {\n    //enum definition\n    // Solidity enum definitions\n    enum HashOp {\n        NO_HASH,\n        SHA256,\n        SHA512,\n        KECCAK,\n        RIPEMD160,\n        BITCOIN,\n        SHA512_256\n    }\n\n    // Solidity enum encoder\n    function encode_HashOp(HashOp x) internal pure returns (int32) {\n        if (x == HashOp.NO_HASH) {\n            return 0;\n        }\n\n        if (x == HashOp.SHA256) {\n            return 1;\n        }\n\n        if (x == HashOp.SHA512) {\n            return 2;\n        }\n\n        if (x == HashOp.KECCAK) {\n            return 3;\n        }\n\n        if (x == HashOp.RIPEMD160) {\n            return 4;\n        }\n\n        if (x == HashOp.BITCOIN) {\n            return 5;\n        }\n\n        if (x == HashOp.SHA512_256) {\n            return 6;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_HashOp(int64 x) internal pure returns (HashOp) {\n        if (x == 0) {\n            return HashOp.NO_HASH;\n        }\n\n        if (x == 1) {\n            return HashOp.SHA256;\n        }\n\n        if (x == 2) {\n            return HashOp.SHA512;\n        }\n\n        if (x == 3) {\n            return HashOp.KECCAK;\n        }\n\n        if (x == 4) {\n            return HashOp.RIPEMD160;\n        }\n\n        if (x == 5) {\n            return HashOp.BITCOIN;\n        }\n\n        if (x == 6) {\n            return HashOp.SHA512_256;\n        }\n        revert();\n    }\n\n    // Solidity enum definitions\n    enum LengthOp {\n        NO_PREFIX,\n        VAR_PROTO,\n        VAR_RLP,\n        FIXED32_BIG,\n        FIXED32_LITTLE,\n        FIXED64_BIG,\n        FIXED64_LITTLE,\n        REQUIRE_32_BYTES,\n        REQUIRE_64_BYTES\n    }\n\n    // Solidity enum encoder\n    function encode_LengthOp(LengthOp x) internal pure returns (int32) {\n        if (x == LengthOp.NO_PREFIX) {\n            return 0;\n        }\n\n        if (x == LengthOp.VAR_PROTO) {\n            return 1;\n        }\n\n        if (x == LengthOp.VAR_RLP) {\n            return 2;\n        }\n\n        if (x == LengthOp.FIXED32_BIG) {\n            return 3;\n        }\n\n        if (x == LengthOp.FIXED32_LITTLE) {\n            return 4;\n        }\n\n        if (x == LengthOp.FIXED64_BIG) {\n            return 5;\n        }\n\n        if (x == LengthOp.FIXED64_LITTLE) {\n            return 6;\n        }\n\n        if (x == LengthOp.REQUIRE_32_BYTES) {\n            return 7;\n        }\n\n        if (x == LengthOp.REQUIRE_64_BYTES) {\n            return 8;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_LengthOp(int64 x) internal pure returns (LengthOp) {\n        if (x == 0) {\n            return LengthOp.NO_PREFIX;\n        }\n\n        if (x == 1) {\n            return LengthOp.VAR_PROTO;\n        }\n\n        if (x == 2) {\n            return LengthOp.VAR_RLP;\n        }\n\n        if (x == 3) {\n            return LengthOp.FIXED32_BIG;\n        }\n\n        if (x == 4) {\n            return LengthOp.FIXED32_LITTLE;\n        }\n\n        if (x == 5) {\n            return LengthOp.FIXED64_BIG;\n        }\n\n        if (x == 6) {\n            return LengthOp.FIXED64_LITTLE;\n        }\n\n        if (x == 7) {\n            return LengthOp.REQUIRE_32_BYTES;\n        }\n\n        if (x == 8) {\n            return LengthOp.REQUIRE_64_BYTES;\n        }\n        revert();\n    }\n}\n//library PROOFS_PROTO_GLOBAL_ENUMS\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/ProtoBufRuntime.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n/**\n * @title Runtime library for ProtoBuf serialization and/or deserialization.\n * All ProtoBuf generated code will use this library.\n */\nlibrary ProtoBufRuntime {\n    // Types defined in ProtoBuf\n    enum WireType {\n        Varint,\n        Fixed64,\n        LengthDelim,\n        StartGroup,\n        EndGroup,\n        Fixed32\n    }\n    // Constants for bytes calculation\n    uint256 constant WORD_LENGTH = 32;\n    uint256 constant HEADER_SIZE_LENGTH_IN_BYTES = 4;\n    uint256 constant BYTE_SIZE = 8;\n    uint256 constant REMAINING_LENGTH = WORD_LENGTH - HEADER_SIZE_LENGTH_IN_BYTES;\n    string constant OVERFLOW_MESSAGE = \"length overflow\";\n\n    //Storages\n    /**\n     * @dev Encode to storage location using assembly to save storage space.\n     * @param location The location of storage\n     * @param encoded The encoded ProtoBuf bytes\n     */\n    function encodeStorage(bytes storage location, bytes memory encoded) internal {\n        //\n        // This code use the first four bytes as size,\n        // and then put the rest of `encoded` bytes.\n        //\n        uint256 length = encoded.length;\n        uint256 firstWord;\n        uint256 wordLength = WORD_LENGTH;\n        uint256 remainingLength = REMAINING_LENGTH;\n\n        assembly {\n            firstWord := mload(add(encoded, wordLength))\n        }\n        firstWord =\n            (firstWord >> (BYTE_SIZE * HEADER_SIZE_LENGTH_IN_BYTES)) |\n            (length << (BYTE_SIZE * REMAINING_LENGTH));\n\n        assembly {\n            sstore(location.slot, firstWord)\n        }\n\n        if (length > REMAINING_LENGTH) {\n            length -= REMAINING_LENGTH;\n            for (uint256 i = 0; i < ceil(length, WORD_LENGTH); i++) {\n                assembly {\n                    let offset := add(mul(i, wordLength), remainingLength)\n                    let slotIndex := add(i, 1)\n                    sstore(add(location.slot, slotIndex), mload(add(add(encoded, wordLength), offset)))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Decode storage location using assembly using the format in `encodeStorage`.\n     * @param location The location of storage\n     * @return The encoded bytes\n     */\n    function decodeStorage(bytes storage location) internal view returns (bytes memory) {\n        //\n        // This code is to decode the first four bytes as size,\n        // and then decode the rest using the decoded size.\n        //\n        uint256 firstWord;\n        uint256 remainingLength = REMAINING_LENGTH;\n        uint256 wordLength = WORD_LENGTH;\n\n        assembly {\n            firstWord := sload(location.slot)\n        }\n\n        uint256 length = firstWord >> (BYTE_SIZE * REMAINING_LENGTH);\n        bytes memory encoded = new bytes(length);\n\n        assembly {\n            mstore(add(encoded, remainingLength), firstWord)\n        }\n\n        if (length > REMAINING_LENGTH) {\n            length -= REMAINING_LENGTH;\n            for (uint256 i = 0; i < ceil(length, WORD_LENGTH); i++) {\n                assembly {\n                    let offset := add(mul(i, wordLength), remainingLength)\n                    let slotIndex := add(i, 1)\n                    mstore(add(add(encoded, wordLength), offset), sload(add(location.slot, slotIndex)))\n                }\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Fast memory copy of bytes using assembly.\n     * @param src The source memory address\n     * @param dest The destination memory address\n     * @param len The length of bytes to copy\n     */\n    function copyBytes(uint256 src, uint256 dest, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_LENGTH; len -= WORD_LENGTH) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_LENGTH;\n            src += WORD_LENGTH;\n        }\n\n        // Copy remaining bytes\n        // TODO: There are two changes in solidity 0.8.x\n        // 1. exponential literal handling\n        // 2. overflow/underflow check enabled by default\n        //\n        // https://docs.soliditylang.org/en/latest/080-breaking-changes.html#how-to-update-your-code\n        //\n        // Here we have underflow / overflow and I don't yet know why. I tested:\n        //    uint256 WORD_LENGTH = 32;\n        //    uint256 len = 20;\n        //    uint256 mask =  256**(WORD_LENGTH - len) - 1;\n        //    uint256 mask2 = (256**(5)) - 1;\n        //    uint256 mask3 = 256**((5) - 1);\n        //\n        // all of them seem to return the same value, so I believe this is the overflow issue.\n        //\n        // To mitigate the issue I wrapped this in unchecked { }\n        uint256 mask;\n        unchecked {\n            mask = 256 ** (WORD_LENGTH - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Use assembly to get memory address.\n     * @param r The in-memory bytes array\n     * @return The memory address of `r`\n     */\n    function getMemoryAddress(bytes memory r) internal pure returns (uint256) {\n        uint256 addr;\n        assembly {\n            addr := r\n        }\n        return addr;\n    }\n\n    /**\n     * @dev Implement Math function of ceil\n     * @param a The denominator\n     * @param m The numerator\n     * @return r The result of ceil(a/m)\n     */\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256 r) {\n        return (a + m - 1) / m;\n    }\n\n    // Decoders\n    /**\n     * This section of code `_decode_(u)int(32|64)`, `_decode_enum` and `_decode_bool`\n     * is to decode ProtoBuf native integers,\n     * using the `varint` encoding.\n     */\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uint32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        return (uint32(varint), sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uint64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        return (uint64(varint), sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_int32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        int32 r;\n        assembly {\n            r := varint\n        }\n        return (r, sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_int64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        int64 r;\n        assembly {\n            r := varint\n        }\n        return (r, sz);\n    }\n\n    /**\n     * @dev Decode enum\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded enum's integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_enum(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        return _decode_int64(p, bs);\n    }\n\n    /**\n     * @dev Decode enum\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded boolean\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_bool(uint256 p, bytes memory bs) internal pure returns (bool, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        if (varint == 0) {\n            return (false, sz);\n        }\n        return (true, sz);\n    }\n\n    /**\n     * This section of code `_decode_sint(32|64)`\n     * is to decode ProtoBuf native signed integers,\n     * using the `zig-zag` encoding.\n     */\n\n    /**\n     * @dev Decode signed integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_sint32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (int256 varint, uint256 sz) = _decode_varints(p, bs);\n        return (int32(varint), sz);\n    }\n\n    /**\n     * @dev Decode signed integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_sint64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (int256 varint, uint256 sz) = _decode_varints(p, bs);\n        return (int64(varint), sz);\n    }\n\n    /**\n     * @dev Decode string\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded string\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_string(uint256 p, bytes memory bs) internal pure returns (string memory, uint256) {\n        (bytes memory x, uint256 sz) = _decode_lendelim(p, bs);\n        return (string(x), sz);\n    }\n\n    /**\n     * @dev Decode bytes array\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded bytes array\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_bytes(uint256 p, bytes memory bs) internal pure returns (bytes memory, uint256) {\n        return _decode_lendelim(p, bs);\n    }\n\n    /**\n     * @dev Decode ProtoBuf key\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded field ID\n     * @return The decoded WireType specified in ProtoBuf\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_key(uint256 p, bytes memory bs) internal pure returns (uint256, WireType, uint256) {\n        (uint256 x, uint256 n) = _decode_varint(p, bs);\n        WireType typeId = WireType(x & 7);\n        uint256 fieldId = x / 8;\n        return (fieldId, typeId, n);\n    }\n\n    /**\n     * @dev Decode ProtoBuf varint\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded unsigned integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_varint(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        //\n        // Read a byte.\n        // Use the lower 7 bits and shift it to the left,\n        // until the most significant bit is 0.\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 x = 0;\n        uint256 sz = 0;\n        uint256 length = bs.length + WORD_LENGTH;\n        assembly {\n            let b := 0x80\n            p := add(bs, p)\n            for {\n\n            } eq(0x80, and(b, 0x80)) {\n\n            } {\n                if eq(lt(sub(p, bs), length), 0) {\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000) //error function selector\n                    mstore(4, 32)\n                    mstore(36, 15)\n                    mstore(68, 0x6c656e677468206f766572666c6f770000000000000000000000000000000000) // length overflow in hex\n                    revert(0, 83)\n                }\n                let tmp := mload(p)\n                let pos := 0\n                for {\n\n                } and(eq(0x80, and(b, 0x80)), lt(pos, 32)) {\n\n                } {\n                    if eq(lt(sub(p, bs), length), 0) {\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000) //error function selector\n                        mstore(4, 32)\n                        mstore(36, 15)\n                        mstore(68, 0x6c656e677468206f766572666c6f770000000000000000000000000000000000) // length overflow in hex\n                        revert(0, 83)\n                    }\n                    b := byte(pos, tmp)\n                    x := or(x, shl(mul(7, sz), and(0x7f, b)))\n                    sz := add(sz, 1)\n                    pos := add(pos, 1)\n                    p := add(p, 0x01)\n                }\n            }\n        }\n        return (x, sz);\n    }\n\n    /**\n     * @dev Decode ProtoBuf zig-zag encoding\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded signed integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_varints(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        (uint256 u, uint256 sz) = _decode_varint(p, bs);\n        int256 s;\n        assembly {\n            s := xor(shr(1, u), add(not(and(u, 1)), 1))\n        }\n        return (s, sz);\n    }\n\n    /**\n     * @dev Decode ProtoBuf fixed-length encoding\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded unsigned integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uintf(uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256, uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 x = 0;\n        uint256 length = bs.length + WORD_LENGTH;\n        assert(p + sz <= length);\n        assembly {\n            let i := 0\n            p := add(bs, p)\n            let tmp := mload(p)\n            for {\n\n            } lt(i, sz) {\n\n            } {\n                x := or(x, shl(mul(8, i), byte(i, tmp)))\n                p := add(p, 0x01)\n                i := add(i, 1)\n            }\n        }\n        return (x, sz);\n    }\n\n    /**\n     * `_decode_(s)fixed(32|64)` is the concrete implementation of `_decode_uintf`\n     */\n    function _decode_fixed32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 4);\n        return (uint32(x), sz);\n    }\n\n    function _decode_fixed64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 8);\n        return (uint64(x), sz);\n    }\n\n    function _decode_sfixed32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 4);\n        int256 r;\n        assembly {\n            r := x\n        }\n        return (int32(r), sz);\n    }\n\n    function _decode_sfixed64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 8);\n        int256 r;\n        assembly {\n            r := x\n        }\n        return (int64(r), sz);\n    }\n\n    /**\n     * @dev Decode bytes array\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded bytes array\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_lendelim(uint256 p, bytes memory bs) internal pure returns (bytes memory, uint256) {\n        //\n        // First read the size encoded in `varint`, then use the size to read bytes.\n        //\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        bytes memory b = new bytes(len);\n        uint256 length = bs.length + WORD_LENGTH;\n        assert(p + sz + len <= length);\n        uint256 sourcePtr;\n        uint256 destPtr;\n        assembly {\n            destPtr := add(b, 32)\n            sourcePtr := add(add(bs, p), sz)\n        }\n        copyBytes(sourcePtr, destPtr, len);\n        return (b, sz + len);\n    }\n\n    // Encoders\n    /**\n     * @dev Encode ProtoBuf key\n     * @param x The field ID\n     * @param wt The WireType specified in ProtoBuf\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_key(uint256 x, WireType wt, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 i;\n        assembly {\n            i := or(mul(x, 8), mod(wt, 8))\n        }\n        return _encode_varint(i, p, bs);\n    }\n\n    /**\n     * @dev Encode ProtoBuf varint\n     * @param x The unsigned integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_varint(uint256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 sz = 0;\n        assembly {\n            let bsptr := add(bs, p)\n            let byt := and(x, 0x7f)\n            for {\n\n            } gt(shr(7, x), 0) {\n\n            } {\n                mstore8(bsptr, or(0x80, byt))\n                bsptr := add(bsptr, 1)\n                sz := add(sz, 1)\n                x := shr(7, x)\n                byt := and(x, 0x7f)\n            }\n            mstore8(bsptr, byt)\n            sz := add(sz, 1)\n        }\n        return sz;\n    }\n\n    /**\n     * @dev Encode ProtoBuf zig-zag encoding\n     * @param x The signed integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_varints(int256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 encodedInt = _encode_zigzag(x);\n        return _encode_varint(encodedInt, p, bs);\n    }\n\n    /**\n     * @dev Encode ProtoBuf bytes\n     * @param xs The bytes array to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_bytes(bytes memory xs, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 xsLength = xs.length;\n        uint256 sz = _encode_varint(xsLength, p, bs);\n        uint256 count = 0;\n        assembly {\n            let bsptr := add(bs, add(p, sz))\n            let xsptr := add(xs, 32)\n            for {\n\n            } lt(count, xsLength) {\n\n            } {\n                mstore8(bsptr, byte(0, mload(xsptr)))\n                bsptr := add(bsptr, 1)\n                xsptr := add(xsptr, 1)\n                count := add(count, 1)\n            }\n        }\n        return sz + count;\n    }\n\n    /**\n     * @dev Encode ProtoBuf string\n     * @param xs The string to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_string(string memory xs, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_bytes(bytes(xs), p, bs);\n    }\n\n    //\n    // `_encode_(u)int(32|64)`, `_encode_enum` and `_encode_bool`\n    // are concrete implementation of `_encode_varint`\n    //\n    function _encode_uint32(uint32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varint(x, p, bs);\n    }\n\n    function _encode_uint64(uint64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varint(x, p, bs);\n    }\n\n    function _encode_int32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_varint(twosComplement, p, bs);\n    }\n\n    function _encode_int64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_varint(twosComplement, p, bs);\n    }\n\n    function _encode_enum(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_int32(x, p, bs);\n    }\n\n    function _encode_bool(bool x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        if (x) {\n            return _encode_varint(1, p, bs);\n        } else return _encode_varint(0, p, bs);\n    }\n\n    //\n    // `_encode_sint(32|64)`, `_encode_enum` and `_encode_bool`\n    // are the concrete implementation of `_encode_varints`\n    //\n    function _encode_sint32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varints(x, p, bs);\n    }\n\n    function _encode_sint64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varints(x, p, bs);\n    }\n\n    //\n    // `_encode_(s)fixed(32|64)` is the concrete implementation of `_encode_uintf`\n    //\n    function _encode_fixed32(uint32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_uintf(x, p, bs, 4);\n    }\n\n    function _encode_fixed64(uint64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_uintf(x, p, bs, 8);\n    }\n\n    function _encode_sfixed32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint32 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_uintf(twosComplement, p, bs, 4);\n    }\n\n    function _encode_sfixed64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_uintf(twosComplement, p, bs, 8);\n    }\n\n    /**\n     * @dev Encode ProtoBuf fixed-length integer\n     * @param x The unsigned integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_uintf(uint256 x, uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256) {\n        assembly {\n            let bsptr := add(sz, add(bs, p))\n            let count := sz\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                bsptr := sub(bsptr, 1)\n                mstore8(bsptr, byte(sub(32, count), x))\n                count := sub(count, 1)\n            }\n        }\n        return sz;\n    }\n\n    /**\n     * @dev Encode ProtoBuf zig-zag signed integer\n     * @param i The unsigned integer to be encoded\n     * @return The encoded unsigned integer\n     */\n    function _encode_zigzag(int256 i) internal pure returns (uint256) {\n        if (i >= 0) {\n            return uint256(i) * 2;\n        } else return uint256(i * -2) - 1;\n    }\n\n    // Estimators\n    /**\n     * @dev Estimate the length of encoded LengthDelim\n     * @param i The length of LengthDelim\n     * @return The estimated encoded length\n     */\n    function _sz_lendelim(uint256 i) internal pure returns (uint256) {\n        return i + _sz_varint(i);\n    }\n\n    /**\n     * @dev Estimate the length of encoded ProtoBuf field ID\n     * @param i The field ID\n     * @return The estimated encoded length\n     */\n    function _sz_key(uint256 i) internal pure returns (uint256) {\n        if (i < 16) {\n            return 1;\n        } else if (i < 2048) {\n            return 2;\n        } else if (i < 262144) {\n            return 3;\n        } else {\n            revert(\"not supported\");\n        }\n    }\n\n    /**\n     * @dev Estimate the length of encoded ProtoBuf varint\n     * @param i The unsigned integer\n     * @return The estimated encoded length\n     */\n    function _sz_varint(uint256 i) internal pure returns (uint256) {\n        uint256 count = 1;\n        assembly {\n            i := shr(7, i)\n            for {\n\n            } gt(i, 0) {\n\n            } {\n                i := shr(7, i)\n                count := add(count, 1)\n            }\n        }\n        return count;\n    }\n\n    /**\n     * `_sz_(u)int(32|64)` and `_sz_enum` are the concrete implementation of `_sz_varint`\n     */\n    function _sz_uint32(uint32 i) internal pure returns (uint256) {\n        return _sz_varint(i);\n    }\n\n    function _sz_uint64(uint64 i) internal pure returns (uint256) {\n        return _sz_varint(i);\n    }\n\n    function _sz_int32(int32 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint32(i));\n    }\n\n    function _sz_int64(int64 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint64(i));\n    }\n\n    function _sz_enum(int64 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint64(i));\n    }\n\n    /**\n     * `_sz_sint(32|64)` and `_sz_enum` are the concrete implementation of zig-zag encoding\n     */\n    function _sz_sint32(int32 i) internal pure returns (uint256) {\n        return _sz_varint(_encode_zigzag(i));\n    }\n\n    function _sz_sint64(int64 i) internal pure returns (uint256) {\n        return _sz_varint(_encode_zigzag(i));\n    }\n\n    // Soltype extensions\n    /**\n     * @dev Decode Solidity integer and/or fixed-size bytes array, filling from lowest bit.\n     * @param n The maximum number of bytes to read\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The bytes32 representation\n     * @return The number of bytes used to decode\n     */\n    function _decode_sol_bytesN_lower(uint8 n, uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        uint256 r;\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        if (len + sz > n + 3) {\n            revert(OVERFLOW_MESSAGE);\n        }\n        p += 3;\n        assert(p < bs.length + WORD_LENGTH);\n        assembly {\n            r := mload(add(p, bs))\n        }\n        for (uint256 i = len - 2; i < WORD_LENGTH; i++) {\n            r /= 256;\n        }\n        return (bytes32(r), len + sz);\n    }\n\n    /**\n     * @dev Decode Solidity integer and/or fixed-size bytes array, filling from highest bit.\n     * @param n The maximum number of bytes to read\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The bytes32 representation\n     * @return The number of bytes used to decode\n     */\n    function _decode_sol_bytesN(uint8 n, uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        uint256 wordLength = WORD_LENGTH;\n        uint256 byteSize = BYTE_SIZE;\n        if (len + sz > n + 3) {\n            revert(OVERFLOW_MESSAGE);\n        }\n        p += 3;\n        bytes32 acc;\n        assert(p < bs.length + WORD_LENGTH);\n        assembly {\n            acc := mload(add(p, bs))\n            let difference := sub(wordLength, sub(len, 2))\n            let bits := mul(byteSize, difference)\n            acc := shl(bits, shr(bits, acc))\n        }\n        return (acc, len + sz);\n    }\n\n    /*\n     * `_decode_sol*` are the concrete implementation of decoding Solidity types\n     */\n    function _decode_sol_address(uint256 p, bytes memory bs) internal pure returns (address, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytesN(20, p, bs);\n        return (address(bytes20(r)), sz);\n    }\n\n    function _decode_sol_bool(uint256 p, bytes memory bs) internal pure returns (bool, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(1, p, bs);\n        if (r == 0) {\n            return (false, sz);\n        }\n        return (true, sz);\n    }\n\n    function _decode_sol_uint(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        return _decode_sol_uint256(p, bs);\n    }\n\n    function _decode_sol_uintN(uint8 n, uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN_lower(n, p, bs);\n        uint256 r;\n        assembly {\n            r := u\n        }\n        return (r, sz);\n    }\n\n    function _decode_sol_uint8(uint256 p, bytes memory bs) internal pure returns (uint8, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(1, p, bs);\n        return (uint8(r), sz);\n    }\n\n    function _decode_sol_uint16(uint256 p, bytes memory bs) internal pure returns (uint16, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(2, p, bs);\n        return (uint16(r), sz);\n    }\n\n    function _decode_sol_uint24(uint256 p, bytes memory bs) internal pure returns (uint24, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(3, p, bs);\n        return (uint24(r), sz);\n    }\n\n    function _decode_sol_uint32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(4, p, bs);\n        return (uint32(r), sz);\n    }\n\n    function _decode_sol_uint40(uint256 p, bytes memory bs) internal pure returns (uint40, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(5, p, bs);\n        return (uint40(r), sz);\n    }\n\n    function _decode_sol_uint48(uint256 p, bytes memory bs) internal pure returns (uint48, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(6, p, bs);\n        return (uint48(r), sz);\n    }\n\n    function _decode_sol_uint56(uint256 p, bytes memory bs) internal pure returns (uint56, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(7, p, bs);\n        return (uint56(r), sz);\n    }\n\n    function _decode_sol_uint64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(8, p, bs);\n        return (uint64(r), sz);\n    }\n\n    function _decode_sol_uint72(uint256 p, bytes memory bs) internal pure returns (uint72, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(9, p, bs);\n        return (uint72(r), sz);\n    }\n\n    function _decode_sol_uint80(uint256 p, bytes memory bs) internal pure returns (uint80, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(10, p, bs);\n        return (uint80(r), sz);\n    }\n\n    function _decode_sol_uint88(uint256 p, bytes memory bs) internal pure returns (uint88, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(11, p, bs);\n        return (uint88(r), sz);\n    }\n\n    function _decode_sol_uint96(uint256 p, bytes memory bs) internal pure returns (uint96, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(12, p, bs);\n        return (uint96(r), sz);\n    }\n\n    function _decode_sol_uint104(uint256 p, bytes memory bs) internal pure returns (uint104, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(13, p, bs);\n        return (uint104(r), sz);\n    }\n\n    function _decode_sol_uint112(uint256 p, bytes memory bs) internal pure returns (uint112, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(14, p, bs);\n        return (uint112(r), sz);\n    }\n\n    function _decode_sol_uint120(uint256 p, bytes memory bs) internal pure returns (uint120, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(15, p, bs);\n        return (uint120(r), sz);\n    }\n\n    function _decode_sol_uint128(uint256 p, bytes memory bs) internal pure returns (uint128, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(16, p, bs);\n        return (uint128(r), sz);\n    }\n\n    function _decode_sol_uint136(uint256 p, bytes memory bs) internal pure returns (uint136, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(17, p, bs);\n        return (uint136(r), sz);\n    }\n\n    function _decode_sol_uint144(uint256 p, bytes memory bs) internal pure returns (uint144, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(18, p, bs);\n        return (uint144(r), sz);\n    }\n\n    function _decode_sol_uint152(uint256 p, bytes memory bs) internal pure returns (uint152, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(19, p, bs);\n        return (uint152(r), sz);\n    }\n\n    function _decode_sol_uint160(uint256 p, bytes memory bs) internal pure returns (uint160, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(20, p, bs);\n        return (uint160(r), sz);\n    }\n\n    function _decode_sol_uint168(uint256 p, bytes memory bs) internal pure returns (uint168, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(21, p, bs);\n        return (uint168(r), sz);\n    }\n\n    function _decode_sol_uint176(uint256 p, bytes memory bs) internal pure returns (uint176, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(22, p, bs);\n        return (uint176(r), sz);\n    }\n\n    function _decode_sol_uint184(uint256 p, bytes memory bs) internal pure returns (uint184, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(23, p, bs);\n        return (uint184(r), sz);\n    }\n\n    function _decode_sol_uint192(uint256 p, bytes memory bs) internal pure returns (uint192, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(24, p, bs);\n        return (uint192(r), sz);\n    }\n\n    function _decode_sol_uint200(uint256 p, bytes memory bs) internal pure returns (uint200, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(25, p, bs);\n        return (uint200(r), sz);\n    }\n\n    function _decode_sol_uint208(uint256 p, bytes memory bs) internal pure returns (uint208, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(26, p, bs);\n        return (uint208(r), sz);\n    }\n\n    function _decode_sol_uint216(uint256 p, bytes memory bs) internal pure returns (uint216, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(27, p, bs);\n        return (uint216(r), sz);\n    }\n\n    function _decode_sol_uint224(uint256 p, bytes memory bs) internal pure returns (uint224, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(28, p, bs);\n        return (uint224(r), sz);\n    }\n\n    function _decode_sol_uint232(uint256 p, bytes memory bs) internal pure returns (uint232, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(29, p, bs);\n        return (uint232(r), sz);\n    }\n\n    function _decode_sol_uint240(uint256 p, bytes memory bs) internal pure returns (uint240, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(30, p, bs);\n        return (uint240(r), sz);\n    }\n\n    function _decode_sol_uint248(uint256 p, bytes memory bs) internal pure returns (uint248, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(31, p, bs);\n        return (uint248(r), sz);\n    }\n\n    function _decode_sol_uint256(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(32, p, bs);\n        return (uint256(r), sz);\n    }\n\n    function _decode_sol_int(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        return _decode_sol_int256(p, bs);\n    }\n\n    function _decode_sol_intN(uint8 n, uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN_lower(n, p, bs);\n        int256 r;\n        assembly {\n            r := u\n            r := signextend(sub(sz, 4), r)\n        }\n        return (r, sz);\n    }\n\n    function _decode_sol_bytes(uint8 n, uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN(n, p, bs);\n        return (u, sz);\n    }\n\n    function _decode_sol_int8(uint256 p, bytes memory bs) internal pure returns (int8, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(1, p, bs);\n        return (int8(r), sz);\n    }\n\n    function _decode_sol_int16(uint256 p, bytes memory bs) internal pure returns (int16, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(2, p, bs);\n        return (int16(r), sz);\n    }\n\n    function _decode_sol_int24(uint256 p, bytes memory bs) internal pure returns (int24, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(3, p, bs);\n        return (int24(r), sz);\n    }\n\n    function _decode_sol_int32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(4, p, bs);\n        return (int32(r), sz);\n    }\n\n    function _decode_sol_int40(uint256 p, bytes memory bs) internal pure returns (int40, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(5, p, bs);\n        return (int40(r), sz);\n    }\n\n    function _decode_sol_int48(uint256 p, bytes memory bs) internal pure returns (int48, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(6, p, bs);\n        return (int48(r), sz);\n    }\n\n    function _decode_sol_int56(uint256 p, bytes memory bs) internal pure returns (int56, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(7, p, bs);\n        return (int56(r), sz);\n    }\n\n    function _decode_sol_int64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(8, p, bs);\n        return (int64(r), sz);\n    }\n\n    function _decode_sol_int72(uint256 p, bytes memory bs) internal pure returns (int72, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(9, p, bs);\n        return (int72(r), sz);\n    }\n\n    function _decode_sol_int80(uint256 p, bytes memory bs) internal pure returns (int80, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(10, p, bs);\n        return (int80(r), sz);\n    }\n\n    function _decode_sol_int88(uint256 p, bytes memory bs) internal pure returns (int88, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(11, p, bs);\n        return (int88(r), sz);\n    }\n\n    function _decode_sol_int96(uint256 p, bytes memory bs) internal pure returns (int96, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(12, p, bs);\n        return (int96(r), sz);\n    }\n\n    function _decode_sol_int104(uint256 p, bytes memory bs) internal pure returns (int104, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(13, p, bs);\n        return (int104(r), sz);\n    }\n\n    function _decode_sol_int112(uint256 p, bytes memory bs) internal pure returns (int112, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(14, p, bs);\n        return (int112(r), sz);\n    }\n\n    function _decode_sol_int120(uint256 p, bytes memory bs) internal pure returns (int120, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(15, p, bs);\n        return (int120(r), sz);\n    }\n\n    function _decode_sol_int128(uint256 p, bytes memory bs) internal pure returns (int128, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(16, p, bs);\n        return (int128(r), sz);\n    }\n\n    function _decode_sol_int136(uint256 p, bytes memory bs) internal pure returns (int136, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(17, p, bs);\n        return (int136(r), sz);\n    }\n\n    function _decode_sol_int144(uint256 p, bytes memory bs) internal pure returns (int144, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(18, p, bs);\n        return (int144(r), sz);\n    }\n\n    function _decode_sol_int152(uint256 p, bytes memory bs) internal pure returns (int152, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(19, p, bs);\n        return (int152(r), sz);\n    }\n\n    function _decode_sol_int160(uint256 p, bytes memory bs) internal pure returns (int160, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(20, p, bs);\n        return (int160(r), sz);\n    }\n\n    function _decode_sol_int168(uint256 p, bytes memory bs) internal pure returns (int168, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(21, p, bs);\n        return (int168(r), sz);\n    }\n\n    function _decode_sol_int176(uint256 p, bytes memory bs) internal pure returns (int176, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(22, p, bs);\n        return (int176(r), sz);\n    }\n\n    function _decode_sol_int184(uint256 p, bytes memory bs) internal pure returns (int184, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(23, p, bs);\n        return (int184(r), sz);\n    }\n\n    function _decode_sol_int192(uint256 p, bytes memory bs) internal pure returns (int192, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(24, p, bs);\n        return (int192(r), sz);\n    }\n\n    function _decode_sol_int200(uint256 p, bytes memory bs) internal pure returns (int200, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(25, p, bs);\n        return (int200(r), sz);\n    }\n\n    function _decode_sol_int208(uint256 p, bytes memory bs) internal pure returns (int208, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(26, p, bs);\n        return (int208(r), sz);\n    }\n\n    function _decode_sol_int216(uint256 p, bytes memory bs) internal pure returns (int216, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(27, p, bs);\n        return (int216(r), sz);\n    }\n\n    function _decode_sol_int224(uint256 p, bytes memory bs) internal pure returns (int224, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(28, p, bs);\n        return (int224(r), sz);\n    }\n\n    function _decode_sol_int232(uint256 p, bytes memory bs) internal pure returns (int232, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(29, p, bs);\n        return (int232(r), sz);\n    }\n\n    function _decode_sol_int240(uint256 p, bytes memory bs) internal pure returns (int240, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(30, p, bs);\n        return (int240(r), sz);\n    }\n\n    function _decode_sol_int248(uint256 p, bytes memory bs) internal pure returns (int248, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(31, p, bs);\n        return (int248(r), sz);\n    }\n\n    function _decode_sol_int256(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(32, p, bs);\n        return (int256(r), sz);\n    }\n\n    function _decode_sol_bytes1(uint256 p, bytes memory bs) internal pure returns (bytes1, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(1, p, bs);\n        return (bytes1(r), sz);\n    }\n\n    function _decode_sol_bytes2(uint256 p, bytes memory bs) internal pure returns (bytes2, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(2, p, bs);\n        return (bytes2(r), sz);\n    }\n\n    function _decode_sol_bytes3(uint256 p, bytes memory bs) internal pure returns (bytes3, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(3, p, bs);\n        return (bytes3(r), sz);\n    }\n\n    function _decode_sol_bytes4(uint256 p, bytes memory bs) internal pure returns (bytes4, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(4, p, bs);\n        return (bytes4(r), sz);\n    }\n\n    function _decode_sol_bytes5(uint256 p, bytes memory bs) internal pure returns (bytes5, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(5, p, bs);\n        return (bytes5(r), sz);\n    }\n\n    function _decode_sol_bytes6(uint256 p, bytes memory bs) internal pure returns (bytes6, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(6, p, bs);\n        return (bytes6(r), sz);\n    }\n\n    function _decode_sol_bytes7(uint256 p, bytes memory bs) internal pure returns (bytes7, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(7, p, bs);\n        return (bytes7(r), sz);\n    }\n\n    function _decode_sol_bytes8(uint256 p, bytes memory bs) internal pure returns (bytes8, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(8, p, bs);\n        return (bytes8(r), sz);\n    }\n\n    function _decode_sol_bytes9(uint256 p, bytes memory bs) internal pure returns (bytes9, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(9, p, bs);\n        return (bytes9(r), sz);\n    }\n\n    function _decode_sol_bytes10(uint256 p, bytes memory bs) internal pure returns (bytes10, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(10, p, bs);\n        return (bytes10(r), sz);\n    }\n\n    function _decode_sol_bytes11(uint256 p, bytes memory bs) internal pure returns (bytes11, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(11, p, bs);\n        return (bytes11(r), sz);\n    }\n\n    function _decode_sol_bytes12(uint256 p, bytes memory bs) internal pure returns (bytes12, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(12, p, bs);\n        return (bytes12(r), sz);\n    }\n\n    function _decode_sol_bytes13(uint256 p, bytes memory bs) internal pure returns (bytes13, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(13, p, bs);\n        return (bytes13(r), sz);\n    }\n\n    function _decode_sol_bytes14(uint256 p, bytes memory bs) internal pure returns (bytes14, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(14, p, bs);\n        return (bytes14(r), sz);\n    }\n\n    function _decode_sol_bytes15(uint256 p, bytes memory bs) internal pure returns (bytes15, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(15, p, bs);\n        return (bytes15(r), sz);\n    }\n\n    function _decode_sol_bytes16(uint256 p, bytes memory bs) internal pure returns (bytes16, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(16, p, bs);\n        return (bytes16(r), sz);\n    }\n\n    function _decode_sol_bytes17(uint256 p, bytes memory bs) internal pure returns (bytes17, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(17, p, bs);\n        return (bytes17(r), sz);\n    }\n\n    function _decode_sol_bytes18(uint256 p, bytes memory bs) internal pure returns (bytes18, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(18, p, bs);\n        return (bytes18(r), sz);\n    }\n\n    function _decode_sol_bytes19(uint256 p, bytes memory bs) internal pure returns (bytes19, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(19, p, bs);\n        return (bytes19(r), sz);\n    }\n\n    function _decode_sol_bytes20(uint256 p, bytes memory bs) internal pure returns (bytes20, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(20, p, bs);\n        return (bytes20(r), sz);\n    }\n\n    function _decode_sol_bytes21(uint256 p, bytes memory bs) internal pure returns (bytes21, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(21, p, bs);\n        return (bytes21(r), sz);\n    }\n\n    function _decode_sol_bytes22(uint256 p, bytes memory bs) internal pure returns (bytes22, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(22, p, bs);\n        return (bytes22(r), sz);\n    }\n\n    function _decode_sol_bytes23(uint256 p, bytes memory bs) internal pure returns (bytes23, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(23, p, bs);\n        return (bytes23(r), sz);\n    }\n\n    function _decode_sol_bytes24(uint256 p, bytes memory bs) internal pure returns (bytes24, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(24, p, bs);\n        return (bytes24(r), sz);\n    }\n\n    function _decode_sol_bytes25(uint256 p, bytes memory bs) internal pure returns (bytes25, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(25, p, bs);\n        return (bytes25(r), sz);\n    }\n\n    function _decode_sol_bytes26(uint256 p, bytes memory bs) internal pure returns (bytes26, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(26, p, bs);\n        return (bytes26(r), sz);\n    }\n\n    function _decode_sol_bytes27(uint256 p, bytes memory bs) internal pure returns (bytes27, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(27, p, bs);\n        return (bytes27(r), sz);\n    }\n\n    function _decode_sol_bytes28(uint256 p, bytes memory bs) internal pure returns (bytes28, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(28, p, bs);\n        return (bytes28(r), sz);\n    }\n\n    function _decode_sol_bytes29(uint256 p, bytes memory bs) internal pure returns (bytes29, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(29, p, bs);\n        return (bytes29(r), sz);\n    }\n\n    function _decode_sol_bytes30(uint256 p, bytes memory bs) internal pure returns (bytes30, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(30, p, bs);\n        return (bytes30(r), sz);\n    }\n\n    function _decode_sol_bytes31(uint256 p, bytes memory bs) internal pure returns (bytes31, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(31, p, bs);\n        return (bytes31(r), sz);\n    }\n\n    function _decode_sol_bytes32(uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        return _decode_sol_bytes(32, p, bs);\n    }\n\n    /*\n     * `_encode_sol*` are the concrete implementation of encoding Solidity types\n     */\n    function _encode_sol_address(address x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(uint160(x)), 20, p, bs);\n    }\n\n    function _encode_sol_uint(uint256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 32, p, bs);\n    }\n\n    function _encode_sol_uint8(uint8 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 1, p, bs);\n    }\n\n    function _encode_sol_uint16(uint16 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 2, p, bs);\n    }\n\n    function _encode_sol_uint24(uint24 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 3, p, bs);\n    }\n\n    function _encode_sol_uint32(uint32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 4, p, bs);\n    }\n\n    function _encode_sol_uint40(uint40 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 5, p, bs);\n    }\n\n    function _encode_sol_uint48(uint48 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 6, p, bs);\n    }\n\n    function _encode_sol_uint56(uint56 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 7, p, bs);\n    }\n\n    function _encode_sol_uint64(uint64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 8, p, bs);\n    }\n\n    function _encode_sol_uint72(uint72 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 9, p, bs);\n    }\n\n    function _encode_sol_uint80(uint80 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 10, p, bs);\n    }\n\n    function _encode_sol_uint88(uint88 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 11, p, bs);\n    }\n\n    function _encode_sol_uint96(uint96 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 12, p, bs);\n    }\n\n    function _encode_sol_uint104(uint104 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 13, p, bs);\n    }\n\n    function _encode_sol_uint112(uint112 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 14, p, bs);\n    }\n\n    function _encode_sol_uint120(uint120 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 15, p, bs);\n    }\n\n    function _encode_sol_uint128(uint128 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 16, p, bs);\n    }\n\n    function _encode_sol_uint136(uint136 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 17, p, bs);\n    }\n\n    function _encode_sol_uint144(uint144 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 18, p, bs);\n    }\n\n    function _encode_sol_uint152(uint152 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 19, p, bs);\n    }\n\n    function _encode_sol_uint160(uint160 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 20, p, bs);\n    }\n\n    function _encode_sol_uint168(uint168 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 21, p, bs);\n    }\n\n    function _encode_sol_uint176(uint176 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 22, p, bs);\n    }\n\n    function _encode_sol_uint184(uint184 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 23, p, bs);\n    }\n\n    function _encode_sol_uint192(uint192 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 24, p, bs);\n    }\n\n    function _encode_sol_uint200(uint200 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 25, p, bs);\n    }\n\n    function _encode_sol_uint208(uint208 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 26, p, bs);\n    }\n\n    function _encode_sol_uint216(uint216 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 27, p, bs);\n    }\n\n    function _encode_sol_uint224(uint224 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 28, p, bs);\n    }\n\n    function _encode_sol_uint232(uint232 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 29, p, bs);\n    }\n\n    function _encode_sol_uint240(uint240 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 30, p, bs);\n    }\n\n    function _encode_sol_uint248(uint248 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 31, p, bs);\n    }\n\n    function _encode_sol_uint256(uint256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 32, p, bs);\n    }\n\n    function _encode_sol_int(int256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(x, 32, p, bs);\n    }\n\n    function _encode_sol_int8(int8 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 1, p, bs);\n    }\n\n    function _encode_sol_int16(int16 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 2, p, bs);\n    }\n\n    function _encode_sol_int24(int24 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 3, p, bs);\n    }\n\n    function _encode_sol_int32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 4, p, bs);\n    }\n\n    function _encode_sol_int40(int40 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 5, p, bs);\n    }\n\n    function _encode_sol_int48(int48 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 6, p, bs);\n    }\n\n    function _encode_sol_int56(int56 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 7, p, bs);\n    }\n\n    function _encode_sol_int64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 8, p, bs);\n    }\n\n    function _encode_sol_int72(int72 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 9, p, bs);\n    }\n\n    function _encode_sol_int80(int80 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 10, p, bs);\n    }\n\n    function _encode_sol_int88(int88 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 11, p, bs);\n    }\n\n    function _encode_sol_int96(int96 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 12, p, bs);\n    }\n\n    function _encode_sol_int104(int104 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 13, p, bs);\n    }\n\n    function _encode_sol_int112(int112 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 14, p, bs);\n    }\n\n    function _encode_sol_int120(int120 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 15, p, bs);\n    }\n\n    function _encode_sol_int128(int128 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 16, p, bs);\n    }\n\n    function _encode_sol_int136(int136 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 17, p, bs);\n    }\n\n    function _encode_sol_int144(int144 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 18, p, bs);\n    }\n\n    function _encode_sol_int152(int152 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 19, p, bs);\n    }\n\n    function _encode_sol_int160(int160 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 20, p, bs);\n    }\n\n    function _encode_sol_int168(int168 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 21, p, bs);\n    }\n\n    function _encode_sol_int176(int176 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 22, p, bs);\n    }\n\n    function _encode_sol_int184(int184 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 23, p, bs);\n    }\n\n    function _encode_sol_int192(int192 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 24, p, bs);\n    }\n\n    function _encode_sol_int200(int200 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 25, p, bs);\n    }\n\n    function _encode_sol_int208(int208 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 26, p, bs);\n    }\n\n    function _encode_sol_int216(int216 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 27, p, bs);\n    }\n\n    function _encode_sol_int224(int224 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 28, p, bs);\n    }\n\n    function _encode_sol_int232(int232 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 29, p, bs);\n    }\n\n    function _encode_sol_int240(int240 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 30, p, bs);\n    }\n\n    function _encode_sol_int248(int248 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 31, p, bs);\n    }\n\n    function _encode_sol_int256(int256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(x, 32, p, bs);\n    }\n\n    function _encode_sol_bytes1(bytes1 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 1, p, bs);\n    }\n\n    function _encode_sol_bytes2(bytes2 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 2, p, bs);\n    }\n\n    function _encode_sol_bytes3(bytes3 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 3, p, bs);\n    }\n\n    function _encode_sol_bytes4(bytes4 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 4, p, bs);\n    }\n\n    function _encode_sol_bytes5(bytes5 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 5, p, bs);\n    }\n\n    function _encode_sol_bytes6(bytes6 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 6, p, bs);\n    }\n\n    function _encode_sol_bytes7(bytes7 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 7, p, bs);\n    }\n\n    function _encode_sol_bytes8(bytes8 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 8, p, bs);\n    }\n\n    function _encode_sol_bytes9(bytes9 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 9, p, bs);\n    }\n\n    function _encode_sol_bytes10(bytes10 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 10, p, bs);\n    }\n\n    function _encode_sol_bytes11(bytes11 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 11, p, bs);\n    }\n\n    function _encode_sol_bytes12(bytes12 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 12, p, bs);\n    }\n\n    function _encode_sol_bytes13(bytes13 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 13, p, bs);\n    }\n\n    function _encode_sol_bytes14(bytes14 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 14, p, bs);\n    }\n\n    function _encode_sol_bytes15(bytes15 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 15, p, bs);\n    }\n\n    function _encode_sol_bytes16(bytes16 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 16, p, bs);\n    }\n\n    function _encode_sol_bytes17(bytes17 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 17, p, bs);\n    }\n\n    function _encode_sol_bytes18(bytes18 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 18, p, bs);\n    }\n\n    function _encode_sol_bytes19(bytes19 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 19, p, bs);\n    }\n\n    function _encode_sol_bytes20(bytes20 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 20, p, bs);\n    }\n\n    function _encode_sol_bytes21(bytes21 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 21, p, bs);\n    }\n\n    function _encode_sol_bytes22(bytes22 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 22, p, bs);\n    }\n\n    function _encode_sol_bytes23(bytes23 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 23, p, bs);\n    }\n\n    function _encode_sol_bytes24(bytes24 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 24, p, bs);\n    }\n\n    function _encode_sol_bytes25(bytes25 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 25, p, bs);\n    }\n\n    function _encode_sol_bytes26(bytes26 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 26, p, bs);\n    }\n\n    function _encode_sol_bytes27(bytes27 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 27, p, bs);\n    }\n\n    function _encode_sol_bytes28(bytes28 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 28, p, bs);\n    }\n\n    function _encode_sol_bytes29(bytes29 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 29, p, bs);\n    }\n\n    function _encode_sol_bytes30(bytes30 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 30, p, bs);\n    }\n\n    function _encode_sol_bytes31(bytes31 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 31, p, bs);\n    }\n\n    function _encode_sol_bytes32(bytes32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(x, 32, p, bs);\n    }\n\n    /**\n     * @dev Encode the key of Solidity integer and/or fixed-size bytes array.\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol_header(uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        p += _encode_varint(sz + 2, p, bs);\n        p += _encode_key(1, WireType.LengthDelim, p, bs);\n        p += _encode_varint(sz, p, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The unsinged integer to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol(uint256 x, uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_other(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The signed integer to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol(int256 x, uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_other(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The fixed-size byte array to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol_bytes(bytes32 x, uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_bytes_array(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Get the actual size needed to encoding an unsigned integer\n     * @param x The unsigned integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _get_real_size(uint256 x, uint256 sz) internal pure returns (uint256) {\n        uint256 base = 0xff;\n        uint256 realSize = sz;\n        while (x & (base << (realSize * BYTE_SIZE - BYTE_SIZE)) == 0 && realSize > 0) {\n            realSize -= 1;\n        }\n        if (realSize == 0) {\n            realSize = 1;\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Get the actual size needed to encoding an signed integer\n     * @param x The signed integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _get_real_size(int256 x, uint256 sz) internal pure returns (uint256) {\n        int256 base = 0xff;\n        if (x >= 0) {\n            uint256 tmp = _get_real_size(uint256(x), sz);\n            int256 remainder = (x & (base << (tmp * BYTE_SIZE - BYTE_SIZE))) >> (tmp * BYTE_SIZE - BYTE_SIZE);\n            if (remainder >= 128) {\n                tmp += 1;\n            }\n            return tmp;\n        }\n\n        uint256 realSize = sz;\n        while (\n            x & (base << (realSize * BYTE_SIZE - BYTE_SIZE)) == (base << (realSize * BYTE_SIZE - BYTE_SIZE)) &&\n            realSize > 0\n        ) {\n            realSize -= 1;\n        }\n        int256 remainder = (x & (base << (realSize * BYTE_SIZE - BYTE_SIZE))) >> (realSize * BYTE_SIZE - BYTE_SIZE);\n        if (remainder < 128) {\n            realSize += 1;\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Encode the fixed-bytes array\n     * @param x The fixed-size byte array to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_bytes_array(\n        bytes32 x,\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (uint256) {\n        //\n        // The idea is to not encode the leading bytes of zero.\n        //\n        uint256 actualSize = sz;\n        for (uint256 i = 0; i < sz; i++) {\n            uint8 current = uint8(x[sz - 1 - i]);\n            if (current == 0 && actualSize > 1) {\n                actualSize--;\n            } else {\n                break;\n            }\n        }\n        assembly {\n            let bsptr := add(bs, p)\n            let count := actualSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(actualSize, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return actualSize;\n    }\n\n    /**\n     * @dev Encode the signed integer\n     * @param x The signed integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_other(int256 x, uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256) {\n        //\n        // The idea is to not encode the leading bytes of zero.or one,\n        // depending on whether it is positive.\n        //\n        uint256 realSize = _get_real_size(x, sz);\n        assembly {\n            let bsptr := add(bs, p)\n            let count := realSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(32, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Encode the unsigned integer\n     * @param x The unsigned integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_other(uint256 x, uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256) {\n        uint256 realSize = _get_real_size(x, sz);\n        assembly {\n            let bsptr := add(bs, p)\n            let count := realSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(32, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return realSize;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/TendermintHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS, Validator, SimpleValidator, BlockID, Vote, CanonicalBlockID, CanonicalPartSetHeader, CanonicalVote, TmHeader, ConsensusState, MerkleRoot, Commit, CommitSig, SignedHeader, ValidatorSet, Duration, Timestamp, Consensus} from \"./TendermintLight.sol\";\nimport \"./Encoder.sol\";\nimport \"../crypto/MerkleTree.sol\";\n\nlibrary TendermintHelper {\n    function toSimpleValidator(Validator.Data memory val) internal pure returns (SimpleValidator.Data memory) {\n        return SimpleValidator.Data({pub_key: val.pub_key, voting_power: val.voting_power});\n    }\n\n    function toCanonicalBlockID(BlockID.Data memory blockID) internal pure returns (CanonicalBlockID.Data memory) {\n        return\n            CanonicalBlockID.Data({\n                hash: blockID.hash,\n                part_set_header: CanonicalPartSetHeader.Data({\n                    total: blockID.part_set_header.total,\n                    hash: blockID.part_set_header.hash\n                })\n            });\n    }\n\n    function toCanonicalVote(\n        Vote.Data memory vote,\n        string memory chainID\n    ) internal pure returns (CanonicalVote.Data memory) {\n        return\n            CanonicalVote.Data({\n                Type: vote.Type,\n                height: vote.height,\n                round: int64(vote.round),\n                block_id: toCanonicalBlockID(vote.block_id),\n                timestamp: vote.timestamp,\n                chain_id: chainID\n            });\n    }\n\n    function toConsensusState(TmHeader.Data memory tmHeader) internal pure returns (ConsensusState.Data memory) {\n        return\n            ConsensusState.Data({\n                timestamp: tmHeader.signed_header.header.time,\n                root: MerkleRoot.Data({hash: tmHeader.signed_header.header.app_hash}),\n                next_validators_hash: tmHeader.signed_header.header.next_validators_hash\n            });\n    }\n\n    function toVote(Commit.Data memory commit, uint256 valIdx) internal pure returns (Vote.Data memory) {\n        CommitSig.Data memory commitSig = commit.signatures[valIdx];\n\n        return\n            Vote.Data({\n                Type: TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT,\n                height: commit.height,\n                round: commit.round,\n                block_id: commit.block_id,\n                timestamp: commitSig.timestamp,\n                validator_address: commitSig.validator_address,\n                validator_index: SafeCast.toInt32(int256(valIdx)),\n                signature: commitSig.signature\n            });\n    }\n\n    function isEqual(BlockID.Data memory b1, BlockID.Data memory b2) internal pure returns (bool) {\n        if (keccak256(abi.encodePacked(b1.hash)) != keccak256(abi.encodePacked(b2.hash))) {\n            return false;\n        }\n\n        if (b1.part_set_header.total != b2.part_set_header.total) {\n            return false;\n        }\n\n        if (\n            keccak256(abi.encodePacked(b1.part_set_header.hash)) != keccak256(abi.encodePacked(b2.part_set_header.hash))\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function isEqual(ConsensusState.Data memory cs1, ConsensusState.Data memory cs2) internal pure returns (bool) {\n        return\n            keccak256(abi.encodePacked(ConsensusState.encode(cs1))) ==\n            keccak256(abi.encodePacked(ConsensusState.encode(cs2)));\n    }\n\n    function isExpired(\n        SignedHeader.Data memory header,\n        Duration.Data memory trustingPeriod,\n        Duration.Data memory currentTime\n    ) internal pure returns (bool) {\n        Timestamp.Data memory expirationTime = Timestamp.Data({\n            Seconds: header.header.time.Seconds + int64(trustingPeriod.Seconds),\n            nanos: header.header.time.nanos\n        });\n\n        return gt(Timestamp.Data({Seconds: int64(currentTime.Seconds), nanos: 0}), expirationTime);\n    }\n\n    function gt(Timestamp.Data memory t1, Timestamp.Data memory t2) internal pure returns (bool) {\n        if (t1.Seconds > t2.Seconds) {\n            return true;\n        }\n\n        if (t1.Seconds == t2.Seconds && t1.nanos > t2.nanos) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function hash(SignedHeader.Data memory h) internal pure returns (bytes32) {\n        require(h.header.validators_hash.length > 0, \"Tendermint: hash can't be empty\");\n\n        bytes memory hbz = Consensus.encode(h.header.version);\n        bytes memory pbt = Timestamp.encode(h.header.time);\n        bytes memory bzbi = BlockID.encode(h.header.last_block_id);\n\n        bytes[14] memory all = [\n            hbz,\n            Encoder.cdcEncode(h.header.chain_id),\n            Encoder.cdcEncode(h.header.height),\n            pbt,\n            bzbi,\n            Encoder.cdcEncode(h.header.last_commit_hash),\n            Encoder.cdcEncode(h.header.data_hash),\n            Encoder.cdcEncode(h.header.validators_hash),\n            Encoder.cdcEncode(h.header.next_validators_hash),\n            Encoder.cdcEncode(h.header.consensus_hash),\n            Encoder.cdcEncode(h.header.app_hash),\n            Encoder.cdcEncode(h.header.last_results_hash),\n            Encoder.cdcEncode(h.header.evidence_hash),\n            Encoder.cdcEncode(h.header.proposer_address)\n        ];\n\n        return MerkleTree.merkleRootHash(all, 0, all.length);\n    }\n\n    function hash(ValidatorSet.Data memory vs) internal pure returns (bytes32) {\n        return MerkleTree.merkleRootHash(vs.validators, 0, vs.validators.length);\n    }\n\n    function getByAddress(\n        ValidatorSet.Data memory vals,\n        bytes memory addr\n    ) internal pure returns (uint256 index, bool found) {\n        bytes32 addrHash = keccak256(abi.encodePacked(addr));\n        for (uint256 idx; idx < vals.validators.length; idx++) {\n            if (keccak256(abi.encodePacked(vals.validators[idx].Address)) == addrHash) {\n                return (idx, true);\n            }\n        }\n\n        return (0, false);\n    }\n\n    function getTotalVotingPower(ValidatorSet.Data memory vals) internal pure returns (int64) {\n        if (vals.total_voting_power == 0) {\n            uint256 sum = 0;\n            uint256 maxInt64 = 1 << (63 - 1);\n            uint256 maxTotalVotingPower = maxInt64 / 8;\n\n            for (uint256 i = 0; i < vals.validators.length; i++) {\n                sum += (SafeCast.toUint256(int256(vals.validators[i].voting_power)));\n                require(sum <= maxTotalVotingPower, \"total voting power should be guarded to not exceed\");\n            }\n\n            vals.total_voting_power = SafeCast.toInt64(int256(sum));\n        }\n\n        return vals.total_voting_power;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/proto/TendermintLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\nimport \"./ProtoBufRuntime.sol\";\nimport \"./GoogleProtobufAny.sol\";\n\nlibrary Fraction {\n    //struct definition\n    struct Data {\n        uint64 numerator;\n        uint64 denominator;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_numerator(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_denominator(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_numerator(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.numerator = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_denominator(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.denominator = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.numerator != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.numerator, pointer, bs);\n        }\n        if (r.denominator != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.denominator, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint64(r.numerator);\n        e += 1 + ProtoBufRuntime._sz_uint64(r.denominator);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.numerator != 0) {\n            return false;\n        }\n\n        if (r.denominator != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.numerator = input.numerator;\n        output.denominator = input.denominator;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Fraction\n\nlibrary Duration {\n    //struct definition\n    struct Data {\n        int64 Seconds;\n        int32 nanos;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Seconds(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nanos(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Seconds(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Seconds = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nanos(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nanos = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Seconds != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.Seconds, pointer, bs);\n        }\n        if (r.nanos != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.nanos, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_int64(r.Seconds);\n        e += 1 + ProtoBufRuntime._sz_int32(r.nanos);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Seconds != 0) {\n            return false;\n        }\n\n        if (r.nanos != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Seconds = input.Seconds;\n        output.nanos = input.nanos;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Duration\n\nlibrary Consensus {\n    //struct definition\n    struct Data {\n        uint64 block;\n        uint64 app;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_block(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_app(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.block = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_app(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.app = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.block != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.block, pointer, bs);\n        }\n        if (r.app != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.app, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint64(r.block);\n        e += 1 + ProtoBufRuntime._sz_uint64(r.app);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.block != 0) {\n            return false;\n        }\n\n        if (r.app != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.block = input.block;\n        output.app = input.app;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Consensus\n\nlibrary ClientState {\n    //struct definition\n    struct Data {\n        string chain_id;\n        Fraction.Data trust_level;\n        Duration.Data trusting_period;\n        Duration.Data unbonding_period;\n        Duration.Data max_clock_drift;\n        int64 frozen_height;\n        int64 latest_height;\n        bool allow_update_after_expiry;\n        bool allow_update_after_misbehaviour;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[10] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_trust_level(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_trusting_period(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_unbonding_period(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_max_clock_drift(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_frozen_height(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_latest_height(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_allow_update_after_expiry(pointer, bs, r, counters);\n            } else if (fieldId == 9) {\n                pointer += _read_allow_update_after_misbehaviour(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trust_level(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Fraction.Data memory x, uint256 sz) = _decode_Fraction(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.trust_level = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusting_period(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.trusting_period = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_unbonding_period(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.unbonding_period = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_clock_drift(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.max_clock_drift = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_frozen_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.frozen_height = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_latest_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.latest_height = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_allow_update_after_expiry(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bool x, uint256 sz) = ProtoBufRuntime._decode_bool(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.allow_update_after_expiry = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_allow_update_after_misbehaviour(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bool x, uint256 sz) = ProtoBufRuntime._decode_bool(p, bs);\n        if (isNil(r)) {\n            counters[9] += 1;\n        } else {\n            r.allow_update_after_misbehaviour = x;\n            if (counters[9] > 0) counters[9] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Fraction(uint256 p, bytes memory bs) internal pure returns (Fraction.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Fraction.Data memory r, ) = Fraction._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Duration(uint256 p, bytes memory bs) internal pure returns (Duration.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Duration.Data memory r, ) = Duration._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Fraction._encode_nested(r.trust_level, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.trusting_period, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.unbonding_period, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.max_clock_drift, pointer, bs);\n\n        if (r.frozen_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.frozen_height, pointer, bs);\n        }\n        if (r.latest_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.latest_height, pointer, bs);\n        }\n        if (r.allow_update_after_expiry != false) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bool(r.allow_update_after_expiry, pointer, bs);\n        }\n        if (r.allow_update_after_misbehaviour != false) {\n            pointer += ProtoBufRuntime._encode_key(9, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bool(r.allow_update_after_misbehaviour, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Fraction._estimate(r.trust_level));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.trusting_period));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.unbonding_period));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.max_clock_drift));\n        e += 1 + ProtoBufRuntime._sz_int64(r.frozen_height);\n        e += 1 + ProtoBufRuntime._sz_int64(r.latest_height);\n        e += 1 + 1;\n        e += 1 + 1;\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        if (r.frozen_height != 0) {\n            return false;\n        }\n\n        if (r.latest_height != 0) {\n            return false;\n        }\n\n        if (r.allow_update_after_expiry != false) {\n            return false;\n        }\n\n        if (r.allow_update_after_misbehaviour != false) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.chain_id = input.chain_id;\n        Fraction.store(input.trust_level, output.trust_level);\n        Duration.store(input.trusting_period, output.trusting_period);\n        Duration.store(input.unbonding_period, output.unbonding_period);\n        Duration.store(input.max_clock_drift, output.max_clock_drift);\n        output.frozen_height = input.frozen_height;\n        output.latest_height = input.latest_height;\n        output.allow_update_after_expiry = input.allow_update_after_expiry;\n        output.allow_update_after_misbehaviour = input.allow_update_after_misbehaviour;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ClientState\n\nlibrary ConsensusState {\n    //struct definition\n    struct Data {\n        Timestamp.Data timestamp;\n        MerkleRoot.Data root;\n        bytes next_validators_hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_root(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_next_validators_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_root(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (MerkleRoot.Data memory x, uint256 sz) = _decode_MerkleRoot(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.root = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_next_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.next_validators_hash = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_MerkleRoot(uint256 p, bytes memory bs) internal pure returns (MerkleRoot.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (MerkleRoot.Data memory r, ) = MerkleRoot._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += MerkleRoot._encode_nested(r.root, pointer, bs);\n\n        if (r.next_validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.next_validators_hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(MerkleRoot._estimate(r.root));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.next_validators_hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.next_validators_hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        Timestamp.store(input.timestamp, output.timestamp);\n        MerkleRoot.store(input.root, output.root);\n        output.next_validators_hash = input.next_validators_hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ConsensusState\n\nlibrary MerkleRoot {\n    //struct definition\n    struct Data {\n        bytes hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[2] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[2] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library MerkleRoot\n\n// TODO: Fix field order after potential BSC upgrade\nlibrary CanonicalPartSetHeader {\n    //struct definition\n    struct Data {\n        bytes hash;\n        uint32 total;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_total(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint32 x, uint256 sz) = ProtoBufRuntime._decode_uint32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.total = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.hash = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        if (r.total != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint32(r.total, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint32(r.total);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.total != 0) {\n            return false;\n        }\n\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.total = input.total;\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalPartSetHeader\n\nlibrary CanonicalBlockID {\n    //struct definition\n    struct Data {\n        bytes hash;\n        CanonicalPartSetHeader.Data part_set_header;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_part_set_header(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_part_set_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CanonicalPartSetHeader.Data memory x, uint256 sz) = _decode_CanonicalPartSetHeader(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.part_set_header = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CanonicalPartSetHeader(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CanonicalPartSetHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CanonicalPartSetHeader.Data memory r, ) = CanonicalPartSetHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CanonicalPartSetHeader._encode_nested(r.part_set_header, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(CanonicalPartSetHeader._estimate(r.part_set_header));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        CanonicalPartSetHeader.store(input.part_set_header, output.part_set_header);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalBlockID\n\nlibrary CanonicalVote {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType Type;\n        int64 height;\n        int64 round;\n        CanonicalBlockID.Data block_id;\n        Timestamp.Data timestamp;\n        string chain_id;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[7] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Type(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Type(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_SignedMsgType(\n            tmp\n        );\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Type = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_sfixed64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.height = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_sfixed64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.round = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CanonicalBlockID.Data memory x, uint256 sz) = _decode_CanonicalBlockID(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CanonicalBlockID(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CanonicalBlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CanonicalBlockID.Data memory r, ) = CanonicalBlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.Type) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_Type = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type);\n            pointer += ProtoBufRuntime._encode_enum(_enum_Type, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Fixed64, pointer, bs);\n            pointer += ProtoBufRuntime._encode_sfixed64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Fixed64, pointer, bs);\n            pointer += ProtoBufRuntime._encode_sfixed64(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CanonicalBlockID._encode_nested(r.block_id, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type));\n        e += 1 + 8;\n        e += 1 + 8;\n        e += 1 + ProtoBufRuntime._sz_lendelim(CanonicalBlockID._estimate(r.block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.Type) != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Type = input.Type;\n        output.height = input.height;\n        output.round = input.round;\n        CanonicalBlockID.store(input.block_id, output.block_id);\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.chain_id = input.chain_id;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalVote\n\nlibrary Vote {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType Type;\n        int64 height;\n        int32 round;\n        BlockID.Data block_id;\n        Timestamp.Data timestamp;\n        bytes validator_address;\n        int32 validator_index;\n        bytes signature;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[9] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Type(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_validator_address(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_validator_index(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_signature(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Type(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_SignedMsgType(\n            tmp\n        );\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Type = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.height = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.round = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.validator_address = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_index(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.validator_index = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signature(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.signature = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.Type) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_Type = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type);\n            pointer += ProtoBufRuntime._encode_enum(_enum_Type, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.block_id, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (r.validator_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validator_address, pointer, bs);\n        }\n        if (r.validator_index != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.validator_index, pointer, bs);\n        }\n        if (r.signature.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.signature, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type));\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_int32(r.round);\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validator_address.length);\n        e += 1 + ProtoBufRuntime._sz_int32(r.validator_index);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.signature.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.Type) != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (r.validator_address.length != 0) {\n            return false;\n        }\n\n        if (r.validator_index != 0) {\n            return false;\n        }\n\n        if (r.signature.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Type = input.Type;\n        output.height = input.height;\n        output.round = input.round;\n        BlockID.store(input.block_id, output.block_id);\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.validator_address = input.validator_address;\n        output.validator_index = input.validator_index;\n        output.signature = input.signature;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Vote\n\nlibrary ValidatorSet {\n    //struct definition\n    struct Data {\n        Validator.Data[] validators;\n        Validator.Data proposer;\n        int64 total_voting_power;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_validators(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_proposer(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_total_voting_power(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.validators = new Validator.Data[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_validators(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_proposer(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_total_voting_power(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validators(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Validator.Data memory x, uint256 sz) = _decode_Validator(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.validators[r.validators.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Validator.Data memory x, uint256 sz) = _decode_Validator(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.proposer = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.total_voting_power = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Validator(uint256 p, bytes memory bs) internal pure returns (Validator.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Validator.Data memory r, ) = Validator._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.validators.length != 0) {\n            for (i = 0; i < r.validators.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += Validator._encode_nested(r.validators[i], pointer, bs);\n            }\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Validator._encode_nested(r.proposer, pointer, bs);\n\n        if (r.total_voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.total_voting_power, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.validators.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(Validator._estimate(r.validators[i]));\n        }\n        e += 1 + ProtoBufRuntime._sz_lendelim(Validator._estimate(r.proposer));\n        e += 1 + ProtoBufRuntime._sz_int64(r.total_voting_power);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.validators.length != 0) {\n            return false;\n        }\n\n        if (r.total_voting_power != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.validators.length; i1++) {\n            output.validators.push(input.validators[i1]);\n        }\n\n        Validator.store(input.proposer, output.proposer);\n        output.total_voting_power = input.total_voting_power;\n    }\n\n    //array helpers for Validators\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addValidators(Data memory self, Validator.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        Validator.Data[] memory tmp = new Validator.Data[](self.validators.length + 1);\n        for (uint256 i = 0; i < self.validators.length; i++) {\n            tmp[i] = self.validators[i];\n        }\n        tmp[self.validators.length] = value;\n        self.validators = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ValidatorSet\n\nlibrary Validator {\n    //struct definition\n    struct Data {\n        bytes Address;\n        PublicKey.Data pub_key;\n        int64 voting_power;\n        int64 proposer_priority;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Address(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_pub_key(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_voting_power(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_proposer_priority(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Address = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_pub_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PublicKey.Data memory x, uint256 sz) = _decode_PublicKey(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.pub_key = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.voting_power = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer_priority(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.proposer_priority = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PublicKey(uint256 p, bytes memory bs) internal pure returns (PublicKey.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PublicKey.Data memory r, ) = PublicKey._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.Address, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PublicKey._encode_nested(r.pub_key, pointer, bs);\n\n        if (r.voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.voting_power, pointer, bs);\n        }\n        if (r.proposer_priority != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.proposer_priority, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.Address.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(PublicKey._estimate(r.pub_key));\n        e += 1 + ProtoBufRuntime._sz_int64(r.voting_power);\n        e += 1 + ProtoBufRuntime._sz_int64(r.proposer_priority);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Address.length != 0) {\n            return false;\n        }\n\n        if (r.voting_power != 0) {\n            return false;\n        }\n\n        if (r.proposer_priority != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Address = input.Address;\n        PublicKey.store(input.pub_key, output.pub_key);\n        output.voting_power = input.voting_power;\n        output.proposer_priority = input.proposer_priority;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Validator\n\nlibrary SimpleValidator {\n    //struct definition\n    struct Data {\n        PublicKey.Data pub_key;\n        int64 voting_power;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_pub_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_voting_power(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_pub_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PublicKey.Data memory x, uint256 sz) = _decode_PublicKey(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.pub_key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.voting_power = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PublicKey(uint256 p, bytes memory bs) internal pure returns (PublicKey.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PublicKey.Data memory r, ) = PublicKey._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PublicKey._encode_nested(r.pub_key, pointer, bs);\n\n        if (r.voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.voting_power, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(PublicKey._estimate(r.pub_key));\n        e += 1 + ProtoBufRuntime._sz_int64(r.voting_power);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.voting_power != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        PublicKey.store(input.pub_key, output.pub_key);\n        output.voting_power = input.voting_power;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library SimpleValidator\n\nlibrary PublicKey {\n    //struct definition\n    struct Data {\n        bytes ed25519;\n        bytes secp256k1;\n        bytes sr25519;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_ed25519(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_secp256k1(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_sr25519(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_ed25519(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.ed25519 = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_secp256k1(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.secp256k1 = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_sr25519(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.sr25519 = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.ed25519.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.ed25519, pointer, bs);\n        }\n        if (r.secp256k1.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.secp256k1, pointer, bs);\n        }\n        if (r.sr25519.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.sr25519, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.ed25519.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.secp256k1.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.sr25519.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.ed25519.length != 0) {\n            return false;\n        }\n\n        if (r.secp256k1.length != 0) {\n            return false;\n        }\n\n        if (r.sr25519.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.ed25519 = input.ed25519;\n        output.secp256k1 = input.secp256k1;\n        output.sr25519 = input.sr25519;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library PublicKey\n\nlibrary PartSetHeader {\n    //struct definition\n    struct Data {\n        uint32 total;\n        bytes hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_total(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint32 x, uint256 sz) = ProtoBufRuntime._decode_uint32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.total = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.hash = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.total != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint32(r.total, pointer, bs);\n        }\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint32(r.total);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.total != 0) {\n            return false;\n        }\n\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.total = input.total;\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library PartSetHeader\n\nlibrary BlockID {\n    //struct definition\n    struct Data {\n        bytes hash;\n        PartSetHeader.Data part_set_header;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_part_set_header(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_part_set_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PartSetHeader.Data memory x, uint256 sz) = _decode_PartSetHeader(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.part_set_header = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PartSetHeader(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (PartSetHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PartSetHeader.Data memory r, ) = PartSetHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PartSetHeader._encode_nested(r.part_set_header, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(PartSetHeader._estimate(r.part_set_header));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        PartSetHeader.store(input.part_set_header, output.part_set_header);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BlockID\n\nlibrary Commit {\n    //struct definition\n    struct Data {\n        int64 height;\n        int32 round;\n        BlockID.Data block_id;\n        CommitSig.Data[] signatures;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signatures(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.signatures = new CommitSig.Data[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_height(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_round(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_block_id(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signatures(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.height = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.round = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signatures(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CommitSig.Data memory x, uint256 sz) = _decode_CommitSig(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.signatures[r.signatures.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CommitSig(uint256 p, bytes memory bs) internal pure returns (CommitSig.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CommitSig.Data memory r, ) = CommitSig._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.block_id, pointer, bs);\n\n        if (r.signatures.length != 0) {\n            for (i = 0; i < r.signatures.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += CommitSig._encode_nested(r.signatures[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_int32(r.round);\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.block_id));\n        for (i = 0; i < r.signatures.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(CommitSig._estimate(r.signatures[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (r.signatures.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.height = input.height;\n        output.round = input.round;\n        BlockID.store(input.block_id, output.block_id);\n\n        for (uint256 i4 = 0; i4 < input.signatures.length; i4++) {\n            output.signatures.push(input.signatures[i4]);\n        }\n    }\n\n    //array helpers for Signatures\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addSignatures(Data memory self, CommitSig.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        CommitSig.Data[] memory tmp = new CommitSig.Data[](self.signatures.length + 1);\n        for (uint256 i = 0; i < self.signatures.length; i++) {\n            tmp[i] = self.signatures[i];\n        }\n        tmp[self.signatures.length] = value;\n        self.signatures = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Commit\n\nlibrary CommitSig {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag block_id_flag;\n        bytes validator_address;\n        Timestamp.Data timestamp;\n        bytes signature;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_block_id_flag(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_validator_address(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signature(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id_flag(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_BlockIDFlag(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.block_id_flag = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.validator_address = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signature(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.signature = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.block_id_flag) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_block_id_flag = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_BlockIDFlag(r.block_id_flag);\n            pointer += ProtoBufRuntime._encode_enum(_enum_block_id_flag, pointer, bs);\n        }\n        if (r.validator_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validator_address, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (r.signature.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.signature, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_BlockIDFlag(r.block_id_flag));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validator_address.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.signature.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.block_id_flag) != 0) {\n            return false;\n        }\n\n        if (r.validator_address.length != 0) {\n            return false;\n        }\n\n        if (r.signature.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.block_id_flag = input.block_id_flag;\n        output.validator_address = input.validator_address;\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.signature = input.signature;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CommitSig\n\nlibrary Timestamp {\n    //struct definition\n    struct Data {\n        int64 Seconds;\n        int32 nanos;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Seconds(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nanos(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Seconds(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Seconds = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nanos(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nanos = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Seconds != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.Seconds, pointer, bs);\n        }\n        if (r.nanos != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.nanos, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_int64(r.Seconds);\n        e += 1 + ProtoBufRuntime._sz_int32(r.nanos);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Seconds != 0) {\n            return false;\n        }\n\n        if (r.nanos != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Seconds = input.Seconds;\n        output.nanos = input.nanos;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Timestamp\n\nlibrary LightHeader {\n    //struct definition\n    struct Data {\n        Consensus.Data version;\n        string chain_id;\n        int64 height;\n        Timestamp.Data time;\n        BlockID.Data last_block_id;\n        bytes last_commit_hash;\n        bytes data_hash;\n        bytes validators_hash;\n        bytes next_validators_hash;\n        bytes consensus_hash;\n        bytes app_hash;\n        bytes last_results_hash;\n        bytes evidence_hash;\n        bytes proposer_address;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[15] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_version(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_time(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_last_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_last_commit_hash(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_data_hash(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_validators_hash(pointer, bs, r, counters);\n            } else if (fieldId == 9) {\n                pointer += _read_next_validators_hash(pointer, bs, r, counters);\n            } else if (fieldId == 10) {\n                pointer += _read_consensus_hash(pointer, bs, r, counters);\n            } else if (fieldId == 11) {\n                pointer += _read_app_hash(pointer, bs, r, counters);\n            } else if (fieldId == 12) {\n                pointer += _read_last_results_hash(pointer, bs, r, counters);\n            } else if (fieldId == 13) {\n                pointer += _read_evidence_hash(pointer, bs, r, counters);\n            } else if (fieldId == 14) {\n                pointer += _read_proposer_address(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_version(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Consensus.Data memory x, uint256 sz) = _decode_Consensus(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.version = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.height = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_time(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.time = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.last_block_id = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_commit_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.last_commit_hash = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_data_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.data_hash = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.validators_hash = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_next_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[9] += 1;\n        } else {\n            r.next_validators_hash = x;\n            if (counters[9] > 0) counters[9] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_consensus_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[10] += 1;\n        } else {\n            r.consensus_hash = x;\n            if (counters[10] > 0) counters[10] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_app_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[11] += 1;\n        } else {\n            r.app_hash = x;\n            if (counters[11] > 0) counters[11] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_results_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[12] += 1;\n        } else {\n            r.last_results_hash = x;\n            if (counters[12] > 0) counters[12] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_evidence_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[13] += 1;\n        } else {\n            r.evidence_hash = x;\n            if (counters[13] > 0) counters[13] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[14] += 1;\n        } else {\n            r.proposer_address = x;\n            if (counters[14] > 0) counters[14] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Consensus(uint256 p, bytes memory bs) internal pure returns (Consensus.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Consensus.Data memory r, ) = Consensus._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Consensus._encode_nested(r.version, pointer, bs);\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.time, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.last_block_id, pointer, bs);\n\n        if (r.last_commit_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.last_commit_hash, pointer, bs);\n        }\n        if (r.data_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.data_hash, pointer, bs);\n        }\n        if (r.validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validators_hash, pointer, bs);\n        }\n        if (r.next_validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(9, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.next_validators_hash, pointer, bs);\n        }\n        if (r.consensus_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(10, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.consensus_hash, pointer, bs);\n        }\n        if (r.app_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(11, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.app_hash, pointer, bs);\n        }\n        if (r.last_results_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(12, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.last_results_hash, pointer, bs);\n        }\n        if (r.evidence_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(13, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.evidence_hash, pointer, bs);\n        }\n        if (r.proposer_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(14, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.proposer_address, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(Consensus._estimate(r.version));\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.time));\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.last_block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.last_commit_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.data_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validators_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.next_validators_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.consensus_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.app_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.last_results_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.evidence_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.proposer_address.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.last_commit_hash.length != 0) {\n            return false;\n        }\n\n        if (r.data_hash.length != 0) {\n            return false;\n        }\n\n        if (r.validators_hash.length != 0) {\n            return false;\n        }\n\n        if (r.next_validators_hash.length != 0) {\n            return false;\n        }\n\n        if (r.consensus_hash.length != 0) {\n            return false;\n        }\n\n        if (r.app_hash.length != 0) {\n            return false;\n        }\n\n        if (r.last_results_hash.length != 0) {\n            return false;\n        }\n\n        if (r.evidence_hash.length != 0) {\n            return false;\n        }\n\n        if (r.proposer_address.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        Consensus.store(input.version, output.version);\n        output.chain_id = input.chain_id;\n        output.height = input.height;\n        Timestamp.store(input.time, output.time);\n        BlockID.store(input.last_block_id, output.last_block_id);\n        output.last_commit_hash = input.last_commit_hash;\n        output.data_hash = input.data_hash;\n        output.validators_hash = input.validators_hash;\n        output.next_validators_hash = input.next_validators_hash;\n        output.consensus_hash = input.consensus_hash;\n        output.app_hash = input.app_hash;\n        output.last_results_hash = input.last_results_hash;\n        output.evidence_hash = input.evidence_hash;\n        output.proposer_address = input.proposer_address;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library LightHeader\n\nlibrary SignedHeader {\n    //struct definition\n    struct Data {\n        LightHeader.Data header;\n        Commit.Data commit;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_header(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_commit(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LightHeader.Data memory x, uint256 sz) = _decode_LightHeader(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.header = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_commit(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Commit.Data memory x, uint256 sz) = _decode_Commit(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.commit = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LightHeader(uint256 p, bytes memory bs) internal pure returns (LightHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LightHeader.Data memory r, ) = LightHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Commit(uint256 p, bytes memory bs) internal pure returns (Commit.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Commit.Data memory r, ) = Commit._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LightHeader._encode_nested(r.header, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Commit._encode_nested(r.commit, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(LightHeader._estimate(r.header));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Commit._estimate(r.commit));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        LightHeader.store(input.header, output.header);\n        Commit.store(input.commit, output.commit);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library SignedHeader\n\nlibrary TmHeader {\n    //struct definition\n    struct Data {\n        SignedHeader.Data signed_header;\n        ValidatorSet.Data validator_set;\n        int64 trusted_height;\n        ValidatorSet.Data trusted_validators;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_signed_header(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_validator_set(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_trusted_height(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_trusted_validators(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signed_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (SignedHeader.Data memory x, uint256 sz) = _decode_SignedHeader(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.signed_header = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_set(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ValidatorSet.Data memory x, uint256 sz) = _decode_ValidatorSet(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.validator_set = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusted_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.trusted_height = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusted_validators(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ValidatorSet.Data memory x, uint256 sz) = _decode_ValidatorSet(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.trusted_validators = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_SignedHeader(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (SignedHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (SignedHeader.Data memory r, ) = SignedHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ValidatorSet(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ValidatorSet.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ValidatorSet.Data memory r, ) = ValidatorSet._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += SignedHeader._encode_nested(r.signed_header, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ValidatorSet._encode_nested(r.validator_set, pointer, bs);\n\n        if (r.trusted_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.trusted_height, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ValidatorSet._encode_nested(r.trusted_validators, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(SignedHeader._estimate(r.signed_header));\n        e += 1 + ProtoBufRuntime._sz_lendelim(ValidatorSet._estimate(r.validator_set));\n        e += 1 + ProtoBufRuntime._sz_int64(r.trusted_height);\n        e += 1 + ProtoBufRuntime._sz_lendelim(ValidatorSet._estimate(r.trusted_validators));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.trusted_height != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        SignedHeader.store(input.signed_header, output.signed_header);\n        ValidatorSet.store(input.validator_set, output.validator_set);\n        output.trusted_height = input.trusted_height;\n        ValidatorSet.store(input.trusted_validators, output.trusted_validators);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library TmHeader\n\nlibrary TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS {\n    //enum definition\n    // Solidity enum definitions\n    enum BlockIDFlag {\n        BLOCK_ID_FLAG_UNKNOWN,\n        BLOCK_ID_FLAG_ABSENT,\n        BLOCK_ID_FLAG_COMMIT,\n        BLOCK_ID_FLAG_NIL\n    }\n\n    // Solidity enum encoder\n    function encode_BlockIDFlag(BlockIDFlag x) internal pure returns (int32) {\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN) {\n            return 0;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_ABSENT) {\n            return 1;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_COMMIT) {\n            return 2;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_NIL) {\n            return 3;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_BlockIDFlag(int64 x) internal pure returns (BlockIDFlag) {\n        if (x == 0) {\n            return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;\n        }\n\n        if (x == 1) {\n            return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;\n        }\n\n        if (x == 2) {\n            return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;\n        }\n\n        if (x == 3) {\n            return BlockIDFlag.BLOCK_ID_FLAG_NIL;\n        }\n        revert();\n    }\n\n    // Solidity enum definitions\n    enum SignedMsgType {\n        SIGNED_MSG_TYPE_UNKNOWN,\n        SIGNED_MSG_TYPE_PREVOTE,\n        SIGNED_MSG_TYPE_PRECOMMIT,\n        SIGNED_MSG_TYPE_PROPOSAL\n    }\n\n    // Solidity enum encoder\n    function encode_SignedMsgType(SignedMsgType x) internal pure returns (int32) {\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN) {\n            return 0;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PREVOTE) {\n            return 1;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT) {\n            return 2;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL) {\n            return 32;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_SignedMsgType(int64 x) internal pure returns (SignedMsgType) {\n        if (x == 0) {\n            return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;\n        }\n\n        if (x == 1) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;\n        }\n\n        if (x == 2) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;\n        }\n\n        if (x == 32) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;\n        }\n        revert();\n    }\n}\n//library TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS\n"
    },
    "contracts/light-client-others/bsc-tendermint/lib/Tendermint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./Bytes.sol\";\nimport {TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS, SignedHeader, BlockID, Timestamp, ValidatorSet, Duration, Fraction, Commit, Validator, CommitSig, CanonicalVote, Vote} from \"./proto/TendermintLight.sol\";\nimport \"./proto/TendermintHelper.sol\";\nimport \"./proto/Encoder.sol\";\nimport \"../Ed25519Verifier.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary Tendermint {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for ValidatorSet.Data;\n    using TendermintHelper for SignedHeader.Data;\n    using TendermintHelper for Timestamp.Data;\n    using TendermintHelper for BlockID.Data;\n    using TendermintHelper for Commit.Data;\n    using TendermintHelper for Vote.Data;\n\n    // TODO: Change visibility to public for deployment. For some reason have to use internal for abigen.\n    function verify(\n        SignedHeader.Data memory trustedHeader,\n        SignedHeader.Data memory untrustedHeader,\n        ValidatorSet.Data memory untrustedVals,\n        address verifier,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) internal view returns (bool) {\n        verifyNewHeaderAndVals(untrustedHeader, untrustedVals, trustedHeader);\n\n        // Check the validator hashes are the same\n        require(\n            untrustedHeader.header.validators_hash.toBytes32() == trustedHeader.header.next_validators_hash.toBytes32(),\n            \"expected old header next validators to match those from new header\"\n        );\n\n        // Ensure that +2/3 of new validators signed correctly.\n        bool ok = verifyCommitLight(\n            untrustedVals,\n            trustedHeader.header.chain_id,\n            untrustedHeader.commit.block_id,\n            untrustedHeader.header.height,\n            untrustedHeader.commit,\n            verifier,\n            proofA,\n            proofB,\n            proofC,\n            proofCommit,\n            proofCommitPub\n        );\n\n        return ok;\n    }\n\n    function verifyNewHeaderAndVals(\n        SignedHeader.Data memory untrustedHeader,\n        ValidatorSet.Data memory untrustedVals,\n        SignedHeader.Data memory trustedHeader\n    ) internal pure {\n        // SignedHeader validate basic\n        require(\n            keccak256(abi.encodePacked(untrustedHeader.header.chain_id)) ==\n                keccak256(abi.encodePacked(trustedHeader.header.chain_id)),\n            \"header belongs to another chain\"\n        );\n        require(untrustedHeader.commit.height == untrustedHeader.header.height, \"header and commit height mismatch\");\n\n        bytes32 untrustedHeaderBlockHash = untrustedHeader.hash();\n        // TODO: Fix block hash\n        // require(\n        //     untrustedHeaderBlockHash == untrustedHeader.commit.block_id.hash.toBytes32(),\n        //     \"commit signs signs block failed\"\n        // );\n\n        require(\n            untrustedHeader.header.height > trustedHeader.header.height,\n            \"expected new header height to be greater than one of old header\"\n        );\n\n        // Skip time verification for now\n\n        bytes32 validatorsHash = untrustedVals.hash();\n        // TODO: Fix validators hash\n        // require(\n        //     untrustedHeader.header.validators_hash.toBytes32() == validatorsHash,\n        //     \"expected new header validators to match those that were supplied at height XX\"\n        // );\n    }\n\n    // VerifyCommitLight\n    // Proof of concept header verification with batch signature SNARK proof\n    function verifyCommitLight(\n        ValidatorSet.Data memory vals,\n        string memory chainID,\n        BlockID.Data memory blockID,\n        int64 height,\n        Commit.Data memory commit,\n        address verifier,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) internal view returns (bool) {\n        require(vals.validators.length == commit.signatures.length, \"invalid commit signatures\");\n        require(commit.signatures.length > 8, \"insufficient signatures\");\n\n        require(height == commit.height, \"invalid commit height\");\n\n        require(commit.block_id.isEqual(blockID), \"invalid commit -- wrong block ID\");\n\n        bytes[8] memory pubkeys;\n        bytes[8] memory messages;\n        uint256 sigCount;\n        for (uint256 i = 0; i < commit.signatures.length; i++) {\n            // no need to verify absent or nil votes.\n            if (\n                commit.signatures[i].block_id_flag !=\n                TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag.BLOCK_ID_FLAG_COMMIT\n            ) {\n                continue;\n            }\n\n            pubkeys[sigCount] = vals.validators[i].pub_key.ed25519;\n            messages[sigCount] = Encoder.encodeDelim(voteSignBytes(commit, chainID, i));\n\n            sigCount++;\n            if (sigCount == 8) {\n                break;\n            }\n        }\n\n        uint256[57] memory input = prepareInput(pubkeys, messages, proofCommitPub);\n        return Ed25519Verifier(verifier).verifyProof(proofA, proofB, proofC, proofCommit, input);\n    }\n\n    function prepareInput(\n        bytes[8] memory pubkeys,\n        bytes[8] memory messages,\n        uint256 proofCommitPub\n    ) private pure returns (uint256[57] memory input) {\n        for (uint256 i = 0; i < 8; i++) {\n            bytes memory messagePart0 = BytesLib.slice(messages[i], 0, 25);\n            bytes memory messagePart1 = BytesLib.slice(messages[i], 25, 25);\n            bytes memory messagePart2 = BytesLib.slice(messages[i], 50, 25);\n            bytes memory messagePart3 = BytesLib.slice(messages[i], 75, 25);\n            bytes memory messagePart4 = BytesLib.slice(messages[i], 100, 22);\n            input[5 * i] = uint256(uint200(bytes25(messagePart0)));\n            input[5 * i + 1] = uint256(uint200(bytes25(messagePart1)));\n            input[5 * i + 2] = uint256(uint200(bytes25(messagePart2)));\n            input[5 * i + 3] = uint256(uint200(bytes25(messagePart3)));\n            input[5 * i + 4] = uint256(uint176(bytes22(messagePart4)));\n            bytes memory pubkeyHigh = BytesLib.slice(pubkeys[i], 0, 16);\n            bytes memory pubkeyLow = BytesLib.slice(pubkeys[i], 16, 16);\n            input[2 * i + 40] = uint256(uint128(bytes16(pubkeyHigh)));\n            input[2 * i + 1 + 40] = uint256(uint128(bytes16(pubkeyLow)));\n        }\n        input[56] = proofCommitPub;\n        return input;\n    }\n\n    function voteSignBytes(\n        Commit.Data memory commit,\n        string memory chainID,\n        uint256 idx\n    ) internal pure returns (bytes memory) {\n        Vote.Data memory vote;\n        vote = commit.toVote(idx);\n\n        return CanonicalVote.encode(vote.toCanonicalVote(chainID));\n    }\n\n    function voteSignBytesDelim(\n        Commit.Data memory commit,\n        string memory chainID,\n        uint256 idx\n    ) internal pure returns (bytes memory) {\n        return Encoder.encodeDelim(voteSignBytes(commit, chainID, idx));\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/System.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Initializable.sol\";\n\ncontract System is Ownable, Initializable {\n    uint32 public constant CODE_OK = 0;\n    uint32 public constant ERROR_FAIL_DECODE = 100;\n\n    uint8 public constant STAKING_CHANNEL_ID = 0x08;\n\n    address public bscValidatorSet;\n    address public tmLightClient;\n    address public crossChain;\n\n    uint16 public bscChainID;\n    address public relayer;\n\n    function init(\n        uint16 _bscChainID,\n        address _relayer,\n        address _bscValidatorSet,\n        address _tmLightClient,\n        address _crossChain\n    ) external onlyUninitialized onlyOwner {\n        bscChainID = _bscChainID;\n        relayer = _relayer;\n        bscValidatorSet = _bscValidatorSet;\n        tmLightClient = _tmLightClient;\n        crossChain = _crossChain;\n\n        _initialized = true;\n    }\n\n    function setRelayer(address _relayer) external onlyOwner {\n        relayer = _relayer;\n    }\n}\n"
    },
    "contracts/light-client-others/bsc-tendermint/TendermintLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport \"./Initializable.sol\";\nimport \"./System.sol\";\nimport \"./lib/Tendermint.sol\";\nimport \"./interfaces/ITendermintLightClient.sol\";\nimport {GoogleProtobufAny as Any} from \"./lib/proto/GoogleProtobufAny.sol\";\nimport {LightHeader, ValidatorSet, ConsensusState, TmHeader} from \"./lib/proto/TendermintLight.sol\";\n\ncontract TendermintLightClient is Initializable, ITendermintLightClient {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for TmHeader.Data;\n    using TendermintHelper for ConsensusState.Data;\n    using TendermintHelper for ValidatorSet.Data;\n\n    struct ProtoTypes {\n        bytes32 consensusState;\n        bytes32 tmHeader;\n    }\n\n    ProtoTypes private _pts;\n    mapping(uint64 => ConsensusState.Data) public consensusStates;\n    mapping(uint64 => bool) public synced;\n    uint64 public initialHeight;\n    uint64 public latestHeight;\n    System private system;\n    address ed25519Verifier;\n\n    event ConsensusStateInit(uint64 initialHeight, bytes32 appHash);\n    event ConsensusStateSynced(uint64 height, bytes32 appHash);\n\n    constructor(address _ed25519Verifier) {\n        ed25519Verifier = _ed25519Verifier;\n    }\n\n    function init(address _system, bytes memory _initHeader) external onlyUninitialized {\n        _pts = ProtoTypes({\n            consensusState: keccak256(abi.encodePacked(\"/tendermint.types.ConsensusState\")),\n            tmHeader: keccak256(abi.encodePacked(\"/tendermint.types.TmHeader\"))\n        });\n\n        system = System(_system);\n\n        (TmHeader.Data memory tmHeader, bool ok) = unmarshalTmHeader(_initHeader);\n        require(ok, \"LC: light block is invalid\");\n\n        uint64 height = uint64(tmHeader.signed_header.header.height);\n        ConsensusState.Data memory cs = tmHeader.toConsensusState();\n        consensusStates[height] = cs;\n\n        initialHeight = height;\n        latestHeight = height;\n\n        emit ConsensusStateInit(initialHeight, bytes32(cs.root.hash));\n\n        _initialized = true;\n    }\n\n    function syncTendermintHeader(\n        bytes calldata header,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) external returns (bool) {\n        require(msg.sender == system.relayer(), \"not relayer\");\n\n        (TmHeader.Data memory tmHeader, bool ok) = unmarshalTmHeader(header);\n        require(ok, \"LC: light block is invalid\");\n\n        uint64 height = uint64(tmHeader.signed_header.header.height);\n        require(!synced[height], \"can't sync duplicated header\");\n        // assert header height is newer than consensus state\n        require(height > latestHeight, \"LC: header height not newer than consensus state height\");\n\n        checkValidity(consensusStates[latestHeight], tmHeader, proofA, proofB, proofC, proofCommit, proofCommitPub);\n\n        synced[height] = true;\n\n        // Store new cs\n        ConsensusState.Data memory cs = tmHeader.toConsensusState();\n        consensusStates[height] = cs;\n\n        emit ConsensusStateSynced(height, bytes32(cs.root.hash));\n\n        return true;\n    }\n\n    // checkValidity checks if the Tendermint header is valid.\n    function checkValidity(\n        ConsensusState.Data memory trustedConsensusState,\n        TmHeader.Data memory tmHeader,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) private view {\n        LightHeader.Data memory lc;\n        lc.chain_id = tmHeader.signed_header.header.chain_id;\n        lc.height = int64(latestHeight);\n        lc.next_validators_hash = trustedConsensusState.next_validators_hash;\n\n        SignedHeader.Data memory trustedHeader;\n        trustedHeader.header = lc;\n\n        SignedHeader.Data memory untrustedHeader = tmHeader.signed_header;\n        ValidatorSet.Data memory untrustedVals = tmHeader.validator_set;\n\n        bool ok = Tendermint.verify(\n            trustedHeader,\n            untrustedHeader,\n            untrustedVals,\n            ed25519Verifier,\n            proofA,\n            proofB,\n            proofC,\n            proofCommit,\n            proofCommitPub\n        );\n\n        require(ok, \"LC: failed to verify header\");\n    }\n\n    function isHeaderSynced(uint64 height) external view override returns (bool) {\n        return synced[height] || height == initialHeight;\n    }\n\n    function getAppHash(uint64 height) external view override returns (bytes32) {\n        return bytes32(consensusStates[height].root.hash);\n    }\n\n    function unmarshalTmHeader(bytes memory bz) internal view returns (TmHeader.Data memory header, bool ok) {\n        Any.Data memory anyHeader = Any.decode(bz);\n        if (keccak256(abi.encodePacked(anyHeader.type_url)) != _pts.tmHeader) {\n            return (header, false);\n        }\n        return (TmHeader.decode(anyHeader.value), true);\n    }\n}\n"
    },
    "contracts/sdk/core/AggregationVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract AggregationVerifier {\n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 12687226338041254036256354793976018101551950541498519737723469310988110076375;\n    uint256 constant ALPHA_Y = 10256096744067903796312426895717444912307333887269693700471886675863901884202;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 14568434424400989500134218686860260673044913626154307815038415359477876138326;\n    uint256 constant BETA_NEG_X_1 = 17693675125505927051254156984291616972594985825456963090951676229850221483155;\n    uint256 constant BETA_NEG_Y_0 = 383177844654040981020264750209583593321791666251217431567253973719249786217;\n    uint256 constant BETA_NEG_Y_1 = 4702609992532524160989377295099704709194662140646545418724680051209738439519;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 14815051514326228068908385609792966191592029825009679736329726616038382980218;\n    uint256 constant GAMMA_NEG_X_1 = 8489924782037803931858936554558907678042032007085687571584766050148524131882;\n    uint256 constant GAMMA_NEG_Y_0 = 6391315949514971922112169675129858004679832006305666954533871914124224506469;\n    uint256 constant GAMMA_NEG_Y_1 = 9697432153854106105017721526895571905909380451908975271046420491866280067319;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 11969087011014935233415460302004973927131871436793824839620612262784709776287;\n    uint256 constant DELTA_NEG_X_1 = 17745678986402717031649917444808681783377938238076091849249985349810291047890;\n    uint256 constant DELTA_NEG_Y_0 = 14493379635216869400631410091008330854226934252257944886907081303740461442501;\n    uint256 constant DELTA_NEG_Y_1 = 10971546432814995027058402624573736138393459536613541815883849635155919667270;\n\n    // VK CommitmentKey pedersen G\n    uint256 constant VK_PEDERSEN_G_X_0 = 14057299646988463495206519058519537185638704662797820033598363672599992650089;\n    uint256 constant VK_PEDERSEN_G_X_1 = 1804161595266085226246183082044496306049360414285214534924891118605265023103;\n    uint256 constant VK_PEDERSEN_G_Y_0 = 11766923715944210670288440569225426103940007632318040679616901977081523796491;\n    uint256 constant VK_PEDERSEN_G_Y_1 = 834977644800539851243602822366909668747653955574809155046777611984277771776;\n\n    // VK CommitmentKey pedersen GRootSigmaNeg\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_0 = 2200585081879595640584858710253685932171753361453491594146898213239013911282;\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_1 = 18049108820983202804944453697657571551769488507736702873053007083714948165248;\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_0 = 133313209624682832535108325381034698477936306159075009510964451507662397140;\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_1 = 7284716207005576333081510645859571066483492723588236030807110008433085609567;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 6007902370513106954063927857306896407269873771373783576471927701052459218140;\n    uint256 constant CONSTANT_Y = 9615488245380845401381011374843992919723531171351287827859567387072925056152;\n    uint256 constant PUB_0_X = 10697034632820275527487335132055183663961098637923488185566513151087951331578;\n    uint256 constant PUB_0_Y = 14276118394759667935635656171580811097043009027735537350675614402636858982615;\n    uint256 constant PUB_1_X = 7026431637307244687706934400969067696388921806356794816186026757716175351296;\n    uint256 constant PUB_1_Y = 15436622150387751729183576709564380175448586470600525414550154039689560853286;\n    uint256 constant PUB_2_X = 18789213879714084532301970527052850153634971040007583328313831819609333025628;\n    uint256 constant PUB_2_Y = 12644985434441667947447298284069253818568865377627482526916716224437437683639;\n    uint256 constant PUB_3_X = 2352523767545466303288228559467558894402028212416744747545968119601089283141;\n    uint256 constant PUB_3_Y = 13695257071455071229016443207102451389133989738511645181261569528680096215705;\n    uint256 constant PUB_4_X = 20294954283864109304508611151182683038973874045536261521739495438667174243353;\n    uint256 constant PUB_4_Y = 20599106385940094055754850903485462352879182423018525029540748703501947756104;\n    uint256 constant PUB_5_X = 1845649746371440289698233659575725525425691003210786644913564503473335851532;\n    uint256 constant PUB_5_Y = 12410812710630094231961965483501933756332459400648886332512582920985597061403;\n    uint256 constant PUB_6_X = 16196196859808012507702203754447245107636768273531678830180174087039554724360;\n    uint256 constant PUB_6_Y = 10381950988710522321182538243355705405734349204185742223036700166915070642227;\n    uint256 constant PUB_7_X = 20794308775100483820552941792995687094020363291744746281004205162259496215606;\n    uint256 constant PUB_7_Y = 9409923316084098672988588998632362167730859696984939162226776086593377522865;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(\n        uint256[7] memory input,\n        uint256 publicCommit,\n        uint256[2] memory commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s :=  mload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s :=  mload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_2_X)\n            mstore(add(g, 0x20), PUB_2_Y)\n            s :=  mload(add(input, 64))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_3_X)\n            mstore(add(g, 0x20), PUB_3_Y)\n            s :=  mload(add(input, 96))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_4_X)\n            mstore(add(g, 0x20), PUB_4_Y)\n            s :=  mload(add(input, 128))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_5_X)\n            mstore(add(g, 0x20), PUB_5_Y)\n            s :=  mload(add(input, 160))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_6_X)\n            mstore(add(g, 0x20), PUB_6_Y)\n            s :=  mload(add(input, 192))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_7_X)\n            mstore(add(g, 0x20), PUB_7_Y)\n\n            s :=  mload(add(input, 224))\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := mload(commit)\n            mstore(g, s) // save commit[0]\n            s := mload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Verify an uncompressed Groth16 proof.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\n    /// of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyProof(\n        uint256[8] memory proof,\n        uint256[2] memory commitment,\n        uint256[2] memory commitmentPOK,\n        uint256[7] memory input\n    ) public view returns (bool) {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commitment[0], commitment[1]))) % MOD_R;\n        (uint256 x, uint256 y) = publicInputMSM(input, inputFr, commitment);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n\n        uint256 a0 = proof[0];\n        uint256 a1 = proof[1];\n        uint256 b00 = proof[2];\n        uint256 b01 = proof[3];\n        uint256 b10 = proof[4];\n        uint256 b11 = proof[5];\n        uint256 c0 = proof[6];\n        uint256 c1 = proof[7];\n\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n        // Copy points (A, B, C) to memory. They are already in correct encoding.\n        // This is pairing e(A, B) and G1 of e(C, -δ).\n            mstore(f, a0)\n            mstore(add(f, 0x20), a1)\n            mstore(add(f, 0x40), b00)\n            mstore(add(f, 0x60), b01)\n            mstore(add(f, 0x80), b10)\n            mstore(add(f, 0xa0), b11)\n            mstore(add(f, 0xc0), c0)\n            mstore(add(f, 0xe0), c1)\n\n        // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n        // OPT: This could be better done using a single codecopy, but\n        //      Solidity (unlike standalone Yul) doesn't provide a way to\n        //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := mload(commitment)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := mload(add(commitment, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), VK_PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), VK_PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), VK_PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), VK_PEDERSEN_G_Y_0)\n\n            c := mload(commitmentPOK)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := mload(add(commitmentPOK, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_1)\n            mstore(add(f, 0x420), VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_0)\n            mstore(add(f, 0x440), VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_1)\n            mstore(add(f, 0x460), VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_0)\n\n        // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n        // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n        return success;\n    }\n\n     function verifyRaw(bytes calldata proofData) external view returns (bool) {\n        uint256[8] memory proof;\n        proof[0] = uint256(bytes32(proofData[:32]));\n        proof[1] = uint256(bytes32(proofData[32:64]));\n        proof[2] = uint256(bytes32(proofData[64:96]));\n        proof[3] = uint256(bytes32(proofData[96:128]));\n        proof[4] = uint256(bytes32(proofData[128:160]));\n        proof[5] = uint256(bytes32(proofData[160:192]));\n        proof[6] = uint256(bytes32(proofData[192:224]));\n        proof[7] = uint256(bytes32(proofData[224:256]));\n\n        uint256[2] memory commitment;\n        commitment[0] = uint256(bytes32(proofData[256:288]));\n        commitment[1] = uint256(bytes32(proofData[288:320]));\n\n        uint256[2] memory commitmentPOK;\n        commitmentPOK[0] = uint256(bytes32(proofData[320:352]));\n        commitmentPOK[1] = uint256(bytes32(proofData[352:384]));\n\n        uint256[7] memory input;\n        input[0] = uint256(bytes32(proofData[384:416]));\n        input[1] = uint256(uint128(bytes16(proofData[416:432])));\n        input[2] = uint256(uint128(bytes16(proofData[432:448])));\n        input[3] = uint256(bytes32(proofData[448:480]));\n        input[4] = uint256(uint128(bytes16(proofData[480:496])));\n        input[5] = uint256(uint128(bytes16(proofData[496:512])));\n        input[6] = uint256(bytes32(proofData[512:544]));\n\n        return verifyProof(proof, commitment, commitmentPOK, input);\n    }\n}"
    },
    "contracts/verifiers/interfaces/IReceiptVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IReceiptVerifier {\n    struct ReceiptInfo {\n        bool success;\n        uint64 chainId;\n        bytes32 blkHash;\n        uint32 blkNum;\n        uint64 blkTime;\n        LogInfo[] logs;\n        // TODO: add transaction index\n    }\n\n    struct LogInfo {\n        address addr;\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // reverts if not verified\n    // - receiptRaw: signed dynamic fee receipt rlp encode data\n    // - proofData: receipt proof data\n    // - auxiBlkVerifyInfo: auxiliary info for blk verify in chunk sync contract\n    function verifyReceipt(\n        bytes calldata receiptRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external view returns (ReceiptInfo memory receiptInfo);\n\n    // verifyReceipt and emit event\n    function verifyReceiptAndLog(\n        bytes calldata receiptRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external returns (ReceiptInfo memory receiptInfo);\n}\n"
    },
    "contracts/verifiers/interfaces/ITxVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface ITxVerifier {\n    struct TxInfo {\n        uint64 chainId;\n        uint64 nonce;\n        uint256 gasTipCap;\n        uint256 gasFeeCap;\n        uint256 gas;\n        address to;\n        uint256 value;\n        bytes data;\n        address from; // calculate from V R S\n        uint32 blkNum;\n        bytes32 blkHash;\n        uint64 blkTime;\n    }\n\n    // reverts if not verified\n    // - txRaw: signed dynamic fee tx rlp encode data\n    // - proofData: tx proof data\n    // - auxiBlkVerifyInfo: auxiliary info for blk verify in chunk sync contract\n    function verifyTx(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external view returns (TxInfo memory txInfo);\n\n    // verifyTx and emit event\n    function verifyTxAndLog(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external returns (TxInfo memory info);\n}\n"
    },
    "contracts/verifiers/interfaces/IZkpVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IZkpVerifier {\n    function verifyRaw(bytes calldata proofData) external view returns (bool r);\n}\n"
    },
    "contracts/verifiers/zk-verifiers/BrevisBn254Verifier.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract BrevisBn254Verifier {\n\n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 12687226338041254036256354793976018101551950541498519737723469310988110076375;\n    uint256 constant ALPHA_Y = 10256096744067903796312426895717444912307333887269693700471886675863901884202;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 14568434424400989500134218686860260673044913626154307815038415359477876138326;\n    uint256 constant BETA_NEG_X_1 = 17693675125505927051254156984291616972594985825456963090951676229850221483155;\n    uint256 constant BETA_NEG_Y_0 = 383177844654040981020264750209583593321791666251217431567253973719249786217;\n    uint256 constant BETA_NEG_Y_1 = 4702609992532524160989377295099704709194662140646545418724680051209738439519;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 14815051514326228068908385609792966191592029825009679736329726616038382980218;\n    uint256 constant GAMMA_NEG_X_1 = 8489924782037803931858936554558907678042032007085687571584766050148524131882;\n    uint256 constant GAMMA_NEG_Y_0 = 6391315949514971922112169675129858004679832006305666954533871914124224506469;\n    uint256 constant GAMMA_NEG_Y_1 = 9697432153854106105017721526895571905909380451908975271046420491866280067319;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 11969087011014935233415460302004973927131871436793824839620612262784709776287;\n    uint256 constant DELTA_NEG_X_1 = 17745678986402717031649917444808681783377938238076091849249985349810291047890;\n    uint256 constant DELTA_NEG_Y_0 = 14493379635216869400631410091008330854226934252257944886907081303740461442501;\n    uint256 constant DELTA_NEG_Y_1 = 10971546432814995027058402624573736138393459536613541815883849635155919667270;\n\n    // VK CommitmentKey pedersen G\n    uint256 constant VK_PEDERSEN_G_X_0 = 14057299646988463495206519058519537185638704662797820033598363672599992650089;\n    uint256 constant VK_PEDERSEN_G_X_1 = 1804161595266085226246183082044496306049360414285214534924891118605265023103;\n    uint256 constant VK_PEDERSEN_G_Y_0 = 11766923715944210670288440569225426103940007632318040679616901977081523796491;\n    uint256 constant VK_PEDERSEN_G_Y_1 = 834977644800539851243602822366909668747653955574809155046777611984277771776;\n\n    // VK CommitmentKey pedersen GRootSigmaNeg\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_0 = 2200585081879595640584858710253685932171753361453491594146898213239013911282;\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_1 = 18049108820983202804944453697657571551769488507736702873053007083714948165248;\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_0 = 133313209624682832535108325381034698477936306159075009510964451507662397140;\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_1 = 7284716207005576333081510645859571066483492723588236030807110008433085609567;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 6007902370513106954063927857306896407269873771373783576471927701052459218140;\n    uint256 constant CONSTANT_Y = 9615488245380845401381011374843992919723531171351287827859567387072925056152;\n    uint256 constant PUB_0_X = 10697034632820275527487335132055183663961098637923488185566513151087951331578;\n    uint256 constant PUB_0_Y = 14276118394759667935635656171580811097043009027735537350675614402636858982615;\n    uint256 constant PUB_1_X = 7026431637307244687706934400969067696388921806356794816186026757716175351296;\n    uint256 constant PUB_1_Y = 15436622150387751729183576709564380175448586470600525414550154039689560853286;\n    uint256 constant PUB_2_X = 18789213879714084532301970527052850153634971040007583328313831819609333025628;\n    uint256 constant PUB_2_Y = 12644985434441667947447298284069253818568865377627482526916716224437437683639;\n    uint256 constant PUB_3_X = 2352523767545466303288228559467558894402028212416744747545968119601089283141;\n    uint256 constant PUB_3_Y = 13695257071455071229016443207102451389133989738511645181261569528680096215705;\n    uint256 constant PUB_4_X = 20294954283864109304508611151182683038973874045536261521739495438667174243353;\n    uint256 constant PUB_4_Y = 20599106385940094055754850903485462352879182423018525029540748703501947756104;\n    uint256 constant PUB_5_X = 1845649746371440289698233659575725525425691003210786644913564503473335851532;\n    uint256 constant PUB_5_Y = 12410812710630094231961965483501933756332459400648886332512582920985597061403;\n    uint256 constant PUB_6_X = 16196196859808012507702203754447245107636768273531678830180174087039554724360;\n    uint256 constant PUB_6_Y = 10381950988710522321182538243355705405734349204185742223036700166915070642227;\n    uint256 constant PUB_7_X = 20794308775100483820552941792995687094020363291744746281004205162259496215606;\n    uint256 constant PUB_7_Y = 9409923316084098672988588998632362167730859696984939162226776086593377522865;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(\n        uint256[7] calldata input,\n        uint256 publicCommit,\n        uint256[2] calldata commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s :=  calldataload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s :=  calldataload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_2_X)\n            mstore(add(g, 0x20), PUB_2_Y)\n            s :=  calldataload(add(input, 64))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_3_X)\n            mstore(add(g, 0x20), PUB_3_Y)\n            s :=  calldataload(add(input, 96))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_4_X)\n            mstore(add(g, 0x20), PUB_4_Y)\n            s :=  calldataload(add(input, 128))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_5_X)\n            mstore(add(g, 0x20), PUB_5_Y)\n            s :=  calldataload(add(input, 160))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_6_X)\n            mstore(add(g, 0x20), PUB_6_Y)\n            s :=  calldataload(add(input, 192))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_7_X)\n            mstore(add(g, 0x20), PUB_7_Y)\n\n            s :=  calldataload(add(input, 224))\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := calldataload(commit)\n            mstore(g, s) // save commit[0]\n            s := calldataload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Verify an uncompressed Groth16 proof.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\n    /// of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyProof(\n        uint256[8] calldata proof,\n        uint256[2] calldata commit,\n        uint256[2] calldata knowledgeProof,\n        uint256[7] calldata input\n    ) public view {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commit[0], commit[1]))) % MOD_R;\n        (uint256 x, uint256 y) = publicInputMSM(input, inputFr, commit);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n        // Copy points (A, B, C) to memory. They are already in correct encoding.\n        // This is pairing e(A, B) and G1 of e(C, -δ).\n            calldatacopy(f, proof, 0x100)\n\n        // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n        // OPT: This could be better done using a single codecopy, but\n        //      Solidity (unlike standalone Yul) doesn't provide a way to\n        //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := calldataload(commit)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := calldataload(add(commit, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), VK_PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), VK_PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), VK_PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), VK_PEDERSEN_G_Y_0)\n\n            c := calldataload(knowledgeProof)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := calldataload(add(knowledgeProof, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_1)\n            mstore(add(f, 0x420), VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_0)\n            mstore(add(f, 0x440), VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_1)\n            mstore(add(f, 0x460), VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_0)\n\n        // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n        // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n    }\n}"
    },
    "contracts/verifiers/zk-verifiers/common/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IVerifier {\n    struct Proof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[2] commitment;\n    }\n\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[10] calldata input\n    ) external view returns (bool r);\n}\n"
    },
    "contracts/verifiers/zk-verifiers/OnChainBn254.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract OnChainBn254Verifier {\n    \n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 4176444929362342937787669138078906418591940449829252770367730812028484234524;\n    uint256 constant ALPHA_Y = 16385862503144070006736171412569611342275130056261647732104289830577387120456;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 14609448517081855383800789168871770161098761125544650382882394124651454336502;\n    uint256 constant BETA_NEG_X_1 = 10222551087791646006228285304731311467278401530530081077339125222980401880313;\n    uint256 constant BETA_NEG_Y_0 = 19995245995694720233293389948808773067747968512591871203560153933770023751369;\n    uint256 constant BETA_NEG_Y_1 = 14754240208040065570509462737284420816226355534128723412179262068098539991818;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 14240627175565189522873377635702663712390061639213321343834765638608285435212;\n    uint256 constant GAMMA_NEG_X_1 = 1405423343886505881959426150442233857194365379796568052656244264683049970894;\n    uint256 constant GAMMA_NEG_Y_0 = 13810710739236350565908581807041017948425905436478113627688212844402925602603;\n    uint256 constant GAMMA_NEG_Y_1 = 13099961862660104230035300620100318444206999107775757241758553510708669622591;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 21068229423759416310098968315340722082374440809676756972099402782301047891161;\n    uint256 constant DELTA_NEG_X_1 = 6190721011031253514139898428504837964683535125663997126819915307510612098440;\n    uint256 constant DELTA_NEG_Y_0 = 16353517931178067994615688141876710590287112002586735726339800389039134092514;\n    uint256 constant DELTA_NEG_Y_1 = 1629062368377648889909861030043016277502236305856077376979507186372920443557;\n\n\t// VK CommitmentKey pedersen G\n\tuint256 constant VK_PEDERSEN_G_X_0 = 997567293143986798375773039001087532375838525051475464527203970003402374926;\n    uint256 constant VK_PEDERSEN_G_X_1 = 3794932166361229972444626844463150823497416579746508910620938861644548988469;\n    uint256 constant VK_PEDERSEN_G_Y_0 = 4155773684454145933777104533309389517038576964076618396066925527226922909609;\n    uint256 constant VK_PEDERSEN_G_Y_1 = 18904502593757612981637926979245435215474654373603789533397268537354726590292;\n\n\t// VK CommitmentKey pedersen GRootSigmaNeg\n\tuint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_0 = 12554627588025205141290865287797703986786796476705536884098290885043592317641;\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_1 = 3569659539857768081328109445387273608174604356989240518233354910951144835984;\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_0 = 12963861487792444056867115341388034142923870741943402162933791949083645648050;\n    uint256 constant VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_1 = 5313907934464608193153732891319697211121774159132851706155812920658149193890;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 14511889174100643761944355716865735787484865263647944420704292473312530527091;\n    uint256 constant CONSTANT_Y = 309621074912741929891308924296531432916492960164982659495231458438207967801;\n    uint256 constant PUB_0_X = 6010393720213894861927577868233336232310050858233841547387731988360469323754;\n    uint256 constant PUB_0_Y = 5118352787645468237281941288371735337311118946572011590714988406202431954309;\n    uint256 constant PUB_1_X = 5665416004360916151826908033845004763159020177259591311461765154914488387044;\n    uint256 constant PUB_1_Y = 4358051533528982461435359410795320758049648106119208927391665341658107506146;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    /// Negation in Fp.\n    /// @notice Returns a number x such that a + x = 0 in Fp.\n    /// @notice The input does not need to be reduced.\n    /// @param a the base\n    /// @return x the result\n    function negate(uint256 a) internal pure returns (uint256 x) {\n        unchecked {\n            x = (P - (a % P)) % P; // Modulo is cheaper than branching\n        }\n    }\n\n    /// Exponentiation in Fp.\n    /// @notice Returns a number x such that a ^ e = x in Fp.\n    /// @notice The input does not need to be reduced.\n    /// @param a the base\n    /// @param e the exponent\n    /// @return x the result\n    function exp(uint256 a, uint256 e) internal view returns (uint256 x) {\n        bool success;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            mstore(f, 0x20)\n            mstore(add(f, 0x20), 0x20)\n            mstore(add(f, 0x40), 0x20)\n            mstore(add(f, 0x60), a)\n            mstore(add(f, 0x80), e)\n            mstore(add(f, 0xa0), P)\n            success := staticcall(gas(), PRECOMPILE_MODEXP, f, 0xc0, f, 0x20)\n            x := mload(f)\n        }\n        if (!success) {\n            // Exponentiation failed.\n            // Should not happen.\n            revert ProofInvalid();\n        } \n    }\n\n    /// Invertsion in Fp.\n    /// @notice Returns a number x such that a * x = 1 in Fp.\n    /// @notice The input does not need to be reduced.\n    /// @notice Reverts with ProofInvalid() if the inverse does not exist\n    /// @param a the input\n    /// @return x the solution\n    function invert_Fp(uint256 a) internal view returns (uint256 x) {\n        x = exp(a, EXP_INVERSE_FP);\n        if (mulmod(a, x, P) != 1) {\n            // Inverse does not exist.\n            // Can only happen during G2 point decompression.\n            revert ProofInvalid();\n        }\n    }\n\n    /// Square root in Fp.\n    /// @notice Returns a number x such that x * x = a in Fp.\n    /// @notice Will revert with InvalidProof() if the input is not a square\n    /// or not reduced.\n    /// @param a the square\n    /// @return x the solution\n    function sqrt_Fp(uint256 a) internal view returns (uint256 x) {\n        x = exp(a, EXP_SQRT_FP);\n        if (mulmod(x, x, P) != a) {\n            // Square root does not exist or a is not reduced.\n            // Happens when G1 point is not on curve.\n            revert ProofInvalid();\n        }\n    }\n\n    /// Square test in Fp.\n    /// @notice Returns wheter a number x exists such that x * x = a in Fp.\n    /// @notice Will revert with InvalidProof() if the input is not a square\n    /// or not reduced.\n    /// @param a the square\n    /// @return x the solution\n    function isSquare_Fp(uint256 a) internal view returns (bool) {\n        uint256 x = exp(a, EXP_SQRT_FP);\n        return mulmod(x, x, P) == a;\n    }\n\n    /// Square root in Fp2.\n    /// @notice Fp2 is the complex extension Fp[i]/(i^2 + 1). The input is\n    /// a0 + a1 ⋅ i and the result is x0 + x1 ⋅ i.\n    /// @notice Will revert with InvalidProof() if\n    ///   * the input is not a square,\n    ///   * the hint is incorrect, or\n    ///   * the input coefficents are not reduced.\n    /// @param a0 The real part of the input.\n    /// @param a1 The imaginary part of the input.\n    /// @param hint A hint which of two possible signs to pick in the equation.\n    /// @return x0 The real part of the square root.\n    /// @return x1 The imaginary part of the square root.\n    function sqrt_Fp2(uint256 a0, uint256 a1, bool hint) internal view returns (uint256 x0, uint256 x1) {\n        // If this square root reverts there is no solution in Fp2.\n        uint256 d = sqrt_Fp(addmod(mulmod(a0, a0, P), mulmod(a1, a1, P), P));\n        if (hint) {\n            d = negate(d);\n        }\n        // If this square root reverts there is no solution in Fp2.\n        x0 = sqrt_Fp(mulmod(addmod(a0, d, P), FRACTION_1_2_FP, P));\n        x1 = mulmod(a1, invert_Fp(mulmod(x0, 2, P)), P);\n\n        // Check result to make sure we found a root.\n        // Note: this also fails if a0 or a1 is not reduced.\n        if (a0 != addmod(mulmod(x0, x0, P), negate(mulmod(x1, x1, P)), P)\n        ||  a1 != mulmod(2, mulmod(x0, x1, P), P)) {\n            revert ProofInvalid();\n        }\n    }\n\n    /// Compress a G1 point.\n    /// @notice Reverts with InvalidProof if the coordinates are not reduced\n    /// or if the point is not on the curve.\n    /// @notice The point at infinity is encoded as (0,0) and compressed to 0.\n    /// @param x The X coordinate in Fp.\n    /// @param y The Y coordinate in Fp.\n    /// @return c The compresed point (x with one signal bit).\n    function compress_g1(uint256 x, uint256 y) internal view returns (uint256 c) {\n        if (x >= P || y >= P) {\n            // G1 point not in field.\n            revert ProofInvalid();\n        }\n        if (x == 0 && y == 0) {\n            // Point at infinity\n            return 0;\n        }\n        \n        // Note: sqrt_Fp reverts if there is no solution, i.e. the x coordinate is invalid.\n        uint256 y_pos = sqrt_Fp(addmod(mulmod(mulmod(x, x, P), x, P), 3, P));\n        if (y == y_pos) {\n            return (x << 1) | 0;\n        } else if (y == negate(y_pos)) {\n            return (x << 1) | 1;\n        } else {\n            // G1 point not on curve.\n            revert ProofInvalid();\n        }\n    }\n\n    /// Decompress a G1 point.\n    /// @notice Reverts with InvalidProof if the input does not represent a valid point.\n    /// @notice The point at infinity is encoded as (0,0) and compressed to 0.\n    /// @param c The compresed point (x with one signal bit).\n    /// @return x The X coordinate in Fp.\n    /// @return y The Y coordinate in Fp.\n    function decompress_g1(uint256 c) internal view returns (uint256 x, uint256 y) {\n        // Note that X = 0 is not on the curve since 0³ + 3 = 3 is not a square.\n        // so we can use it to represent the point at infinity.\n        if (c == 0) {\n            // Point at infinity as encoded in EIP196 and EIP197.\n            return (0, 0);\n        }\n        bool negate_point = c & 1 == 1;\n        x = c >> 1;\n        if (x >= P) {\n            // G1 x coordinate not in field.\n            revert ProofInvalid();\n        }\n\n        // Note: (x³ + 3) is irreducible in Fp, so it can not be zero and therefore\n        //       y can not be zero.\n        // Note: sqrt_Fp reverts if there is no solution, i.e. the point is not on the curve.\n        y = sqrt_Fp(addmod(mulmod(mulmod(x, x, P), x, P), 3, P));\n        if (negate_point) {\n            y = negate(y);\n        }\n    }\n\n    /// Compress a G2 point.\n    /// @notice Reverts with InvalidProof if the coefficients are not reduced\n    /// or if the point is not on the curve.\n    /// @notice The G2 curve is defined over the complex extension Fp[i]/(i^2 + 1)\n    /// with coordinates (x0 + x1 ⋅ i, y0 + y1 ⋅ i). \n    /// @notice The point at infinity is encoded as (0,0,0,0) and compressed to (0,0).\n    /// @param x0 The real part of the X coordinate.\n    /// @param x1 The imaginary poart of the X coordinate.\n    /// @param y0 The real part of the Y coordinate.\n    /// @param y1 The imaginary part of the Y coordinate.\n    /// @return c0 The first half of the compresed point (x0 with two signal bits).\n    /// @return c1 The second half of the compressed point (x1 unmodified).\n    function compress_g2(uint256 x0, uint256 x1, uint256 y0, uint256 y1)\n    internal view returns (uint256 c0, uint256 c1) {\n        if (x0 >= P || x1 >= P || y0 >= P || y1 >= P) {\n            // G2 point not in field.\n            revert ProofInvalid();\n        }\n        if ((x0 | x1 | y0 | y1) == 0) {\n            // Point at infinity\n            return (0, 0);\n        }\n\n        // Compute y^2\n        // Note: shadowing variables and scoping to avoid stack-to-deep.\n        uint256 y0_pos;\n        uint256 y1_pos;\n        {\n            uint256 n3ab = mulmod(mulmod(x0, x1, P), P-3, P);\n            uint256 a_3 = mulmod(mulmod(x0, x0, P), x0, P);\n            uint256 b_3 = mulmod(mulmod(x1, x1, P), x1, P);\n            y0_pos = addmod(FRACTION_27_82_FP, addmod(a_3, mulmod(n3ab, x1, P), P), P);\n            y1_pos = negate(addmod(FRACTION_3_82_FP,  addmod(b_3, mulmod(n3ab, x0, P), P), P));\n        }\n\n        // Determine hint bit\n        // If this sqrt fails the x coordinate is not on the curve.\n        bool hint;\n        {\n            uint256 d = sqrt_Fp(addmod(mulmod(y0_pos, y0_pos, P), mulmod(y1_pos, y1_pos, P), P));\n            hint = !isSquare_Fp(mulmod(addmod(y0_pos, d, P), FRACTION_1_2_FP, P));\n        }\n\n        // Recover y\n        (y0_pos, y1_pos) = sqrt_Fp2(y0_pos, y1_pos, hint);\n        if (y0 == y0_pos && y1 == y1_pos) {\n            c0 = (x0 << 2) | (hint ? 2  : 0) | 0;\n            c1 = x1;\n        } else if (y0 == negate(y0_pos) && y1 == negate(y1_pos)) {\n            c0 = (x0 << 2) | (hint ? 2  : 0) | 1;\n            c1 = x1;\n        } else {\n            // G1 point not on curve.\n            revert ProofInvalid();\n        }\n    }\n\n    /// Decompress a G2 point.\n    /// @notice Reverts with InvalidProof if the input does not represent a valid point.\n    /// @notice The G2 curve is defined over the complex extension Fp[i]/(i^2 + 1)\n    /// with coordinates (x0 + x1 ⋅ i, y0 + y1 ⋅ i). \n    /// @notice The point at infinity is encoded as (0,0,0,0) and compressed to (0,0).\n    /// @param c0 The first half of the compresed point (x0 with two signal bits).\n    /// @param c1 The second half of the compressed point (x1 unmodified).\n    /// @return x0 The real part of the X coordinate.\n    /// @return x1 The imaginary poart of the X coordinate.\n    /// @return y0 The real part of the Y coordinate.\n    /// @return y1 The imaginary part of the Y coordinate.\n    function decompress_g2(uint256 c0, uint256 c1)\n    internal view returns (uint256 x0, uint256 x1, uint256 y0, uint256 y1) {\n        // Note that X = (0, 0) is not on the curve since 0³ + 3/(9 + i) is not a square.\n        // so we can use it to represent the point at infinity.\n        if (c0 == 0 && c1 == 0) {\n            // Point at infinity as encoded in EIP197.\n            return (0, 0, 0, 0);\n        }\n        bool negate_point = c0 & 1 == 1;\n        bool hint = c0 & 2 == 2;\n        x0 = c0 >> 2;\n        x1 = c1;\n        if (x0 >= P || x1 >= P) {\n            // G2 x0 or x1 coefficient not in field.\n            revert ProofInvalid();\n        }\n\n        uint256 n3ab = mulmod(mulmod(x0, x1, P), P-3, P);\n        uint256 a_3 = mulmod(mulmod(x0, x0, P), x0, P);\n        uint256 b_3 = mulmod(mulmod(x1, x1, P), x1, P);\n\n        y0 = addmod(FRACTION_27_82_FP, addmod(a_3, mulmod(n3ab, x1, P), P), P);\n        y1 = negate(addmod(FRACTION_3_82_FP,  addmod(b_3, mulmod(n3ab, x0, P), P), P));\n\n        // Note: sqrt_Fp2 reverts if there is no solution, i.e. the point is not on the curve.\n        // Note: (X³ + 3/(9 + i)) is irreducible in Fp2, so y can not be zero.\n        //       But y0 or y1 may still independently be zero.\n        (y0, y1) = sqrt_Fp2(y0, y1, hint);\n        if (negate_point) {\n            y0 = negate(y0);\n            y1 = negate(y1);\n        }\n    }\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(uint256[2] calldata input)\n    internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s :=  calldataload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s :=  calldataload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n\t/// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSMWithCommit(\n        uint256[1] calldata input,\n        uint256 publicCommit,\n        uint256[2] calldata commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s := calldataload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := calldataload(commit)\n            mstore(g, s) // save commit[0]\n            s := calldataload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Compress a proof.\n    /// @notice Will revert with InvalidProof if the curve points are invalid,\n    /// but does not verify the proof itself.\n    /// @param proof The uncompressed Groth16 proof. Elements are in the same order as for\n    /// verifyProof. I.e. Groth16 points (A, B, C) encoded as in EIP-197.\n    /// @return compressed The compressed proof. Elements are in the same order as for\n    /// verifyCompressedProof. I.e. points (A, B, C) in compressed format.\n    function compressProof(uint256[8] calldata proof)\n    public view returns (uint256[4] memory compressed) {\n        compressed[0] = compress_g1(proof[0], proof[1]);\n        (compressed[2], compressed[1]) = compress_g2(proof[3], proof[2], proof[5], proof[4]);\n        compressed[3] = compress_g1(proof[6], proof[7]);\n    }\n\n    /// Verify a Groth16 proof with compressed points.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param compressedProof the points (A, B, C) in compressed format\n    /// matching the output of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyCompressedProof(\n        uint256[4] calldata compressedProof,\n        uint256[2] calldata input\n    ) public view {\n        (uint256 Ax, uint256 Ay) = decompress_g1(compressedProof[0]);\n        (uint256 Bx0, uint256 Bx1, uint256 By0, uint256 By1) = decompress_g2(\n                compressedProof[2], compressedProof[1]);\n        (uint256 Cx, uint256 Cy) = decompress_g1(compressedProof[3]);\n        (uint256 Lx, uint256 Ly) = publicInputMSM(input);\n\n        // Verify the pairing\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n        uint256[24] memory pairings;\n        // e(A, B)\n        pairings[ 0] = Ax;\n        pairings[ 1] = Ay;\n        pairings[ 2] = Bx1;\n        pairings[ 3] = Bx0;\n        pairings[ 4] = By1;\n        pairings[ 5] = By0;\n        // e(C, -δ)\n        pairings[ 6] = Cx;\n        pairings[ 7] = Cy;\n        pairings[ 8] = DELTA_NEG_X_1;\n        pairings[ 9] = DELTA_NEG_X_0;\n        pairings[10] = DELTA_NEG_Y_1;\n        pairings[11] = DELTA_NEG_Y_0;\n        // e(α, -β)\n        pairings[12] = ALPHA_X;\n        pairings[13] = ALPHA_Y;\n        pairings[14] = BETA_NEG_X_1;\n        pairings[15] = BETA_NEG_X_0;\n        pairings[16] = BETA_NEG_Y_1;\n        pairings[17] = BETA_NEG_Y_0;\n        // e(L_pub, -γ)\n        pairings[18] = Lx;\n        pairings[19] = Ly;\n        pairings[20] = GAMMA_NEG_X_1;\n        pairings[21] = GAMMA_NEG_X_0;\n        pairings[22] = GAMMA_NEG_Y_1;\n        pairings[23] = GAMMA_NEG_Y_0;\n\n        // Check pairing equation.\n        bool success;\n        uint256[1] memory output;\n        assembly (\"memory-safe\") {\n            success := staticcall(gas(), PRECOMPILE_VERIFY, pairings, 0x300, output, 0x20)\n        }\n        if (!success || output[0] != 1) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n    }\n\n    function verifyProofWithCommitAll(\n        uint256[8] calldata proof,\n        uint256[2] calldata commit,\n        uint256[1] calldata input,\n        uint256[2] calldata knowledgeProof\n    ) public view {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commit[0], commit[1]))) % MOD_R;\n\n        (uint256 x, uint256 y) = publicInputMSMWithCommit(input, inputFr, commit);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n        // Copy points (A, B, C) to memory. They are already in correct encoding.\n        // This is pairing e(A, B) and G1 of e(C, -δ).\n            calldatacopy(f, proof, 0x100)\n\n        // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n        // OPT: This could be better done using a single codecopy, but\n        //      Solidity (unlike standalone Yul) doesn't provide a way to\n        //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := calldataload(commit)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := calldataload(add(commit, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), VK_PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), VK_PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), VK_PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), VK_PEDERSEN_G_Y_0)\n\n            c := calldataload(knowledgeProof)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := calldataload(add(knowledgeProof, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_1)\n            mstore(add(f, 0x420), VK_PEDERSEN_G_ROOT_SIGMA_NEG_X_0)\n            mstore(add(f, 0x440), VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_1)\n            mstore(add(f, 0x460), VK_PEDERSEN_G_ROOT_SIGMA_NEG_Y_0)\n\n        // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n        // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}