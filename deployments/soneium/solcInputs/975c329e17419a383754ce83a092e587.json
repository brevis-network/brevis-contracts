{
  "language": "Solidity",
  "sources": {
    "contracts/verifiers/zk-verifiers/BrevisPlonky2SmtVerifier.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract BrevisPlonky2SmtVerifier {\n\n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 9711627955724311834784488649640453336865142251193944219245711722439808200371;\n    uint256 constant ALPHA_Y = 2505492180822423263041788355812321952759547577899451782511577455005757262923;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 13499871872605582160891168838829521262451463065113808703943528539835480766637;\n    uint256 constant BETA_NEG_X_1 = 15820632028657616015057294708134858252841059230313550478583050800247359581668;\n    uint256 constant BETA_NEG_Y_0 = 12573886416676420363793835962707721718375062605004734481621777844586734840058;\n    uint256 constant BETA_NEG_Y_1 = 17241979172256983835296876038192904084559798366531371721860514963600379797728;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 533823341112532332181875592415981129573597537830924362231409714066441860387;\n    uint256 constant GAMMA_NEG_X_1 = 12348343873624267645852071153801626064988242899882169083465143781800401707028;\n    uint256 constant GAMMA_NEG_Y_0 = 17632037757301536792061392519062620953482381884525709241195276603115804280991;\n    uint256 constant GAMMA_NEG_Y_1 = 8847137175606651042410049397316706456512545587952246616766240538562941278989;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 20781536877202454612313904077056964109565138894038139857017864417168276560552;\n    uint256 constant DELTA_NEG_X_1 = 1855809939155669843883400186204044222539672494056438732094818963231743115356;\n    uint256 constant DELTA_NEG_Y_0 = 18893290922867552704630406592968945566656800474066642978211441389325229765791;\n    uint256 constant DELTA_NEG_Y_1 = 3156392774641462836878961591011179191215975872658186634315222489938736390860;\n    // Pedersen G point in G2 in powers of i\n    uint256 constant PEDERSEN_G_X_0 = 7590769814777716702368274323822866203310371035775963421714290244640267968810;\n    uint256 constant PEDERSEN_G_X_1 = 13938521311676760312862721950667387012021892932709293153309340203335041800131;\n    uint256 constant PEDERSEN_G_Y_0 = 16526346463830461447055374657535131780765081106386257238916332479510606353171;\n    uint256 constant PEDERSEN_G_Y_1 = 17209259504677688674058987403089010076299754933268187705508266825052530638006;\n\n    // Pedersen GRootSigmaNeg point in G2 in powers of i\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_0 = 9414394291441915470653952017248010394073630170817386807456454754534113486211;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_1 = 993594027156440135435878430487261545559346686988903913189119717580184039914;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_0 = 6753985584860452045608779244881915107652171843322826399403112115513279076356;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_1 = 20326437300128747457179208676007395546113513461444267108581568995017323902270;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 16394830929394585354971696367942597959752012849364332032406395500147703696364;\n    uint256 constant CONSTANT_Y = 18990408379527419892373164294228897292913339848455176086560734160755260265556;\n    uint256 constant PUB_0_X = 1541846356150730107649357576989558778593922841044037975616107812810761390288;\n    uint256 constant PUB_0_Y = 12165766330834405566640925553296798813533309205026909616247549209542384721769;\n    uint256 constant PUB_1_X = 21044130314309058741590430830727323323167235138300104168139318366407917460634;\n    uint256 constant PUB_1_Y = 6076021234838724413024445698409144369514907023593371385124049879264360116914;\n    uint256 constant PUB_2_X = 16624608716437642121497813738496178101080484698345802682659089838844161464017;\n    uint256 constant PUB_2_Y = 10079905137910246263777471805555085968086808156311073864304068017881822427903;\n    uint256 constant PUB_3_X = 12195366618644555674077950137013938458590421350318166883167722941029843893946;\n    uint256 constant PUB_3_Y = 4305785304004972390928951397679187128288606373956332808827657642751230470232;\n    uint256 constant PUB_4_X = 18281912648112712652823898977108230597943776269455822175403060820026923549081;\n    uint256 constant PUB_4_Y = 12455636581371328050369695832676869257569189466133302902328476078575183979595;\n    uint256 constant PUB_5_X = 7958475172690672829748492988249572878991386204317802601773893461459343248265;\n    uint256 constant PUB_5_Y = 9389532256402089527316365862774204613814889098999755171094402267653410979428;\n    uint256 constant PUB_6_X = 419128560521272670682877864475153060065413905152921277659659034298547869000;\n    uint256 constant PUB_6_Y = 6372879698814001335093396030028684780920775852316901267801270385648097815751;\n    uint256 constant PUB_7_X = 14500643290997515859841688368473103213584819763054667829457080972623677945522;\n    uint256 constant PUB_7_Y = 2510796519049536186265902727442848210238425627035721385815340217938059673026;\n    uint256 constant PUB_8_X = 13714803245493495615164497351979481060151182221430936280030201759204693767852;\n    uint256 constant PUB_8_Y = 8075942977904763478797072463106634173664284978886652995431784609076641694121;\n    uint256 constant PUB_9_X = 7162979031372881348274523157895919204553728918944491306315207279319570802655;\n    uint256 constant PUB_9_Y = 19440880952494561475061748206555677803194228459619058424983217515493100789065;\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(\n        uint256[9] memory input,\n        uint256 publicCommit,\n        uint256[2] memory commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s := mload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s := mload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_2_X)\n            mstore(add(g, 0x20), PUB_2_Y)\n            s := mload(add(input, 64))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_3_X)\n            mstore(add(g, 0x20), PUB_3_Y)\n            s := mload(add(input, 96))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_4_X)\n            mstore(add(g, 0x20), PUB_4_Y)\n            s := mload(add(input, 128))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_5_X)\n            mstore(add(g, 0x20), PUB_5_Y)\n            s := mload(add(input, 160))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_6_X)\n            mstore(add(g, 0x20), PUB_6_Y)\n\n            s := mload(add(input, 192))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_7_X)\n            mstore(add(g, 0x20), PUB_7_Y)\n\n            s := mload(add(input, 224))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_8_X)\n            mstore(add(g, 0x20), PUB_8_Y)\n\n            s := mload(add(input, 256))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_9_X)\n            mstore(add(g, 0x20), PUB_9_Y)\n\n            s := mload(add(input, 288))\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := mload(commit)\n            mstore(g, s) // save commit[0]\n            s := mload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Verify an uncompressed Groth16 proof.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\n    /// of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyProof(\n        uint256[8] memory proof,\n        uint256[2] memory commitment,\n        uint256[2] memory commitmentPOK,\n        uint256[9] memory input\n    ) public view returns (bool) {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commitment[0], commitment[1]))) % MOD_R;\n        (uint256 x, uint256 y) = publicInputMSM(input, inputFr, commitment);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n\n        uint256 a0 = proof[0];\n        uint256 a1 = proof[1];\n        uint256 b00 = proof[2];\n        uint256 b01 = proof[3];\n        uint256 b10 = proof[4];\n        uint256 b11 = proof[5];\n        uint256 c0 = proof[6];\n        uint256 c1 = proof[7];\n\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n        // Copy points (A, B, C) to memory. They are already in correct encoding.\n        // This is pairing e(A, B) and G1 of e(C, -δ).\n            mstore(f, a0)\n            mstore(add(f, 0x20), a1)\n            mstore(add(f, 0x40), b00)\n            mstore(add(f, 0x60), b01)\n            mstore(add(f, 0x80), b10)\n            mstore(add(f, 0xa0), b11)\n            mstore(add(f, 0xc0), c0)\n            mstore(add(f, 0xe0), c1)\n\n        // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n        // OPT: This could be better done using a single codecopy, but\n        //      Solidity (unlike standalone Yul) doesn't provide a way to\n        //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := mload(commitment)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := mload(add(commitment, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), PEDERSEN_G_Y_0)\n\n            c := mload(commitmentPOK)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := mload(add(commitmentPOK, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), PEDERSEN_GROOTSIGMANEG_X_1)\n            mstore(add(f, 0x420), PEDERSEN_GROOTSIGMANEG_X_0)\n            mstore(add(f, 0x440), PEDERSEN_GROOTSIGMANEG_Y_1)\n            mstore(add(f, 0x460), PEDERSEN_GROOTSIGMANEG_Y_0)\n\n        // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n        // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}