{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/IEthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\ninterface IEthereumLightClient {\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n}\n"
    },
    "contracts/light-client/Constants.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\n// light client security params\nuint256 constant MIN_SYNC_COMMITTEE_PARTICIPANTS = 1;\nuint256 constant UPDATE_TIMEOUT = 86400;\n\n// beacon chain constants\nuint256 constant FINALIZED_ROOT_INDEX = 105;\nuint256 constant NEXT_SYNC_COMMITTEE_INDEX = 55;\nuint256 constant EXECUTION_STATE_ROOT_INDEX = 898;\n// uint256 constant EXECUTION_STATE_ROOT_INDEX = 402;\nuint256 constant SYNC_COMMITTEE_SIZE = 512;\nuint64 constant SLOTS_PER_EPOCH = 32;\nuint64 constant EPOCHS_PER_SYNC_COMMITTEE_PERIOD = 256;\nbytes32 constant DOMAIN_SYNC_COMMITTEE = bytes32(uint256(0x07) << 248);\nuint256 constant SLOT_LENGTH_SECONDS = 12;\n"
    },
    "contracts/light-client/EthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IEthereumLightClient.sol\";\n\nimport \"./IZkVerifier.sol\";\nimport \"./LightClientStore.sol\";\nimport \"./SSZ.sol\";\nimport \"./Constants.sol\";\nimport \"./Types.sol\";\n\ncontract EthereumLightClient is IEthereumLightClient, LightClientStore, Ownable {\n    event HeaderUpdated(uint256 slot, bytes32 stateRoot, bytes32 executionStateRoot, bool finalized);\n    event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot);\n    event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion);\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        BeaconBlockHeader memory _finalizedHeader,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    )\n        LightClientStore(\n            genesisTime,\n            genesisValidatorsRoot,\n            _forkEpochs,\n            _forkVersions,\n            _finalizedHeader,\n            syncCommitteeRoot,\n            syncCommitteePoseidonRoot,\n            _zkVerifier\n        )\n    {}\n\n    function latestFinalizedSlotAndCommitteeRoots()\n        external\n        view\n        returns (uint64 slot, bytes32 currentRoot, bytes32 nextRoot)\n    {\n        return (finalizedHeader.slot, currentSyncCommitteeRoot, nextSyncCommitteeRoot);\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (finalizedExecutionStateRoot, finalizedExecutionStateRootSlot);\n    }\n\n    function updateForkVersion(uint64 epoch, bytes4 forkVersion) external onlyOwner {\n        require(forkVersion != bytes4(0), \"bad fork version\");\n        forkEpochs.push(epoch);\n        forkVersions.push(forkVersion);\n        emit ForkVersionUpdated(epoch, forkVersion);\n    }\n\n    function processLightClientForceUpdate() external onlyOwner {\n        require(currentSlot() > finalizedHeader.slot + UPDATE_TIMEOUT, \"timeout not passed\");\n        require(bestValidUpdate.attestedHeader.slot > 0, \"no best valid update\");\n\n        // Forced best update when the update timeout has elapsed.\n        // Because the apply logic waits for finalizedHeader.slot to indicate sync committee fin,\n        // the attestedHeader may be treated as finalizedHeader in extended periods of non-fin\n        // to guarantee progression into later sync committee periods according to isBetterUpdate().\n        if (bestValidUpdate.finalizedHeader.slot <= finalizedHeader.slot) {\n            bestValidUpdate.finalizedHeader = bestValidUpdate.attestedHeader;\n        }\n        applyLightClientUpdate(bestValidUpdate);\n        delete bestValidUpdate;\n    }\n\n    function processLightClientUpdate(LightClientUpdate memory update) public {\n        validateLightClientUpdate(update);\n\n        // Update the best update in case we have to force-update to it if the timeout elapses\n        if (isBetterUpdate(update, bestValidUpdate)) {\n            bestValidUpdate = update;\n        }\n\n        // Apply fin update\n        bool updateHasFinalizedNextSyncCommittee = hasNextSyncCommitteeProof(update) &&\n            hasFinalityProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.finalizedHeader.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.slot) &&\n            nextSyncCommitteeRoot == bytes32(0);\n        if (\n            hasSupermajority(update.syncAggregate.participation) &&\n            (update.finalizedHeader.slot > finalizedHeader.slot || updateHasFinalizedNextSyncCommittee)\n        ) {\n            applyLightClientUpdate(update);\n            delete bestValidUpdate;\n        }\n    }\n\n    function validateLightClientUpdate(LightClientUpdate memory update) private view {\n        // Verify sync committee has sufficient participants\n        require(update.syncAggregate.participation > MIN_SYNC_COMMITTEE_PARTICIPANTS, \"not enough participation\");\n        // Verify update does not skip a sync committee period\n        require(\n            currentSlot() > update.attestedHeader.slot && update.attestedHeader.slot > update.finalizedHeader.slot,\n            \"bad slot\"\n        );\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedHeader.slot);\n        uint64 updatePeriod = computeSyncCommitteePeriodAtSlot(update.finalizedHeader.slot);\n        require(updatePeriod == storePeriod || updatePeriod == storePeriod + 1);\n\n        // Verify update is relavant\n        uint64 updateAttestedPeriod = computeSyncCommitteePeriodAtSlot(update.attestedHeader.slot);\n        bool updateHasNextSyncCommittee = nextSyncCommitteeRoot == bytes32(0) &&\n            hasNextSyncCommitteeProof(update) &&\n            updateAttestedPeriod == storePeriod;\n        // since sync committee update prefers older header (see isBetterUpdate), an update either\n        // needs to have a newer header or it should have sync committee update.\n        require(update.attestedHeader.slot > finalizedHeader.slot || updateHasNextSyncCommittee);\n\n        // Verify that the finalityBranch, if present, confirms finalizedHeader\n        // to match the finalized checkpoint root saved in the state of attestedHeader.\n        // Note that the genesis finalized checkpoint root is represented as a zero hash.\n        if (!hasFinalityProof(update)) {\n            require(isEmptyHeader(update.finalizedHeader), \"no fin proof\");\n        } else {\n            // genesis block header\n            if (update.finalizedHeader.slot == 0) {\n                require(isEmptyHeader(update.finalizedHeader), \"genesis header should be empty\");\n            } else {\n                bool isValidFinalityProof = SSZ.isValidMerkleBranch(\n                    SSZ.hashTreeRoot(update.finalizedHeader),\n                    update.finalityBranch,\n                    FINALIZED_ROOT_INDEX,\n                    update.attestedHeader.stateRoot\n                );\n                require(isValidFinalityProof, \"bad fin proof\");\n            }\n        }\n\n        // Verify finalizedExecutionStateRoot\n        if (!hasExecutionFinalityProof(update)) {\n            require(update.finalizedExecutionStateRoot == bytes32(0), \"no exec fin proof\");\n        } else {\n            require(hasFinalityProof(update), \"no exec fin proof\");\n            bool isValidFinalizedExecutionRootProof = SSZ.isValidMerkleBranch(\n                update.finalizedExecutionStateRoot,\n                update.finalizedExecutionStateRootBranch,\n                EXECUTION_STATE_ROOT_INDEX,\n                update.finalizedHeader.stateRoot\n            );\n            require(isValidFinalizedExecutionRootProof, \"bad exec fin proof\");\n        }\n\n        // Verify that the update's nextSyncCommittee, if present, actually is the next sync committee\n        // saved in the state of the update's attested header\n        if (!hasNextSyncCommitteeProof(update)) {\n            require(\n                update.nextSyncCommitteeRoot == bytes32(0) && update.nextSyncCommitteePoseidonRoot == bytes32(0),\n                \"no next sync committee proof\"\n            );\n        } else {\n            if (updateAttestedPeriod == storePeriod && nextSyncCommitteeRoot != bytes32(0)) {\n                require(update.nextSyncCommitteeRoot == nextSyncCommitteeRoot, \"bad next sync committee\");\n            }\n            bool isValidSyncCommitteeProof = SSZ.isValidMerkleBranch(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteeBranch,\n                NEXT_SYNC_COMMITTEE_INDEX,\n                update.attestedHeader.stateRoot\n            );\n            require(isValidSyncCommitteeProof, \"bad next sync committee proof\");\n            bool isValidCommitteeRootMappingProof = zkVerifier.verifySyncCommitteeRootMappingProof(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteePoseidonRoot,\n                update.nextSyncCommitteeRootMappingProof\n            );\n            require(isValidCommitteeRootMappingProof, \"bad next sync committee root mapping proof\");\n        }\n\n        // Verify sync committee signature ZK proof\n        bytes4 forkVersion = computeForkVersion(computeEpochAtSlot(update.signatureSlot));\n        bytes32 domain = computeDomain(forkVersion);\n        bytes32 signingRoot = computeSigningRoot(update.attestedHeader, domain);\n        bytes32 activeSyncCommitteePoseidonRoot;\n        if (updatePeriod == storePeriod) {\n            require(currentSyncCommitteePoseidonRoot == update.syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = currentSyncCommitteePoseidonRoot;\n        } else if (updatePeriod == storePeriod + 1) {\n            require(nextSyncCommitteePoseidonRoot == update.syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n        }\n        require(\n            zkVerifier.verifySignatureProof(\n                signingRoot,\n                activeSyncCommitteePoseidonRoot,\n                update.syncAggregate.participation,\n                update.syncAggregate.commitment,\n                update.syncAggregate.proof\n            ),\n            \"bad bls sig proof\"\n        );\n    }\n\n    function applyLightClientUpdate(LightClientUpdate memory update) private {\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedHeader.slot);\n        uint64 updateFinalizedPeriod = computeSyncCommitteePeriodAtSlot(update.finalizedHeader.slot);\n        if (nextSyncCommitteeRoot == bytes32(0)) {\n            require(updateFinalizedPeriod == storePeriod, \"mismatch period\");\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        } else if (updateFinalizedPeriod == storePeriod + 1) {\n            currentSyncCommitteeRoot = nextSyncCommitteeRoot;\n            currentSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        }\n        if (update.finalizedHeader.slot > finalizedHeader.slot) {\n            finalizedHeader = update.finalizedHeader;\n            if (update.finalizedExecutionStateRoot != bytes32(0)) {\n                finalizedExecutionStateRoot = update.finalizedExecutionStateRoot;\n                finalizedExecutionStateRootSlot = update.finalizedHeader.slot;\n            }\n            emit HeaderUpdated(\n                update.finalizedHeader.slot,\n                update.finalizedHeader.stateRoot,\n                update.finalizedExecutionStateRoot,\n                true\n            );\n        }\n    }\n\n    /*\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#is_better_update\n     */\n    function isBetterUpdate(\n        LightClientUpdate memory newUpdate,\n        LightClientUpdate memory oldUpdate\n    ) private pure returns (bool) {\n        // Old update doesn't exist\n        if (oldUpdate.syncAggregate.participation == 0) {\n            return newUpdate.syncAggregate.participation > 0;\n        }\n\n        // Compare supermajority (> 2/3) sync committee participation\n        bool newHasSupermajority = hasSupermajority(newUpdate.syncAggregate.participation);\n        bool oldHasSupermajority = hasSupermajority(oldUpdate.syncAggregate.participation);\n        if (newHasSupermajority != oldHasSupermajority) {\n            // the new update is a better one if new has supermajority but old doesn't\n            return newHasSupermajority && !oldHasSupermajority;\n        }\n        if (!newHasSupermajority && newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            // a better update is the one with higher participation when both new and old doesn't have supermajority\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Compare presence of relevant sync committee\n        bool newHasSyncCommittee = hasRelavantSyncCommittee(newUpdate);\n        bool oldHasSyncCommittee = hasRelavantSyncCommittee(oldUpdate);\n        if (newHasSyncCommittee != oldHasSyncCommittee) {\n            return newHasSyncCommittee;\n        }\n\n        // Compare indication of any fin\n        bool newHasFinality = hasFinalityProof(newUpdate);\n        bool oldHasFinality = hasFinalityProof(oldUpdate);\n        if (newHasFinality != oldHasFinality) {\n            return newHasFinality;\n        }\n\n        // Compare sync committee fin\n        if (newHasFinality) {\n            bool newHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(newUpdate.finalizedHeader.slot) ==\n                computeSyncCommitteePeriodAtSlot(newUpdate.attestedHeader.slot);\n            bool oldHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(oldUpdate.finalizedHeader.slot) ==\n                computeSyncCommitteePeriodAtSlot(oldUpdate.attestedHeader.slot);\n            if (newHasCommitteeFinality != oldHasCommitteeFinality) {\n                return newHasCommitteeFinality;\n            }\n        }\n\n        // Tiebreaker 1: Sync committee participation beyond supermajority\n        if (newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Tiebreaker 2: Prefer older data (fewer changes to best)\n        if (newUpdate.attestedHeader.slot != oldUpdate.attestedHeader.slot) {\n            return newUpdate.attestedHeader.slot < oldUpdate.attestedHeader.slot;\n        }\n\n        return newUpdate.signatureSlot < oldUpdate.signatureSlot;\n    }\n\n    function hasRelavantSyncCommittee(LightClientUpdate memory update) private pure returns (bool) {\n        return\n            hasNextSyncCommitteeProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.signatureSlot);\n    }\n\n    function hasNextSyncCommitteeProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.nextSyncCommitteeBranch.length > 0;\n    }\n\n    function hasFinalityProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.finalityBranch.length > 0;\n    }\n\n    function hasExecutionFinalityProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.finalizedExecutionStateRootBranch.length > 0;\n    }\n\n    function hasSupermajority(uint64 participation) private pure returns (bool) {\n        return participation * 3 >= SYNC_COMMITTEE_SIZE * 2;\n    }\n\n    function isEmptyHeader(BeaconBlockHeader memory header) private pure returns (bool) {\n        return header.stateRoot == bytes32(0);\n    }\n\n    function currentSlot() private view returns (uint64) {\n        return uint64((block.timestamp - GENESIS_TIME) / SLOT_LENGTH_SECONDS);\n    }\n\n    function computeForkVersion(uint64 epoch) private view returns (bytes4) {\n        for (uint256 i = forkVersions.length - 1; i >= 0; i--) {\n            if (epoch >= forkEpochs[i]) {\n                return forkVersions[i];\n            }\n        }\n        revert(\"fork versions not set\");\n    }\n\n    function computeSyncCommitteePeriodAtSlot(uint64 slot) private pure returns (uint64) {\n        return computeSyncCommitteePeriod(computeEpochAtSlot(slot));\n    }\n\n    function computeEpochAtSlot(uint64 slot) private pure returns (uint64) {\n        return slot / SLOTS_PER_EPOCH;\n    }\n\n    function computeSyncCommitteePeriod(uint64 epoch) private pure returns (uint64) {\n        return epoch / EPOCHS_PER_SYNC_COMMITTEE_PERIOD;\n    }\n\n    /**\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_domain\n     */\n    function computeDomain(bytes4 forkVersion) public view returns (bytes32) {\n        return DOMAIN_SYNC_COMMITTEE | (sha256(abi.encode(forkVersion, GENESIS_VALIDATOR_ROOT)) >> 32);\n    }\n\n    // computeDomain(forkVersion, genesisValidatorsRoot)\n    function computeSigningRoot(BeaconBlockHeader memory header, bytes32 domain) public pure returns (bytes32) {\n        return sha256(bytes.concat(SSZ.hashTreeRoot(header), domain));\n    }\n}\n"
    },
    "contracts/light-client/IZkVerifier.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\n\ninterface IZkVerifier {\n    function verifySignatureProof(\n        bytes32 signingRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        uint256 participation,\n        uint256 commitment,\n        Proof memory p\n    ) external view returns (bool);\n\n    function verifySyncCommitteeRootMappingProof(\n        bytes32 sszRoot,\n        bytes32 poseidonRoot,\n        Proof memory p\n    ) external view returns (bool);\n}\n"
    },
    "contracts/light-client/LightClientStore.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\nimport \"./IZkVerifier.sol\";\n\nabstract contract LightClientStore {\n    // beacon chain genesis information\n    uint256 immutable GENESIS_TIME;\n    bytes32 immutable GENESIS_VALIDATOR_ROOT;\n\n    // light client store\n    BeaconBlockHeader public finalizedHeader;\n    bytes32 public finalizedExecutionStateRoot;\n    uint64 public finalizedExecutionStateRootSlot;\n\n    bytes32 public currentSyncCommitteeRoot;\n    bytes32 public currentSyncCommitteePoseidonRoot;\n    bytes32 public nextSyncCommitteeRoot;\n    bytes32 public nextSyncCommitteePoseidonRoot;\n\n    LightClientUpdate public bestValidUpdate;\n\n    // fork versions\n    uint64[] public forkEpochs;\n    bytes4[] public forkVersions;\n\n    // zk verifier\n    IZkVerifier public zkVerifier; // contract too big. need to move this one out\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        BeaconBlockHeader memory _finalizedHeader,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    ) {\n        GENESIS_TIME = genesisTime;\n        GENESIS_VALIDATOR_ROOT = genesisValidatorsRoot;\n        forkEpochs = _forkEpochs;\n        forkVersions = _forkVersions;\n        finalizedHeader = _finalizedHeader;\n        currentSyncCommitteeRoot = syncCommitteeRoot;\n        currentSyncCommitteePoseidonRoot = syncCommitteePoseidonRoot;\n        zkVerifier = IZkVerifier(_zkVerifier);\n    }\n}\n"
    },
    "contracts/light-client/SSZ.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\n\nlibrary SSZ {\n    function isValidMerkleBranch(\n        bytes32 leaf,\n        bytes32[] memory branch,\n        uint256 index,\n        bytes32 root\n    ) internal pure returns (bool) {\n        bytes32 restoredMerkleRoot = restoreMerkleRoot(leaf, branch, index);\n        return root == restoredMerkleRoot;\n    }\n\n    function restoreMerkleRoot(bytes32 leaf, bytes32[] memory branch, uint256 index) internal pure returns (bytes32) {\n        bytes32 value = leaf;\n        for (uint256 i = 0; i < branch.length; i++) {\n            if ((index / (2 ** i)) % 2 == 1) {\n                value = sha256(bytes.concat(branch[i], value));\n            } else {\n                value = sha256(bytes.concat(value, branch[i]));\n            }\n        }\n        return value;\n    }\n\n    function hashTreeRoot(BeaconBlockHeader memory header) internal pure returns (bytes32) {\n        bytes32 left = sha256(\n            bytes.concat(\n                sha256(bytes.concat(toLittleEndian(header.slot), toLittleEndian(header.proposerIndex))),\n                sha256(bytes.concat(header.parentRoot, header.stateRoot))\n            )\n        );\n        bytes32 right = sha256(\n            bytes.concat(\n                sha256(bytes.concat(header.bodyRoot, bytes32(0))),\n                sha256(bytes.concat(bytes32(0), bytes32(0)))\n            )\n        );\n        return sha256(bytes.concat(left, right));\n    }\n\n    function toLittleEndian(uint256 x) internal pure returns (bytes32) {\n        bytes32 res;\n        for (uint256 i = 0; i < 32; i++) {\n            res = (res << 8) | bytes32(x & 0xff);\n            x >>= 8;\n        }\n        return res;\n    }\n}\n"
    },
    "contracts/light-client/Types.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nstruct BeaconBlockHeader {\n    uint64 slot;\n    uint64 proposerIndex;\n    bytes32 parentRoot;\n    bytes32 stateRoot;\n    bytes32 bodyRoot;\n}\n\nstruct LightClientUpdate {\n    // Header attested to by the sync committee\n    BeaconBlockHeader attestedHeader;\n    // Finalized header corresponding to `attested_header.state_root`\n    BeaconBlockHeader finalizedHeader;\n    bytes32[] finalityBranch;\n    bytes32 finalizedExecutionStateRoot;\n    bytes32[] finalizedExecutionStateRootBranch;\n    bytes32 optimisticExecutionStateRoot;\n    bytes32[] optimisticExecutionStateRootBranch;\n    bytes32 nextSyncCommitteeRoot;\n    bytes32[] nextSyncCommitteeBranch;\n    bytes32 nextSyncCommitteePoseidonRoot;\n    Proof nextSyncCommitteeRootMappingProof;\n    // Sync committee aggregate signature participation & zk proof\n    SyncAggregate syncAggregate;\n    // Slot at which the aggregate signature was created (untrusted)\n    uint64 signatureSlot;\n}\n\nstruct SyncAggregate {\n    uint64 participation;\n    bytes32 poseidonRoot;\n    uint256 commitment;\n    Proof proof;\n}\n\nstruct Proof {\n    uint256[2] a;\n    uint256[2][2] b;\n    uint256[2] c;\n    uint256[2] commitment;\n}\n"
    },
    "contracts/light-client/verifier/BlsSigVerifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nimport \"./Pairing.sol\";\nimport \"./Constants.sol\";\nimport \"./Common.sol\";\n\ncontract BlsSigVerifier {\n    using Pairing for *;\n\n    function verifyingKey() internal pure returns (Common.VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(21869404648590355938070204738007299921184879677994422527706836467860465229555),\n            uint256(13498271808119839955057715147407595718888788089303053071109523938531313129416)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(7054962807852101821777521907353900534536574912206623342548135225636684065633),\n                uint256(4719416372386397569789716378331929165562736304329438825528404248445356317544)\n            ],\n            [\n                uint256(13169505134780753056527210184700054053183554009975495323937739848223108944491),\n                uint256(13592098286878802627104334887812977484641971308142750321766707760557234071693)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(11095415866555931179835746321035950972580128700079993342944687987088771893970),\n                uint256(7608157602633458693059833022944239778069565713137388978977277542137468568611)\n            ],\n            [\n                uint256(7401180895810745229430756020474788835440387402515164454484661092797156083108),\n                uint256(5065358031358114712449190279086624673751222971320486961839316362446988673960)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(2222475616788908183739316851660307727267648260775064003405822118215303226516),\n                uint256(6757963293650080478631547193181808365039329301693745170213066300772412893432)\n            ],\n            [\n                uint256(16109832433313432721291101899523165130162303404627529133543410010343809968099),\n                uint256(10657128623625091271138067059727783952095522932162725865057316893805238179881)\n            ]\n        );\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyBlsSigProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[35] memory input\n    ) public view returns (bool r) {\n        Common.Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        Common.VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(6164202379403353093337803285728957014471789019875115975131401894724388184318); // vk.K[0].X\n        vk_x.Y = uint256(14653739865386807698202111307501669964169649892515646451656712652300441924746); // vk.K[0].Y\n        mul_input[0] = uint256(21624815114078889503955414395662096302081445496963466787344578976263660902728); // vk.K[1].X\n        mul_input[1] = uint256(11975795059976038387412140269866198306105499844184502711829412068023274602635); // vk.K[1].Y\n        mul_input[2] = input[0];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(9775291361201569299414467699407168277620212957980866255045879806029778744670); // vk.K[2].X\n        mul_input[1] = uint256(17233924503171010558175232794027883068335710383496735149565234989213088796768); // vk.K[2].Y\n        mul_input[2] = input[1];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(8261354145794168978236113350349424817333204461878829563010649753110739562635); // vk.K[3].X\n        mul_input[1] = uint256(228648003771409636961945287326030341918541270047335109757141629333782275554); // vk.K[3].Y\n        mul_input[2] = input[2];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(17152002075022784984752660010686481854578129701150390242442680875098241592838); // vk.K[4].X\n        mul_input[1] = uint256(11918344010421497075133630718996356084858247140809583870914170975825762239902); // vk.K[4].Y\n        mul_input[2] = input[3];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(6724640989773315527339379483030265695332390420189583344806142015699008773038); // vk.K[5].X\n        mul_input[1] = uint256(861669679975036023917296038423011939661116903611653803520085082890905199789); // vk.K[5].Y\n        mul_input[2] = input[4];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(14251387140848206404864695272174413529185588726241264808479413090259577951538); // vk.K[6].X\n        mul_input[1] = uint256(4877123074037160235642133175015361159040197060194606461929469075209090452909); // vk.K[6].Y\n        mul_input[2] = input[5];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(20478957346453652200579299273452777262775946284794283970558676720582194409443); // vk.K[7].X\n        mul_input[1] = uint256(13820772652701693231224118191632029591356297457861304887694791784009996804692); // vk.K[7].Y\n        mul_input[2] = input[6];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(9234465648938974703786224967061256507261169398685469391550057760202443899331); // vk.K[8].X\n        mul_input[1] = uint256(13214614408686260510380993851179383149022140264065385584700637692530775154803); // vk.K[8].Y\n        mul_input[2] = input[7];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(8322398570000964255587165898643030029017010777972305270331988207302834192671); // vk.K[9].X\n        mul_input[1] = uint256(2792163176420440857016104913456882943905817335378546111765666996712066935576); // vk.K[9].Y\n        mul_input[2] = input[8];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        mul_input[0] = uint256(15797084070376204854261757656819325712271250278301568410976291761898112633721); // vk.K[10].X\n        mul_input[1] = uint256(16921845299282876706614570130523339313885521170603933721890067977426560293948); // vk.K[10].Y\n        mul_input[2] = input[9];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[10] * input[9]\n        mul_input[0] = uint256(406216972217762516055114890594086577323982284148453070046117814489609787072); // vk.K[11].X\n        mul_input[1] = uint256(19680277307775257363705979553150354779381952871529724380294836363819544498123); // vk.K[11].Y\n        mul_input[2] = input[10];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[11] * input[10]\n        mul_input[0] = uint256(12525306314981123491352345009709438907206215415831226491632499998999204127459); // vk.K[12].X\n        mul_input[1] = uint256(1658709794415567495634480941878933577381576154054415708255836274811180964933); // vk.K[12].Y\n        mul_input[2] = input[11];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[12] * input[11]\n        mul_input[0] = uint256(243194178389731910341565843545971823670153019065524768068260919793967722188); // vk.K[13].X\n        mul_input[1] = uint256(1539016065323199244386584217201350236710807235938447628544504644138676080000); // vk.K[13].Y\n        mul_input[2] = input[12];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[13] * input[12]\n        mul_input[0] = uint256(9275972589095639516678595044389709393960973430061520882565539743422692685960); // vk.K[14].X\n        mul_input[1] = uint256(4472610206252234523359317365636135395350815197903460649733786399406367486575); // vk.K[14].Y\n        mul_input[2] = input[13];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[14] * input[13]\n        mul_input[0] = uint256(1604039017774374075569025682010500744317749653925017699242881946260024023542); // vk.K[15].X\n        mul_input[1] = uint256(9410905005395438689346852685696727671986553838639094357993770247718588779274); // vk.K[15].Y\n        mul_input[2] = input[14];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[15] * input[14]\n        mul_input[0] = uint256(5467079506302237253715880360217400787071012184171130827989740479628417662627); // vk.K[16].X\n        mul_input[1] = uint256(5224193576447153852009901997143890474156655585587640006673196987947931700778); // vk.K[16].Y\n        mul_input[2] = input[15];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[16] * input[15]\n        mul_input[0] = uint256(9387444906146485207075936664808214655500107570142417551032840004938425984101); // vk.K[17].X\n        mul_input[1] = uint256(590813342019945519768071606508477036322091281941727992935444194199808517685); // vk.K[17].Y\n        mul_input[2] = input[16];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[17] * input[16]\n        mul_input[0] = uint256(19041927819469860627785730717901058973852083133163312846046958804599105964228); // vk.K[18].X\n        mul_input[1] = uint256(8145703607669957376931460933689362105951308370224326599319773750727102492008); // vk.K[18].Y\n        mul_input[2] = input[17];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[18] * input[17]\n        mul_input[0] = uint256(14204777538249598371293791017226113964614885045747036692434310643177244084169); // vk.K[19].X\n        mul_input[1] = uint256(19991551163786857983848828955926174440512514907619539468704022616567132258153); // vk.K[19].Y\n        mul_input[2] = input[18];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[19] * input[18]\n        mul_input[0] = uint256(12417075001679265443105210537412885798344552810848770848740273623901433226365); // vk.K[20].X\n        mul_input[1] = uint256(15254102101044498161161923790765048216173887701468938517549705046497697348129); // vk.K[20].Y\n        mul_input[2] = input[19];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[20] * input[19]\n        mul_input[0] = uint256(10269550220001463320881104580554222531390353399943986353550597742767825203938); // vk.K[21].X\n        mul_input[1] = uint256(3029115017209685411907558073483483867359830128318261715424531870119465329684); // vk.K[21].Y\n        mul_input[2] = input[20];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[21] * input[20]\n        mul_input[0] = uint256(14428083165341078925702200873211485650187256256509974692495884984971265925464); // vk.K[22].X\n        mul_input[1] = uint256(15475503186436372842471391388091832734881597469954031845230603258731548786526); // vk.K[22].Y\n        mul_input[2] = input[21];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[22] * input[21]\n        mul_input[0] = uint256(21628050343072376849090277477176470142622908553816436115710816402067062636840); // vk.K[23].X\n        mul_input[1] = uint256(7029190031936503335713201259562887395453755842232447142827705567066954030015); // vk.K[23].Y\n        mul_input[2] = input[22];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[23] * input[22]\n        mul_input[0] = uint256(18110637118732954586253866494394595281955623057396063638731715904832753062595); // vk.K[24].X\n        mul_input[1] = uint256(10041565796468001571466611556015291077335046776933681659744217988421358102715); // vk.K[24].Y\n        mul_input[2] = input[23];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[24] * input[23]\n        mul_input[0] = uint256(4394594477670212487624118222291685582484342594449655582983945008137107825); // vk.K[25].X\n        mul_input[1] = uint256(12907667141942256119052629834176444916095324468551648766101314800519980891911); // vk.K[25].Y\n        mul_input[2] = input[24];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[25] * input[24]\n        mul_input[0] = uint256(12264813020217849970868777479799238229912660701320711442659475763187093184540); // vk.K[26].X\n        mul_input[1] = uint256(5418405552541349472839540236004659645077530645792067120765938377537697612686); // vk.K[26].Y\n        mul_input[2] = input[25];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[26] * input[25]\n        mul_input[0] = uint256(511205244113194326604079314682967281483973984567702129900795395158408587823); // vk.K[27].X\n        mul_input[1] = uint256(13182904816261728693468832675109011780365501025377828890958755203977021114190); // vk.K[27].Y\n        mul_input[2] = input[26];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[27] * input[26]\n        mul_input[0] = uint256(7745322370569289256054483431857334835907602968150216319025615839493340926445); // vk.K[28].X\n        mul_input[1] = uint256(802527185108559510753348953543835956246583756974633024055374364959752960622); // vk.K[28].Y\n        mul_input[2] = input[27];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[28] * input[27]\n        mul_input[0] = uint256(6443616155328954964370112634631799535966126116548305083954877582628003863726); // vk.K[29].X\n        mul_input[1] = uint256(6748022417080637760377192763249012207074862674787085243054196391894862853769); // vk.K[29].Y\n        mul_input[2] = input[28];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[29] * input[28]\n        mul_input[0] = uint256(4746053807226732815609107613694422909828283203346089197433464043542316944158); // vk.K[30].X\n        mul_input[1] = uint256(568459565911058268471985303141965010407745186442811181897604717750346101795); // vk.K[30].Y\n        mul_input[2] = input[29];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[30] * input[29]\n        mul_input[0] = uint256(6867388841298402377650181552003032287359815924707163591172560189355289362811); // vk.K[31].X\n        mul_input[1] = uint256(12681153196280456072370427543675941721359193477428355329469521843056250842522); // vk.K[31].Y\n        mul_input[2] = input[30];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[31] * input[30]\n        mul_input[0] = uint256(11834855045548628237299252472287217659541095251983817826749302275066363050032); // vk.K[32].X\n        mul_input[1] = uint256(10549551457031005862882545350575007326729695512101543170018470906439946899475); // vk.K[32].Y\n        mul_input[2] = input[31];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[32] * input[31]\n        mul_input[0] = uint256(21080571058062105169480371434944542317741872583578405624882037076932528614624); // vk.K[33].X\n        mul_input[1] = uint256(11386667982944779644843347272450639356560600194842785817671488724791644458315); // vk.K[33].Y\n        mul_input[2] = input[32];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[33] * input[32]\n        mul_input[0] = uint256(8323118186735247530367920845955364944904052300793452286806441510422146880773); // vk.K[34].X\n        mul_input[1] = uint256(7046818066858629220640333055452104424201007141089175803564675939513429614352); // vk.K[34].Y\n        mul_input[2] = input[33];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[34] * input[33]\n        mul_input[0] = uint256(12620149755261046671755404694759801128385638190500539207079026239458336064522); // vk.K[35].X\n        mul_input[1] = uint256(10994846953135033560648325534438412658436366579529892185303274351838980685981); // vk.K[35].Y\n        mul_input[2] = input[34];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[35] * input[34]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/light-client/verifier/CommitteeRootMappingVerifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nimport \"./Pairing.sol\";\nimport \"./Constants.sol\";\nimport \"./Common.sol\";\n\ncontract CommitteeRootMappingVerifier {\n    using Pairing for *;\n\n    function verifyingKey1() private pure returns (Common.VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(4625995678875839184227102343980957941553435037863367632170514069470978075482),\n            uint256(7745472346822620166365670179252096531675980956628675937691452644416704349631)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(16133906051290029359415836500687237322258320219528941728637152470582101797559),\n                uint256(9982592290591904397750372202184781412509742437847499064025507928193374812763)\n            ],\n            [\n                uint256(20447084996628162496147084243623314997274147610235538549283479856317752366847),\n                uint256(10652060452474388359080900509291122865897396777233890537481945528644944582649)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(14205774305928561884273671177098614973303096843515928049981466843882075090453),\n                uint256(6194647019556442694746623566240152360142526955447025858054760757353994166695)\n            ],\n            [\n                uint256(720177741655577944140882804072173464461234581005085937938128202222496044348),\n                uint256(15180859461535417805311870856102250988010112023636345871703449475067945282517)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(2075341858515413383107490988194322113274273165071779395977011288835607214232),\n                uint256(21779842329350845285414688998042134519611654255235365675696046856282966715158)\n            ],\n            [\n                uint256(4310903133868833376693610009744123646701594778591654462646551313203044329349),\n                uint256(8934039419334185533732134671857943150009456594043165319933471646801466475060)\n            ]\n        );\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyCommitteeRootMappingProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[33] memory input\n    ) public view returns (bool r) {\n        Common.Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        Common.VerifyingKey memory vk = verifyingKey1();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(20552480178503420105472757749758256930777503163697981232418248899738739436302); // vk.K[0].X\n        vk_x.Y = uint256(21874644052683447189335205444383300629386926406593895540736254865290692175330); // vk.K[0].Y\n        mul_input[0] = uint256(2419465434811246925970456918943785845329721675292263546063218305166868830301); // vk.K[1].X\n        mul_input[1] = uint256(224414837900933448241244127409926533084118787014653569685139207760162770563); // vk.K[1].Y\n        mul_input[2] = input[0];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(20237582094031100903111658800543003981446659818658320070287593450545147260932); // vk.K[2].X\n        mul_input[1] = uint256(9498936270692258262448475366106441134297508170417707117017418182506243810929); // vk.K[2].Y\n        mul_input[2] = input[1];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(21686431407509598771022896245105442713057757617842882639916055310118549735455); // vk.K[3].X\n        mul_input[1] = uint256(18587475580363988870337779644366478839186363821430368900189877147428300473925); // vk.K[3].Y\n        mul_input[2] = input[2];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(4190323520659374373641761976155873288531237902311450285189695279890286046705); // vk.K[4].X\n        mul_input[1] = uint256(8044837422277408304807431419004307582225876792722238390231063677200212676904); // vk.K[4].Y\n        mul_input[2] = input[3];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(2652622379392044318082038991710242104342228971779836360052332572087628421201); // vk.K[5].X\n        mul_input[1] = uint256(406860223885500452975843681654102213552218004006375181643914225581644355831); // vk.K[5].Y\n        mul_input[2] = input[4];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(6057918943482398019697118579402810827270820344972408585195554580949838772589); // vk.K[6].X\n        mul_input[1] = uint256(5060377211716517826689871487122513539243478809827924728351043431363438746264); // vk.K[6].Y\n        mul_input[2] = input[5];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(3687702938753468537462497928786246235243684882237823906440956320376037461563); // vk.K[7].X\n        mul_input[1] = uint256(1208686206265801496727901652555022795816232879429721718984614404615694111083); // vk.K[7].Y\n        mul_input[2] = input[6];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(11710614008104008246282861623202747769385618500144669344475214097509828684593); // vk.K[8].X\n        mul_input[1] = uint256(5065836875015911503963590142184023993405575153173968399414211124081308802733); // vk.K[8].Y\n        mul_input[2] = input[7];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(544404787870686540959136485911507545335221912755631162384362056307403363961); // vk.K[9].X\n        mul_input[1] = uint256(2345869893991024974950769006226913293849021455623995373213361343160988457751); // vk.K[9].Y\n        mul_input[2] = input[8];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        mul_input[0] = uint256(2209389364146280288951908471817129375141759543141552284740145921306411049406); // vk.K[10].X\n        mul_input[1] = uint256(9042259349973012497614444570261244747029883119587798835387806797437998198439); // vk.K[10].Y\n        mul_input[2] = input[9];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[10] * input[9]\n        mul_input[0] = uint256(5329749415213215279150815169017002879660981652478899879932293459107956198272); // vk.K[11].X\n        mul_input[1] = uint256(1269241490245981774317800992176787362067828005821041854984670483140659381972); // vk.K[11].Y\n        mul_input[2] = input[10];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[11] * input[10]\n        mul_input[0] = uint256(4943793813361186613838184379271444100858893499387902057809188182513783485846); // vk.K[12].X\n        mul_input[1] = uint256(9275690329715777324103642003412034648418070562981699307031172873365106078545); // vk.K[12].Y\n        mul_input[2] = input[11];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[12] * input[11]\n        mul_input[0] = uint256(12729498268013982038852548044563174517696421517428254680176367740849220266709); // vk.K[13].X\n        mul_input[1] = uint256(7546589572574852665535613703939452808321148398493753492131740521875420626909); // vk.K[13].Y\n        mul_input[2] = input[12];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[13] * input[12]\n        mul_input[0] = uint256(9333085734209829031122997463964247926338222396225058317742956090059153031592); // vk.K[14].X\n        mul_input[1] = uint256(4043123151744068929699760825751364162242644369436915556155534564396462636465); // vk.K[14].Y\n        mul_input[2] = input[13];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[14] * input[13]\n        mul_input[0] = uint256(3698686717106590496650986585007797659650605418055308742433506982460764492730); // vk.K[15].X\n        mul_input[1] = uint256(9179617523334761636265229485895993306228474412981061346064728177636515751968); // vk.K[15].Y\n        mul_input[2] = input[14];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[15] * input[14]\n        mul_input[0] = uint256(15521850592660810728436432508964964041834382081916421935161893482249902884387); // vk.K[16].X\n        mul_input[1] = uint256(5449901017503560405242500659614777785834634841695450826672263537767974100219); // vk.K[16].Y\n        mul_input[2] = input[15];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[16] * input[15]\n        mul_input[0] = uint256(20102906107256118088436001377164222872704427733042089123636772674622559816716); // vk.K[17].X\n        mul_input[1] = uint256(12498854682789208487185327670228889940757953195079617884138082484806034246784); // vk.K[17].Y\n        mul_input[2] = input[16];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[17] * input[16]\n        mul_input[0] = uint256(9455841695606475800176819517076441035373288808813491909032241063291148788930); // vk.K[18].X\n        mul_input[1] = uint256(5760837211388967374979882368837632355372021503182733102840122488409476353553); // vk.K[18].Y\n        mul_input[2] = input[17];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[18] * input[17]\n        mul_input[0] = uint256(1446991383552871512734012954692326283314249519870143612600792757960520781278); // vk.K[19].X\n        mul_input[1] = uint256(9834470268591454131741863361237282178002203711883219940241340793939995038767); // vk.K[19].Y\n        mul_input[2] = input[18];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[19] * input[18]\n        mul_input[0] = uint256(1059357485615144832413353841149751938707953460935522780194084907196702253731); // vk.K[20].X\n        mul_input[1] = uint256(10815569476482003993766770423385630209543201328293985898718647153832884016017); // vk.K[20].Y\n        mul_input[2] = input[19];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[20] * input[19]\n        mul_input[0] = uint256(7433245970798099608332042376067563625513377267096206052430761000239299269566); // vk.K[21].X\n        mul_input[1] = uint256(12741834193487831964894419250386047831198155854304448707022734193570700410821); // vk.K[21].Y\n        mul_input[2] = input[20];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[21] * input[20]\n        mul_input[0] = uint256(8648224634225961431530490440075030243542463588893169022877288417966438069777); // vk.K[22].X\n        mul_input[1] = uint256(16540610842070555034877322476339116325277917786072762919274678110762172365508); // vk.K[22].Y\n        mul_input[2] = input[21];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[22] * input[21]\n        mul_input[0] = uint256(16908648218709781420138074614673957046034248547088691701260866141074824824919); // vk.K[23].X\n        mul_input[1] = uint256(20980273428957053574278769661356962533672481733183512384951407225298181139010); // vk.K[23].Y\n        mul_input[2] = input[22];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[23] * input[22]\n        mul_input[0] = uint256(20934252423600973663175987808002009495824217352345209099319606411155218995932); // vk.K[24].X\n        mul_input[1] = uint256(9987927206019920292163635872827487165514620975045002130414615160938718715749); // vk.K[24].Y\n        mul_input[2] = input[23];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[24] * input[23]\n        mul_input[0] = uint256(9602737041922572073213386264444643405537681976425696147506639312256088109115); // vk.K[25].X\n        mul_input[1] = uint256(5030838233095700558123674330813925820525997306253984515590208165812087573689); // vk.K[25].Y\n        mul_input[2] = input[24];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[25] * input[24]\n        mul_input[0] = uint256(20088832978375886523413495106079569725269630343909328763686584839952109161933); // vk.K[26].X\n        mul_input[1] = uint256(8311397503596416021728705867174781915782892850820869993294450806608979293432); // vk.K[26].Y\n        mul_input[2] = input[25];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[26] * input[25]\n        mul_input[0] = uint256(15729968276421379987872047780863974781795109674620595131198333451598870913212); // vk.K[27].X\n        mul_input[1] = uint256(11755585053459843437112320638816029546922021127794137048950074210155862560131); // vk.K[27].Y\n        mul_input[2] = input[26];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[27] * input[26]\n        mul_input[0] = uint256(5783930197610380391486193680213891260111080319012345925622032738683845648623); // vk.K[28].X\n        mul_input[1] = uint256(15914052883335873414184612431500787588848752068877353731383121390711998005745); // vk.K[28].Y\n        mul_input[2] = input[27];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[28] * input[27]\n        mul_input[0] = uint256(13576027419855184371737615151659181815220661446877879847199764825219880625500); // vk.K[29].X\n        mul_input[1] = uint256(2191728030944522062213775267825510142676636904535936426097088151735038661017); // vk.K[29].Y\n        mul_input[2] = input[28];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[29] * input[28]\n        mul_input[0] = uint256(17443744306907421274656073114832682866914815795994710278637727590770342132904); // vk.K[30].X\n        mul_input[1] = uint256(6204265850197846880732314988280474321915051365218910504902500465319260176648); // vk.K[30].Y\n        mul_input[2] = input[29];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[30] * input[29]\n        mul_input[0] = uint256(7667236600173703281656707827902729453577123223272717952708859478183847798002); // vk.K[31].X\n        mul_input[1] = uint256(3073364345901477288521870238026227645583520851820532416933060479253244595356); // vk.K[31].Y\n        mul_input[2] = input[30];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[31] * input[30]\n        mul_input[0] = uint256(9980877541970177898146397507672456369445448128646497326829193893755401659297); // vk.K[32].X\n        mul_input[1] = uint256(11845859001496825643147981605740249183632753870257747701403057774143489519069); // vk.K[32].Y\n        mul_input[2] = input[31];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[32] * input[31]\n        mul_input[0] = uint256(12453897189547283279636360437482740153245209912090247350145743599538029507132); // vk.K[33].X\n        mul_input[1] = uint256(6469937287375115226432040539121250021511388797917475330256634615436829876816); // vk.K[33].Y\n        mul_input[2] = input[32];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[33] * input[32]\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/light-client/verifier/Common.sol": {
      "content": "// SPDX-License-Identifier: AML\n\npragma solidity ^0.8.0;\n\nimport \"./Pairing.sol\";\n\nlibrary Common {\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n}\n"
    },
    "contracts/light-client/verifier/Constants.sol": {
      "content": "// SPDX-License-Identifier: AML\n\npragma solidity ^0.8.0;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n"
    },
    "contracts/light-client/verifier/Pairing.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nlibrary Pairing {\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n"
    },
    "contracts/light-client/verifier/ZkVerifier.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"../Types.sol\";\nimport \"./BlsSigVerifier.sol\";\nimport \"./CommitteeRootMappingVerifier.sol\";\n\ncontract ZkVerifier is BlsSigVerifier, CommitteeRootMappingVerifier {\n    function verifySignatureProof(\n        bytes32 signingRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        uint256 participation,\n        uint256 commitment,\n        Proof memory p\n    ) public view returns (bool) {\n        uint256[35] memory input;\n        uint256 root = uint256(signingRoot);\n        // slice the signing root into 32 individual bytes and assign them in order to the first 32 slots of input[]\n        for (uint256 i = 0; i < 32; i++) {\n            input[(32 - 1 - i)] = root % 256;\n            root = root / 256;\n        }\n        input[32] = participation;\n        input[33] = uint256(syncCommitteePoseidonRoot);\n        input[34] = commitment;\n        return verifyBlsSigProof(p.a, p.b, p.c, p.commitment, input);\n    }\n\n    function verifySyncCommitteeRootMappingProof(\n        bytes32 sszRoot,\n        bytes32 poseidonRoot,\n        Proof memory p\n    ) public view returns (bool) {\n        uint256[33] memory input;\n        uint256 root = uint256(sszRoot);\n        for (uint256 i = 0; i < 32; i++) {\n            input[(32 - 1 - i)] = root % 256;\n            root = root / 256;\n        }\n        input[32] = uint256(poseidonRoot);\n        return verifyCommitteeRootMappingProof(p.a, p.b, p.c, input);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}