{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/BSCValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./System.sol\";\nimport \"./lib/BytesToTypes.sol\";\nimport \"./lib/Memory.sol\";\nimport \"./interface/IApplication.sol\";\nimport \"./lib/RLPDecode.sol\";\nimport \"./lib/CmnPkg.sol\";\n\ncontract BSCValidatorSet is IApplication {\n    using RLPDecode for *;\n\n    uint8 public constant VALIDATORS_UPDATE_MESSAGE_TYPE = 0;\n\n    uint256 public constant EXPIRE_TIME_SECOND_GAP = 1000;\n    uint256 public constant MAX_NUM_OF_VALIDATORS = 41;\n\n    uint32 public constant ERROR_UNKNOWN_PACKAGE_TYPE = 101;\n    uint32 public constant ERROR_FAIL_CHECK_VALIDATORS = 102;\n    uint32 public constant ERROR_LEN_OF_VAL_MISMATCH = 103;\n\n    uint256 public constant INIT_NUM_OF_CABINETS = 21;\n    uint256 public constant EPOCH = 200;\n\n    /*********************** state of the contract **************************/\n    Validator[] public currentValidatorSet;\n    uint256 public expireTimeSecondGap;\n\n    System private system;\n\n    // key is the `consensusAddress` of `Validator`,\n    // value is the index of the element in `currentValidatorSet`.\n    mapping(address => uint256) public currentValidatorSetMap;\n\n    struct Validator {\n        address consensusAddress;\n        address payable feeAddress;\n        address BBCFeeAddress;\n        uint64 votingPower;\n        // only in state\n        bool jailed;\n        uint256 incoming;\n    }\n\n    /*********************** cross chain package **************************/\n    struct IbcValidatorSetPackage {\n        uint8 packageType;\n        Validator[] validatorSet;\n    }\n\n    /*********************** events **************************/\n    event ValidatorSetUpdated();\n    event UnexpectedPackage(uint8 channelId, bytes msgBytes);\n    event FailedWithReasonStr(string message);\n\n    /*********************** init **************************/\n    constructor(address _system, bytes memory _initValidatorSetBytes) {\n        (IbcValidatorSetPackage memory validatorSetPkg, bool valid) = decodeValidatorSetSynPackage(\n            _initValidatorSetBytes\n        );\n        require(valid, \"failed to parse init validatorSet\");\n        for (uint256 i; i < validatorSetPkg.validatorSet.length; ++i) {\n            currentValidatorSet.push(validatorSetPkg.validatorSet[i]);\n            currentValidatorSetMap[validatorSetPkg.validatorSet[i].consensusAddress] = i + 1;\n        }\n        expireTimeSecondGap = EXPIRE_TIME_SECOND_GAP;\n        system = System(_system);\n    }\n\n    /*********************** Cross Chain App Implement **************************/\n    function handleSynPackage(uint8, bytes calldata msgBytes) external override returns (bytes memory responsePayload) {\n        require(msg.sender == System(system).crossChain(), \"not cross chain contract\");\n\n        (IbcValidatorSetPackage memory validatorSetPackage, bool ok) = decodeValidatorSetSynPackage(msgBytes);\n        if (!ok) {\n            return CmnPkg.encodeCommonAckPackage(system.ERROR_FAIL_DECODE());\n        }\n        uint32 resCode;\n        if (validatorSetPackage.packageType == VALIDATORS_UPDATE_MESSAGE_TYPE) {\n            resCode = updateValidatorSet(validatorSetPackage.validatorSet);\n        } else {\n            resCode = ERROR_UNKNOWN_PACKAGE_TYPE;\n        }\n        if (resCode == system.CODE_OK()) {\n            return new bytes(0);\n        } else {\n            return CmnPkg.encodeCommonAckPackage(resCode);\n        }\n    }\n\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external override {\n        require(msg.sender == system.crossChain(), \"not cross chain contract\");\n\n        // should not happen\n        emit UnexpectedPackage(channelId, msgBytes);\n    }\n\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external override {\n        require(msg.sender == system.crossChain(), \"not cross chain contract\");\n\n        // should not happen\n        emit UnexpectedPackage(channelId, msgBytes);\n    }\n\n    function updateValidatorSet(Validator[] memory validatorSet) internal returns (uint32) {\n        {\n            // do verify.\n            (bool valid, string memory errMsg) = checkValidatorSet(validatorSet);\n            if (!valid) {\n                emit FailedWithReasonStr(errMsg);\n                return ERROR_FAIL_CHECK_VALIDATORS;\n            }\n        }\n\n        // update validator set state\n        doUpdateState(validatorSet);\n\n        emit ValidatorSetUpdated();\n        return system.CODE_OK();\n    }\n\n    /*********************** Internal Functions **************************/\n\n    function checkValidatorSet(Validator[] memory validatorSet) private pure returns (bool, string memory) {\n        if (validatorSet.length > MAX_NUM_OF_VALIDATORS) {\n            return (false, \"the number of validators exceed the limit\");\n        }\n        for (uint256 i; i < validatorSet.length; ++i) {\n            for (uint256 j = 0; j < i; j++) {\n                if (validatorSet[i].consensusAddress == validatorSet[j].consensusAddress) {\n                    return (false, \"duplicate consensus address of validatorSet\");\n                }\n            }\n        }\n        return (true, \"\");\n    }\n\n    function doUpdateState(Validator[] memory validatorSet) private {\n        uint256 n = currentValidatorSet.length;\n        uint256 m = validatorSet.length;\n\n        for (uint256 i; i < n; ++i) {\n            bool stale = true;\n            Validator memory oldValidator = currentValidatorSet[i];\n            for (uint256 j = 0; j < m; j++) {\n                if (oldValidator.consensusAddress == validatorSet[j].consensusAddress) {\n                    stale = false;\n                    break;\n                }\n            }\n            if (stale) {\n                delete currentValidatorSetMap[oldValidator.consensusAddress];\n            }\n        }\n\n        if (n > m) {\n            for (uint256 i = m; i < n; ++i) {\n                currentValidatorSet.pop();\n            }\n        }\n        uint256 k = n < m ? n : m;\n        for (uint256 i; i < k; ++i) {\n            if (!isSameValidator(validatorSet[i], currentValidatorSet[i])) {\n                currentValidatorSetMap[validatorSet[i].consensusAddress] = i + 1;\n                currentValidatorSet[i] = validatorSet[i];\n            }\n        }\n    }\n\n    function isSameValidator(Validator memory v1, Validator memory v2) private pure returns (bool) {\n        return\n            v1.consensusAddress == v2.consensusAddress &&\n            v1.feeAddress == v2.feeAddress &&\n            v1.BBCFeeAddress == v2.BBCFeeAddress &&\n            v1.votingPower == v2.votingPower;\n    }\n\n    //rlp encode & decode function\n    function decodeValidatorSetSynPackage(bytes memory msgBytes)\n        internal\n        pure\n        returns (IbcValidatorSetPackage memory, bool)\n    {\n        IbcValidatorSetPackage memory validatorSetPkg;\n\n        RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                validatorSetPkg.packageType = uint8(iter.next().toUint());\n            } else if (idx == 1) {\n                RLPDecode.RLPItem[] memory items = iter.next().toList();\n                validatorSetPkg.validatorSet = new Validator[](items.length);\n                for (uint256 j; j < items.length; ++j) {\n                    (Validator memory val, bool ok) = decodeValidator(items[j]);\n                    if (!ok) {\n                        return (validatorSetPkg, false);\n                    }\n                    validatorSetPkg.validatorSet[j] = val;\n                }\n                success = true;\n            } else {\n                break;\n            }\n            idx++;\n        }\n        return (validatorSetPkg, success);\n    }\n\n    function decodeValidator(RLPDecode.RLPItem memory itemValidator) internal pure returns (Validator memory, bool) {\n        Validator memory validator;\n        RLPDecode.Iterator memory iter = itemValidator.iterator();\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                validator.consensusAddress = iter.next().toAddress();\n            } else if (idx == 1) {\n                validator.feeAddress = payable(iter.next().toAddress());\n            } else if (idx == 2) {\n                validator.BBCFeeAddress = iter.next().toAddress();\n            } else if (idx == 3) {\n                validator.votingPower = uint64(iter.next().toUint());\n                success = true;\n            } else {\n                break;\n            }\n            idx++;\n        }\n        return (validator, success);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/CrossChain.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./interface/IApplication.sol\";\nimport \"./interface/ICrossChain.sol\";\nimport \"./interface/ITendermintLightClient.sol\";\nimport \"./lib/Memory.sol\";\nimport \"./lib/MerkleProof.sol\";\nimport \"./lib/BytesToTypes.sol\";\nimport \"./System.sol\";\n\ncontract CrossChain is ICrossChain {\n    // constant variables\n    string public constant STORE_NAME = \"ibc\";\n    uint256 public constant CROSS_CHAIN_KEY_PREFIX = 0x01006000; // last 6 bytes\n    uint8 public constant SYN_PACKAGE = 0x00;\n    uint8 public constant ACK_PACKAGE = 0x01;\n    uint8 public constant FAIL_ACK_PACKAGE = 0x02;\n    uint256 public constant INIT_BATCH_SIZE = 50;\n\n    // governable parameters\n    uint256 public batchSizeForOracle;\n\n    //state variables\n    uint256 public previousTxHeight;\n    uint256 public txCounter;\n    int64 public oracleSequence;\n    mapping(uint8 => address) public channelHandlerContractMap;\n    mapping(address => mapping(uint8 => bool)) public registeredContractChannelMap;\n    mapping(uint8 => uint64) public channelSendSequenceMap;\n    mapping(uint8 => uint64) public channelReceiveSequenceMap;\n    System private system;\n\n    // event\n    event CrossChainPackage(\n        uint16 chainId,\n        uint64 indexed oracleSequence,\n        uint64 indexed packageSequence,\n        uint8 indexed channelId,\n        bytes payload\n    );\n    event ReceivedPackage(uint8 packageType, uint64 indexed packageSequence, uint8 indexed channelId);\n    event UnsupportedPackage(uint64 indexed packageSequence, uint8 indexed channelId, bytes payload);\n    event UnexpectedRevertInPackageHandler(address indexed contractAddr, string reason);\n    event UnexpectedFailureAssertionInPackageHandler(address indexed contractAddr, bytes lowLevelData);\n\n    modifier sequenceInOrder(uint64 _sequence, uint8 _channelID) {\n        uint64 expectedSequence = channelReceiveSequenceMap[_channelID];\n        require(_sequence == expectedSequence, \"sequence not in order\");\n\n        channelReceiveSequenceMap[_channelID] = expectedSequence + 1;\n        _;\n    }\n\n    modifier blockSynced(uint64 _height) {\n        require(\n            ITendermintLightClient(system.tmLightClient()).isHeaderSynced(_height),\n            \"light client not sync the block yet\"\n        );\n        _;\n    }\n\n    modifier channelSupported(uint8 _channelID) {\n        require(channelHandlerContractMap[_channelID] != address(0x0), \"channel is not supported\");\n        _;\n    }\n\n    modifier onlyRegisteredContractChannel(uint8 channleId) {\n        require(\n            registeredContractChannelMap[msg.sender][channleId],\n            \"the contract and channel have not been registered\"\n        );\n        _;\n    }\n\n    // | length   | prefix | sourceChainID| destinationChainID | channelID | sequence |\n    // | 32 bytes | 1 byte | 2 bytes      | 2 bytes            |  1 bytes  | 8 bytes  |\n    function generateKey(uint64 _sequence, uint8 _channelID) internal pure returns (bytes memory) {\n        uint256 fullCROSS_CHAIN_KEY_PREFIX = CROSS_CHAIN_KEY_PREFIX | _channelID;\n        bytes memory key = new bytes(14);\n\n        uint256 ptr;\n        assembly {\n            ptr := add(key, 14)\n        }\n        assembly {\n            mstore(ptr, _sequence)\n        }\n        ptr -= 8;\n        assembly {\n            mstore(ptr, fullCROSS_CHAIN_KEY_PREFIX)\n        }\n        ptr -= 6;\n        assembly {\n            mstore(ptr, 14)\n        }\n        return key;\n    }\n\n    constructor(address _system) {\n        system = System(_system);\n\n        channelHandlerContractMap[system.STAKING_CHANNEL_ID()] = system.bscValidatorSet();\n        registeredContractChannelMap[system.bscValidatorSet()][system.STAKING_CHANNEL_ID()] = true;\n\n        batchSizeForOracle = INIT_BATCH_SIZE;\n\n        oracleSequence = -1;\n        previousTxHeight = 0;\n        txCounter = 0;\n    }\n\n    function encodePayload(\n        uint8 packageType,\n        uint256 relayFee,\n        bytes memory msgBytes\n    ) public pure returns (bytes memory) {\n        uint256 payloadLength = msgBytes.length + 33;\n        bytes memory payload = new bytes(payloadLength);\n        uint256 ptr;\n        assembly {\n            ptr := payload\n        }\n        ptr += 33;\n\n        assembly {\n            mstore(ptr, relayFee)\n        }\n\n        ptr -= 32;\n        assembly {\n            mstore(ptr, packageType)\n        }\n\n        ptr -= 1;\n        assembly {\n            mstore(ptr, payloadLength)\n        }\n\n        ptr += 65;\n        (uint256 src, ) = Memory.fromBytes(msgBytes);\n        Memory.copy(src, ptr, msgBytes.length);\n\n        return payload;\n    }\n\n    // | type   | relayFee   |package  |\n    // | 1 byte | 32 bytes   | bytes    |\n    function decodePayloadHeader(bytes memory payload)\n        internal\n        pure\n        returns (\n            bool,\n            uint8,\n            uint256,\n            bytes memory\n        )\n    {\n        if (payload.length < 33) {\n            return (false, 0, 0, new bytes(0));\n        }\n\n        uint256 ptr;\n        assembly {\n            ptr := payload\n        }\n\n        uint8 packageType;\n        ptr += 1;\n        assembly {\n            packageType := mload(ptr)\n        }\n\n        uint256 relayFee;\n        ptr += 32;\n        assembly {\n            relayFee := mload(ptr)\n        }\n\n        ptr += 32;\n        bytes memory msgBytes = new bytes(payload.length - 33);\n        (uint256 dst, ) = Memory.fromBytes(msgBytes);\n        Memory.copy(ptr, dst, payload.length - 33);\n\n        return (true, packageType, relayFee, msgBytes);\n    }\n\n    function handlePackage(\n        bytes calldata payload,\n        bytes calldata proof,\n        uint64 height,\n        uint64 packageSequence,\n        uint8 channelId\n    ) external sequenceInOrder(packageSequence, channelId) blockSynced(height) channelSupported(channelId) {\n        require(msg.sender == system.relayer(), \"not relayer\");\n\n        bytes memory payloadLocal = payload; // fix error: stack too deep, try removing local variables\n        bytes memory proofLocal = proof; // fix error: stack too deep, try removing local variables\n        require(\n            MerkleProof.validateMerkleProof(\n                ITendermintLightClient(system.tmLightClient()).getAppHash(height),\n                STORE_NAME,\n                generateKey(packageSequence, channelId),\n                payloadLocal,\n                proofLocal\n            ),\n            \"invalid merkle proof\"\n        );\n\n        uint8 channelIdLocal = channelId; // fix error: stack too deep, try removing local variables\n        (bool success, uint8 packageType, , bytes memory msgBytes) = decodePayloadHeader(payloadLocal);\n        if (!success) {\n            emit UnsupportedPackage(packageSequence, channelIdLocal, payloadLocal);\n            return;\n        }\n        emit ReceivedPackage(packageType, packageSequence, channelIdLocal);\n        if (packageType == SYN_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleSynPackage(channelIdLocal, msgBytes) returns (\n                bytes memory responsePayload\n            ) {\n                if (responsePayload.length != 0) {\n                    sendPackage(\n                        channelSendSequenceMap[channelIdLocal],\n                        channelIdLocal,\n                        encodePayload(ACK_PACKAGE, 0, responsePayload)\n                    );\n                    channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                }\n            } catch Error(string memory reason) {\n                sendPackage(\n                    channelSendSequenceMap[channelIdLocal],\n                    channelIdLocal,\n                    encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n                );\n                channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                sendPackage(\n                    channelSendSequenceMap[channelIdLocal],\n                    channelIdLocal,\n                    encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n                );\n                channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        } else if (packageType == ACK_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleAckPackage(channelIdLocal, msgBytes) {} catch Error(\n                string memory reason\n            ) {\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        } else if (packageType == FAIL_ACK_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleFailAckPackage(channelIdLocal, msgBytes) {} catch Error(\n                string memory reason\n            ) {\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        }\n    }\n\n    function sendPackage(\n        uint64 packageSequence,\n        uint8 channelId,\n        bytes memory payload\n    ) internal {\n        if (block.number > previousTxHeight) {\n            oracleSequence++;\n            txCounter = 1;\n            previousTxHeight = block.number;\n        } else {\n            txCounter++;\n            if (txCounter > batchSizeForOracle) {\n                oracleSequence++;\n                txCounter = 1;\n            }\n        }\n        emit CrossChainPackage(system.bscChainID(), uint64(oracleSequence), packageSequence, channelId, payload);\n    }\n\n    function sendSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes,\n        uint256 relayFee\n    ) external override onlyRegisteredContractChannel(channelId) {\n        uint64 sendSequence = channelSendSequenceMap[channelId];\n        sendPackage(sendSequence, channelId, encodePayload(SYN_PACKAGE, relayFee, msgBytes));\n        sendSequence++;\n        channelSendSequenceMap[channelId] = sendSequence;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/interface/IApplication.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface IApplication {\n    /**\n     * @dev Handle syn package\n     */\n    function handleSynPackage(uint8 channelId, bytes calldata msgBytes) external returns (bytes memory responsePayload);\n\n    /**\n     * @dev Handle ack package\n     */\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n\n    /**\n     * @dev Handle fail ack package\n     */\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n}\n"
    },
    "contracts/bsc-tendermint/interface/ICrossChain.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface ICrossChain {\n    /**\n     * @dev Send package to Binance Chain\n     */\n    function sendSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes,\n        uint256 relayFee\n    ) external;\n}\n"
    },
    "contracts/bsc-tendermint/interface/ITendermintLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface ITendermintLightClient {\n    function isHeaderSynced(uint64 height) external view returns (bool);\n\n    function getAppHash(uint64 height) external view returns (bytes32);\n}\n"
    },
    "contracts/bsc-tendermint/lib/BytesToTypes.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\n/**\n * @title BytesToTypes\n * Copyright (c) 2016-2020 zpouladzade/Seriality\n * @dev The BytesToTypes contract converts the memory byte arrays to the standard solidity types\n * @author pouladzade@gmail.com\n */\n\nlibrary BytesToTypes {\n    function bytesToAddress(uint256 _offst, bytes memory _input) internal pure returns (address _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToBool(uint256 _offst, bytes memory _input) internal pure returns (bool _output) {\n        uint8 x;\n        assembly {\n            x := mload(add(_input, _offst))\n        }\n        x == 0 ? _output = false : _output = true;\n    }\n\n    function getStringSize(uint256 _offst, bytes memory _input) internal pure returns (uint256 size) {\n        assembly {\n            size := mload(add(_input, _offst))\n            let chunk_count := add(div(size, 32), 1) // chunk_count = size/32 + 1\n\n            if gt(mod(size, 32), 0) {\n                // if size%32 > 0\n                chunk_count := add(chunk_count, 1)\n            }\n\n            size := mul(chunk_count, 32) // first 32 bytes reseves for size in strings\n        }\n    }\n\n    function bytesToString(\n        uint256 _offst,\n        bytes memory _input,\n        bytes memory _output\n    ) internal pure {\n        uint256 size = 32;\n        assembly {\n            let chunk_count\n\n            size := mload(add(_input, _offst))\n            chunk_count := add(div(size, 32), 1) // chunk_count = size/32 + 1\n\n            if gt(mod(size, 32), 0) {\n                chunk_count := add(chunk_count, 1) // chunk_count++\n            }\n\n            for {\n                let index := 0\n            } lt(index, chunk_count) {\n                index := add(index, 1)\n            } {\n                mstore(add(_output, mul(index, 32)), mload(add(_input, _offst)))\n                _offst := sub(_offst, 32) // _offst -= 32\n            }\n        }\n    }\n\n    function bytesToBytes32(\n        uint256 _offst,\n        bytes memory _input,\n        bytes32 _output\n    ) internal pure {\n        assembly {\n            mstore(_output, add(_input, _offst))\n            mstore(add(_output, 32), add(add(_input, _offst), 32))\n        }\n    }\n\n    function bytesToInt8(uint256 _offst, bytes memory _input) internal pure returns (int8 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt16(uint256 _offst, bytes memory _input) internal pure returns (int16 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt24(uint256 _offst, bytes memory _input) internal pure returns (int24 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt32(uint256 _offst, bytes memory _input) internal pure returns (int32 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt40(uint256 _offst, bytes memory _input) internal pure returns (int40 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt48(uint256 _offst, bytes memory _input) internal pure returns (int48 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt56(uint256 _offst, bytes memory _input) internal pure returns (int56 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt64(uint256 _offst, bytes memory _input) internal pure returns (int64 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt72(uint256 _offst, bytes memory _input) internal pure returns (int72 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt80(uint256 _offst, bytes memory _input) internal pure returns (int80 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt88(uint256 _offst, bytes memory _input) internal pure returns (int88 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt96(uint256 _offst, bytes memory _input) internal pure returns (int96 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt104(uint256 _offst, bytes memory _input) internal pure returns (int104 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt112(uint256 _offst, bytes memory _input) internal pure returns (int112 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt120(uint256 _offst, bytes memory _input) internal pure returns (int120 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt128(uint256 _offst, bytes memory _input) internal pure returns (int128 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt136(uint256 _offst, bytes memory _input) internal pure returns (int136 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt144(uint256 _offst, bytes memory _input) internal pure returns (int144 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt152(uint256 _offst, bytes memory _input) internal pure returns (int152 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt160(uint256 _offst, bytes memory _input) internal pure returns (int160 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt168(uint256 _offst, bytes memory _input) internal pure returns (int168 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt176(uint256 _offst, bytes memory _input) internal pure returns (int176 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt184(uint256 _offst, bytes memory _input) internal pure returns (int184 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt192(uint256 _offst, bytes memory _input) internal pure returns (int192 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt200(uint256 _offst, bytes memory _input) internal pure returns (int200 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt208(uint256 _offst, bytes memory _input) internal pure returns (int208 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt216(uint256 _offst, bytes memory _input) internal pure returns (int216 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt224(uint256 _offst, bytes memory _input) internal pure returns (int224 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt232(uint256 _offst, bytes memory _input) internal pure returns (int232 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt240(uint256 _offst, bytes memory _input) internal pure returns (int240 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt248(uint256 _offst, bytes memory _input) internal pure returns (int248 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt256(uint256 _offst, bytes memory _input) internal pure returns (int256 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint8(uint256 _offst, bytes memory _input) internal pure returns (uint8 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint16(uint256 _offst, bytes memory _input) internal pure returns (uint16 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint24(uint256 _offst, bytes memory _input) internal pure returns (uint24 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint32(uint256 _offst, bytes memory _input) internal pure returns (uint32 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint40(uint256 _offst, bytes memory _input) internal pure returns (uint40 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint48(uint256 _offst, bytes memory _input) internal pure returns (uint48 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint56(uint256 _offst, bytes memory _input) internal pure returns (uint56 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint64(uint256 _offst, bytes memory _input) internal pure returns (uint64 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint72(uint256 _offst, bytes memory _input) internal pure returns (uint72 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint80(uint256 _offst, bytes memory _input) internal pure returns (uint80 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint88(uint256 _offst, bytes memory _input) internal pure returns (uint88 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint96(uint256 _offst, bytes memory _input) internal pure returns (uint96 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint104(uint256 _offst, bytes memory _input) internal pure returns (uint104 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint112(uint256 _offst, bytes memory _input) internal pure returns (uint112 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint120(uint256 _offst, bytes memory _input) internal pure returns (uint120 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint128(uint256 _offst, bytes memory _input) internal pure returns (uint128 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint136(uint256 _offst, bytes memory _input) internal pure returns (uint136 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint144(uint256 _offst, bytes memory _input) internal pure returns (uint144 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint152(uint256 _offst, bytes memory _input) internal pure returns (uint152 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint160(uint256 _offst, bytes memory _input) internal pure returns (uint160 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint168(uint256 _offst, bytes memory _input) internal pure returns (uint168 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint176(uint256 _offst, bytes memory _input) internal pure returns (uint176 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint184(uint256 _offst, bytes memory _input) internal pure returns (uint184 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint192(uint256 _offst, bytes memory _input) internal pure returns (uint192 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint200(uint256 _offst, bytes memory _input) internal pure returns (uint200 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint208(uint256 _offst, bytes memory _input) internal pure returns (uint208 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint216(uint256 _offst, bytes memory _input) internal pure returns (uint216 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint224(uint256 _offst, bytes memory _input) internal pure returns (uint224 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint232(uint256 _offst, bytes memory _input) internal pure returns (uint232 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint240(uint256 _offst, bytes memory _input) internal pure returns (uint240 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint248(uint256 _offst, bytes memory _input) internal pure returns (uint248 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint256(uint256 _offst, bytes memory _input) internal pure returns (uint256 _output) {\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/CmnPkg.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./RLPEncode.sol\";\nimport \"./RLPDecode.sol\";\n\nlibrary CmnPkg {\n    using RLPEncode for *;\n    using RLPDecode for *;\n\n    struct CommonAckPackage {\n        uint32 code;\n    }\n\n    function encodeCommonAckPackage(uint32 code) internal pure returns (bytes memory) {\n        bytes[] memory elements = new bytes[](1);\n        elements[0] = uint256(code).encodeUint();\n        return elements.encodeList();\n    }\n\n    function decodeCommonAckPackage(bytes memory msgBytes) internal pure returns (CommonAckPackage memory, bool) {\n        CommonAckPackage memory ackPkg;\n        RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\n\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                ackPkg.code = uint32(iter.next().toUint());\n                success = true;\n            } else {\n                break;\n            }\n            idx++;\n        }\n        return (ackPkg, success);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/Memory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nlibrary Memory {\n    // Size of a word, in bytes.\n    uint256 internal constant WORD_SIZE = 32;\n    // Size of the header of a 'bytes' array.\n    uint256 internal constant BYTES_HEADER_SIZE = 32;\n    // Address of the free memory pointer.\n    uint256 internal constant FREE_MEM_PTR = 0x40;\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\n    // bytes starting at 'addr2'.\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\n    function equals(\n        uint256 addr,\n        uint256 addr2,\n        uint256 len\n    ) internal pure returns (bool equal) {\n        assembly {\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\n        }\n    }\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\n    // the first 'len' bytes will be compared.\n    // Requires that 'bts.length >= len'\n    function equals(\n        uint256 addr,\n        uint256 len,\n        bytes memory bts\n    ) internal pure returns (bool equal) {\n        require(bts.length >= len);\n        uint256 addr2;\n        assembly {\n            addr2 := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n        return equals(addr, addr2, len);\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\n    // This function does not check the or destination, it only copies\n    // the bytes.\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_SIZE;\n            src += WORD_SIZE;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    // Returns a memory pointer to the provided bytes array.\n    function ptr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := bts\n        }\n    }\n\n    // Returns a memory pointer to the data portion of the provided bytes array.\n    function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n    }\n\n    // This function does the same as 'dataPtr(bytes memory)', but will also return the\n    // length of the provided bytes array.\n    function fromBytes(bytes memory bts) internal pure returns (uint256 addr, uint256 len) {\n        len = bts.length;\n        assembly {\n            addr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n    }\n\n    // Creates a 'bytes memory' variable from the memory address 'addr', with the\n    // length 'len'. The function will allocate new memory for the bytes array, and\n    // the 'len bytes starting at 'addr' will be copied into that new memory.\n    function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) {\n        bts = new bytes(len);\n        uint256 btsptr;\n        assembly {\n            btsptr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n        copy(addr, btsptr, len);\n    }\n\n    // Get the word stored at memory address 'addr' as a 'uint'.\n    function toUint(uint256 addr) internal pure returns (uint256 n) {\n        assembly {\n            n := mload(addr)\n        }\n    }\n\n    // Get the word stored at memory address 'addr' as a 'bytes32'.\n    function toBytes32(uint256 addr) internal pure returns (bytes32 bts) {\n        assembly {\n            bts := mload(addr)\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./Memory.sol\";\n\nlibrary MerkleProof {\n    function validateMerkleProof(\n        bytes32 appHash,\n        string memory storeName,\n        bytes memory key,\n        bytes memory value,\n        bytes memory proof\n    ) internal view returns (bool) {\n        if (appHash == bytes32(0)) {\n            return false;\n        }\n\n        // | storeName | key length | key | value length | value | appHash  | proof |\n        // | 32 bytes  | 32 bytes   |   | 32 bytes   |     | 32 bytes |\n        bytes memory input = new bytes(128 + key.length + value.length + proof.length);\n\n        uint256 ptr = Memory.dataPtr(input);\n\n        bytes memory storeNameBytes = bytes(storeName);\n        assembly {\n            mstore(ptr, mload(add(storeNameBytes, 32)))\n        }\n\n        uint256 src;\n        uint256 length;\n\n        // write key length and key to input\n        ptr += 32;\n        (src, length) = Memory.fromBytes(key);\n        assembly {\n            mstore(ptr, length)\n        }\n        ptr += 32;\n        Memory.copy(src, ptr, length);\n\n        // write value length and value to input\n        ptr += length;\n        (src, length) = Memory.fromBytes(value);\n        assembly {\n            mstore(ptr, length)\n        }\n        ptr += 32;\n        Memory.copy(src, ptr, length);\n\n        // write appHash to input\n        ptr += length;\n        assembly {\n            mstore(ptr, appHash)\n        }\n\n        // write proof to input\n        ptr += 32;\n        (src, length) = Memory.fromBytes(proof);\n        Memory.copy(src, ptr, length);\n\n        length = input.length + 32;\n\n        uint256[1] memory result;\n        assembly {\n            // call validateMerkleProof precompile contract\n            // Contract address: 0x65\n            if iszero(staticcall(not(0), 0x65, input, length, result, 0x20)) {\n\n            }\n        }\n\n        return result[0] == 0x01;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/RLPDecode.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n\n        return RLPItem(self.length, memPtr);\n    }\n\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"length is less than offset\");\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/RLPEncode.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nlibrary RLPEncode {\n    uint8 constant STRING_OFFSET = 0x80;\n    uint8 constant LIST_OFFSET = 0xc0;\n\n    /**\n     * @notice Encode string item\n     * @param self The string (ie. byte array) item to encode\n     * @return The RLP encoded string in bytes\n     */\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\n        if (self.length == 1 && self[0] <= 0x7f) {\n            return self;\n        }\n        return mergeBytes(encodeLength(self.length, STRING_OFFSET), self);\n    }\n\n    /**\n     * @notice Encode address\n     * @param self The address to encode\n     * @return The RLP encoded address in bytes\n     */\n    function encodeAddress(address self) internal pure returns (bytes memory) {\n        bytes memory b;\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, self))\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n        return encodeBytes(b);\n    }\n\n    /**\n     * @notice Encode uint\n     * @param self The uint to encode\n     * @return The RLP encoded uint in bytes\n     */\n    function encodeUint(uint256 self) internal pure returns (bytes memory) {\n        return encodeBytes(toBinary(self));\n    }\n\n    /**\n     * @notice Encode int\n     * @param self The int to encode\n     * @return The RLP encoded int in bytes\n     */\n    function encodeInt(int256 self) internal pure returns (bytes memory) {\n        return encodeUint(uint256(self));\n    }\n\n    /**\n     * @notice Encode bool\n     * @param self The bool to encode\n     * @return The RLP encoded bool in bytes\n     */\n    function encodeBool(bool self) internal pure returns (bytes memory) {\n        bytes memory rs = new bytes(1);\n        if (self) {\n            rs[0] = bytes1(uint8(1));\n        }\n        return rs;\n    }\n\n    /**\n     * @notice Encode list of items\n     * @param self The list of items to encode, each item in list must be already encoded\n     * @return The RLP encoded list of items in bytes\n     */\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\n        if (self.length == 0) {\n            return new bytes(0);\n        }\n        bytes memory payload = self[0];\n        for (uint256 i = 1; i < self.length; i++) {\n            payload = mergeBytes(payload, self[i]);\n        }\n        return mergeBytes(encodeLength(payload.length, LIST_OFFSET), payload);\n    }\n\n    /**\n     * @notice Concat two bytes arrays\n     * @param _preBytes The first bytes array\n     * @param _postBytes The second bytes array\n     * @return The merged bytes array\n     */\n    function mergeBytes(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @notice Encode the first byte, followed by the `length` in binary form if `length` is more than 55.\n     * @param length The length of the string or the payload\n     * @param offset `STRING_OFFSET` if item is string, `LIST_OFFSET` if item is list\n     * @return RLP encoded bytes\n     */\n    function encodeLength(uint256 length, uint256 offset) internal pure returns (bytes memory) {\n        require(length < 256**8, \"input too long\");\n        bytes memory rs = new bytes(1);\n        if (length <= 55) {\n            rs[0] = bytes1(uint8(length + offset));\n            return rs;\n        }\n        bytes memory bl = toBinary(length);\n        rs[0] = bytes1(uint8(bl.length + offset + 55));\n        return mergeBytes(rs, bl);\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes\n     * @param x The integer to encode\n     * @return RLP encoded bytes\n     */\n    function toBinary(uint256 x) internal pure returns (bytes memory) {\n        bytes memory b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n        uint256 i;\n        if (x & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000 == 0) {\n            i = 24;\n        } else if (x & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 == 0) {\n            i = 16;\n        } else {\n            i = 0;\n        }\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n        uint256 length = 32 - i;\n        bytes memory rs = new bytes(length);\n        assembly {\n            mstore(add(rs, length), x)\n            mstore(rs, length)\n        }\n        return rs;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/proto/Encoder.sol": {
      "content": "// SPDX-License-Identifier: TBD\npragma solidity ^0.8.2;\n\nimport \"./ProtoBufRuntime.sol\";\n\nlibrary Encoder {\n    uint64 private constant _MAX_UINT64 = 0xFFFFFFFFFFFFFFFF;\n\n    function cdcEncode(string memory item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_lendelim(bytes(item).length);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (bytes(item).length > 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    function cdcEncode(bytes memory item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_lendelim(item.length);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (item.length > 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    function cdcEncode(int64 item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_int64(item);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (item != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // TODO: Can we make this cheaper?\n    // https://docs.soliditylang.org/en/v0.6.5/types.html#allocating-memory-arrays\n    function encodeDelim(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length < _MAX_UINT64, \"Encoder: out of bounds (uint64)\");\n\n        uint64 length = uint64(input.length);\n        uint256 additionalEstimated = ProtoBufRuntime._sz_uint64(length);\n\n        bytes memory delimitedPrefix = new bytes(additionalEstimated);\n        uint256 delimitedPrefixLen = ProtoBufRuntime._encode_uint64(length, 32, delimitedPrefix);\n\n        assembly {\n            mstore(delimitedPrefix, delimitedPrefixLen)\n        }\n\n        // concatenate buffers\n        return abi.encodePacked(delimitedPrefix, input);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/proto/GoogleProtobufAny.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\nimport \"./ProtoBufRuntime.sol\";\n\nlibrary GoogleProtobufAny {\n    //struct definition\n    struct Data {\n        string type_url;\n        bytes value;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_type_url(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_type_url(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        //\n        // if `r` is NULL, then only counting the number of fields.\n        //\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.type_url = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        //\n        // if `r` is NULL, then only counting the number of fields.\n        //\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ProtoBufRuntime._encode_string(r.type_url, pointer, bs);\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.type_url).length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        return e;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.type_url = input.type_url;\n        output.value = input.value;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n//library Any\n"
    },
    "contracts/bsc-tendermint/proto/ProtoBufRuntime.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n/**\n * @title Runtime library for ProtoBuf serialization and/or deserialization.\n * All ProtoBuf generated code will use this library.\n */\nlibrary ProtoBufRuntime {\n    // Types defined in ProtoBuf\n    enum WireType {\n        Varint,\n        Fixed64,\n        LengthDelim,\n        StartGroup,\n        EndGroup,\n        Fixed32\n    }\n    // Constants for bytes calculation\n    uint256 constant WORD_LENGTH = 32;\n    uint256 constant HEADER_SIZE_LENGTH_IN_BYTES = 4;\n    uint256 constant BYTE_SIZE = 8;\n    uint256 constant REMAINING_LENGTH = WORD_LENGTH - HEADER_SIZE_LENGTH_IN_BYTES;\n    string constant OVERFLOW_MESSAGE = \"length overflow\";\n\n    //Storages\n    /**\n     * @dev Encode to storage location using assembly to save storage space.\n     * @param location The location of storage\n     * @param encoded The encoded ProtoBuf bytes\n     */\n    function encodeStorage(bytes storage location, bytes memory encoded) internal {\n        //\n        // This code use the first four bytes as size,\n        // and then put the rest of `encoded` bytes.\n        //\n        uint256 length = encoded.length;\n        uint256 firstWord;\n        uint256 wordLength = WORD_LENGTH;\n        uint256 remainingLength = REMAINING_LENGTH;\n\n        assembly {\n            firstWord := mload(add(encoded, wordLength))\n        }\n        firstWord =\n            (firstWord >> (BYTE_SIZE * HEADER_SIZE_LENGTH_IN_BYTES)) |\n            (length << (BYTE_SIZE * REMAINING_LENGTH));\n\n        assembly {\n            sstore(location.slot, firstWord)\n        }\n\n        if (length > REMAINING_LENGTH) {\n            length -= REMAINING_LENGTH;\n            for (uint256 i = 0; i < ceil(length, WORD_LENGTH); i++) {\n                assembly {\n                    let offset := add(mul(i, wordLength), remainingLength)\n                    let slotIndex := add(i, 1)\n                    sstore(add(location.slot, slotIndex), mload(add(add(encoded, wordLength), offset)))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Decode storage location using assembly using the format in `encodeStorage`.\n     * @param location The location of storage\n     * @return The encoded bytes\n     */\n    function decodeStorage(bytes storage location) internal view returns (bytes memory) {\n        //\n        // This code is to decode the first four bytes as size,\n        // and then decode the rest using the decoded size.\n        //\n        uint256 firstWord;\n        uint256 remainingLength = REMAINING_LENGTH;\n        uint256 wordLength = WORD_LENGTH;\n\n        assembly {\n            firstWord := sload(location.slot)\n        }\n\n        uint256 length = firstWord >> (BYTE_SIZE * REMAINING_LENGTH);\n        bytes memory encoded = new bytes(length);\n\n        assembly {\n            mstore(add(encoded, remainingLength), firstWord)\n        }\n\n        if (length > REMAINING_LENGTH) {\n            length -= REMAINING_LENGTH;\n            for (uint256 i = 0; i < ceil(length, WORD_LENGTH); i++) {\n                assembly {\n                    let offset := add(mul(i, wordLength), remainingLength)\n                    let slotIndex := add(i, 1)\n                    mstore(add(add(encoded, wordLength), offset), sload(add(location.slot, slotIndex)))\n                }\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Fast memory copy of bytes using assembly.\n     * @param src The source memory address\n     * @param dest The destination memory address\n     * @param len The length of bytes to copy\n     */\n    function copyBytes(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_LENGTH; len -= WORD_LENGTH) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_LENGTH;\n            src += WORD_LENGTH;\n        }\n\n        // Copy remaining bytes\n        // TODO: There are two changes in solidity 0.8.x\n        // 1. exponential literal handling\n        // 2. overflow/underflow check enabled by default\n        //\n        // https://docs.soliditylang.org/en/latest/080-breaking-changes.html#how-to-update-your-code\n        //\n        // Here we have underflow / overflow and I don't yet know why. I tested:\n        //    uint256 WORD_LENGTH = 32;\n        //    uint256 len = 20;\n        //    uint256 mask =  256**(WORD_LENGTH - len) - 1;\n        //    uint256 mask2 = (256**(5)) - 1;\n        //    uint256 mask3 = 256**((5) - 1);\n        //\n        // all of them seem to return the same value, so I believe this is the overflow issue.\n        //\n        // To mitigate the issue I wrapped this in unchecked { }\n        uint256 mask;\n        unchecked {\n            mask = 256**(WORD_LENGTH - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Use assembly to get memory address.\n     * @param r The in-memory bytes array\n     * @return The memory address of `r`\n     */\n    function getMemoryAddress(bytes memory r) internal pure returns (uint256) {\n        uint256 addr;\n        assembly {\n            addr := r\n        }\n        return addr;\n    }\n\n    /**\n     * @dev Implement Math function of ceil\n     * @param a The denominator\n     * @param m The numerator\n     * @return r The result of ceil(a/m)\n     */\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256 r) {\n        return (a + m - 1) / m;\n    }\n\n    // Decoders\n    /**\n     * This section of code `_decode_(u)int(32|64)`, `_decode_enum` and `_decode_bool`\n     * is to decode ProtoBuf native integers,\n     * using the `varint` encoding.\n     */\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uint32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        return (uint32(varint), sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uint64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        return (uint64(varint), sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_int32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        int32 r;\n        assembly {\n            r := varint\n        }\n        return (r, sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_int64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        int64 r;\n        assembly {\n            r := varint\n        }\n        return (r, sz);\n    }\n\n    /**\n     * @dev Decode enum\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded enum's integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_enum(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        return _decode_int64(p, bs);\n    }\n\n    /**\n     * @dev Decode enum\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded boolean\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_bool(uint256 p, bytes memory bs) internal pure returns (bool, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        if (varint == 0) {\n            return (false, sz);\n        }\n        return (true, sz);\n    }\n\n    /**\n     * This section of code `_decode_sint(32|64)`\n     * is to decode ProtoBuf native signed integers,\n     * using the `zig-zag` encoding.\n     */\n\n    /**\n     * @dev Decode signed integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_sint32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (int256 varint, uint256 sz) = _decode_varints(p, bs);\n        return (int32(varint), sz);\n    }\n\n    /**\n     * @dev Decode signed integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_sint64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (int256 varint, uint256 sz) = _decode_varints(p, bs);\n        return (int64(varint), sz);\n    }\n\n    /**\n     * @dev Decode string\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded string\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_string(uint256 p, bytes memory bs) internal pure returns (string memory, uint256) {\n        (bytes memory x, uint256 sz) = _decode_lendelim(p, bs);\n        return (string(x), sz);\n    }\n\n    /**\n     * @dev Decode bytes array\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded bytes array\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_bytes(uint256 p, bytes memory bs) internal pure returns (bytes memory, uint256) {\n        return _decode_lendelim(p, bs);\n    }\n\n    /**\n     * @dev Decode ProtoBuf key\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded field ID\n     * @return The decoded WireType specified in ProtoBuf\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_key(uint256 p, bytes memory bs)\n        internal\n        pure\n        returns (\n            uint256,\n            WireType,\n            uint256\n        )\n    {\n        (uint256 x, uint256 n) = _decode_varint(p, bs);\n        WireType typeId = WireType(x & 7);\n        uint256 fieldId = x / 8;\n        return (fieldId, typeId, n);\n    }\n\n    /**\n     * @dev Decode ProtoBuf varint\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded unsigned integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_varint(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        //\n        // Read a byte.\n        // Use the lower 7 bits and shift it to the left,\n        // until the most significant bit is 0.\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 x = 0;\n        uint256 sz = 0;\n        uint256 length = bs.length + WORD_LENGTH;\n        assembly {\n            let b := 0x80\n            p := add(bs, p)\n            for {\n\n            } eq(0x80, and(b, 0x80)) {\n\n            } {\n                if eq(lt(sub(p, bs), length), 0) {\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000) //error function selector\n                    mstore(4, 32)\n                    mstore(36, 15)\n                    mstore(68, 0x6c656e677468206f766572666c6f770000000000000000000000000000000000) // length overflow in hex\n                    revert(0, 83)\n                }\n                let tmp := mload(p)\n                let pos := 0\n                for {\n\n                } and(eq(0x80, and(b, 0x80)), lt(pos, 32)) {\n\n                } {\n                    if eq(lt(sub(p, bs), length), 0) {\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000) //error function selector\n                        mstore(4, 32)\n                        mstore(36, 15)\n                        mstore(68, 0x6c656e677468206f766572666c6f770000000000000000000000000000000000) // length overflow in hex\n                        revert(0, 83)\n                    }\n                    b := byte(pos, tmp)\n                    x := or(x, shl(mul(7, sz), and(0x7f, b)))\n                    sz := add(sz, 1)\n                    pos := add(pos, 1)\n                    p := add(p, 0x01)\n                }\n            }\n        }\n        return (x, sz);\n    }\n\n    /**\n     * @dev Decode ProtoBuf zig-zag encoding\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded signed integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_varints(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        (uint256 u, uint256 sz) = _decode_varint(p, bs);\n        int256 s;\n        assembly {\n            s := xor(shr(1, u), add(not(and(u, 1)), 1))\n        }\n        return (s, sz);\n    }\n\n    /**\n     * @dev Decode ProtoBuf fixed-length encoding\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded unsigned integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uintf(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (uint256, uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 x = 0;\n        uint256 length = bs.length + WORD_LENGTH;\n        assert(p + sz <= length);\n        assembly {\n            let i := 0\n            p := add(bs, p)\n            let tmp := mload(p)\n            for {\n\n            } lt(i, sz) {\n\n            } {\n                x := or(x, shl(mul(8, i), byte(i, tmp)))\n                p := add(p, 0x01)\n                i := add(i, 1)\n            }\n        }\n        return (x, sz);\n    }\n\n    /**\n     * `_decode_(s)fixed(32|64)` is the concrete implementation of `_decode_uintf`\n     */\n    function _decode_fixed32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 4);\n        return (uint32(x), sz);\n    }\n\n    function _decode_fixed64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 8);\n        return (uint64(x), sz);\n    }\n\n    function _decode_sfixed32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 4);\n        int256 r;\n        assembly {\n            r := x\n        }\n        return (int32(r), sz);\n    }\n\n    function _decode_sfixed64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 8);\n        int256 r;\n        assembly {\n            r := x\n        }\n        return (int64(r), sz);\n    }\n\n    /**\n     * @dev Decode bytes array\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded bytes array\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_lendelim(uint256 p, bytes memory bs) internal pure returns (bytes memory, uint256) {\n        //\n        // First read the size encoded in `varint`, then use the size to read bytes.\n        //\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        bytes memory b = new bytes(len);\n        uint256 length = bs.length + WORD_LENGTH;\n        assert(p + sz + len <= length);\n        uint256 sourcePtr;\n        uint256 destPtr;\n        assembly {\n            destPtr := add(b, 32)\n            sourcePtr := add(add(bs, p), sz)\n        }\n        copyBytes(sourcePtr, destPtr, len);\n        return (b, sz + len);\n    }\n\n    // Encoders\n    /**\n     * @dev Encode ProtoBuf key\n     * @param x The field ID\n     * @param wt The WireType specified in ProtoBuf\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_key(\n        uint256 x,\n        WireType wt,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 i;\n        assembly {\n            i := or(mul(x, 8), mod(wt, 8))\n        }\n        return _encode_varint(i, p, bs);\n    }\n\n    /**\n     * @dev Encode ProtoBuf varint\n     * @param x The unsigned integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_varint(\n        uint256 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 sz = 0;\n        assembly {\n            let bsptr := add(bs, p)\n            let byt := and(x, 0x7f)\n            for {\n\n            } gt(shr(7, x), 0) {\n\n            } {\n                mstore8(bsptr, or(0x80, byt))\n                bsptr := add(bsptr, 1)\n                sz := add(sz, 1)\n                x := shr(7, x)\n                byt := and(x, 0x7f)\n            }\n            mstore8(bsptr, byt)\n            sz := add(sz, 1)\n        }\n        return sz;\n    }\n\n    /**\n     * @dev Encode ProtoBuf zig-zag encoding\n     * @param x The signed integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_varints(\n        int256 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 encodedInt = _encode_zigzag(x);\n        return _encode_varint(encodedInt, p, bs);\n    }\n\n    /**\n     * @dev Encode ProtoBuf bytes\n     * @param xs The bytes array to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_bytes(\n        bytes memory xs,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 xsLength = xs.length;\n        uint256 sz = _encode_varint(xsLength, p, bs);\n        uint256 count = 0;\n        assembly {\n            let bsptr := add(bs, add(p, sz))\n            let xsptr := add(xs, 32)\n            for {\n\n            } lt(count, xsLength) {\n\n            } {\n                mstore8(bsptr, byte(0, mload(xsptr)))\n                bsptr := add(bsptr, 1)\n                xsptr := add(xsptr, 1)\n                count := add(count, 1)\n            }\n        }\n        return sz + count;\n    }\n\n    /**\n     * @dev Encode ProtoBuf string\n     * @param xs The string to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_string(\n        string memory xs,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_bytes(bytes(xs), p, bs);\n    }\n\n    //\n    // `_encode_(u)int(32|64)`, `_encode_enum` and `_encode_bool`\n    // are concrete implementation of `_encode_varint`\n    //\n    function _encode_uint32(\n        uint32 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_varint(x, p, bs);\n    }\n\n    function _encode_uint64(\n        uint64 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_varint(x, p, bs);\n    }\n\n    function _encode_int32(\n        int32 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_varint(twosComplement, p, bs);\n    }\n\n    function _encode_int64(\n        int64 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_varint(twosComplement, p, bs);\n    }\n\n    function _encode_enum(\n        int32 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_int32(x, p, bs);\n    }\n\n    function _encode_bool(\n        bool x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        if (x) {\n            return _encode_varint(1, p, bs);\n        } else return _encode_varint(0, p, bs);\n    }\n\n    //\n    // `_encode_sint(32|64)`, `_encode_enum` and `_encode_bool`\n    // are the concrete implementation of `_encode_varints`\n    //\n    function _encode_sint32(\n        int32 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_varints(x, p, bs);\n    }\n\n    function _encode_sint64(\n        int64 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_varints(x, p, bs);\n    }\n\n    //\n    // `_encode_(s)fixed(32|64)` is the concrete implementation of `_encode_uintf`\n    //\n    function _encode_fixed32(\n        uint32 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_uintf(x, p, bs, 4);\n    }\n\n    function _encode_fixed64(\n        uint64 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_uintf(x, p, bs, 8);\n    }\n\n    function _encode_sfixed32(\n        int32 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint32 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_uintf(twosComplement, p, bs, 4);\n    }\n\n    function _encode_sfixed64(\n        int64 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_uintf(twosComplement, p, bs, 8);\n    }\n\n    /**\n     * @dev Encode ProtoBuf fixed-length integer\n     * @param x The unsigned integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_uintf(\n        uint256 x,\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (uint256) {\n        assembly {\n            let bsptr := add(sz, add(bs, p))\n            let count := sz\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                bsptr := sub(bsptr, 1)\n                mstore8(bsptr, byte(sub(32, count), x))\n                count := sub(count, 1)\n            }\n        }\n        return sz;\n    }\n\n    /**\n     * @dev Encode ProtoBuf zig-zag signed integer\n     * @param i The unsigned integer to be encoded\n     * @return The encoded unsigned integer\n     */\n    function _encode_zigzag(int256 i) internal pure returns (uint256) {\n        if (i >= 0) {\n            return uint256(i) * 2;\n        } else return uint256(i * -2) - 1;\n    }\n\n    // Estimators\n    /**\n     * @dev Estimate the length of encoded LengthDelim\n     * @param i The length of LengthDelim\n     * @return The estimated encoded length\n     */\n    function _sz_lendelim(uint256 i) internal pure returns (uint256) {\n        return i + _sz_varint(i);\n    }\n\n    /**\n     * @dev Estimate the length of encoded ProtoBuf field ID\n     * @param i The field ID\n     * @return The estimated encoded length\n     */\n    function _sz_key(uint256 i) internal pure returns (uint256) {\n        if (i < 16) {\n            return 1;\n        } else if (i < 2048) {\n            return 2;\n        } else if (i < 262144) {\n            return 3;\n        } else {\n            revert(\"not supported\");\n        }\n    }\n\n    /**\n     * @dev Estimate the length of encoded ProtoBuf varint\n     * @param i The unsigned integer\n     * @return The estimated encoded length\n     */\n    function _sz_varint(uint256 i) internal pure returns (uint256) {\n        uint256 count = 1;\n        assembly {\n            i := shr(7, i)\n            for {\n\n            } gt(i, 0) {\n\n            } {\n                i := shr(7, i)\n                count := add(count, 1)\n            }\n        }\n        return count;\n    }\n\n    /**\n     * `_sz_(u)int(32|64)` and `_sz_enum` are the concrete implementation of `_sz_varint`\n     */\n    function _sz_uint32(uint32 i) internal pure returns (uint256) {\n        return _sz_varint(i);\n    }\n\n    function _sz_uint64(uint64 i) internal pure returns (uint256) {\n        return _sz_varint(i);\n    }\n\n    function _sz_int32(int32 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint32(i));\n    }\n\n    function _sz_int64(int64 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint64(i));\n    }\n\n    function _sz_enum(int64 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint64(i));\n    }\n\n    /**\n     * `_sz_sint(32|64)` and `_sz_enum` are the concrete implementation of zig-zag encoding\n     */\n    function _sz_sint32(int32 i) internal pure returns (uint256) {\n        return _sz_varint(_encode_zigzag(i));\n    }\n\n    function _sz_sint64(int64 i) internal pure returns (uint256) {\n        return _sz_varint(_encode_zigzag(i));\n    }\n\n    // Soltype extensions\n    /**\n     * @dev Decode Solidity integer and/or fixed-size bytes array, filling from lowest bit.\n     * @param n The maximum number of bytes to read\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The bytes32 representation\n     * @return The number of bytes used to decode\n     */\n    function _decode_sol_bytesN_lower(\n        uint8 n,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (bytes32, uint256) {\n        uint256 r;\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        if (len + sz > n + 3) {\n            revert(OVERFLOW_MESSAGE);\n        }\n        p += 3;\n        assert(p < bs.length + WORD_LENGTH);\n        assembly {\n            r := mload(add(p, bs))\n        }\n        for (uint256 i = len - 2; i < WORD_LENGTH; i++) {\n            r /= 256;\n        }\n        return (bytes32(r), len + sz);\n    }\n\n    /**\n     * @dev Decode Solidity integer and/or fixed-size bytes array, filling from highest bit.\n     * @param n The maximum number of bytes to read\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The bytes32 representation\n     * @return The number of bytes used to decode\n     */\n    function _decode_sol_bytesN(\n        uint8 n,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (bytes32, uint256) {\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        uint256 wordLength = WORD_LENGTH;\n        uint256 byteSize = BYTE_SIZE;\n        if (len + sz > n + 3) {\n            revert(OVERFLOW_MESSAGE);\n        }\n        p += 3;\n        bytes32 acc;\n        assert(p < bs.length + WORD_LENGTH);\n        assembly {\n            acc := mload(add(p, bs))\n            let difference := sub(wordLength, sub(len, 2))\n            let bits := mul(byteSize, difference)\n            acc := shl(bits, shr(bits, acc))\n        }\n        return (acc, len + sz);\n    }\n\n    /*\n     * `_decode_sol*` are the concrete implementation of decoding Solidity types\n     */\n    function _decode_sol_address(uint256 p, bytes memory bs) internal pure returns (address, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytesN(20, p, bs);\n        return (address(bytes20(r)), sz);\n    }\n\n    function _decode_sol_bool(uint256 p, bytes memory bs) internal pure returns (bool, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(1, p, bs);\n        if (r == 0) {\n            return (false, sz);\n        }\n        return (true, sz);\n    }\n\n    function _decode_sol_uint(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        return _decode_sol_uint256(p, bs);\n    }\n\n    function _decode_sol_uintN(\n        uint8 n,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN_lower(n, p, bs);\n        uint256 r;\n        assembly {\n            r := u\n        }\n        return (r, sz);\n    }\n\n    function _decode_sol_uint8(uint256 p, bytes memory bs) internal pure returns (uint8, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(1, p, bs);\n        return (uint8(r), sz);\n    }\n\n    function _decode_sol_uint16(uint256 p, bytes memory bs) internal pure returns (uint16, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(2, p, bs);\n        return (uint16(r), sz);\n    }\n\n    function _decode_sol_uint24(uint256 p, bytes memory bs) internal pure returns (uint24, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(3, p, bs);\n        return (uint24(r), sz);\n    }\n\n    function _decode_sol_uint32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(4, p, bs);\n        return (uint32(r), sz);\n    }\n\n    function _decode_sol_uint40(uint256 p, bytes memory bs) internal pure returns (uint40, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(5, p, bs);\n        return (uint40(r), sz);\n    }\n\n    function _decode_sol_uint48(uint256 p, bytes memory bs) internal pure returns (uint48, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(6, p, bs);\n        return (uint48(r), sz);\n    }\n\n    function _decode_sol_uint56(uint256 p, bytes memory bs) internal pure returns (uint56, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(7, p, bs);\n        return (uint56(r), sz);\n    }\n\n    function _decode_sol_uint64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(8, p, bs);\n        return (uint64(r), sz);\n    }\n\n    function _decode_sol_uint72(uint256 p, bytes memory bs) internal pure returns (uint72, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(9, p, bs);\n        return (uint72(r), sz);\n    }\n\n    function _decode_sol_uint80(uint256 p, bytes memory bs) internal pure returns (uint80, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(10, p, bs);\n        return (uint80(r), sz);\n    }\n\n    function _decode_sol_uint88(uint256 p, bytes memory bs) internal pure returns (uint88, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(11, p, bs);\n        return (uint88(r), sz);\n    }\n\n    function _decode_sol_uint96(uint256 p, bytes memory bs) internal pure returns (uint96, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(12, p, bs);\n        return (uint96(r), sz);\n    }\n\n    function _decode_sol_uint104(uint256 p, bytes memory bs) internal pure returns (uint104, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(13, p, bs);\n        return (uint104(r), sz);\n    }\n\n    function _decode_sol_uint112(uint256 p, bytes memory bs) internal pure returns (uint112, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(14, p, bs);\n        return (uint112(r), sz);\n    }\n\n    function _decode_sol_uint120(uint256 p, bytes memory bs) internal pure returns (uint120, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(15, p, bs);\n        return (uint120(r), sz);\n    }\n\n    function _decode_sol_uint128(uint256 p, bytes memory bs) internal pure returns (uint128, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(16, p, bs);\n        return (uint128(r), sz);\n    }\n\n    function _decode_sol_uint136(uint256 p, bytes memory bs) internal pure returns (uint136, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(17, p, bs);\n        return (uint136(r), sz);\n    }\n\n    function _decode_sol_uint144(uint256 p, bytes memory bs) internal pure returns (uint144, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(18, p, bs);\n        return (uint144(r), sz);\n    }\n\n    function _decode_sol_uint152(uint256 p, bytes memory bs) internal pure returns (uint152, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(19, p, bs);\n        return (uint152(r), sz);\n    }\n\n    function _decode_sol_uint160(uint256 p, bytes memory bs) internal pure returns (uint160, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(20, p, bs);\n        return (uint160(r), sz);\n    }\n\n    function _decode_sol_uint168(uint256 p, bytes memory bs) internal pure returns (uint168, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(21, p, bs);\n        return (uint168(r), sz);\n    }\n\n    function _decode_sol_uint176(uint256 p, bytes memory bs) internal pure returns (uint176, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(22, p, bs);\n        return (uint176(r), sz);\n    }\n\n    function _decode_sol_uint184(uint256 p, bytes memory bs) internal pure returns (uint184, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(23, p, bs);\n        return (uint184(r), sz);\n    }\n\n    function _decode_sol_uint192(uint256 p, bytes memory bs) internal pure returns (uint192, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(24, p, bs);\n        return (uint192(r), sz);\n    }\n\n    function _decode_sol_uint200(uint256 p, bytes memory bs) internal pure returns (uint200, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(25, p, bs);\n        return (uint200(r), sz);\n    }\n\n    function _decode_sol_uint208(uint256 p, bytes memory bs) internal pure returns (uint208, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(26, p, bs);\n        return (uint208(r), sz);\n    }\n\n    function _decode_sol_uint216(uint256 p, bytes memory bs) internal pure returns (uint216, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(27, p, bs);\n        return (uint216(r), sz);\n    }\n\n    function _decode_sol_uint224(uint256 p, bytes memory bs) internal pure returns (uint224, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(28, p, bs);\n        return (uint224(r), sz);\n    }\n\n    function _decode_sol_uint232(uint256 p, bytes memory bs) internal pure returns (uint232, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(29, p, bs);\n        return (uint232(r), sz);\n    }\n\n    function _decode_sol_uint240(uint256 p, bytes memory bs) internal pure returns (uint240, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(30, p, bs);\n        return (uint240(r), sz);\n    }\n\n    function _decode_sol_uint248(uint256 p, bytes memory bs) internal pure returns (uint248, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(31, p, bs);\n        return (uint248(r), sz);\n    }\n\n    function _decode_sol_uint256(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(32, p, bs);\n        return (uint256(r), sz);\n    }\n\n    function _decode_sol_int(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        return _decode_sol_int256(p, bs);\n    }\n\n    function _decode_sol_intN(\n        uint8 n,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (int256, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN_lower(n, p, bs);\n        int256 r;\n        assembly {\n            r := u\n            r := signextend(sub(sz, 4), r)\n        }\n        return (r, sz);\n    }\n\n    function _decode_sol_bytes(\n        uint8 n,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (bytes32, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN(n, p, bs);\n        return (u, sz);\n    }\n\n    function _decode_sol_int8(uint256 p, bytes memory bs) internal pure returns (int8, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(1, p, bs);\n        return (int8(r), sz);\n    }\n\n    function _decode_sol_int16(uint256 p, bytes memory bs) internal pure returns (int16, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(2, p, bs);\n        return (int16(r), sz);\n    }\n\n    function _decode_sol_int24(uint256 p, bytes memory bs) internal pure returns (int24, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(3, p, bs);\n        return (int24(r), sz);\n    }\n\n    function _decode_sol_int32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(4, p, bs);\n        return (int32(r), sz);\n    }\n\n    function _decode_sol_int40(uint256 p, bytes memory bs) internal pure returns (int40, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(5, p, bs);\n        return (int40(r), sz);\n    }\n\n    function _decode_sol_int48(uint256 p, bytes memory bs) internal pure returns (int48, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(6, p, bs);\n        return (int48(r), sz);\n    }\n\n    function _decode_sol_int56(uint256 p, bytes memory bs) internal pure returns (int56, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(7, p, bs);\n        return (int56(r), sz);\n    }\n\n    function _decode_sol_int64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(8, p, bs);\n        return (int64(r), sz);\n    }\n\n    function _decode_sol_int72(uint256 p, bytes memory bs) internal pure returns (int72, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(9, p, bs);\n        return (int72(r), sz);\n    }\n\n    function _decode_sol_int80(uint256 p, bytes memory bs) internal pure returns (int80, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(10, p, bs);\n        return (int80(r), sz);\n    }\n\n    function _decode_sol_int88(uint256 p, bytes memory bs) internal pure returns (int88, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(11, p, bs);\n        return (int88(r), sz);\n    }\n\n    function _decode_sol_int96(uint256 p, bytes memory bs) internal pure returns (int96, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(12, p, bs);\n        return (int96(r), sz);\n    }\n\n    function _decode_sol_int104(uint256 p, bytes memory bs) internal pure returns (int104, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(13, p, bs);\n        return (int104(r), sz);\n    }\n\n    function _decode_sol_int112(uint256 p, bytes memory bs) internal pure returns (int112, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(14, p, bs);\n        return (int112(r), sz);\n    }\n\n    function _decode_sol_int120(uint256 p, bytes memory bs) internal pure returns (int120, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(15, p, bs);\n        return (int120(r), sz);\n    }\n\n    function _decode_sol_int128(uint256 p, bytes memory bs) internal pure returns (int128, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(16, p, bs);\n        return (int128(r), sz);\n    }\n\n    function _decode_sol_int136(uint256 p, bytes memory bs) internal pure returns (int136, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(17, p, bs);\n        return (int136(r), sz);\n    }\n\n    function _decode_sol_int144(uint256 p, bytes memory bs) internal pure returns (int144, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(18, p, bs);\n        return (int144(r), sz);\n    }\n\n    function _decode_sol_int152(uint256 p, bytes memory bs) internal pure returns (int152, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(19, p, bs);\n        return (int152(r), sz);\n    }\n\n    function _decode_sol_int160(uint256 p, bytes memory bs) internal pure returns (int160, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(20, p, bs);\n        return (int160(r), sz);\n    }\n\n    function _decode_sol_int168(uint256 p, bytes memory bs) internal pure returns (int168, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(21, p, bs);\n        return (int168(r), sz);\n    }\n\n    function _decode_sol_int176(uint256 p, bytes memory bs) internal pure returns (int176, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(22, p, bs);\n        return (int176(r), sz);\n    }\n\n    function _decode_sol_int184(uint256 p, bytes memory bs) internal pure returns (int184, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(23, p, bs);\n        return (int184(r), sz);\n    }\n\n    function _decode_sol_int192(uint256 p, bytes memory bs) internal pure returns (int192, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(24, p, bs);\n        return (int192(r), sz);\n    }\n\n    function _decode_sol_int200(uint256 p, bytes memory bs) internal pure returns (int200, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(25, p, bs);\n        return (int200(r), sz);\n    }\n\n    function _decode_sol_int208(uint256 p, bytes memory bs) internal pure returns (int208, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(26, p, bs);\n        return (int208(r), sz);\n    }\n\n    function _decode_sol_int216(uint256 p, bytes memory bs) internal pure returns (int216, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(27, p, bs);\n        return (int216(r), sz);\n    }\n\n    function _decode_sol_int224(uint256 p, bytes memory bs) internal pure returns (int224, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(28, p, bs);\n        return (int224(r), sz);\n    }\n\n    function _decode_sol_int232(uint256 p, bytes memory bs) internal pure returns (int232, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(29, p, bs);\n        return (int232(r), sz);\n    }\n\n    function _decode_sol_int240(uint256 p, bytes memory bs) internal pure returns (int240, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(30, p, bs);\n        return (int240(r), sz);\n    }\n\n    function _decode_sol_int248(uint256 p, bytes memory bs) internal pure returns (int248, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(31, p, bs);\n        return (int248(r), sz);\n    }\n\n    function _decode_sol_int256(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(32, p, bs);\n        return (int256(r), sz);\n    }\n\n    function _decode_sol_bytes1(uint256 p, bytes memory bs) internal pure returns (bytes1, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(1, p, bs);\n        return (bytes1(r), sz);\n    }\n\n    function _decode_sol_bytes2(uint256 p, bytes memory bs) internal pure returns (bytes2, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(2, p, bs);\n        return (bytes2(r), sz);\n    }\n\n    function _decode_sol_bytes3(uint256 p, bytes memory bs) internal pure returns (bytes3, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(3, p, bs);\n        return (bytes3(r), sz);\n    }\n\n    function _decode_sol_bytes4(uint256 p, bytes memory bs) internal pure returns (bytes4, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(4, p, bs);\n        return (bytes4(r), sz);\n    }\n\n    function _decode_sol_bytes5(uint256 p, bytes memory bs) internal pure returns (bytes5, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(5, p, bs);\n        return (bytes5(r), sz);\n    }\n\n    function _decode_sol_bytes6(uint256 p, bytes memory bs) internal pure returns (bytes6, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(6, p, bs);\n        return (bytes6(r), sz);\n    }\n\n    function _decode_sol_bytes7(uint256 p, bytes memory bs) internal pure returns (bytes7, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(7, p, bs);\n        return (bytes7(r), sz);\n    }\n\n    function _decode_sol_bytes8(uint256 p, bytes memory bs) internal pure returns (bytes8, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(8, p, bs);\n        return (bytes8(r), sz);\n    }\n\n    function _decode_sol_bytes9(uint256 p, bytes memory bs) internal pure returns (bytes9, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(9, p, bs);\n        return (bytes9(r), sz);\n    }\n\n    function _decode_sol_bytes10(uint256 p, bytes memory bs) internal pure returns (bytes10, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(10, p, bs);\n        return (bytes10(r), sz);\n    }\n\n    function _decode_sol_bytes11(uint256 p, bytes memory bs) internal pure returns (bytes11, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(11, p, bs);\n        return (bytes11(r), sz);\n    }\n\n    function _decode_sol_bytes12(uint256 p, bytes memory bs) internal pure returns (bytes12, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(12, p, bs);\n        return (bytes12(r), sz);\n    }\n\n    function _decode_sol_bytes13(uint256 p, bytes memory bs) internal pure returns (bytes13, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(13, p, bs);\n        return (bytes13(r), sz);\n    }\n\n    function _decode_sol_bytes14(uint256 p, bytes memory bs) internal pure returns (bytes14, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(14, p, bs);\n        return (bytes14(r), sz);\n    }\n\n    function _decode_sol_bytes15(uint256 p, bytes memory bs) internal pure returns (bytes15, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(15, p, bs);\n        return (bytes15(r), sz);\n    }\n\n    function _decode_sol_bytes16(uint256 p, bytes memory bs) internal pure returns (bytes16, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(16, p, bs);\n        return (bytes16(r), sz);\n    }\n\n    function _decode_sol_bytes17(uint256 p, bytes memory bs) internal pure returns (bytes17, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(17, p, bs);\n        return (bytes17(r), sz);\n    }\n\n    function _decode_sol_bytes18(uint256 p, bytes memory bs) internal pure returns (bytes18, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(18, p, bs);\n        return (bytes18(r), sz);\n    }\n\n    function _decode_sol_bytes19(uint256 p, bytes memory bs) internal pure returns (bytes19, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(19, p, bs);\n        return (bytes19(r), sz);\n    }\n\n    function _decode_sol_bytes20(uint256 p, bytes memory bs) internal pure returns (bytes20, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(20, p, bs);\n        return (bytes20(r), sz);\n    }\n\n    function _decode_sol_bytes21(uint256 p, bytes memory bs) internal pure returns (bytes21, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(21, p, bs);\n        return (bytes21(r), sz);\n    }\n\n    function _decode_sol_bytes22(uint256 p, bytes memory bs) internal pure returns (bytes22, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(22, p, bs);\n        return (bytes22(r), sz);\n    }\n\n    function _decode_sol_bytes23(uint256 p, bytes memory bs) internal pure returns (bytes23, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(23, p, bs);\n        return (bytes23(r), sz);\n    }\n\n    function _decode_sol_bytes24(uint256 p, bytes memory bs) internal pure returns (bytes24, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(24, p, bs);\n        return (bytes24(r), sz);\n    }\n\n    function _decode_sol_bytes25(uint256 p, bytes memory bs) internal pure returns (bytes25, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(25, p, bs);\n        return (bytes25(r), sz);\n    }\n\n    function _decode_sol_bytes26(uint256 p, bytes memory bs) internal pure returns (bytes26, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(26, p, bs);\n        return (bytes26(r), sz);\n    }\n\n    function _decode_sol_bytes27(uint256 p, bytes memory bs) internal pure returns (bytes27, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(27, p, bs);\n        return (bytes27(r), sz);\n    }\n\n    function _decode_sol_bytes28(uint256 p, bytes memory bs) internal pure returns (bytes28, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(28, p, bs);\n        return (bytes28(r), sz);\n    }\n\n    function _decode_sol_bytes29(uint256 p, bytes memory bs) internal pure returns (bytes29, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(29, p, bs);\n        return (bytes29(r), sz);\n    }\n\n    function _decode_sol_bytes30(uint256 p, bytes memory bs) internal pure returns (bytes30, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(30, p, bs);\n        return (bytes30(r), sz);\n    }\n\n    function _decode_sol_bytes31(uint256 p, bytes memory bs) internal pure returns (bytes31, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(31, p, bs);\n        return (bytes31(r), sz);\n    }\n\n    function _decode_sol_bytes32(uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        return _decode_sol_bytes(32, p, bs);\n    }\n\n    /*\n     * `_encode_sol*` are the concrete implementation of encoding Solidity types\n     */\n    function _encode_sol_address(\n        address x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(uint160(x)), 20, p, bs);\n    }\n\n    function _encode_sol_uint(\n        uint256 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 32, p, bs);\n    }\n\n    function _encode_sol_uint8(\n        uint8 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 1, p, bs);\n    }\n\n    function _encode_sol_uint16(\n        uint16 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 2, p, bs);\n    }\n\n    function _encode_sol_uint24(\n        uint24 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 3, p, bs);\n    }\n\n    function _encode_sol_uint32(\n        uint32 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 4, p, bs);\n    }\n\n    function _encode_sol_uint40(\n        uint40 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 5, p, bs);\n    }\n\n    function _encode_sol_uint48(\n        uint48 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 6, p, bs);\n    }\n\n    function _encode_sol_uint56(\n        uint56 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 7, p, bs);\n    }\n\n    function _encode_sol_uint64(\n        uint64 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 8, p, bs);\n    }\n\n    function _encode_sol_uint72(\n        uint72 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 9, p, bs);\n    }\n\n    function _encode_sol_uint80(\n        uint80 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 10, p, bs);\n    }\n\n    function _encode_sol_uint88(\n        uint88 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 11, p, bs);\n    }\n\n    function _encode_sol_uint96(\n        uint96 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 12, p, bs);\n    }\n\n    function _encode_sol_uint104(\n        uint104 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 13, p, bs);\n    }\n\n    function _encode_sol_uint112(\n        uint112 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 14, p, bs);\n    }\n\n    function _encode_sol_uint120(\n        uint120 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 15, p, bs);\n    }\n\n    function _encode_sol_uint128(\n        uint128 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 16, p, bs);\n    }\n\n    function _encode_sol_uint136(\n        uint136 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 17, p, bs);\n    }\n\n    function _encode_sol_uint144(\n        uint144 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 18, p, bs);\n    }\n\n    function _encode_sol_uint152(\n        uint152 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 19, p, bs);\n    }\n\n    function _encode_sol_uint160(\n        uint160 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 20, p, bs);\n    }\n\n    function _encode_sol_uint168(\n        uint168 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 21, p, bs);\n    }\n\n    function _encode_sol_uint176(\n        uint176 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 22, p, bs);\n    }\n\n    function _encode_sol_uint184(\n        uint184 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 23, p, bs);\n    }\n\n    function _encode_sol_uint192(\n        uint192 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 24, p, bs);\n    }\n\n    function _encode_sol_uint200(\n        uint200 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 25, p, bs);\n    }\n\n    function _encode_sol_uint208(\n        uint208 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 26, p, bs);\n    }\n\n    function _encode_sol_uint216(\n        uint216 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 27, p, bs);\n    }\n\n    function _encode_sol_uint224(\n        uint224 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 28, p, bs);\n    }\n\n    function _encode_sol_uint232(\n        uint232 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 29, p, bs);\n    }\n\n    function _encode_sol_uint240(\n        uint240 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 30, p, bs);\n    }\n\n    function _encode_sol_uint248(\n        uint248 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 31, p, bs);\n    }\n\n    function _encode_sol_uint256(\n        uint256 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 32, p, bs);\n    }\n\n    function _encode_sol_int(\n        int256 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(x, 32, p, bs);\n    }\n\n    function _encode_sol_int8(\n        int8 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 1, p, bs);\n    }\n\n    function _encode_sol_int16(\n        int16 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 2, p, bs);\n    }\n\n    function _encode_sol_int24(\n        int24 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 3, p, bs);\n    }\n\n    function _encode_sol_int32(\n        int32 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 4, p, bs);\n    }\n\n    function _encode_sol_int40(\n        int40 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 5, p, bs);\n    }\n\n    function _encode_sol_int48(\n        int48 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 6, p, bs);\n    }\n\n    function _encode_sol_int56(\n        int56 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 7, p, bs);\n    }\n\n    function _encode_sol_int64(\n        int64 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 8, p, bs);\n    }\n\n    function _encode_sol_int72(\n        int72 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 9, p, bs);\n    }\n\n    function _encode_sol_int80(\n        int80 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 10, p, bs);\n    }\n\n    function _encode_sol_int88(\n        int88 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 11, p, bs);\n    }\n\n    function _encode_sol_int96(\n        int96 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 12, p, bs);\n    }\n\n    function _encode_sol_int104(\n        int104 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 13, p, bs);\n    }\n\n    function _encode_sol_int112(\n        int112 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 14, p, bs);\n    }\n\n    function _encode_sol_int120(\n        int120 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 15, p, bs);\n    }\n\n    function _encode_sol_int128(\n        int128 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 16, p, bs);\n    }\n\n    function _encode_sol_int136(\n        int136 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 17, p, bs);\n    }\n\n    function _encode_sol_int144(\n        int144 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 18, p, bs);\n    }\n\n    function _encode_sol_int152(\n        int152 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 19, p, bs);\n    }\n\n    function _encode_sol_int160(\n        int160 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 20, p, bs);\n    }\n\n    function _encode_sol_int168(\n        int168 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 21, p, bs);\n    }\n\n    function _encode_sol_int176(\n        int176 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 22, p, bs);\n    }\n\n    function _encode_sol_int184(\n        int184 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 23, p, bs);\n    }\n\n    function _encode_sol_int192(\n        int192 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 24, p, bs);\n    }\n\n    function _encode_sol_int200(\n        int200 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 25, p, bs);\n    }\n\n    function _encode_sol_int208(\n        int208 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 26, p, bs);\n    }\n\n    function _encode_sol_int216(\n        int216 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 27, p, bs);\n    }\n\n    function _encode_sol_int224(\n        int224 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 28, p, bs);\n    }\n\n    function _encode_sol_int232(\n        int232 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 29, p, bs);\n    }\n\n    function _encode_sol_int240(\n        int240 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 30, p, bs);\n    }\n\n    function _encode_sol_int248(\n        int248 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 31, p, bs);\n    }\n\n    function _encode_sol_int256(\n        int256 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol(x, 32, p, bs);\n    }\n\n    function _encode_sol_bytes1(\n        bytes1 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 1, p, bs);\n    }\n\n    function _encode_sol_bytes2(\n        bytes2 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 2, p, bs);\n    }\n\n    function _encode_sol_bytes3(\n        bytes3 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 3, p, bs);\n    }\n\n    function _encode_sol_bytes4(\n        bytes4 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 4, p, bs);\n    }\n\n    function _encode_sol_bytes5(\n        bytes5 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 5, p, bs);\n    }\n\n    function _encode_sol_bytes6(\n        bytes6 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 6, p, bs);\n    }\n\n    function _encode_sol_bytes7(\n        bytes7 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 7, p, bs);\n    }\n\n    function _encode_sol_bytes8(\n        bytes8 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 8, p, bs);\n    }\n\n    function _encode_sol_bytes9(\n        bytes9 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 9, p, bs);\n    }\n\n    function _encode_sol_bytes10(\n        bytes10 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 10, p, bs);\n    }\n\n    function _encode_sol_bytes11(\n        bytes11 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 11, p, bs);\n    }\n\n    function _encode_sol_bytes12(\n        bytes12 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 12, p, bs);\n    }\n\n    function _encode_sol_bytes13(\n        bytes13 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 13, p, bs);\n    }\n\n    function _encode_sol_bytes14(\n        bytes14 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 14, p, bs);\n    }\n\n    function _encode_sol_bytes15(\n        bytes15 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 15, p, bs);\n    }\n\n    function _encode_sol_bytes16(\n        bytes16 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 16, p, bs);\n    }\n\n    function _encode_sol_bytes17(\n        bytes17 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 17, p, bs);\n    }\n\n    function _encode_sol_bytes18(\n        bytes18 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 18, p, bs);\n    }\n\n    function _encode_sol_bytes19(\n        bytes19 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 19, p, bs);\n    }\n\n    function _encode_sol_bytes20(\n        bytes20 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 20, p, bs);\n    }\n\n    function _encode_sol_bytes21(\n        bytes21 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 21, p, bs);\n    }\n\n    function _encode_sol_bytes22(\n        bytes22 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 22, p, bs);\n    }\n\n    function _encode_sol_bytes23(\n        bytes23 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 23, p, bs);\n    }\n\n    function _encode_sol_bytes24(\n        bytes24 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 24, p, bs);\n    }\n\n    function _encode_sol_bytes25(\n        bytes25 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 25, p, bs);\n    }\n\n    function _encode_sol_bytes26(\n        bytes26 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 26, p, bs);\n    }\n\n    function _encode_sol_bytes27(\n        bytes27 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 27, p, bs);\n    }\n\n    function _encode_sol_bytes28(\n        bytes28 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 28, p, bs);\n    }\n\n    function _encode_sol_bytes29(\n        bytes29 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 29, p, bs);\n    }\n\n    function _encode_sol_bytes30(\n        bytes30 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 30, p, bs);\n    }\n\n    function _encode_sol_bytes31(\n        bytes31 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 31, p, bs);\n    }\n\n    function _encode_sol_bytes32(\n        bytes32 x,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        return _encode_sol_bytes(x, 32, p, bs);\n    }\n\n    /**\n     * @dev Encode the key of Solidity integer and/or fixed-size bytes array.\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol_header(\n        uint256 sz,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        p += _encode_varint(sz + 2, p, bs);\n        p += _encode_key(1, WireType.LengthDelim, p, bs);\n        p += _encode_varint(sz, p, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The unsinged integer to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol(\n        uint256 x,\n        uint256 sz,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_other(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The signed integer to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol(\n        int256 x,\n        uint256 sz,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_other(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The fixed-size byte array to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol_bytes(\n        bytes32 x,\n        uint256 sz,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_bytes_array(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Get the actual size needed to encoding an unsigned integer\n     * @param x The unsigned integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _get_real_size(uint256 x, uint256 sz) internal pure returns (uint256) {\n        uint256 base = 0xff;\n        uint256 realSize = sz;\n        while (x & (base << (realSize * BYTE_SIZE - BYTE_SIZE)) == 0 && realSize > 0) {\n            realSize -= 1;\n        }\n        if (realSize == 0) {\n            realSize = 1;\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Get the actual size needed to encoding an signed integer\n     * @param x The signed integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _get_real_size(int256 x, uint256 sz) internal pure returns (uint256) {\n        int256 base = 0xff;\n        if (x >= 0) {\n            uint256 tmp = _get_real_size(uint256(x), sz);\n            int256 remainder = (x & (base << (tmp * BYTE_SIZE - BYTE_SIZE))) >> (tmp * BYTE_SIZE - BYTE_SIZE);\n            if (remainder >= 128) {\n                tmp += 1;\n            }\n            return tmp;\n        }\n\n        uint256 realSize = sz;\n        while (\n            x & (base << (realSize * BYTE_SIZE - BYTE_SIZE)) == (base << (realSize * BYTE_SIZE - BYTE_SIZE)) &&\n            realSize > 0\n        ) {\n            realSize -= 1;\n        }\n        int256 remainder = (x & (base << (realSize * BYTE_SIZE - BYTE_SIZE))) >> (realSize * BYTE_SIZE - BYTE_SIZE);\n        if (remainder < 128) {\n            realSize += 1;\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Encode the fixed-bytes array\n     * @param x The fixed-size byte array to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_bytes_array(\n        bytes32 x,\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (uint256) {\n        //\n        // The idea is to not encode the leading bytes of zero.\n        //\n        uint256 actualSize = sz;\n        for (uint256 i = 0; i < sz; i++) {\n            uint8 current = uint8(x[sz - 1 - i]);\n            if (current == 0 && actualSize > 1) {\n                actualSize--;\n            } else {\n                break;\n            }\n        }\n        assembly {\n            let bsptr := add(bs, p)\n            let count := actualSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(actualSize, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return actualSize;\n    }\n\n    /**\n     * @dev Encode the signed integer\n     * @param x The signed integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_other(\n        int256 x,\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (uint256) {\n        //\n        // The idea is to not encode the leading bytes of zero.or one,\n        // depending on whether it is positive.\n        //\n        uint256 realSize = _get_real_size(x, sz);\n        assembly {\n            let bsptr := add(bs, p)\n            let count := realSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(32, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Encode the unsigned integer\n     * @param x The unsigned integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_other(\n        uint256 x,\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (uint256) {\n        uint256 realSize = _get_real_size(x, sz);\n        assembly {\n            let bsptr := add(bs, p)\n            let count := realSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(32, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return realSize;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/proto/TendermintHelper.sol": {
      "content": "// SPDX-License-Identifier: TBD\n\npragma solidity ^0.8.2;\n\nimport {TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS, Validator, SimpleValidator, BlockID, Vote, CanonicalBlockID, CanonicalPartSetHeader, CanonicalVote, TmHeader, ConsensusState, MerkleRoot, Commit, CommitSig, SignedHeader, ValidatorSet, Duration, Timestamp, Consensus} from \"./TendermintLight.sol\";\nimport \"./Encoder.sol\";\nimport \"../utils/crypto/MerkleTree.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nlibrary TendermintHelper {\n    function toSimpleValidator(Validator.Data memory val) internal pure returns (SimpleValidator.Data memory) {\n        return SimpleValidator.Data({pub_key: val.pub_key, voting_power: val.voting_power});\n    }\n\n    function toCanonicalBlockID(BlockID.Data memory blockID) internal pure returns (CanonicalBlockID.Data memory) {\n        return\n            CanonicalBlockID.Data({\n                hash: blockID.hash,\n                part_set_header: CanonicalPartSetHeader.Data({\n                    total: blockID.part_set_header.total,\n                    hash: blockID.part_set_header.hash\n                })\n            });\n    }\n\n    function toCanonicalVote(Vote.Data memory vote, string memory chainID)\n        internal\n        pure\n        returns (CanonicalVote.Data memory)\n    {\n        return\n            CanonicalVote.Data({\n                Type: vote.Type,\n                height: vote.height,\n                round: int64(vote.round),\n                block_id: toCanonicalBlockID(vote.block_id),\n                timestamp: vote.timestamp,\n                chain_id: chainID\n            });\n    }\n\n    function toConsensusState(TmHeader.Data memory tmHeader) internal pure returns (ConsensusState.Data memory) {\n        return\n            ConsensusState.Data({\n                timestamp: tmHeader.signed_header.header.time,\n                root: MerkleRoot.Data({hash: tmHeader.signed_header.header.app_hash}),\n                next_validators_hash: tmHeader.signed_header.header.next_validators_hash\n            });\n    }\n\n    function toVote(Commit.Data memory commit, uint256 valIdx) internal pure returns (Vote.Data memory) {\n        CommitSig.Data memory commitSig = commit.signatures[valIdx];\n\n        return\n            Vote.Data({\n                Type: TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT,\n                height: commit.height,\n                round: commit.round,\n                block_id: commit.block_id,\n                timestamp: commitSig.timestamp,\n                validator_address: commitSig.validator_address,\n                validator_index: SafeCast.toInt32(int256(valIdx)),\n                signature: commitSig.signature\n            });\n    }\n\n    function isEqual(BlockID.Data memory b1, BlockID.Data memory b2) internal pure returns (bool) {\n        if (keccak256(abi.encodePacked(b1.hash)) != keccak256(abi.encodePacked(b2.hash))) {\n            return false;\n        }\n\n        if (b1.part_set_header.total != b2.part_set_header.total) {\n            return false;\n        }\n\n        if (\n            keccak256(abi.encodePacked(b1.part_set_header.hash)) != keccak256(abi.encodePacked(b2.part_set_header.hash))\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function isEqual(ConsensusState.Data memory cs1, ConsensusState.Data memory cs2) internal pure returns (bool) {\n        return\n            keccak256(abi.encodePacked(ConsensusState.encode(cs1))) ==\n            keccak256(abi.encodePacked(ConsensusState.encode(cs2)));\n    }\n\n    function isExpired(\n        SignedHeader.Data memory header,\n        Duration.Data memory trustingPeriod,\n        Duration.Data memory currentTime\n    ) internal pure returns (bool) {\n        Timestamp.Data memory expirationTime = Timestamp.Data({\n            Seconds: header.header.time.Seconds + int64(trustingPeriod.Seconds),\n            nanos: header.header.time.nanos\n        });\n\n        return gt(Timestamp.Data({Seconds: int64(currentTime.Seconds), nanos: 0}), expirationTime);\n    }\n\n    function gt(Timestamp.Data memory t1, Timestamp.Data memory t2) internal pure returns (bool) {\n        if (t1.Seconds > t2.Seconds) {\n            return true;\n        }\n\n        if (t1.Seconds == t2.Seconds && t1.nanos > t2.nanos) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function hash(SignedHeader.Data memory h) internal pure returns (bytes32) {\n        require(h.header.validators_hash.length > 0, \"Tendermint: hash can't be empty\");\n\n        bytes memory hbz = Consensus.encode(h.header.version);\n        bytes memory pbt = Timestamp.encode(h.header.time);\n        bytes memory bzbi = BlockID.encode(h.header.last_block_id);\n\n        bytes[14] memory all = [\n            hbz,\n            Encoder.cdcEncode(h.header.chain_id),\n            Encoder.cdcEncode(h.header.height),\n            pbt,\n            bzbi,\n            Encoder.cdcEncode(h.header.last_commit_hash),\n            Encoder.cdcEncode(h.header.data_hash),\n            Encoder.cdcEncode(h.header.validators_hash),\n            Encoder.cdcEncode(h.header.next_validators_hash),\n            Encoder.cdcEncode(h.header.consensus_hash),\n            Encoder.cdcEncode(h.header.app_hash),\n            Encoder.cdcEncode(h.header.last_results_hash),\n            Encoder.cdcEncode(h.header.evidence_hash),\n            Encoder.cdcEncode(h.header.proposer_address)\n        ];\n\n        return MerkleTree.merkleRootHash(all, 0, all.length);\n    }\n\n    function hash(ValidatorSet.Data memory vs) internal pure returns (bytes32) {\n        return MerkleTree.merkleRootHash(vs.validators, 0, vs.validators.length);\n    }\n\n    function getByAddress(ValidatorSet.Data memory vals, bytes memory addr)\n        internal\n        pure\n        returns (uint256 index, bool found)\n    {\n        bytes32 addrHash = keccak256(abi.encodePacked(addr));\n        for (uint256 idx; idx < vals.validators.length; idx++) {\n            if (keccak256(abi.encodePacked(vals.validators[idx].Address)) == addrHash) {\n                return (idx, true);\n            }\n        }\n\n        return (0, false);\n    }\n\n    function getTotalVotingPower(ValidatorSet.Data memory vals) internal pure returns (int64) {\n        if (vals.total_voting_power == 0) {\n            uint256 sum = 0;\n            uint256 maxInt64 = 1 << (63 - 1);\n            uint256 maxTotalVotingPower = maxInt64 / 8;\n\n            for (uint256 i = 0; i < vals.validators.length; i++) {\n                sum += (SafeCast.toUint256(int256(vals.validators[i].voting_power)));\n                require(sum <= maxTotalVotingPower, \"total voting power should be guarded to not exceed\");\n            }\n\n            vals.total_voting_power = SafeCast.toInt64(int256(sum));\n        }\n\n        return vals.total_voting_power;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/proto/TendermintLight.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\nimport \"./ProtoBufRuntime.sol\";\nimport \"./GoogleProtobufAny.sol\";\n\nlibrary Fraction {\n    //struct definition\n    struct Data {\n        uint64 numerator;\n        uint64 denominator;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_numerator(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_denominator(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_numerator(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.numerator = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_denominator(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.denominator = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.numerator != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.numerator, pointer, bs);\n        }\n        if (r.denominator != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.denominator, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint64(r.numerator);\n        e += 1 + ProtoBufRuntime._sz_uint64(r.denominator);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.numerator != 0) {\n            return false;\n        }\n\n        if (r.denominator != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.numerator = input.numerator;\n        output.denominator = input.denominator;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Fraction\n\nlibrary Duration {\n    //struct definition\n    struct Data {\n        int64 Seconds;\n        int32 nanos;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Seconds(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nanos(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Seconds(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Seconds = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nanos(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nanos = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Seconds != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.Seconds, pointer, bs);\n        }\n        if (r.nanos != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.nanos, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_int64(r.Seconds);\n        e += 1 + ProtoBufRuntime._sz_int32(r.nanos);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Seconds != 0) {\n            return false;\n        }\n\n        if (r.nanos != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Seconds = input.Seconds;\n        output.nanos = input.nanos;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Duration\n\nlibrary Consensus {\n    //struct definition\n    struct Data {\n        uint64 block;\n        uint64 app;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_block(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_app(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.block = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_app(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.app = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.block != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.block, pointer, bs);\n        }\n        if (r.app != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.app, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint64(r.block);\n        e += 1 + ProtoBufRuntime._sz_uint64(r.app);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.block != 0) {\n            return false;\n        }\n\n        if (r.app != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.block = input.block;\n        output.app = input.app;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Consensus\n\nlibrary ClientState {\n    //struct definition\n    struct Data {\n        string chain_id;\n        Fraction.Data trust_level;\n        Duration.Data trusting_period;\n        Duration.Data unbonding_period;\n        Duration.Data max_clock_drift;\n        int64 frozen_height;\n        int64 latest_height;\n        bool allow_update_after_expiry;\n        bool allow_update_after_misbehaviour;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[10] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_trust_level(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_trusting_period(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_unbonding_period(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_max_clock_drift(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_frozen_height(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_latest_height(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_allow_update_after_expiry(pointer, bs, r, counters);\n            } else if (fieldId == 9) {\n                pointer += _read_allow_update_after_misbehaviour(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trust_level(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Fraction.Data memory x, uint256 sz) = _decode_Fraction(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.trust_level = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusting_period(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.trusting_period = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_unbonding_period(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.unbonding_period = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_clock_drift(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.max_clock_drift = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_frozen_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.frozen_height = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_latest_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.latest_height = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_allow_update_after_expiry(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bool x, uint256 sz) = ProtoBufRuntime._decode_bool(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.allow_update_after_expiry = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_allow_update_after_misbehaviour(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bool x, uint256 sz) = ProtoBufRuntime._decode_bool(p, bs);\n        if (isNil(r)) {\n            counters[9] += 1;\n        } else {\n            r.allow_update_after_misbehaviour = x;\n            if (counters[9] > 0) counters[9] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Fraction(uint256 p, bytes memory bs) internal pure returns (Fraction.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Fraction.Data memory r, ) = Fraction._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Duration(uint256 p, bytes memory bs) internal pure returns (Duration.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Duration.Data memory r, ) = Duration._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Fraction._encode_nested(r.trust_level, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.trusting_period, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.unbonding_period, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.max_clock_drift, pointer, bs);\n\n        if (r.frozen_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.frozen_height, pointer, bs);\n        }\n        if (r.latest_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.latest_height, pointer, bs);\n        }\n        if (r.allow_update_after_expiry != false) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bool(r.allow_update_after_expiry, pointer, bs);\n        }\n        if (r.allow_update_after_misbehaviour != false) {\n            pointer += ProtoBufRuntime._encode_key(9, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bool(r.allow_update_after_misbehaviour, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Fraction._estimate(r.trust_level));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.trusting_period));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.unbonding_period));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.max_clock_drift));\n        e += 1 + ProtoBufRuntime._sz_int64(r.frozen_height);\n        e += 1 + ProtoBufRuntime._sz_int64(r.latest_height);\n        e += 1 + 1;\n        e += 1 + 1;\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        if (r.frozen_height != 0) {\n            return false;\n        }\n\n        if (r.latest_height != 0) {\n            return false;\n        }\n\n        if (r.allow_update_after_expiry != false) {\n            return false;\n        }\n\n        if (r.allow_update_after_misbehaviour != false) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.chain_id = input.chain_id;\n        Fraction.store(input.trust_level, output.trust_level);\n        Duration.store(input.trusting_period, output.trusting_period);\n        Duration.store(input.unbonding_period, output.unbonding_period);\n        Duration.store(input.max_clock_drift, output.max_clock_drift);\n        output.frozen_height = input.frozen_height;\n        output.latest_height = input.latest_height;\n        output.allow_update_after_expiry = input.allow_update_after_expiry;\n        output.allow_update_after_misbehaviour = input.allow_update_after_misbehaviour;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ClientState\n\nlibrary ConsensusState {\n    //struct definition\n    struct Data {\n        Timestamp.Data timestamp;\n        MerkleRoot.Data root;\n        bytes next_validators_hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_root(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_next_validators_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_root(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (MerkleRoot.Data memory x, uint256 sz) = _decode_MerkleRoot(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.root = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_next_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.next_validators_hash = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_MerkleRoot(uint256 p, bytes memory bs) internal pure returns (MerkleRoot.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (MerkleRoot.Data memory r, ) = MerkleRoot._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += MerkleRoot._encode_nested(r.root, pointer, bs);\n\n        if (r.next_validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.next_validators_hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(MerkleRoot._estimate(r.root));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.next_validators_hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.next_validators_hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        Timestamp.store(input.timestamp, output.timestamp);\n        MerkleRoot.store(input.root, output.root);\n        output.next_validators_hash = input.next_validators_hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ConsensusState\n\nlibrary MerkleRoot {\n    //struct definition\n    struct Data {\n        bytes hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[2] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[2] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library MerkleRoot\n\nlibrary CanonicalPartSetHeader {\n    //struct definition\n    struct Data {\n        uint32 total;\n        bytes hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_total(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint32 x, uint256 sz) = ProtoBufRuntime._decode_uint32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.total = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.hash = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.total != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint32(r.total, pointer, bs);\n        }\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint32(r.total);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.total != 0) {\n            return false;\n        }\n\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.total = input.total;\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalPartSetHeader\n\nlibrary CanonicalBlockID {\n    //struct definition\n    struct Data {\n        bytes hash;\n        CanonicalPartSetHeader.Data part_set_header;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_part_set_header(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_part_set_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CanonicalPartSetHeader.Data memory x, uint256 sz) = _decode_CanonicalPartSetHeader(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.part_set_header = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CanonicalPartSetHeader(uint256 p, bytes memory bs)\n        internal\n        pure\n        returns (CanonicalPartSetHeader.Data memory, uint256)\n    {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CanonicalPartSetHeader.Data memory r, ) = CanonicalPartSetHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CanonicalPartSetHeader._encode_nested(r.part_set_header, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(CanonicalPartSetHeader._estimate(r.part_set_header));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        CanonicalPartSetHeader.store(input.part_set_header, output.part_set_header);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalBlockID\n\nlibrary CanonicalVote {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType Type;\n        int64 height;\n        int64 round;\n        CanonicalBlockID.Data block_id;\n        Timestamp.Data timestamp;\n        string chain_id;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[7] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Type(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Type(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_SignedMsgType(\n            tmp\n        );\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Type = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_sfixed64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.height = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_sfixed64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.round = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CanonicalBlockID.Data memory x, uint256 sz) = _decode_CanonicalBlockID(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CanonicalBlockID(uint256 p, bytes memory bs)\n        internal\n        pure\n        returns (CanonicalBlockID.Data memory, uint256)\n    {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CanonicalBlockID.Data memory r, ) = CanonicalBlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.Type) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_Type = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type);\n            pointer += ProtoBufRuntime._encode_enum(_enum_Type, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Fixed64, pointer, bs);\n            pointer += ProtoBufRuntime._encode_sfixed64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Fixed64, pointer, bs);\n            pointer += ProtoBufRuntime._encode_sfixed64(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CanonicalBlockID._encode_nested(r.block_id, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type));\n        e += 1 + 8;\n        e += 1 + 8;\n        e += 1 + ProtoBufRuntime._sz_lendelim(CanonicalBlockID._estimate(r.block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.Type) != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Type = input.Type;\n        output.height = input.height;\n        output.round = input.round;\n        CanonicalBlockID.store(input.block_id, output.block_id);\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.chain_id = input.chain_id;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalVote\n\nlibrary Vote {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType Type;\n        int64 height;\n        int32 round;\n        BlockID.Data block_id;\n        Timestamp.Data timestamp;\n        bytes validator_address;\n        int32 validator_index;\n        bytes signature;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[9] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Type(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_validator_address(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_validator_index(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_signature(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Type(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_SignedMsgType(\n            tmp\n        );\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Type = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.height = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.round = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.validator_address = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_index(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.validator_index = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signature(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.signature = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.Type) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_Type = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type);\n            pointer += ProtoBufRuntime._encode_enum(_enum_Type, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.block_id, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (r.validator_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validator_address, pointer, bs);\n        }\n        if (r.validator_index != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.validator_index, pointer, bs);\n        }\n        if (r.signature.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.signature, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type));\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_int32(r.round);\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validator_address.length);\n        e += 1 + ProtoBufRuntime._sz_int32(r.validator_index);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.signature.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.Type) != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (r.validator_address.length != 0) {\n            return false;\n        }\n\n        if (r.validator_index != 0) {\n            return false;\n        }\n\n        if (r.signature.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Type = input.Type;\n        output.height = input.height;\n        output.round = input.round;\n        BlockID.store(input.block_id, output.block_id);\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.validator_address = input.validator_address;\n        output.validator_index = input.validator_index;\n        output.signature = input.signature;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Vote\n\nlibrary ValidatorSet {\n    //struct definition\n    struct Data {\n        Validator.Data[] validators;\n        Validator.Data proposer;\n        int64 total_voting_power;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_validators(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_proposer(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_total_voting_power(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.validators = new Validator.Data[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_validators(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_proposer(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_total_voting_power(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validators(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Validator.Data memory x, uint256 sz) = _decode_Validator(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.validators[r.validators.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Validator.Data memory x, uint256 sz) = _decode_Validator(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.proposer = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.total_voting_power = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Validator(uint256 p, bytes memory bs) internal pure returns (Validator.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Validator.Data memory r, ) = Validator._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.validators.length != 0) {\n            for (i = 0; i < r.validators.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += Validator._encode_nested(r.validators[i], pointer, bs);\n            }\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Validator._encode_nested(r.proposer, pointer, bs);\n\n        if (r.total_voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.total_voting_power, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.validators.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(Validator._estimate(r.validators[i]));\n        }\n        e += 1 + ProtoBufRuntime._sz_lendelim(Validator._estimate(r.proposer));\n        e += 1 + ProtoBufRuntime._sz_int64(r.total_voting_power);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.validators.length != 0) {\n            return false;\n        }\n\n        if (r.total_voting_power != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.validators.length; i1++) {\n            output.validators.push(input.validators[i1]);\n        }\n\n        Validator.store(input.proposer, output.proposer);\n        output.total_voting_power = input.total_voting_power;\n    }\n\n    //array helpers for Validators\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addValidators(Data memory self, Validator.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        Validator.Data[] memory tmp = new Validator.Data[](self.validators.length + 1);\n        for (uint256 i = 0; i < self.validators.length; i++) {\n            tmp[i] = self.validators[i];\n        }\n        tmp[self.validators.length] = value;\n        self.validators = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ValidatorSet\n\nlibrary Validator {\n    //struct definition\n    struct Data {\n        bytes Address;\n        PublicKey.Data pub_key;\n        int64 voting_power;\n        int64 proposer_priority;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Address(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_pub_key(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_voting_power(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_proposer_priority(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Address = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_pub_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PublicKey.Data memory x, uint256 sz) = _decode_PublicKey(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.pub_key = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.voting_power = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer_priority(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.proposer_priority = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PublicKey(uint256 p, bytes memory bs) internal pure returns (PublicKey.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PublicKey.Data memory r, ) = PublicKey._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.Address, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PublicKey._encode_nested(r.pub_key, pointer, bs);\n\n        if (r.voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.voting_power, pointer, bs);\n        }\n        if (r.proposer_priority != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.proposer_priority, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.Address.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(PublicKey._estimate(r.pub_key));\n        e += 1 + ProtoBufRuntime._sz_int64(r.voting_power);\n        e += 1 + ProtoBufRuntime._sz_int64(r.proposer_priority);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Address.length != 0) {\n            return false;\n        }\n\n        if (r.voting_power != 0) {\n            return false;\n        }\n\n        if (r.proposer_priority != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Address = input.Address;\n        PublicKey.store(input.pub_key, output.pub_key);\n        output.voting_power = input.voting_power;\n        output.proposer_priority = input.proposer_priority;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Validator\n\nlibrary SimpleValidator {\n    //struct definition\n    struct Data {\n        PublicKey.Data pub_key;\n        int64 voting_power;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_pub_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_voting_power(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_pub_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PublicKey.Data memory x, uint256 sz) = _decode_PublicKey(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.pub_key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.voting_power = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PublicKey(uint256 p, bytes memory bs) internal pure returns (PublicKey.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PublicKey.Data memory r, ) = PublicKey._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PublicKey._encode_nested(r.pub_key, pointer, bs);\n\n        if (r.voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.voting_power, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(PublicKey._estimate(r.pub_key));\n        e += 1 + ProtoBufRuntime._sz_int64(r.voting_power);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.voting_power != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        PublicKey.store(input.pub_key, output.pub_key);\n        output.voting_power = input.voting_power;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library SimpleValidator\n\nlibrary PublicKey {\n    //struct definition\n    struct Data {\n        bytes ed25519;\n        bytes secp256k1;\n        bytes sr25519;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_ed25519(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_secp256k1(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_sr25519(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_ed25519(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.ed25519 = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_secp256k1(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.secp256k1 = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_sr25519(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.sr25519 = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.ed25519.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.ed25519, pointer, bs);\n        }\n        if (r.secp256k1.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.secp256k1, pointer, bs);\n        }\n        if (r.sr25519.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.sr25519, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.ed25519.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.secp256k1.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.sr25519.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.ed25519.length != 0) {\n            return false;\n        }\n\n        if (r.secp256k1.length != 0) {\n            return false;\n        }\n\n        if (r.sr25519.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.ed25519 = input.ed25519;\n        output.secp256k1 = input.secp256k1;\n        output.sr25519 = input.sr25519;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library PublicKey\n\nlibrary PartSetHeader {\n    //struct definition\n    struct Data {\n        uint32 total;\n        bytes hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_total(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint32 x, uint256 sz) = ProtoBufRuntime._decode_uint32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.total = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.hash = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.total != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint32(r.total, pointer, bs);\n        }\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint32(r.total);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.total != 0) {\n            return false;\n        }\n\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.total = input.total;\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library PartSetHeader\n\nlibrary BlockID {\n    //struct definition\n    struct Data {\n        bytes hash;\n        PartSetHeader.Data part_set_header;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_part_set_header(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_part_set_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PartSetHeader.Data memory x, uint256 sz) = _decode_PartSetHeader(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.part_set_header = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PartSetHeader(uint256 p, bytes memory bs)\n        internal\n        pure\n        returns (PartSetHeader.Data memory, uint256)\n    {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PartSetHeader.Data memory r, ) = PartSetHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PartSetHeader._encode_nested(r.part_set_header, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(PartSetHeader._estimate(r.part_set_header));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        PartSetHeader.store(input.part_set_header, output.part_set_header);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BlockID\n\nlibrary Commit {\n    //struct definition\n    struct Data {\n        int64 height;\n        int32 round;\n        BlockID.Data block_id;\n        CommitSig.Data[] signatures;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signatures(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.signatures = new CommitSig.Data[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_height(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_round(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_block_id(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signatures(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.height = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.round = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signatures(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CommitSig.Data memory x, uint256 sz) = _decode_CommitSig(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.signatures[r.signatures.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CommitSig(uint256 p, bytes memory bs) internal pure returns (CommitSig.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CommitSig.Data memory r, ) = CommitSig._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.block_id, pointer, bs);\n\n        if (r.signatures.length != 0) {\n            for (i = 0; i < r.signatures.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += CommitSig._encode_nested(r.signatures[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_int32(r.round);\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.block_id));\n        for (i = 0; i < r.signatures.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(CommitSig._estimate(r.signatures[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (r.signatures.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.height = input.height;\n        output.round = input.round;\n        BlockID.store(input.block_id, output.block_id);\n\n        for (uint256 i4 = 0; i4 < input.signatures.length; i4++) {\n            output.signatures.push(input.signatures[i4]);\n        }\n    }\n\n    //array helpers for Signatures\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addSignatures(Data memory self, CommitSig.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        CommitSig.Data[] memory tmp = new CommitSig.Data[](self.signatures.length + 1);\n        for (uint256 i = 0; i < self.signatures.length; i++) {\n            tmp[i] = self.signatures[i];\n        }\n        tmp[self.signatures.length] = value;\n        self.signatures = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Commit\n\nlibrary CommitSig {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag block_id_flag;\n        bytes validator_address;\n        Timestamp.Data timestamp;\n        bytes signature;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_block_id_flag(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_validator_address(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signature(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id_flag(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_BlockIDFlag(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.block_id_flag = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.validator_address = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signature(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.signature = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.block_id_flag) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_block_id_flag = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_BlockIDFlag(r.block_id_flag);\n            pointer += ProtoBufRuntime._encode_enum(_enum_block_id_flag, pointer, bs);\n        }\n        if (r.validator_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validator_address, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (r.signature.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.signature, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_BlockIDFlag(r.block_id_flag));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validator_address.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.signature.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.block_id_flag) != 0) {\n            return false;\n        }\n\n        if (r.validator_address.length != 0) {\n            return false;\n        }\n\n        if (r.signature.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.block_id_flag = input.block_id_flag;\n        output.validator_address = input.validator_address;\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.signature = input.signature;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CommitSig\n\nlibrary Timestamp {\n    //struct definition\n    struct Data {\n        int64 Seconds;\n        int32 nanos;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Seconds(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nanos(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Seconds(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Seconds = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nanos(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nanos = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Seconds != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.Seconds, pointer, bs);\n        }\n        if (r.nanos != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.nanos, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_int64(r.Seconds);\n        e += 1 + ProtoBufRuntime._sz_int32(r.nanos);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Seconds != 0) {\n            return false;\n        }\n\n        if (r.nanos != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Seconds = input.Seconds;\n        output.nanos = input.nanos;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Timestamp\n\nlibrary LightHeader {\n    //struct definition\n    struct Data {\n        Consensus.Data version;\n        string chain_id;\n        int64 height;\n        Timestamp.Data time;\n        BlockID.Data last_block_id;\n        bytes last_commit_hash;\n        bytes data_hash;\n        bytes validators_hash;\n        bytes next_validators_hash;\n        bytes consensus_hash;\n        bytes app_hash;\n        bytes last_results_hash;\n        bytes evidence_hash;\n        bytes proposer_address;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[15] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_version(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_time(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_last_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_last_commit_hash(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_data_hash(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_validators_hash(pointer, bs, r, counters);\n            } else if (fieldId == 9) {\n                pointer += _read_next_validators_hash(pointer, bs, r, counters);\n            } else if (fieldId == 10) {\n                pointer += _read_consensus_hash(pointer, bs, r, counters);\n            } else if (fieldId == 11) {\n                pointer += _read_app_hash(pointer, bs, r, counters);\n            } else if (fieldId == 12) {\n                pointer += _read_last_results_hash(pointer, bs, r, counters);\n            } else if (fieldId == 13) {\n                pointer += _read_evidence_hash(pointer, bs, r, counters);\n            } else if (fieldId == 14) {\n                pointer += _read_proposer_address(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_version(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Consensus.Data memory x, uint256 sz) = _decode_Consensus(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.version = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.height = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_time(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.time = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.last_block_id = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_commit_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.last_commit_hash = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_data_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.data_hash = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.validators_hash = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_next_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[9] += 1;\n        } else {\n            r.next_validators_hash = x;\n            if (counters[9] > 0) counters[9] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_consensus_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[10] += 1;\n        } else {\n            r.consensus_hash = x;\n            if (counters[10] > 0) counters[10] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_app_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[11] += 1;\n        } else {\n            r.app_hash = x;\n            if (counters[11] > 0) counters[11] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_results_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[12] += 1;\n        } else {\n            r.last_results_hash = x;\n            if (counters[12] > 0) counters[12] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_evidence_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[13] += 1;\n        } else {\n            r.evidence_hash = x;\n            if (counters[13] > 0) counters[13] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[14] += 1;\n        } else {\n            r.proposer_address = x;\n            if (counters[14] > 0) counters[14] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Consensus(uint256 p, bytes memory bs) internal pure returns (Consensus.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Consensus.Data memory r, ) = Consensus._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Consensus._encode_nested(r.version, pointer, bs);\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.time, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.last_block_id, pointer, bs);\n\n        if (r.last_commit_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.last_commit_hash, pointer, bs);\n        }\n        if (r.data_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.data_hash, pointer, bs);\n        }\n        if (r.validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validators_hash, pointer, bs);\n        }\n        if (r.next_validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(9, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.next_validators_hash, pointer, bs);\n        }\n        if (r.consensus_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(10, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.consensus_hash, pointer, bs);\n        }\n        if (r.app_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(11, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.app_hash, pointer, bs);\n        }\n        if (r.last_results_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(12, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.last_results_hash, pointer, bs);\n        }\n        if (r.evidence_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(13, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.evidence_hash, pointer, bs);\n        }\n        if (r.proposer_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(14, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.proposer_address, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(Consensus._estimate(r.version));\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.time));\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.last_block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.last_commit_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.data_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validators_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.next_validators_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.consensus_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.app_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.last_results_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.evidence_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.proposer_address.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.last_commit_hash.length != 0) {\n            return false;\n        }\n\n        if (r.data_hash.length != 0) {\n            return false;\n        }\n\n        if (r.validators_hash.length != 0) {\n            return false;\n        }\n\n        if (r.next_validators_hash.length != 0) {\n            return false;\n        }\n\n        if (r.consensus_hash.length != 0) {\n            return false;\n        }\n\n        if (r.app_hash.length != 0) {\n            return false;\n        }\n\n        if (r.last_results_hash.length != 0) {\n            return false;\n        }\n\n        if (r.evidence_hash.length != 0) {\n            return false;\n        }\n\n        if (r.proposer_address.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        Consensus.store(input.version, output.version);\n        output.chain_id = input.chain_id;\n        output.height = input.height;\n        Timestamp.store(input.time, output.time);\n        BlockID.store(input.last_block_id, output.last_block_id);\n        output.last_commit_hash = input.last_commit_hash;\n        output.data_hash = input.data_hash;\n        output.validators_hash = input.validators_hash;\n        output.next_validators_hash = input.next_validators_hash;\n        output.consensus_hash = input.consensus_hash;\n        output.app_hash = input.app_hash;\n        output.last_results_hash = input.last_results_hash;\n        output.evidence_hash = input.evidence_hash;\n        output.proposer_address = input.proposer_address;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library LightHeader\n\nlibrary SignedHeader {\n    //struct definition\n    struct Data {\n        LightHeader.Data header;\n        Commit.Data commit;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_header(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_commit(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LightHeader.Data memory x, uint256 sz) = _decode_LightHeader(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.header = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_commit(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Commit.Data memory x, uint256 sz) = _decode_Commit(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.commit = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LightHeader(uint256 p, bytes memory bs) internal pure returns (LightHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LightHeader.Data memory r, ) = LightHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Commit(uint256 p, bytes memory bs) internal pure returns (Commit.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Commit.Data memory r, ) = Commit._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LightHeader._encode_nested(r.header, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Commit._encode_nested(r.commit, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(LightHeader._estimate(r.header));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Commit._estimate(r.commit));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        LightHeader.store(input.header, output.header);\n        Commit.store(input.commit, output.commit);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library SignedHeader\n\nlibrary TmHeader {\n    //struct definition\n    struct Data {\n        SignedHeader.Data signed_header;\n        ValidatorSet.Data validator_set;\n        int64 trusted_height;\n        ValidatorSet.Data trusted_validators;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_signed_header(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_validator_set(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_trusted_height(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_trusted_validators(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signed_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (SignedHeader.Data memory x, uint256 sz) = _decode_SignedHeader(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.signed_header = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_set(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ValidatorSet.Data memory x, uint256 sz) = _decode_ValidatorSet(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.validator_set = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusted_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.trusted_height = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusted_validators(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ValidatorSet.Data memory x, uint256 sz) = _decode_ValidatorSet(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.trusted_validators = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_SignedHeader(uint256 p, bytes memory bs)\n        internal\n        pure\n        returns (SignedHeader.Data memory, uint256)\n    {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (SignedHeader.Data memory r, ) = SignedHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ValidatorSet(uint256 p, bytes memory bs)\n        internal\n        pure\n        returns (ValidatorSet.Data memory, uint256)\n    {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ValidatorSet.Data memory r, ) = ValidatorSet._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += SignedHeader._encode_nested(r.signed_header, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ValidatorSet._encode_nested(r.validator_set, pointer, bs);\n\n        if (r.trusted_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.trusted_height, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ValidatorSet._encode_nested(r.trusted_validators, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(\n        Data memory r,\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(SignedHeader._estimate(r.signed_header));\n        e += 1 + ProtoBufRuntime._sz_lendelim(ValidatorSet._estimate(r.validator_set));\n        e += 1 + ProtoBufRuntime._sz_int64(r.trusted_height);\n        e += 1 + ProtoBufRuntime._sz_lendelim(ValidatorSet._estimate(r.trusted_validators));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.trusted_height != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        SignedHeader.store(input.signed_header, output.signed_header);\n        ValidatorSet.store(input.validator_set, output.validator_set);\n        output.trusted_height = input.trusted_height;\n        ValidatorSet.store(input.trusted_validators, output.trusted_validators);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library TmHeader\n\nlibrary TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS {\n    //enum definition\n    // Solidity enum definitions\n    enum BlockIDFlag {\n        BLOCK_ID_FLAG_UNKNOWN,\n        BLOCK_ID_FLAG_ABSENT,\n        BLOCK_ID_FLAG_COMMIT,\n        BLOCK_ID_FLAG_NIL\n    }\n\n    // Solidity enum encoder\n    function encode_BlockIDFlag(BlockIDFlag x) internal pure returns (int32) {\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN) {\n            return 0;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_ABSENT) {\n            return 1;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_COMMIT) {\n            return 2;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_NIL) {\n            return 3;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_BlockIDFlag(int64 x) internal pure returns (BlockIDFlag) {\n        if (x == 0) {\n            return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;\n        }\n\n        if (x == 1) {\n            return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;\n        }\n\n        if (x == 2) {\n            return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;\n        }\n\n        if (x == 3) {\n            return BlockIDFlag.BLOCK_ID_FLAG_NIL;\n        }\n        revert();\n    }\n\n    // Solidity enum definitions\n    enum SignedMsgType {\n        SIGNED_MSG_TYPE_UNKNOWN,\n        SIGNED_MSG_TYPE_PREVOTE,\n        SIGNED_MSG_TYPE_PRECOMMIT,\n        SIGNED_MSG_TYPE_PROPOSAL\n    }\n\n    // Solidity enum encoder\n    function encode_SignedMsgType(SignedMsgType x) internal pure returns (int32) {\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN) {\n            return 0;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PREVOTE) {\n            return 1;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT) {\n            return 2;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL) {\n            return 32;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_SignedMsgType(int64 x) internal pure returns (SignedMsgType) {\n        if (x == 0) {\n            return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;\n        }\n\n        if (x == 1) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;\n        }\n\n        if (x == 2) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;\n        }\n\n        if (x == 32) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;\n        }\n        revert();\n    }\n}\n//library TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS\n"
    },
    "contracts/bsc-tendermint/System.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract System is Ownable {\n    uint32 public constant CODE_OK = 0;\n    uint32 public constant ERROR_FAIL_DECODE = 100;\n\n    uint8 public constant STAKING_CHANNEL_ID = 0x08;\n\n    address public bscValidatorSet;\n    address public tmLightClient;\n    address public crossChain;\n\n    uint16 public bscChainID;\n    address public relayer;\n\n    constructor(uint16 _bscChainID, address _relayer) {\n        bscChainID = _bscChainID;\n        relayer = _relayer;\n    }\n\n    function setBscValidatorSet(address _bscValidatorSet) external onlyOwner {\n        bscValidatorSet = _bscValidatorSet;\n    }\n\n    function setTmLightClient(address _tmLightClient) external onlyOwner {\n        tmLightClient = _tmLightClient;\n    }\n\n    function setCrossChain(address _crossChain) external onlyOwner {\n        crossChain = _crossChain;\n    }\n\n    function setRelayer(address _relayer) external onlyOwner {\n        relayer = _relayer;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/TendermintLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./lib/Memory.sol\";\nimport \"./lib/BytesToTypes.sol\";\nimport \"./interface/ITendermintLightClient.sol\";\nimport \"./System.sol\";\nimport \"./utils/Tendermint.sol\";\nimport {GoogleProtobufAny as Any} from \"./proto/GoogleProtobufAny.sol\";\nimport {LightHeader, ValidatorSet, ConsensusState, TmHeader} from \"./proto/TendermintLight.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TendermintLightClient is ITendermintLightClient {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for TmHeader.Data;\n    using TendermintHelper for ConsensusState.Data;\n    using TendermintHelper for ValidatorSet.Data;\n\n    struct ProtoTypes {\n        bytes32 consensusState;\n        bytes32 tmHeader;\n    }\n\n    ProtoTypes private _pts;\n    mapping(uint64 => ConsensusState.Data) public consensusStates;\n    mapping(uint64 => bool) public synced;\n    uint64 public initialHeight;\n    uint64 public latestHeight;\n    System private system;\n\n    event ConsensusStateInit(uint64 initialHeight, bytes32 appHash);\n    event ConsensusStateSynced(uint64 height, bytes32 appHash);\n\n    constructor(address _system, bytes memory _initHeader) {\n        _pts = ProtoTypes({\n            consensusState: keccak256(abi.encodePacked(\"/tendermint.types.ConsensusState\")),\n            tmHeader: keccak256(abi.encodePacked(\"/tendermint.types.TmHeader\"))\n        });\n\n        system = System(_system);\n\n        (TmHeader.Data memory tmHeader, bool ok) = unmarshalTmHeader(_initHeader);\n        require(ok, \"LC: light block is invalid\");\n\n        uint64 height = uint64(tmHeader.signed_header.header.height);\n        ConsensusState.Data memory cs = tmHeader.toConsensusState();\n        consensusStates[height] = cs;\n\n        initialHeight = height;\n        latestHeight = height;\n\n        emit ConsensusStateInit(initialHeight, bytes32(cs.root.hash));\n    }\n\n    function syncTendermintHeader(\n        bytes calldata header,\n        // TODO: Decide on proof interface\n        bytes memory sigsProof\n    ) external returns (bool) {\n        require(msg.sender == system.relayer(), \"not relayer\");\n\n        (TmHeader.Data memory tmHeader, bool ok) = unmarshalTmHeader(header);\n        require(ok, \"LC: light block is invalid\");\n\n        uint64 height = uint64(tmHeader.signed_header.header.height);\n        require(!synced[height], \"can't sync duplicated header\");\n        // assert header height is newer than consensus state\n        require(height > latestHeight, \"LC: header height not newer than consensus state height\");\n\n        checkValidity(consensusStates[latestHeight], tmHeader);\n\n        synced[height] = true;\n\n        // Store new cs\n        ConsensusState.Data memory cs = tmHeader.toConsensusState();\n        consensusStates[height] = cs;\n\n        emit ConsensusStateSynced(height, bytes32(cs.root.hash));\n\n        return true;\n    }\n\n    // checkValidity checks if the Tendermint header is valid.\n    function checkValidity(ConsensusState.Data memory trustedConsensusState, TmHeader.Data memory tmHeader)\n        private\n        view\n    {\n        LightHeader.Data memory lc;\n        lc.chain_id = tmHeader.signed_header.header.chain_id;\n        lc.height = int64(latestHeight);\n        lc.next_validators_hash = trustedConsensusState.next_validators_hash;\n\n        SignedHeader.Data memory trustedHeader;\n        trustedHeader.header = lc;\n\n        SignedHeader.Data memory untrustedHeader = tmHeader.signed_header;\n        ValidatorSet.Data memory untrustedVals = tmHeader.validator_set;\n\n        bool ok = Tendermint.verify(trustedHeader, untrustedHeader, untrustedVals);\n\n        require(ok, \"LC: failed to verify header\");\n    }\n\n    function isHeaderSynced(uint64 height) external view override returns (bool) {\n        return synced[height] || height == initialHeight;\n    }\n\n    function getAppHash(uint64 height) external view override returns (bytes32) {\n        return bytes32(consensusStates[height].root.hash);\n    }\n\n    function unmarshalTmHeader(bytes memory bz) internal view returns (TmHeader.Data memory header, bool ok) {\n        Any.Data memory anyHeader = Any.decode(bz);\n        if (keccak256(abi.encodePacked(anyHeader.type_url)) != _pts.tmHeader) {\n            return (header, false);\n        }\n        return (TmHeader.decode(anyHeader.value), true);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/utils/Bytes.sol": {
      "content": "// SPDX-License-Identifier: TBD\npragma solidity ^0.8.2;\n\nlibrary Bytes {\n    function toBytes32(bytes memory bz) internal pure returns (bytes32 ret) {\n        require(bz.length == 32, \"Bytes: toBytes32 invalid size\");\n        assembly {\n            ret := mload(add(bz, 32))\n        }\n    }\n\n    function toBytes(bytes32 data) public pure returns (bytes memory) {\n        return abi.encodePacked(data);\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64 ret) {\n        require(_bytes.length >= _start + 8, \"Bytes: toUint64 out of bounds\");\n        assembly {\n            ret := mload(add(add(_bytes, 0x8), _start))\n        }\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"Bytes: toUint256 out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAddress(bytes memory _bytes) internal pure returns (address addr) {\n        // convert last 20 bytes of keccak hash (bytes32) to address\n        bytes32 hash = keccak256(_bytes);\n        assembly {\n            mstore(0, hash)\n            addr := mload(0)\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/utils/crypto/Ed25519.sol": {
      "content": "// SPDX-License-Identifier: TBD\npragma solidity ^0.8.2;\n\nlibrary Ed25519 {\n    uint256 private constant _CELO_ED25519_PRECOMPILE_ADDR = 0xf3;\n\n    /**\n     * @dev verifies the ed25519 signature against the public key and message\n     * This method works only with Celo Blockchain, by calling the ed25519 precompile (currently unavailable in vanilla EVM)\n     *\n     * See: tendermint/crypto/secp256k1/secp256k1_nocgo.go (Sign, Verify methods)\n     */\n    function verify(\n        bytes memory message,\n        bytes memory publicKey,\n        bytes memory signature\n    ) internal view returns (bool) {\n        require(signature.length == 64, \"Ed25519: siganture length != 64\");\n        require(publicKey.length == 32, \"Ed25519: pubkey length != 32\");\n\n        bytes memory all = abi.encodePacked(publicKey, signature, message);\n        bytes32 result = 0x0000000000000000000000000000000000000000000000000000000000000001;\n\n        assembly {\n            let success := staticcall(gas(), _CELO_ED25519_PRECOMPILE_ADDR, add(all, 0x20), mload(all), result, 0x20)\n\n            switch success\n            case 0 {\n                revert(0, \"ed25519 precompile failed\")\n            }\n            default {\n                result := mload(result)\n            }\n        }\n\n        // result > 0 is an error\n        return (bytes32(0x0000000000000000000000000000000000000000000000000000000000000000) == result);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/utils/crypto/MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: TBD\npragma solidity ^0.8.2;\n\nimport \"../../proto/TendermintHelper.sol\";\nimport {SimpleValidator, Validator} from \"../../proto/TendermintLight.sol\";\n\nlibrary MerkleTree {\n    /**\n     * @dev returns empty hash\n     */\n    function emptyHash() internal pure returns (bytes32) {\n        return sha256(abi.encode());\n    }\n\n    /**\n     * @dev returns tmhash(0x00 || leaf)\n     *\n     */\n    function leafHash(bytes memory leaf) internal pure returns (bytes32) {\n        uint8 leafPrefix = 0x00;\n        return sha256(abi.encodePacked(leafPrefix, leaf));\n    }\n\n    /**\n     * @dev returns tmhash(0x01 || left || right)\n     */\n    function innerHash(bytes32 leaf, bytes32 right) internal pure returns (bytes32) {\n        uint8 innerPrefix = 0x01;\n        return sha256(abi.encodePacked(innerPrefix, leaf, right));\n    }\n\n    /**\n     * @dev returns the largest power of 2 less than length\n     *\n     * TODO: This function can be optimized with bit shifting approach:\n     * https://www.baeldung.com/java-largest-power-of-2-less-than-number\n     */\n    function getSplitPoint(uint256 input) internal pure returns (uint256) {\n        require(input > 1, \"MerkleTree: invalid input\");\n\n        uint256 result = 1;\n        for (uint256 i = input - 1; i > 1; i--) {\n            if ((i & (i - 1)) == 0) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev computes a Merkle tree where the leaves are validators, in the provided order\n     * Follows RFC-6962\n     */\n    function merkleRootHash(\n        Validator.Data[] memory validators,\n        uint256 start,\n        uint256 total\n    ) internal pure returns (bytes32) {\n        if (total == 0) {\n            return emptyHash();\n        } else if (total == 1) {\n            bytes memory encodedValidator = SimpleValidator.encode(\n                TendermintHelper.toSimpleValidator(validators[start])\n            );\n            return leafHash(encodedValidator);\n        } else {\n            uint256 k = getSplitPoint(total);\n            bytes32 left = merkleRootHash(validators, start, k); // validators[:k]\n            bytes32 right = merkleRootHash(validators, start + k, total - k); // validators[k:]\n            return innerHash(left, right);\n        }\n    }\n\n    /**\n     * @dev computes a Merkle tree where the leaves are the byte slice in the provided order\n     * Follows RFC-6962\n     */\n    function merkleRootHash(\n        bytes[14] memory validators,\n        uint256 start,\n        uint256 total\n    ) internal pure returns (bytes32) {\n        if (total == 0) {\n            return emptyHash();\n        } else if (total == 1) {\n            return leafHash(validators[start]);\n        } else {\n            uint256 k = getSplitPoint(total);\n            bytes32 left = merkleRootHash(validators, start, k); // validators[:k]\n            bytes32 right = merkleRootHash(validators, start + k, total - k); // validators[k:]\n            return innerHash(left, right);\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/utils/Tendermint.sol": {
      "content": "// SPDX-License-Identifier: TBD\npragma solidity ^0.8.2;\n\nimport {TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS, SignedHeader, BlockID, Timestamp, ValidatorSet, Duration, Fraction, Commit, Validator, CommitSig, CanonicalVote, Vote} from \"../proto/TendermintLight.sol\";\nimport \"../proto/TendermintHelper.sol\";\nimport \"../proto/Encoder.sol\";\nimport \"./crypto/Ed25519.sol\";\nimport \"./Bytes.sol\";\n\nlibrary Tendermint {\n    using Bytes for bytes;\n    using TendermintHelper for ValidatorSet.Data;\n    using TendermintHelper for SignedHeader.Data;\n    using TendermintHelper for Timestamp.Data;\n    using TendermintHelper for BlockID.Data;\n    using TendermintHelper for Commit.Data;\n    using TendermintHelper for Vote.Data;\n\n    function verify(\n        SignedHeader.Data memory trustedHeader,\n        SignedHeader.Data memory untrustedHeader,\n        ValidatorSet.Data memory untrustedVals\n    ) internal view returns (bool) {\n        verifyNewHeaderAndVals(untrustedHeader, untrustedVals, trustedHeader);\n\n        // Check the validator hashes are the same\n        require(\n            untrustedHeader.header.validators_hash.toBytes32() == trustedHeader.header.next_validators_hash.toBytes32(),\n            \"expected old header next validators to match those from new header\"\n        );\n\n        // Ensure that +2/3 of new validators signed correctly.\n        bool ok = verifyCommitLight(\n            untrustedVals,\n            trustedHeader.header.chain_id,\n            untrustedHeader.commit.block_id,\n            untrustedHeader.header.height,\n            untrustedHeader.commit\n        );\n\n        return ok;\n    }\n\n    function verifyNewHeaderAndVals(\n        SignedHeader.Data memory untrustedHeader,\n        ValidatorSet.Data memory untrustedVals,\n        SignedHeader.Data memory trustedHeader\n    ) internal pure {\n        // SignedHeader validate basic\n        require(\n            keccak256(abi.encodePacked(untrustedHeader.header.chain_id)) ==\n                keccak256(abi.encodePacked(trustedHeader.header.chain_id)),\n            \"header belongs to another chain\"\n        );\n        require(untrustedHeader.commit.height == untrustedHeader.header.height, \"header and commit height mismatch\");\n\n        bytes32 untrustedHeaderBlockHash = untrustedHeader.hash();\n        require(\n            untrustedHeaderBlockHash == untrustedHeader.commit.block_id.hash.toBytes32(),\n            \"commit signs signs block failed\"\n        );\n\n        require(\n            untrustedHeader.header.height > trustedHeader.header.height,\n            \"expected new header height to be greater than one of old header\"\n        );\n\n        // Skip time verification for now\n\n        bytes32 validatorsHash = untrustedVals.hash();\n        require(\n            untrustedHeader.header.validators_hash.toBytes32() == validatorsHash,\n            \"expected new header validators to match those that were supplied at height XX\"\n        );\n    }\n\n    // VerifyCommitLight verifies +2/3 of the set had signed the given commit.\n    //\n    // This method is primarily used by the light client and does not check all the\n    // signatures.\n    function verifyCommitLight(\n        ValidatorSet.Data memory vals,\n        string memory chainID,\n        BlockID.Data memory blockID,\n        int64 height,\n        Commit.Data memory commit\n    ) internal view returns (bool) {\n        require(vals.validators.length == commit.signatures.length, \"invalid commit signatures\");\n\n        require(height == commit.height, \"invalid commit height\");\n\n        require(commit.block_id.isEqual(blockID), \"invalid commit -- wrong block ID\");\n\n        Validator.Data memory val;\n        CommitSig.Data memory commitSig;\n\n        int64 talliedVotingPower = 0;\n        int64 votingPowerNeeded = (vals.getTotalVotingPower() * 2) / 3;\n\n        for (uint256 i = 0; i < commit.signatures.length; i++) {\n            commitSig = commit.signatures[i];\n\n            // no need to verify absent or nil votes.\n            if (commitSig.block_id_flag != TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag.BLOCK_ID_FLAG_COMMIT) {\n                continue;\n            }\n\n            val = vals.validators[i];\n\n            // validate signature\n            bytes memory message = Encoder.encodeDelim(voteSignBytes(commit, chainID, i));\n            bytes memory sig = commitSig.signature;\n\n            if (!verifySig(val, message, sig)) {\n                return false;\n            }\n\n            talliedVotingPower += val.voting_power;\n\n            if (talliedVotingPower > votingPowerNeeded) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function verifySig(\n        Validator.Data memory val,\n        bytes memory message,\n        bytes memory sig\n    ) internal view returns (bool) {\n        bytes memory pubkey;\n\n        // TODO: Use zk proof\n        require(val.pub_key.ed25519.length > 0, \"empty signature\");\n        pubkey = val.pub_key.ed25519;\n        return Ed25519.verify(message, pubkey, sig);\n    }\n\n    function voteSignBytes(\n        Commit.Data memory commit,\n        string memory chainID,\n        uint256 idx\n    ) internal pure returns (bytes memory) {\n        Vote.Data memory vote;\n        vote = commit.toVote(idx);\n\n        return (CanonicalVote.encode(vote.toCanonicalVote(chainID)));\n    }\n\n    function voteSignBytesDelim(\n        Commit.Data memory commit,\n        string memory chainID,\n        uint256 idx\n    ) internal pure returns (bytes memory) {\n        return Encoder.encodeDelim(voteSignBytes(commit, chainID, idx));\n    }\n}\n"
    },
    "contracts/interfaces/IEthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\ninterface IEthereumLightClient {\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n}\n"
    },
    "contracts/interfaces/ITendermintLightClient.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\ninterface ITendermintLightClient {\n    function validateSigner(address signer) external view returns (bool valid);\n}\n"
    },
    "contracts/light-client/Constants.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\n// light client security params\nuint256 constant MIN_SYNC_COMMITTEE_PARTICIPANTS = 1;\nuint256 constant UPDATE_TIMEOUT = 86400;\n\n// beacon chain constants\nuint256 constant FINALIZED_ROOT_INDEX = 105;\nuint256 constant NEXT_SYNC_COMMITTEE_INDEX = 55;\nuint256 constant EXECUTION_STATE_ROOT_INDEX = 898;\n// uint256 constant EXECUTION_STATE_ROOT_INDEX = 402;\nuint256 constant SYNC_COMMITTEE_SIZE = 512;\nuint64 constant SLOTS_PER_EPOCH = 32;\nuint64 constant EPOCHS_PER_SYNC_COMMITTEE_PERIOD = 256;\nbytes32 constant DOMAIN_SYNC_COMMITTEE = bytes32(uint256(0x07000000));\nuint256 constant SLOT_LENGTH_SECONDS = 12;\n"
    },
    "contracts/light-client/EthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IEthereumLightClient.sol\";\n\nimport \"./LightClientStore.sol\";\nimport \"./ZkVerifier.sol\";\nimport \"./SSZ.sol\";\nimport \"./Constants.sol\";\nimport \"./Types.sol\";\n\ncontract EthereumLightClient is IEthereumLightClient, LightClientStore, Ownable {\n    event HeaderUpdated(uint256 slot, bytes32 stateRoot, bytes32 executionStateRoot, bool finalized);\n    event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot);\n    event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion);\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        BeaconBlockHeader memory _finalizedHeader,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot\n    )\n        LightClientStore(\n            genesisTime,\n            genesisValidatorsRoot,\n            _forkEpochs,\n            _forkVersions,\n            _finalizedHeader,\n            syncCommitteeRoot,\n            syncCommitteePoseidonRoot\n        )\n    {}\n\n    function latestFinalizedSlotAndCommitteeRoots() external view returns (uint64 slot, bytes32 currentRoot, bytes32 nextRoot) {\n        return (finalizedHeader.slot, currentSyncCommitteeRoot, nextSyncCommitteeRoot);\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (finalizedExecutionStateRoot, finalizedExecutionStateRootSlot);\n    }\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (optimisticExecutionStateRoot, optimisticExecutionStateRootSlot);\n    }\n\n    function updateForkVersion(uint64 epoch, bytes4 forkVersion) external onlyOwner {\n        require(forkVersion != bytes4(0), \"invalid fork version\");\n        forkEpochs.push(epoch);\n        forkVersions.push(forkVersion);\n        emit ForkVersionUpdated(epoch, forkVersion);\n    }\n\n    function processLightClientFinalityUpdate(LightClientFinalityUpdate memory u) external {\n        LightClientUpdate memory update = LightClientUpdate({\n            attestedHeader: u.attestedHeader,\n            finalizedHeader: u.finalizedHeader,\n            finalityBranch: u.finalityBranch,\n            finalizedExecutionStateRoot: u.finalizedExecutionStateRoot,\n            finalizedExecutionStateRootBranch: u.finalizedExecutionStateRootBranch,\n            syncAggregate: u.syncAggregate,\n            signatureSlot: u.signatureSlot,\n            // irrelavant fields\n            optimisticExecutionStateRoot: bytes32(0),\n            optimisticdExecutionStateRootBranch: new bytes32[](0),\n            nextSyncCommitteeRoot: bytes32(0),\n            nextSyncCommitteeBranch: new bytes32[](0),\n            nextSyncCommitteePoseidonRoot: bytes32(0),\n            nextSyncCommitteeRootMappingProof: emptyProof()\n        });\n        processLightClientUpdate(update);\n    }\n\n    function processLightClientOptimisticUpdate(LightClientOptimisticUpdate memory u) external {\n        LightClientUpdate memory update = LightClientUpdate({\n            attestedHeader: u.attestedHeader,\n            finalizedHeader: emptyBeaconBlockHeader(),\n            optimisticExecutionStateRoot: u.optimisticExecutionStateRoot,\n            optimisticdExecutionStateRootBranch: u.optimisticdExecutionStateRootBranch,\n            syncAggregate: u.syncAggregate,\n            signatureSlot: u.signatureSlot,\n            // irrelavant fields\n            finalityBranch: new bytes32[](0),\n            finalizedExecutionStateRoot: bytes32(0),\n            finalizedExecutionStateRootBranch: new bytes32[](0),\n            nextSyncCommitteeRoot: bytes32(0),\n            nextSyncCommitteeBranch: new bytes32[](0),\n            nextSyncCommitteePoseidonRoot: bytes32(0),\n            nextSyncCommitteeRootMappingProof: emptyProof()\n        });\n        processLightClientUpdate(update);\n    }\n\n    function processSyncCommitteeUpdate(SyncCommitteeUpdate memory u) external {\n        LightClientUpdate memory update = LightClientUpdate({\n            attestedHeader: u.attestedHeader,\n            nextSyncCommitteeRoot: u.nextSyncCommitteeRoot,\n            nextSyncCommitteeBranch: u.nextSyncCommitteeBranch,\n            nextSyncCommitteePoseidonRoot: u.nextSyncCommitteePoseidonRoot,\n            finalizedHeader: u.finalizedHeader,\n            finalityBranch: u.finalityBranch,\n            syncAggregate: u.syncAggregate,\n            signatureSlot: u.signatureSlot,\n            nextSyncCommitteeRootMappingProof: u.nextSyncCommitteeRootMappingProof,\n            // irrelavant fields\n            finalizedExecutionStateRoot: bytes32(0),\n            finalizedExecutionStateRootBranch: new bytes32[](0),\n            optimisticExecutionStateRoot: bytes32(0),\n            optimisticdExecutionStateRootBranch: new bytes32[](0)\n        });\n        processLightClientUpdate(update);\n    }\n\n    function processLightClientForceUpdate() external onlyOwner {\n        require(currentSlot() > finalizedHeader.slot + UPDATE_TIMEOUT, \"timeout not passed\");\n        require(bestValidUpdate.attestedHeader.slot > 0, \"no best valid update\");\n\n        // Forced best update when the update timeout has elapsed.\n        // Because the apply logic waits for finalizedHeader.slot to indicate sync committee finality,\n        // the attestedHeader may be treated as finalizedHeader in extended periods of non-finality\n        // to guarantee progression into later sync committee periods according to isBetterUpdate().\n        if (bestValidUpdate.finalizedHeader.slot <= finalizedHeader.slot) {\n            bestValidUpdate.finalizedHeader = bestValidUpdate.attestedHeader;\n        }\n        applyLightClientUpdate(bestValidUpdate);\n        delete bestValidUpdate;\n    }\n\n    function processLightClientUpdate(LightClientUpdate memory update) public {\n        validateLightClientUpdate(update);\n\n        // Update the best update in case we have to force-update to it if the timeout elapses\n        if (isBetterUpdate(update, bestValidUpdate)) {\n            bestValidUpdate = update;\n        }\n\n        // Track the maximum number of active participants in the committee signatures\n        if (update.syncAggregate.participation > currentMaxActiveParticipants) {\n            currentMaxActiveParticipants = update.syncAggregate.participation;\n        }\n\n        // Apply optimistic update\n        if (\n            update.syncAggregate.participation > getSafetyThreshold() &&\n            update.attestedHeader.slot > optimisticHeader.slot\n        ) {\n            optimisticHeader = update.attestedHeader;\n            optimisticExecutionStateRoot = update.optimisticExecutionStateRoot;\n            emit HeaderUpdated(\n                update.attestedHeader.slot,\n                update.attestedHeader.stateRoot,\n                update.optimisticExecutionStateRoot,\n                false\n            );\n        }\n\n        // Apply finality update\n        bool updateHasFinalizedNextSyncCommittee = hasNextSyncCommitteeProof(update) &&\n            hasFinalityProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.finalizedHeader.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.slot) &&\n            nextSyncCommitteeRoot == bytes32(0);\n        if (\n            hasSupermajority(update.syncAggregate.participation) &&\n            (update.finalizedHeader.slot > finalizedHeader.slot || updateHasFinalizedNextSyncCommittee)\n        ) {\n            applyLightClientUpdate(update);\n            delete bestValidUpdate;\n        }\n    }\n\n    function validateLightClientUpdate(LightClientUpdate memory update) private view {\n        // Verify sync committee has sufficient participants\n        require(\n            update.syncAggregate.participation > MIN_SYNC_COMMITTEE_PARTICIPANTS,\n            \"not enough committee participation\"\n        );\n        // Verify update does not skip a sync committee period\n        require(\n            currentSlot() > update.attestedHeader.slot && update.attestedHeader.slot > update.finalizedHeader.slot,\n            \"invalid slot\"\n        );\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedHeader.slot);\n        uint64 updatePeriod = computeSyncCommitteePeriodAtSlot(update.finalizedHeader.slot);\n        require(updatePeriod == storePeriod || updatePeriod == storePeriod + 1);\n\n        // Verify update is relavant\n        uint64 updateAttestedPeriod = computeSyncCommitteePeriodAtSlot(update.attestedHeader.slot);\n        bool updateHasNextSyncCommittee = nextSyncCommitteeRoot == bytes32(0) &&\n            hasNextSyncCommitteeProof(update) &&\n            updateAttestedPeriod == storePeriod;\n        // since sync committee update prefers older header (see isBetterUpdate), an update either\n        // needs to have a newer header or it should have sync committee update.\n        require(update.attestedHeader.slot > finalizedHeader.slot || updateHasNextSyncCommittee);\n\n        // Verify that the finalityBranch, if present, confirms finalizedHeader\n        // to match the finalized checkpoint root saved in the state of attestedHeader.\n        // Note that the genesis finalized checkpoint root is represented as a zero hash.\n        if (!hasFinalityProof(update)) {\n            require(isEmptyHeader(update.finalizedHeader), \"no finality proof\");\n        } else {\n            // genesis block header\n            if (update.finalizedHeader.slot == 0) {\n                require(isEmptyHeader(update.finalizedHeader), \"genesis header should be empty\");\n            } else {\n                bool isValidFinalityProof = SSZ.isValidMerkleBranch(\n                    SSZ.hashTreeRoot(update.finalizedHeader),\n                    update.finalityBranch,\n                    FINALIZED_ROOT_INDEX,\n                    update.attestedHeader.stateRoot\n                );\n                require(isValidFinalityProof, \"invalid finality proof\");\n            }\n        }\n\n        // Verify finalizedExecutionStateRoot\n        if (!hasExecutionFinalityProof(update)) {\n            require(update.finalizedExecutionStateRoot == bytes32(0), \"no execution finality proof\");\n        } else {\n            require(hasFinalityProof(update), \"no execution finality proof\");\n            bool isValidFinalizedExecutionRootProof = SSZ.isValidMerkleBranch(\n                update.finalizedExecutionStateRoot,\n                update.finalizedExecutionStateRootBranch,\n                EXECUTION_STATE_ROOT_INDEX,\n                update.finalizedHeader.stateRoot\n            );\n            require(isValidFinalizedExecutionRootProof, \"invalid execution finality proof\");\n        }\n\n        // Verify optimisticExecutionStateRoot\n        if (!hasExecutionOptimisticProof(update)) {\n            require(update.optimisticExecutionStateRoot == bytes32(0), \"no execution optimistic proof\");\n        } else {\n            bool isvalidOptimisticExecutionRootProof = SSZ.isValidMerkleBranch(\n                update.optimisticExecutionStateRoot,\n                update.optimisticdExecutionStateRootBranch,\n                EXECUTION_STATE_ROOT_INDEX,\n                update.attestedHeader.stateRoot\n            );\n            require(isvalidOptimisticExecutionRootProof, \"invalid execution optimistic proof\");\n        }\n\n        // Verify that the update's nextSyncCommittee, if present, actually is the next sync committee\n        // saved in the state of the update's finalizedHeader\n        if (!hasNextSyncCommitteeProof(update)) {\n            require(\n                update.nextSyncCommitteeRoot == bytes32(0) && update.nextSyncCommitteePoseidonRoot == bytes32(0),\n                \"no next sync committee proof\"\n            );\n        } else {\n            if (updateAttestedPeriod == storePeriod && nextSyncCommitteeRoot != bytes32(0)) {\n                require(update.nextSyncCommitteeRoot == nextSyncCommitteeRoot, \"invalid next sync committee\");\n            }\n            bool isValidSyncCommitteeProof = SSZ.isValidMerkleBranch(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteeBranch,\n                NEXT_SYNC_COMMITTEE_INDEX,\n                update.attestedHeader.stateRoot\n            );\n            require(isValidSyncCommitteeProof, \"invalid next sync committee proof\");\n            bool isValidCommitteeRootMappingProof = ZkVerifier.verifySyncCommitteeRootMappingProof(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteePoseidonRoot,\n                update.nextSyncCommitteeRootMappingProof\n            );\n            require(isValidCommitteeRootMappingProof, \"invalid next sync committee root mapping proof\");\n        }\n\n        // Verify sync committee signature ZK proof\n        bytes4 forkVersion = computeForkVersion(computeEpochAtSlot(update.signatureSlot));\n        bytes32 domain = computeDomain(forkVersion);\n        bytes32 signingRoot = computeSigningRoot(update.attestedHeader, domain);\n        require(\n            currentSyncCommitteePoseidonRoot == update.syncAggregate.poseidonRoot,\n            \"invalid committee poseidon root\"\n        );\n        require(\n            ZkVerifier.verifySignatureProof(\n                signingRoot,\n                currentSyncCommitteePoseidonRoot,\n                update.syncAggregate.participation,\n                update.syncAggregate.proof\n            ),\n            \"invalid bls sig proof\"\n        );\n    }\n\n    function applyLightClientUpdate(LightClientUpdate memory update) private {\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedHeader.slot);\n        uint64 updateFinalizedPeriod = computeSyncCommitteePeriodAtSlot(update.finalizedHeader.slot);\n        if (nextSyncCommitteeRoot == bytes32(0)) {\n            require(updateFinalizedPeriod == storePeriod);\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        } else if (updateFinalizedPeriod == storePeriod + 1) {\n            currentSyncCommitteeRoot = nextSyncCommitteeRoot;\n            currentSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            previousMaxActiveParticipants = currentMaxActiveParticipants;\n            currentMaxActiveParticipants = 0;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        }\n        if (update.finalizedHeader.slot > finalizedHeader.slot) {\n            finalizedHeader = update.finalizedHeader;\n            if (update.finalizedExecutionStateRoot != bytes32(0)) {\n                finalizedExecutionStateRoot = update.finalizedExecutionStateRoot;\n                finalizedExecutionStateRootSlot = update.finalizedHeader.slot;\n            }\n            if (finalizedHeader.slot > optimisticHeader.slot) {\n                optimisticHeader = finalizedHeader;\n                optimisticExecutionStateRoot = finalizedExecutionStateRoot;\n                optimisticExecutionStateRootSlot = finalizedHeader.slot;\n            }\n            emit HeaderUpdated(\n                update.finalizedHeader.slot,\n                update.finalizedHeader.stateRoot,\n                update.finalizedExecutionStateRoot,\n                true\n            );\n        }\n    }\n\n    /*\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#is_better_update\n     */\n    function isBetterUpdate(\n        LightClientUpdate memory newUpdate,\n        LightClientUpdate memory oldUpdate\n    ) private pure returns (bool) {\n        // Old update doesn't exist\n        if (oldUpdate.syncAggregate.participation == 0) {\n            return newUpdate.syncAggregate.participation > 0;\n        }\n\n        // Compare supermajority (> 2/3) sync committee participation\n        bool newHasSupermajority = hasSupermajority(newUpdate.syncAggregate.participation);\n        bool oldHasSupermajority = hasSupermajority(oldUpdate.syncAggregate.participation);\n        if (newHasSupermajority != oldHasSupermajority) {\n            // the new update is a better one if new has supermajority but old doesn't\n            return newHasSupermajority && !oldHasSupermajority;\n        }\n        if (!newHasSupermajority && newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            // a better update is the one with higher participation when both new and old doesn't have supermajority\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Compare presence of relevant sync committee\n        bool newHasSyncCommittee = hasRelavantSyncCommittee(newUpdate);\n        bool oldHasSyncCommittee = hasRelavantSyncCommittee(oldUpdate);\n        if (newHasSyncCommittee != oldHasSyncCommittee) {\n            return newHasSyncCommittee;\n        }\n\n        // Compare indication of any finality\n        bool newHasFinality = hasFinalityProof(newUpdate);\n        bool oldHasFinality = hasFinalityProof(oldUpdate);\n        if (newHasFinality != oldHasFinality) {\n            return newHasFinality;\n        }\n\n        // Compare sync committee finality\n        if (newHasFinality) {\n            bool newHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(newUpdate.finalizedHeader.slot) ==\n                computeSyncCommitteePeriodAtSlot(newUpdate.attestedHeader.slot);\n            bool oldHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(oldUpdate.finalizedHeader.slot) ==\n                computeSyncCommitteePeriodAtSlot(oldUpdate.attestedHeader.slot);\n            if (newHasCommitteeFinality != oldHasCommitteeFinality) {\n                return newHasCommitteeFinality;\n            }\n        }\n\n        // Tiebreaker 1: Sync committee participation beyond supermajority\n        if (newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Tiebreaker 2: Prefer older data (fewer changes to best)\n        if (newUpdate.attestedHeader.slot != oldUpdate.attestedHeader.slot) {\n            return newUpdate.attestedHeader.slot < oldUpdate.attestedHeader.slot;\n        }\n\n        return newUpdate.signatureSlot < oldUpdate.signatureSlot;\n    }\n\n    function hasRelavantSyncCommittee(LightClientUpdate memory update) private pure returns (bool) {\n        return\n            hasNextSyncCommitteeProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.signatureSlot);\n    }\n\n    function hasNextSyncCommitteeProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.nextSyncCommitteeBranch.length > 0;\n    }\n\n    function hasFinalityProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.finalityBranch.length > 0;\n    }\n\n    function hasExecutionFinalityProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.finalizedExecutionStateRootBranch.length > 0;\n    }\n\n    function hasExecutionOptimisticProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.optimisticdExecutionStateRootBranch.length > 0;\n    }\n\n    function hasSupermajority(uint64 participation) private pure returns (bool) {\n        return participation * 3 >= SYNC_COMMITTEE_SIZE * 2;\n    }\n\n    function isEmptyHeader(BeaconBlockHeader memory header) private pure returns (bool) {\n        return header.stateRoot == bytes32(0);\n    }\n\n    function currentSlot() private view returns (uint64) {\n        return uint64((block.timestamp - GENESIS_TIME) / SLOT_LENGTH_SECONDS);\n    }\n\n    function getSafetyThreshold() private view returns (uint64) {\n        return (previousMaxActiveParticipants + currentMaxActiveParticipants) / 2;\n    }\n\n    function computeForkVersion(uint64 epoch) private view returns (bytes4) {\n        for (uint256 i = forkVersions.length - 1; i >= 0; i--) {\n            if (epoch >= forkEpochs[i]) {\n                return forkVersions[i];\n            }\n        }\n        revert(\"fork versions not set\");\n    }\n\n    function computeSyncCommitteePeriodAtSlot(uint64 slot) private pure returns (uint64) {\n        return computeSyncCommitteePeriod(computeEpochAtSlot(slot));\n    }\n\n    function computeEpochAtSlot(uint64 slot) private pure returns (uint64) {\n        return slot / SLOTS_PER_EPOCH;\n    }\n\n    function computeSyncCommitteePeriod(uint64 epoch) private pure returns (uint64) {\n        return epoch / EPOCHS_PER_SYNC_COMMITTEE_PERIOD;\n    }\n\n    /**\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_domain\n     */\n    function computeDomain(bytes4 forkVersion) internal view returns (bytes32) {\n        return DOMAIN_SYNC_COMMITTEE | (sha256(abi.encode(forkVersion, GENESIS_VALIDATOR_ROOT)) >> 32);\n    }\n\n    // computeDomain(forkVersion, genesisValidatorsRoot)\n    function computeSigningRoot(BeaconBlockHeader memory header, bytes32 domain) internal pure returns (bytes32) {\n        return sha256(bytes.concat(SSZ.hashTreeRoot(header), domain));\n    }\n}\n"
    },
    "contracts/light-client/LightClientStore.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\n\nabstract contract LightClientStore {\n    // beacon chain genesis information\n    uint256 immutable GENESIS_TIME;\n    bytes32 immutable GENESIS_VALIDATOR_ROOT;\n\n    // light client store\n    BeaconBlockHeader public finalizedHeader;\n    bytes32 public finalizedExecutionStateRoot;\n    uint64 public finalizedExecutionStateRootSlot;\n\n    BeaconBlockHeader public optimisticHeader;\n    bytes32 public optimisticExecutionStateRoot;\n    uint64 public optimisticExecutionStateRootSlot;\n\n    bytes32 public currentSyncCommitteeRoot;\n    bytes32 public currentSyncCommitteePoseidonRoot;\n    bytes32 public nextSyncCommitteeRoot;\n    bytes32 public nextSyncCommitteePoseidonRoot;\n\n    LightClientUpdate public bestValidUpdate;\n    uint64 public previousMaxActiveParticipants;\n    uint64 public currentMaxActiveParticipants;\n\n    // fork versions\n    uint64[] public forkEpochs;\n    bytes4[] public forkVersions;\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        BeaconBlockHeader memory _finalizedHeader,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot\n    ) {\n        GENESIS_TIME = genesisTime;\n        GENESIS_VALIDATOR_ROOT = genesisValidatorsRoot;\n        forkEpochs = _forkEpochs;\n        forkVersions = _forkVersions;\n        finalizedHeader = _finalizedHeader;\n        optimisticHeader = _finalizedHeader;\n        currentSyncCommitteeRoot = syncCommitteeRoot;\n        currentSyncCommitteePoseidonRoot = syncCommitteePoseidonRoot;\n    }\n}\n"
    },
    "contracts/light-client/SSZ.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\n\nlibrary SSZ {\n    function isValidMerkleBranch(\n        bytes32 leaf,\n        bytes32[] memory branch,\n        uint256 index,\n        bytes32 root\n    ) internal pure returns (bool) {\n        bytes32 restoredMerkleRoot = restoreMerkleRoot(leaf, branch, index);\n        return root == restoredMerkleRoot;\n    }\n\n    function restoreMerkleRoot(bytes32 leaf, bytes32[] memory branch, uint256 index) internal pure returns (bytes32) {\n        bytes32 value = leaf;\n        for (uint256 i = 0; i < branch.length; i++) {\n            if ((index / (2 ** i)) % 2 == 1) {\n                value = sha256(bytes.concat(branch[i], value));\n            } else {\n                value = sha256(bytes.concat(value, branch[i]));\n            }\n        }\n        return value;\n    }\n\n    function hashTreeRoot(BeaconBlockHeader memory header) internal pure returns (bytes32) {\n        bytes32 left = sha256(\n            bytes.concat(\n                sha256(bytes.concat(toLittleEndian(header.slot), toLittleEndian(header.proposerIndex))),\n                sha256(bytes.concat(header.parentRoot, header.stateRoot))\n            )\n        );\n        bytes32 right = sha256(\n            bytes.concat(\n                sha256(bytes.concat(header.bodyRoot, bytes32(0))),\n                sha256(bytes.concat(bytes32(0), bytes32(0)))\n            )\n        );\n        return sha256(bytes.concat(left, right));\n    }\n\n    function toLittleEndian(uint256 x) internal pure returns (bytes32) {\n        bytes32 res;\n        for (uint256 i = 0; i < 32; i++) {\n            res = (res << 8) | bytes32(x & 0xff);\n            x >>= 8;\n        }\n        return res;\n    }\n}\n"
    },
    "contracts/light-client/Types.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nstruct BeaconBlockHeader {\n    uint64 slot;\n    uint64 proposerIndex;\n    bytes32 parentRoot;\n    bytes32 stateRoot;\n    bytes32 bodyRoot;\n}\n\nfunction emptyBeaconBlockHeader() pure returns (BeaconBlockHeader memory) {\n    return\n        BeaconBlockHeader({\n            slot: 0,\n            proposerIndex: 0,\n            parentRoot: bytes32(0),\n            stateRoot: bytes32(0),\n            bodyRoot: bytes32(0)\n        });\n}\n\n// subset of LightClientUpdate\nstruct LightClientFinalityUpdate {\n    BeaconBlockHeader attestedHeader;\n    BeaconBlockHeader finalizedHeader;\n    bytes32[] finalityBranch;\n    bytes32 finalizedExecutionStateRoot;\n    bytes32[] finalizedExecutionStateRootBranch;\n    SyncAggregate syncAggregate;\n    uint64 signatureSlot;\n}\n\n// subset of LightClientUpdate\nstruct LightClientOptimisticUpdate {\n    BeaconBlockHeader attestedHeader;\n    bytes32 optimisticExecutionStateRoot;\n    bytes32[] optimisticdExecutionStateRootBranch;\n    SyncAggregate syncAggregate;\n    uint64 signatureSlot;\n}\n\n// subset of LightClientUpdate\nstruct SyncCommitteeUpdate {\n    BeaconBlockHeader attestedHeader;\n    BeaconBlockHeader finalizedHeader;\n    bytes32[] finalityBranch;\n    bytes32 nextSyncCommitteeRoot;\n    bytes32[] nextSyncCommitteeBranch;\n    bytes32 nextSyncCommitteePoseidonRoot;\n    Proof nextSyncCommitteeRootMappingProof;\n    SyncAggregate syncAggregate;\n    uint64 signatureSlot;\n}\n\nstruct LightClientUpdate {\n    // Header attested to by the sync committee\n    BeaconBlockHeader attestedHeader;\n    // Finalized header corresponding to `attested_header.state_root`\n    BeaconBlockHeader finalizedHeader;\n    bytes32[] finalityBranch;\n    bytes32 finalizedExecutionStateRoot;\n    bytes32[] finalizedExecutionStateRootBranch;\n    bytes32 optimisticExecutionStateRoot;\n    bytes32[] optimisticdExecutionStateRootBranch;\n    bytes32 nextSyncCommitteeRoot;\n    bytes32[] nextSyncCommitteeBranch;\n    bytes32 nextSyncCommitteePoseidonRoot;\n    Proof nextSyncCommitteeRootMappingProof;\n    // Sync committee aggregate signature participation & zk proof\n    SyncAggregate syncAggregate;\n    // Slot at which the aggregate signature was created (untrusted)\n    uint64 signatureSlot;\n}\n\nstruct SyncAggregate {\n    uint64 participation;\n    bytes32 poseidonRoot;\n    Proof proof;\n}\n\nstruct Proof {\n    bytes32 placeholder;\n}\n\nfunction emptyProof() pure returns (Proof memory) {\n    return Proof({placeholder: bytes32(0)});\n}\n"
    },
    "contracts/light-client/ZkVerifier.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\n\nlibrary ZkVerifier {\n    function verifySignatureProof(\n        bytes32 signingRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        uint256 participation,\n        Proof memory proof\n    ) internal pure returns (bool) {\n        // TODO\n        return true;\n    }\n\n    function verifySyncCommitteeRootMappingProof(\n        bytes32 sszRoot,\n        bytes32 poseidonRoot,\n        Proof memory proof\n    ) internal pure returns (bool) {\n        // TODO\n        return true;\n    }\n}\n"
    },
    "contracts/message-bridge/interfaces/IMessageBridge.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\n\npragma solidity 0.8.18;\n\nimport \"../../interfaces/IEthereumLightClient.sol\";\n\ninterface IMessageBridge {\n    enum MessageStatus {\n        NEW,\n        INVALID,\n        FAILED,\n        EXECUTED\n    }\n\n    event MessageSent(bytes32 indexed messageHash, uint256 indexed nonce, bytes message);\n    event MessageExecuted(bytes32 indexed messageHash, uint256 indexed nonce, bytes message, bool success);\n\n    function lightClient() external view returns (IEthereumLightClient);\n\n    function sendMessage(address receiver, bytes calldata message, uint256 gasLimit) external returns (bytes32);\n\n    function executeMessage(\n        uint64 slot,\n        bytes calldata message,\n        bytes[] calldata accountProof,\n        bytes[] calldata storageProof\n    ) external returns (bool);\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n}\n"
    },
    "contracts/message-bridge/libraries/MerkleProofTree.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./RLPReader.sol\";\n\nlibrary MerkleProofTree {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    function _gnaw(uint256 index, bytes32 key) private pure returns (uint256 gnaw) {\n        assembly {\n            gnaw := shr(mul(sub(63, index), 4), key)\n        }\n        return gnaw % 16;\n    }\n\n    function _pathLength(bytes memory path) private pure returns (uint256, bool) {\n        uint256 gnaw = uint256(uint8(path[0])) / 16;\n        return ((path.length - 1) * 2 + (gnaw % 2), gnaw > 1);\n    }\n\n    function read(bytes32 key, bytes[] memory proof) internal pure returns (bytes memory result) {\n        bytes32 root;\n        bytes memory node = proof[0];\n\n        uint256 index = 0;\n        uint256 pathLength = 0;\n\n        while (true) {\n            RLPReader.RLPItem[] memory items = node.toRlpItem().toList();\n            if (items.length == 17) {\n                uint256 gnaw = _gnaw(pathLength++, key);\n                root = bytes32(items[gnaw].toUint());\n            } else {\n                require(items.length == 2, \"MessageBridge: Iinvalid RLP list length\");\n                (uint256 nodePathLength, bool isLeaf) = _pathLength(items[0].toBytes());\n                pathLength += nodePathLength;\n                if (isLeaf) {\n                    return items[1].toBytes();\n                } else {\n                    root = bytes32(items[1].toUint());\n                }\n            }\n\n            node = proof[++index];\n            require(root == keccak256(node), \"MessageBridge: node hash mismatched\");\n        }\n    }\n\n    function restoreMerkleRoot(bytes32 leaf, uint256 index, bytes32[] memory proof) internal pure returns (bytes32) {\n        bytes32 value = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            if ((index / (2 ** i)) % 2 == 1) {\n                value = sha256(bytes.concat(proof[i], value));\n            } else {\n                value = sha256(bytes.concat(value, proof[i]));\n            }\n        }\n        return value;\n    }\n}\n"
    },
    "contracts/message-bridge/libraries/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity >=0.5.10 <0.9.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    },
    "contracts/message-bridge/MessageBridge.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IMessageBridge.sol\";\nimport \"./libraries/RLPReader.sol\";\nimport \"./libraries/MerkleProofTree.sol\";\nimport \"../interfaces/IEthereumLightClient.sol\";\n\ncontract MessageBridge is IMessageBridge, ReentrancyGuard {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    // storage at sender side\n    mapping(uint256 => bytes32) public sentMessages;\n    uint256 public nonce;\n    uint256 public gasLimitPerTransaction;\n\n    // storage at receiver side\n    IEthereumLightClient public lightClient;\n    mapping(bytes32 => MessageStatus) public receivedMessages;\n    mapping(uint256 => bytes32) public storageRoots;\n    address public remoteMessageBridge;\n    bytes32 public remoteMessageBridgeHash;\n\n    bool private initialized;\n\n    // struct to avoid \"stack too deep\"\n    struct MessageVars {\n        bytes32 messageHash;\n        uint256 nonce;\n        address sender;\n        address receiver;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    function initialize(address _lightClient, uint256 _gasLimitPerTransaction, address _remoteMessageBridge) external {\n        require(!initialized, \"already initialized\");\n        lightClient = IEthereumLightClient(_lightClient);\n        gasLimitPerTransaction = _gasLimitPerTransaction;\n        remoteMessageBridge = _remoteMessageBridge;\n        remoteMessageBridgeHash = keccak256(abi.encodePacked(remoteMessageBridge));\n        initialized = true;\n    }\n\n    function sendMessage(address receiver, bytes calldata data, uint256 gasLimit) external returns (bytes32) {\n        require(gasLimit <= gasLimitPerTransaction, \"MessageBridge: exceed gas limit\");\n        bytes memory message = abi.encode(nonce, msg.sender, receiver, gasLimit, data);\n        bytes32 messageHash = keccak256(message);\n        sentMessages[nonce] = messageHash;\n        emit MessageSent(messageHash, nonce++, message);\n        return messageHash;\n    }\n\n    function executeMessage(\n        uint64 slot,\n        bytes calldata message,\n        bytes[] calldata accountProof,\n        bytes[] calldata storageProof\n    ) external nonReentrant returns (bool success) {\n        MessageVars memory vars;\n        vars.messageHash = keccak256(message);\n        require(receivedMessages[vars.messageHash] == MessageStatus.NEW, \"MessageBridge: message already executed\");\n\n        // verify the storageProof and message\n        require(\n            _retrieveStorageRoot(slot, accountProof) == keccak256(storageProof[0]),\n            \"MessageBridge: invalid storage root\"\n        );\n\n        (vars.nonce, vars.sender, vars.receiver, vars.gasLimit, vars.data) = abi.decode(\n            message,\n            (uint256, address, address, uint256, bytes)\n        );\n\n        bytes32 key = keccak256(abi.encode(keccak256(abi.encode(vars.nonce, 0))));\n        bytes memory proof = MerkleProofTree.read(key, storageProof);\n\n        require(bytes32(proof.toRlpItem().toUint()) == vars.messageHash, \"MessageBridge: invalid message hash\");\n\n        // execute message\n        require((gasleft() * 63) / 64 > vars.gasLimit + 40000, \"MessageBridge: insufficient gas\");\n        bytes memory recieveCall = abi.encodeWithSignature(\"receiveMessage(address,bytes)\", vars.sender, vars.data);\n        (success, ) = vars.receiver.call{gas: vars.gasLimit}(recieveCall);\n        receivedMessages[vars.messageHash] = success ? MessageStatus.EXECUTED : MessageStatus.FAILED;\n        emit MessageExecuted(vars.messageHash, vars.nonce, message, success);\n        return success;\n    }\n\n    function finalizedExecutionStateRootAndSlot() public view returns (bytes32 root, uint64 slot) {\n        return lightClient.finalizedExecutionStateRootAndSlot();\n    }\n\n    function optimisticExecutionStateRootAndSlot() public view returns (bytes32 root, uint64 slot) {\n        return lightClient.optimisticExecutionStateRootAndSlot();\n    }\n\n    function _retrieveStorageRoot(uint64 slot, bytes[] calldata accountProof) private returns (bytes32) {\n        bytes32 storageRoot = storageRoots[slot];\n\n        // verify accountProof and get storageRoot{}\n        if (storageRoot == bytes32(0)) {\n            (bytes32 executionStateRoot, uint64 latestSlot) = finalizedExecutionStateRootAndSlot();\n            require(slot <= latestSlot, \"MessageBridge: slot not matched\");\n            require(executionStateRoot != bytes32(0), \"MessageBridge: execution state root not found\");\n            require(executionStateRoot == keccak256(accountProof[0]), \"MessageBridge: invalid account proof root\");\n\n            // get storageRoot\n            bytes memory accountInfo = MerkleProofTree.read(remoteMessageBridgeHash, accountProof);\n            RLPReader.RLPItem[] memory items = accountInfo.toRlpItem().toList();\n            require(items.length == 4, \"MessageBridge: invalid account decoded from RLP\");\n            storageRoot = bytes32(items[2].toUint());\n            storageRoots[slot] = storageRoot;\n        }\n        return storageRoot;\n    }\n}\n"
    },
    "contracts/message-bridge/test/MockMerkleProofTree.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"../libraries/MerkleProofTree.sol\";\n\ncontract MockMerkleProofTree {\n    function mockRead(bytes32 key, bytes[] memory proof) external pure returns (bytes memory result) {\n        return MerkleProofTree.read(key, proof);\n    }\n}\n"
    },
    "contracts/message-bridge/test/MockMessageBridge.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"../MessageBridge.sol\";\nimport \"../../interfaces/IEthereumLightClient.sol\";\n\ncontract MockLightClient is IEthereumLightClient {\n    uint64 public latestSlot; // slot of latest known block\n    bytes32 public stateRoot; // slot => header\n\n    function submitHeader(uint64 slot, bytes32 _stateRoot) external {\n        latestSlot = slot;\n        stateRoot = _stateRoot;\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (stateRoot, latestSlot);\n    }\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (stateRoot, latestSlot);\n    }\n}\n\ncontract MockMessageBridge {\n    MessageBridge public messageBridge;\n    MockLightClient public lightClient;\n\n    function initialize(\n        uint64 slot,\n        address _messageBridgeAddress,\n        address otherSideBridgeAddress,\n        address _mockLightClient,\n        bytes32 _mockStateRoot\n    ) public {\n        messageBridge = MessageBridge(_messageBridgeAddress);\n        lightClient = MockLightClient(_mockLightClient);\n        messageBridge.initialize(address(lightClient), 2000000, address(otherSideBridgeAddress));\n        lightClient.submitHeader(slot, _mockStateRoot);\n    }\n\n    function testExecutedMessage(\n        uint64 slot,\n        bytes calldata message,\n        bytes[] calldata accountProof,\n        bytes[] calldata storageProof\n    ) external returns (bool success) {\n        return messageBridge.executeMessage(slot, message, accountProof, storageProof);\n    }\n}\n"
    },
    "contracts/poa/libraries/ECDSA.sol": {
      "content": "// Inspired: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol\n\npragma solidity 0.8.18;\n\nimport \"hardhat/console.sol\";\n\nlibrary ECDSA {\n\n    /**\n     * Get signer's address with message and signature of the hashed message\n     * @param message original message to be hashed\n     * @param signature of hashed message\n     * @return signer's address\n     */\n    function recoverAddress(\n        bytes32 message,\n        bytes memory signature\n    ) internal pure returns (address) {\n        require(signature.length == 65, \"ECDSA: invalid signature length\");\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return getSigner(message, v, r, s);\n    }\n\n    /**\n     * Get signer of message \n     * @param message original message\n     * @param r r value extracted from signature\n     * @param s s value extracted from signature\n     * @param v v value extracted from signature\n     * @return signer address\n     */\n    function getSigner(\n        bytes32 message, \n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        require(uint256(s) < 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1, \"ECDSA: invalid s value of signature\");\n        require(v == 27 || v == 28, \"ECDSA: invalid v value of signature\");\n        address signer = ecrecover(hashMessageForSignature(message), v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signer\");\n        return signer;\n    }\n\n    /**\n     * Hash message with \"\\x19Ethereum Signed Message:\\n32\"\n     * @param message Message to be hashed\n     * @return messageHash hash\n     */\n    function hashMessageForSignature(bytes32 message) internal pure returns (bytes32 messageHash) {\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, message)\n            messageHash := keccak256(0x00, 0x3c)\n        }\n    }\n\n}"
    },
    "contracts/poa/libraries/Memory.sol": {
      "content": "pragma solidity 0.8.18;\n\nlibrary Memory {\n    /**\n     * Copies a part of bytes.\n     * @param source original bytes\n     * @param from the first index to be copied, data included\n     * @param to the last index(to be copied) + 1, data excluded.\n     */\n    function range(bytes memory source, uint256 from, uint256 to) internal  pure returns (bytes memory) {\n        if (from >= to) {\n            return \"\";\n        }\n\n        require(from < source.length && from >= 0, 'Memory: from out of bounds');\n        require(to <= source.length && to >= 0, 'Memory: to out of bounds');\n\n        bytes memory result = new bytes(to - from);\n\n        uint256 srcPtr;\n        assembly {\n            srcPtr := add(source, 0x20)\n        }\n\n        srcPtr += from;\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(result, 0x20)\n        }\n\n        copy(destPtr, srcPtr, to - from);\n\n        return result;\n    }\n\n    /**\n     * Copies a piece of memory to another location\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol\n     * @param _destPtr Destination location pointer\n     * @param _srcPtr Source location pointer\n     * @param _length Length of memory(in bytes) to be copied.\n     */\n    function copy(uint256 _destPtr, uint256 _srcPtr, uint256 _length) internal pure {\n        uint256 destPtr = _destPtr;\n        uint256 srcPtr = _srcPtr;\n        uint256 remainingLength = _length;\n\n        for (; remainingLength >= 32; remainingLength -= 32) {\n            assembly {\n                mstore(destPtr, mload(srcPtr))\n            }\n            destPtr += 32;\n            srcPtr += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256 ** (32 - remainingLength) - 1;\n        }\n\n        assembly {\n            let srcPart := and(mload(srcPtr), not(mask))\n            let destPart := and(mload(destPtr), mask)\n            mstore(destPtr, or(destPart, srcPart))\n        }\n    }\n}"
    },
    "contracts/poa/libraries/RLPWriter.sol": {
      "content": "// Inspired: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/rlp/Lib_RLPWriter.sol\n\npragma solidity 0.8.18;\n\nimport './Memory.sol';\nimport \"hardhat/console.sol\";\n\nlibrary RLPWriter {\n\n    /**\n     * RLP encodes bool\n     * @param _input The bool value to be encoded\n     * @return RLP encoded bool value in bytes\n     */\n    function writeBool(bool _input) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_input ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * RLP encodes bytes\n     * @param _input The byte string to be encoded\n     * @return RLP encoded string in bytes\n     */\n    function writeBytes(bytes memory _input) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        // input ∈ [0x00, 0x7f]\n        if (_input.length == 1 && uint8(_input[0]) < 128) {\n            encoded = _input;\n        } else {\n            // Offset 0x80\n            encoded = abi.encodePacked(_writeLength(_input.length, 128), _input);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded items\n     * @param _input The list of RLP encoded items\n     * @return RLP encoded list of items in bytes\n     */\n    function writeList(bytes[] memory _input) internal pure returns (bytes memory) {\n        bytes memory flatten = _flatten(_input);\n        // offset 0xc0\n        return abi.encodePacked(_writeLength(flatten.length, 192), flatten);\n    }\n\n    /**\n     * RLP encodes a string\n     * @param _input The string to be encoded\n     * @return RLP encoded string in bytes\n     */\n    function writeString(string memory _input) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_input));\n    }\n\n    /**\n     * RLP encodes an address\n     * @param _input The address to be encoded\n     * @return RLP encoded address in bytes\n     */\n    function writeAddress(address _input) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_input));\n    }\n \n    /**\n     * RLP encodes a uint256 value\n     * @param _input The uint256 to be encoded\n     * @return RLP encoded uint256 in bytes\n     */\n    function writeUint(uint256 _input) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_input));\n    }\n\n    /**\n     * Encode offset + length as first byte, followed by length in hex display if needed\n     * _offset: 0x80 for single item, 0xc0/192 for list\n     * If length is greater than 55, offset should add 55. 0xb7 for single item, 0xf7 for list\n     * @param _length The length of single item or list\n     * @param _offset Type indicator \n     * @return RLP encoded bytes\n     */\n    function _writeLength(uint256 _length, uint256 _offset) private pure returns (bytes memory)   {        \n        bytes memory encoded;\n        \n        if (_length < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_offset) + uint8(_length));\n        } else {\n            uint256 hexLengthForInputLength = 0;\n            uint256 index = 1;\n            while (_length / index != 0) {\n                index *= 256;\n                hexLengthForInputLength++; \n            }\n            encoded = new bytes(hexLengthForInputLength + 1);\n\n            // 0x80 + 55 = 0xb7\n            // 0xc0 + 55 = 0xf7\n            encoded[0] = bytes1(uint8(_offset) + 55 + uint8(hexLengthForInputLength));\n            for (index = 1; index <= hexLengthForInputLength; index++) {\n                encoded[index] = bytes1(uint8((_length / (256**(hexLengthForInputLength - index))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    function toBinary(uint256 _input) internal pure returns (bytes memory) { \n        return _toBinary(_input);\n    }\n\n    /**\n     * Encode integer into big endian without leading zeros\n     * @param _input The integer to be encoded\n     * @return RLP encoded bytes\n     */\n    function _toBinary(uint256 _input) private pure returns (bytes memory) {\n        // if input value is 0, return 0x00\n        if (_input == 0) {\n            bytes memory zeroResult = new bytes(1);\n            zeroResult[0] = 0;\n            return zeroResult;\n        }\n\n        bytes memory data = abi.encodePacked(_input);\n\n        uint8 index = 0;\n        for (; index < 32;) {\n            if (data[index] != 0) {\n                break;\n            }\n\n            unchecked {\n                ++index;\n            }\n        }\n\n        bytes memory result = new bytes(32 - index);\n        uint256 resultPtr;\n        assembly {\n            resultPtr := add(result, 0x20)\n        }\n\n        uint256 dataPtr;\n        assembly {\n            dataPtr := add(data, 0x20)\n        }\n\n        Memory.copy(resultPtr, dataPtr + index, 32 - index);\n\n        return result;\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 length = 0;\n        uint256 index = 0;\n\n        for (; index < _list.length; ) {\n            length += _list[index].length;\n            unchecked {\n                ++index;\n            }\n        }\n\n        bytes memory flattened = new bytes(length);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (index = 0; index < _list.length; ) {\n            bytes memory item = _list[index];\n            uint256 itemPtr;\n            assembly {\n                itemPtr := add(item, 0x20)\n            }\n\n            Memory.copy(flattenedPtr, itemPtr, item.length);\n            flattenedPtr += _list[index].length;\n\n            unchecked {\n                ++index;\n            }\n        }\n\n        return flattened;\n    }\n}"
    },
    "contracts/poa/PoALightClient.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\nimport \"../interfaces/ITendermintLightClient.sol\";\nimport \"./libraries/ECDSA.sol\";\nimport \"./libraries/Memory.sol\";\nimport \"./libraries/RLPWriter.sol\";\n\n// Sample header\n// curl --location --request POST 'https://bsc.getblock.io/API_KEY/testnet/'  \n//  -H \"Content-Type: application/json\" \n//  --data-raw '{\"jsonrpc\": \"2.0\", \"method\": \"eth_getBlockByNumber\", \"params\": [\"0x68B3\", true], \"id\": \"getblock.io\"}'\n// {\n// \"difficulty\":\"0x2\",\n// \"extraData\":\"0xd983010000846765746889676f312e31322e3137856c696e7578000000000000c3daa60d95817e2789de3eafd44dc354fe804bf5f08059cde7c86bc1215941d022bf9609ca1dee2881baf2144aa93fc80082e6edd0b9f8eac16f327e7d59f16500\",\n// \"gasLimit\":\"0x1c9c380\",\n// \"gasUsed\":\"0x0\",\n// \"hash\":\"0xc3fa2927a8e5b7cfbd575188a30c34994d3356607deb4c10d7fefe0dd5cdcc83\",\n// \"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n// \"miner\":\"0x35552c16704d214347f29fa77f77da6d75d7c752\",\n// \"mixHash\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n// \"nonce\":\"0x0000000000000000\",\n// \"number\":\"0x68b3\",\n// \"parentHash\":\"0xbf4d16769b8fd946394957049eef29ed938da92454762fc6ac65e0364ea004c7\",\n// \"receiptsRoot\":\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\",\n// \"sha3Uncles\":\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",\n// \"size\":\"0x261\",\n// \"stateRoot\":\"0x7b5a72075082c31ec909afe5c5df032b6e7f19c686a9a408a2cb6b75dec072a3\",\n// \"timestamp\":\"0x5f080818\",\n// \"totalDifficulty\":\"0xd167\",\n// \"transactions\":[],\n// \"transactionsRoot\":\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\",\n// \"uncles\":[]\n// }\n\ncontract PoALightClient {\n    using Memory for bytes;\n\n    struct BNBHeaderInfo {\n        uint256 difficulty;\n        bytes extraData;\n        uint64 gasLimit;\n        uint64 gasUsed;\n        bytes32 hash;\n        bytes logsBloom;\n        address miner;\n        bytes32 mixHash;\n        bytes8 nonce;\n        uint256 number;\n        bytes32 parentHash;\n        bytes32 receiptsRoot;\n        bytes32 sha3Uncles;\n        uint256 size; /// Type uncertainty \n        bytes32 stateRoot;\n        uint64 timestamp;\n        uint256 totalDifficulty;\n        bytes[] transactions; /// Type uncertainty\n        bytes32 transactionsRoot;\n        bytes[] uncles; /// Type uncertainty\n    }\n\n    ITendermintLightClient public lightClient;\n\n    constructor(address _lightClient) {\n        lightClient = ITendermintLightClient(_lightClient);\n    }\n\n    // Fixed number of extra-data prefix bytes reserved for signer vanity.\n    // https://eips.ethereum.org/EIPS/eip-225\n    uint256 constant private EXTRA_VANITY_LENGTH = 32;\n\n    // Length of signer's signature\n    uint256 constant private SIGNATURE_LENGTH = 65;\n\n    function verifyHeader(BNBHeaderInfo calldata header) external view returns (bool) {\n        address signer = _retrieveSignerInfo(header);\n        return lightClient.validateSigner(signer);\n    }\n\n    function _retrieveSignerInfo(BNBHeaderInfo calldata header) internal pure returns (address signer) {\n        bytes memory extraData = header.extraData;\n\n        require(extraData.length > EXTRA_VANITY_LENGTH, 'PoALightClient: invalid extra data for vanity');\n        require(extraData.length >= EXTRA_VANITY_LENGTH + SIGNATURE_LENGTH, 'PoALightClient: invalid extra data for signature');\n\n        // data: [0, extraData.length - SIGNATURE_LENGTH)\n        // signature: [extraData.length - SIGNATURE_LENGTH, extraData.length)\n        bytes memory extraDataWithoutSignature = Memory.range(extraData, 0, extraData.length - SIGNATURE_LENGTH);\n        bytes memory signature = Memory.range(extraData, extraData.length - SIGNATURE_LENGTH, extraData.length);\n\n        require(signature.length == SIGNATURE_LENGTH, \"PoALightClient: signature retrieval failed\");\n        BNBHeaderInfo memory unsignedHeader = BNBHeaderInfo({\n            difficulty: header.difficulty,\n            extraData: extraDataWithoutSignature,\n            gasLimit: header.gasLimit,\n            gasUsed: header.gasUsed,\n            hash: header.hash,\n            logsBloom: header.logsBloom,\n            miner: header.miner,\n            mixHash: header.mixHash,\n            nonce: header.nonce,\n            number: header.number,\n            parentHash: header.parentHash,\n            receiptsRoot: header.receiptsRoot,\n            sha3Uncles: header.sha3Uncles,\n            size: header.size,\n            stateRoot: header.stateRoot,\n            timestamp: header.timestamp,\n            totalDifficulty: header.totalDifficulty,\n            transactions: header.transactions,\n            transactionsRoot: header.transactionsRoot,\n            uncles: header.uncles\n        });\n\n        bytes32 message = _hashHeader(unsignedHeader);\n\n        return ECDSA.recoverAddress(message, signature);\n    }\n\n    function _hashHeader(BNBHeaderInfo memory header) internal pure returns(bytes32) {\n        bytes[] memory list = new bytes[](20);\n        list[0] = RLPWriter.writeUint(header.difficulty);\n        list[1] = RLPWriter.writeBytes(header.extraData);\n        list[2] = RLPWriter.writeUint(header.gasLimit);\n        list[3] = RLPWriter.writeUint(header.gasUsed);\n        list[4] = RLPWriter.writeBytes(abi.encodePacked(header.hash));\n        list[5] = RLPWriter.writeBytes(header.logsBloom);\n        list[6] = RLPWriter.writeAddress(header.miner);\n        list[7] = RLPWriter.writeBytes(abi.encodePacked(header.mixHash));\n        list[8] = RLPWriter.writeBytes(abi.encodePacked(header.nonce));\n        list[9] = RLPWriter.writeUint(header.number);\n        list[10] = RLPWriter.writeBytes(abi.encodePacked(header.parentHash));\n        list[11] = RLPWriter.writeBytes(abi.encodePacked(header.receiptsRoot));\n        list[12] = RLPWriter.writeBytes(abi.encodePacked(header.sha3Uncles));\n        list[13] = RLPWriter.writeUint(header.size);\n        list[14] = RLPWriter.writeBytes(abi.encodePacked(header.stateRoot));\n        list[15] = RLPWriter.writeUint(header.timestamp);\n        list[16] = RLPWriter.writeUint(header.totalDifficulty);\n        list[17] = RLPWriter.writeList(header.transactions);\n        list[18] = RLPWriter.writeBytes(abi.encodePacked(header.transactionsRoot));\n        list[19] = RLPWriter.writeList(header.uncles);\n\n        return keccak256(RLPWriter.writeList(list));\n    }\n}\n\n\n"
    },
    "contracts/poa/test/MockPOALightClient.sol": {
      "content": "pragma solidity 0.8.18;\n\nimport \"../../interfaces/ITendermintLightClient.sol\";\n\ncontract MockTendermintLightClient is ITendermintLightClient {\n    address public signerAddress;\n\n    function updateSigner(address _newSigner) external {\n        signerAddress = _newSigner;\n    }\n    \n    constructor(address _signer) {\n        signerAddress = _signer;\n    }\n\n    function validateSigner(address _signer) external view returns (bool valid) {\n        return signerAddress == _signer;\n    }\n}\n"
    },
    "contracts/poa/test/PoALibTest.sol": {
      "content": "pragma solidity 0.8.18;\n\nimport '../libraries/RLPWriter.sol';\nimport '../libraries/Memory.sol';\nimport '../libraries/ECDSA.sol';\n\ncontract PoALibTest {\n\n    function mockRange(bytes memory source, uint256 from, uint256 to) public pure returns (bytes memory) {\n        return Memory.range(source, from, to);\n    } \n\n    function mockCopy(bytes memory _source, uint256 _length) public pure returns (bytes memory) {\n        bytes memory dest = new bytes(_length);\n        uint256 destPtr;\n        assembly {\n            destPtr := add(dest, 0x20)\n        }\n\n        uint256 srcPtr;\n        assembly {\n            srcPtr := add(_source, 0x20)\n        }\n\n        Memory.copy(destPtr, srcPtr, _length);\n        return dest;\n    }\n\n    function mockWriteUint(uint256 _input) public pure returns (bytes memory) {\n        return RLPWriter.writeUint(_input);\n    }\n\n    function mockWriteAddress(address _input) public pure returns (bytes memory) {\n        return RLPWriter.writeAddress(_input);\n    }\n\n    function mockWriteRLPList(bytes[] memory _input) public pure returns (bytes memory) {\n        return RLPWriter.writeList(_input);\n    }\n\n    function mockWriteBool(bool _input) public pure returns (bytes memory) {\n        return RLPWriter.writeBool(_input);\n    }\n\n    function mockWriteString(string calldata _input) public pure returns (bytes memory) {\n        return RLPWriter.writeString(_input);\n    }\n\n    function mockWriteBytes(bytes memory _input) public pure returns (bytes memory) {\n        return RLPWriter.writeBytes(_input);\n    }\n\n    function mockToBinary(uint256 _input) public pure returns (bytes memory) {\n        return RLPWriter.toBinary(_input);\n    }\n\n    function mockUint256MaxToBinary() public pure returns (bytes memory) {\n        return RLPWriter.toBinary(115792089237316195423570985008687907853269984665640564039457584007913129639935);\n    }\n\n    function mockRecoverAddress(bytes32 message, bytes memory signature) public pure returns (address) {\n        return ECDSA.recoverAddress(message, signature);\n    }\n\n}\n"
    },
    "contracts/token-bridge/PegBridge.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../message-bridge/interfaces/IMessageBridge.sol\";\n\ninterface IPeggedToken {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n}\n\ncontract PegBridge is Ownable {\n    using SafeERC20 for IERC20;\n    uint256 private constant GAS_LIMIT = 1000000;\n\n    mapping(bytes32 => bool) public records;\n    mapping(address => uint256) public supplies;\n    mapping(address => address) public vaultToPegTokens; // vault -> peg\n    mapping(address => address) public pegToVaultTokens; // peg -> vault\n\n    mapping(address => uint256) public minBurn;\n\n    address public messageBridge;\n    address public remoteTokenVault;\n\n    event Mint(bytes32 mintId, address account, address token, uint256 amount, bytes32 refId, address depositor);\n\n    event Burn(\n        bytes32 burnId,\n        address burnAccount,\n        address token,\n        uint256 amount,\n        address withdrawAccount,\n        uint64 nonce,\n        bytes32 messageId\n    );\n\n    event BridgeTokenAdded(address vaultToken, address pegToken);\n    event BridgeTokenDeleted(address vaultToken, address pegToken);\n\n    event MinBurnUpdated(address token, uint256 amount);\n\n    modifier onlyMessageBridge() {\n        require(msg.sender == messageBridge, \"caller is not message bridge\");\n        _;\n    }\n\n    constructor(address _messageBridge, address _remoteTokenVault) {\n        messageBridge = _messageBridge;\n        remoteTokenVault = _remoteTokenVault;\n    }\n\n    function receiveMessage(address _sender, bytes calldata _message) external onlyMessageBridge {\n        require(_sender == remoteTokenVault, \"sender is not remote token vault\");\n        _mint(_message);\n    }\n\n    function _mint(bytes calldata _message) private {\n        (address vaultToken, uint256 amount, address mintAccount, address depositor, bytes32 depositId) = abi.decode(\n            (_message),\n            (address, uint256, address, address, bytes32)\n        );\n        address pegToken = vaultToPegTokens[vaultToken];\n        require(pegToken != address(0), \"no peg token\");\n        bytes32 mintId = keccak256(\n            abi.encodePacked(pegToken, amount, mintAccount, depositor, depositId, address(this))\n        );\n        require(records[mintId] == false, \"record exists\");\n        records[mintId] = true;\n        IPeggedToken(pegToken).mint(mintAccount, amount);\n        supplies[pegToken] += amount;\n        emit Mint(mintId, mintAccount, pegToken, amount, depositId, depositor);\n    }\n\n    function burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) external returns (bytes32) {\n        bytes32 burnId = _burn(_token, _amount, _toChainId, _withdrawAccount, _nonce);\n        IPeggedToken(_token).burn(msg.sender, _amount);\n        return burnId;\n    }\n\n    function _burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) private returns (bytes32) {\n        require(_amount > minBurn[_token], \"amount too small\");\n        address vaultToken = pegToVaultTokens[_token];\n        require(vaultToken != address(0), \"no vault token\");\n        supplies[_token] -= _amount;\n        bytes32 burnId = keccak256(\n            abi.encodePacked(\n                msg.sender,\n                _token,\n                _amount,\n                _toChainId,\n                _withdrawAccount,\n                _nonce,\n                uint64(block.chainid),\n                address(this)\n            )\n        );\n        require(records[burnId] == false, \"record exists\");\n        records[burnId] = true;\n        bytes memory message = abi.encode(vaultToken, _amount, _withdrawAccount, msg.sender, burnId);\n        bytes32 messageId = IMessageBridge(messageBridge).sendMessage(_withdrawAccount, message, GAS_LIMIT);\n        emit Burn(burnId, msg.sender, _token, _amount, _withdrawAccount, _nonce, messageId);\n        return burnId;\n    }\n\n    function setBridgeTokens(address[] calldata _vaultTokens, address[] calldata _pegTokens) external onlyOwner {\n        require(_vaultTokens.length == _pegTokens.length, \"length mismatch\");\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            vaultToPegTokens[_vaultTokens[i]] = _pegTokens[i];\n            pegToVaultTokens[_pegTokens[i]] = _vaultTokens[i];\n            emit BridgeTokenAdded(_vaultTokens[i], _pegTokens[i]);\n        }\n    }\n\n    function deletePegTokens(address[] calldata _pegTokens) external onlyOwner {\n        for (uint256 i = 0; i < _pegTokens.length; i++) {\n            address pegToken = _pegTokens[i];\n            address vaultToken = pegToVaultTokens[pegToken];\n            delete vaultToPegTokens[vaultToken];\n            delete pegToVaultTokens[pegToken];\n            emit BridgeTokenDeleted(vaultToken, pegToken);\n        }\n    }\n\n    function deleteVaultTokens(address[] calldata _vaultTokens) external onlyOwner {\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address vaultToken = _vaultTokens[i];\n            address pegToken = vaultToPegTokens[vaultToken];\n            delete vaultToPegTokens[vaultToken];\n            delete pegToVaultTokens[pegToken];\n            emit BridgeTokenDeleted(vaultToken, pegToken);\n        }\n    }\n\n    function setMinBurn(address[] calldata _tokens, uint256[] calldata _amounts) external onlyOwner {\n        require(_tokens.length == _amounts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            minBurn[_tokens[i]] = _amounts[i];\n            emit MinBurnUpdated(_tokens[i], _amounts[i]);\n        }\n    }\n}\n"
    },
    "contracts/token-bridge/TokenVault.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../message-bridge/interfaces/IMessageBridge.sol\";\n\ncontract TokenVault is Ownable {\n    using SafeERC20 for IERC20;\n    uint256 private constant GAS_LIMIT = 1000000;\n\n    mapping(bytes32 => bool) public records;\n\n    address public messageBridge;\n    address public remotePegBridge;\n\n    mapping(address => uint256) public minDeposit;\n\n    event Deposited(\n        bytes32 depositId,\n        address depositor,\n        address token,\n        uint256 amount,\n        address mintAccount,\n        uint64 nonce,\n        bytes32 messageId\n    );\n\n    event Withdrawn(\n        bytes32 withdrawId,\n        address receiver,\n        address token,\n        uint256 amount,\n        bytes32 refId,\n        address burnAccount\n    );\n\n    event MinDepositUpdated(address token, uint256 amount);\n\n    modifier onlyMessageBridge() {\n        require(msg.sender == messageBridge, \"caller is not message bridge\");\n        _;\n    }\n\n    constructor(address _messageBridge, address _remotePegBridge) {\n        messageBridge = _messageBridge;\n        remotePegBridge = _remotePegBridge;\n    }\n\n    function deposit(address _token, uint256 _amount, address _mintAccount, uint64 _nonce) external returns (bytes32) {\n        (bytes32 depositId, bytes32 messageId) = _deposit(_token, _amount, _mintAccount, _nonce);\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        emit Deposited(depositId, msg.sender, _token, _amount, _mintAccount, _nonce, messageId);\n        return depositId;\n    }\n\n    function _deposit(\n        address _token,\n        uint256 _amount,\n        address _mintAccount,\n        uint64 _nonce\n    ) private returns (bytes32, bytes32) {\n        require(_amount > minDeposit[_token], \"amount too small\");\n        bytes32 depositId = keccak256(\n            abi.encodePacked(msg.sender, _token, _amount, _mintAccount, _nonce, uint64(block.chainid), address(this))\n        );\n        require(records[depositId] == false, \"record exists\");\n        bytes memory message = abi.encode(_token, _amount, _mintAccount, msg.sender, depositId);\n        bytes32 messageId = IMessageBridge(messageBridge).sendMessage(_mintAccount, message, GAS_LIMIT);\n        records[depositId] = true;\n        return (depositId, messageId);\n    }\n\n    function receiveMessage(address _sender, bytes calldata _message) external onlyMessageBridge {\n        require(_sender == remotePegBridge, \"sender is not remote peg bridge\");\n        _withdraw(_message);\n    }\n\n    function _withdraw(bytes calldata _message) private {\n        (address token, uint256 amount, address receiver, address burnAccount, bytes32 burnId) = abi.decode(\n            (_message),\n            (address, uint256, address, address, bytes32)\n        );\n        bytes32 withdrawId = keccak256(abi.encodePacked(receiver, token, amount, burnAccount, burnId, address(this)));\n        require(records[withdrawId] == false, \"record exists\");\n        records[withdrawId] = true;\n        IERC20(token).safeTransfer(receiver, amount);\n        emit Withdrawn(withdrawId, receiver, token, amount, burnId, burnAccount);\n    }\n\n    function setMinDeposit(address[] calldata _tokens, uint256[] calldata _amounts) external onlyOwner {\n        require(_tokens.length == _amounts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            minDeposit[_tokens[i]] = _amounts[i];\n            emit MinDepositUpdated(_tokens[i], _amounts[i]);\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}