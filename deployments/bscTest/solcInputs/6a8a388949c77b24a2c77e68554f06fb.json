{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/IEthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\ninterface IEthereumLightClient {\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n}\n"
    },
    "contracts/light-client/Constants.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\n// light client security params\nuint256 constant MIN_SYNC_COMMITTEE_PARTICIPANTS = 1;\nuint256 constant UPDATE_TIMEOUT = 86400;\n\n// beacon chain constants\nuint256 constant FINALIZED_ROOT_INDEX = 105;\nuint256 constant NEXT_SYNC_COMMITTEE_INDEX = 55;\nuint256 constant EXECUTION_STATE_ROOT_INDEX = 898;\n// uint256 constant EXECUTION_STATE_ROOT_INDEX = 402;\nuint256 constant SYNC_COMMITTEE_SIZE = 512;\nuint64 constant SLOTS_PER_EPOCH = 32;\nuint64 constant EPOCHS_PER_SYNC_COMMITTEE_PERIOD = 256;\nbytes32 constant DOMAIN_SYNC_COMMITTEE = bytes32(uint256(0x07) << 248);\nuint256 constant SLOT_LENGTH_SECONDS = 12;\n"
    },
    "contracts/light-client/EthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IEthereumLightClient.sol\";\n\nimport \"./IZkVerifier.sol\";\nimport \"./LightClientStore.sol\";\nimport \"./SSZ.sol\";\nimport \"./Constants.sol\";\nimport \"./Types.sol\";\n\ncontract EthereumLightClient is IEthereumLightClient, LightClientStore, Ownable {\n    event HeaderUpdated(uint256 slot, bytes32 stateRoot, bytes32 executionStateRoot, bool finalized);\n    event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot);\n    event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion);\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        BeaconBlockHeader memory _finalizedHeader,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    )\n        LightClientStore(\n            genesisTime,\n            genesisValidatorsRoot,\n            _forkEpochs,\n            _forkVersions,\n            _finalizedHeader,\n            syncCommitteeRoot,\n            syncCommitteePoseidonRoot,\n            _zkVerifier\n        )\n    {}\n\n    function latestFinalizedSlotAndCommitteeRoots()\n        external\n        view\n        returns (\n            uint64 slot,\n            bytes32 currentRoot,\n            bytes32 nextRoot\n        )\n    {\n        return (finalizedHeader.slot, currentSyncCommitteeRoot, nextSyncCommitteeRoot);\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (finalizedExecutionStateRoot, finalizedExecutionStateRootSlot);\n    }\n\n    function updateForkVersion(uint64 epoch, bytes4 forkVersion) external onlyOwner {\n        require(forkVersion != bytes4(0), \"bad fork version\");\n        forkEpochs.push(epoch);\n        forkVersions.push(forkVersion);\n        emit ForkVersionUpdated(epoch, forkVersion);\n    }\n\n    function processLightClientForceUpdate() external onlyOwner {\n        require(currentSlot() > finalizedHeader.slot + UPDATE_TIMEOUT, \"timeout not passed\");\n        require(bestValidUpdate.attestedHeader.slot > 0, \"no best valid update\");\n\n        // Forced best update when the update timeout has elapsed.\n        // Because the apply logic waits for finalizedHeader.slot to indicate sync committee fin,\n        // the attestedHeader may be treated as finalizedHeader in extended periods of non-fin\n        // to guarantee progression into later sync committee periods according to isBetterUpdate().\n        if (bestValidUpdate.finalizedHeader.slot <= finalizedHeader.slot) {\n            bestValidUpdate.finalizedHeader = bestValidUpdate.attestedHeader;\n        }\n        applyLightClientUpdate(bestValidUpdate);\n        delete bestValidUpdate;\n    }\n\n    function processLightClientUpdate(LightClientUpdate memory update) public {\n        validateLightClientUpdate(update);\n\n        // Update the best update in case we have to force-update to it if the timeout elapses\n        if (isBetterUpdate(update, bestValidUpdate)) {\n            bestValidUpdate = update;\n        }\n\n        // Apply fin update\n        bool updateHasFinalizedNextSyncCommittee = hasNextSyncCommitteeProof(update) &&\n            hasFinalityProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.finalizedHeader.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.slot) &&\n            nextSyncCommitteeRoot == bytes32(0);\n        if (\n            hasSupermajority(update.syncAggregate.participation) &&\n            (update.finalizedHeader.slot > finalizedHeader.slot || updateHasFinalizedNextSyncCommittee)\n        ) {\n            applyLightClientUpdate(update);\n            delete bestValidUpdate;\n        }\n    }\n\n    function validateLightClientUpdate(LightClientUpdate memory update) private view {\n        // Verify sync committee has sufficient participants\n        require(update.syncAggregate.participation > MIN_SYNC_COMMITTEE_PARTICIPANTS, \"not enough participation\");\n        // Verify update does not skip a sync committee period\n        require(\n            currentSlot() > update.attestedHeader.slot && update.attestedHeader.slot > update.finalizedHeader.slot,\n            \"bad slot\"\n        );\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedHeader.slot);\n        uint64 updatePeriod = computeSyncCommitteePeriodAtSlot(update.finalizedHeader.slot);\n        require(updatePeriod == storePeriod || updatePeriod == storePeriod + 1);\n\n        // Verify update is relavant\n        uint64 updateAttestedPeriod = computeSyncCommitteePeriodAtSlot(update.attestedHeader.slot);\n        bool updateHasNextSyncCommittee = nextSyncCommitteeRoot == bytes32(0) &&\n            hasNextSyncCommitteeProof(update) &&\n            updateAttestedPeriod == storePeriod;\n        // since sync committee update prefers older header (see isBetterUpdate), an update either\n        // needs to have a newer header or it should have sync committee update.\n        require(update.attestedHeader.slot > finalizedHeader.slot || updateHasNextSyncCommittee);\n\n        // Verify that the finalityBranch, if present, confirms finalizedHeader\n        // to match the finalized checkpoint root saved in the state of attestedHeader.\n        // Note that the genesis finalized checkpoint root is represented as a zero hash.\n        if (!hasFinalityProof(update)) {\n            require(isEmptyHeader(update.finalizedHeader), \"no fin proof\");\n        } else {\n            // genesis block header\n            if (update.finalizedHeader.slot == 0) {\n                require(isEmptyHeader(update.finalizedHeader), \"genesis header should be empty\");\n            } else {\n                bool isValidFinalityProof = SSZ.isValidMerkleBranch(\n                    SSZ.hashTreeRoot(update.finalizedHeader),\n                    update.finalityBranch,\n                    FINALIZED_ROOT_INDEX,\n                    update.attestedHeader.stateRoot\n                );\n                require(isValidFinalityProof, \"bad fin proof\");\n            }\n        }\n\n        // Verify finalizedExecutionStateRoot\n        if (!hasExecutionFinalityProof(update)) {\n            require(update.finalizedExecutionStateRoot == bytes32(0), \"no exec fin proof\");\n        } else {\n            require(hasFinalityProof(update), \"no exec fin proof\");\n            bool isValidFinalizedExecutionRootProof = SSZ.isValidMerkleBranch(\n                update.finalizedExecutionStateRoot,\n                update.finalizedExecutionStateRootBranch,\n                EXECUTION_STATE_ROOT_INDEX,\n                update.finalizedHeader.stateRoot\n            );\n            require(isValidFinalizedExecutionRootProof, \"bad exec fin proof\");\n        }\n\n        // Verify that the update's nextSyncCommittee, if present, actually is the next sync committee\n        // saved in the state of the update's attested header\n        if (!hasNextSyncCommitteeProof(update)) {\n            require(\n                update.nextSyncCommitteeRoot == bytes32(0) && update.nextSyncCommitteePoseidonRoot == bytes32(0),\n                \"no next sync committee proof\"\n            );\n        } else {\n            if (updateAttestedPeriod == storePeriod && nextSyncCommitteeRoot != bytes32(0)) {\n                require(update.nextSyncCommitteeRoot == nextSyncCommitteeRoot, \"bad next sync committee\");\n            }\n            bool isValidSyncCommitteeProof = SSZ.isValidMerkleBranch(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteeBranch,\n                NEXT_SYNC_COMMITTEE_INDEX,\n                update.attestedHeader.stateRoot\n            );\n            require(isValidSyncCommitteeProof, \"bad next sync committee proof\");\n            bool isValidCommitteeRootMappingProof = zkVerifier.verifySyncCommitteeRootMappingProof(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteePoseidonRoot,\n                update.nextSyncCommitteeRootMappingProof\n            );\n            require(isValidCommitteeRootMappingProof, \"bad next sync committee root mapping proof\");\n        }\n\n        // Verify sync committee signature ZK proof\n        bytes4 forkVersion = computeForkVersion(computeEpochAtSlot(update.signatureSlot));\n        bytes32 domain = computeDomain(forkVersion);\n        bytes32 signingRoot = computeSigningRoot(update.attestedHeader, domain);\n        bytes32 activeSyncCommitteePoseidonRoot;\n        if (updatePeriod == storePeriod) {\n            require(currentSyncCommitteePoseidonRoot == update.syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = currentSyncCommitteePoseidonRoot;\n        } else if (updatePeriod == storePeriod + 1) {\n            require(nextSyncCommitteePoseidonRoot == update.syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n        }\n        require(\n            zkVerifier.verifySignatureProof(\n                signingRoot,\n                activeSyncCommitteePoseidonRoot,\n                update.syncAggregate.participation,\n                update.syncAggregate.proof\n            ),\n            \"bad bls sig proof\"\n        );\n    }\n\n    function applyLightClientUpdate(LightClientUpdate memory update) private {\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedHeader.slot);\n        uint64 updateFinalizedPeriod = computeSyncCommitteePeriodAtSlot(update.finalizedHeader.slot);\n        if (nextSyncCommitteeRoot == bytes32(0)) {\n            require(updateFinalizedPeriod == storePeriod, \"mismatch period\");\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        } else if (updateFinalizedPeriod == storePeriod + 1) {\n            currentSyncCommitteeRoot = nextSyncCommitteeRoot;\n            currentSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        }\n        if (update.finalizedHeader.slot > finalizedHeader.slot) {\n            finalizedHeader = update.finalizedHeader;\n            if (update.finalizedExecutionStateRoot != bytes32(0)) {\n                finalizedExecutionStateRoot = update.finalizedExecutionStateRoot;\n                finalizedExecutionStateRootSlot = update.finalizedHeader.slot;\n            }\n            emit HeaderUpdated(\n                update.finalizedHeader.slot,\n                update.finalizedHeader.stateRoot,\n                update.finalizedExecutionStateRoot,\n                true\n            );\n        }\n    }\n\n    /*\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#is_better_update\n     */\n    function isBetterUpdate(LightClientUpdate memory newUpdate, LightClientUpdate memory oldUpdate)\n        private\n        pure\n        returns (bool)\n    {\n        // Old update doesn't exist\n        if (oldUpdate.syncAggregate.participation == 0) {\n            return newUpdate.syncAggregate.participation > 0;\n        }\n\n        // Compare supermajority (> 2/3) sync committee participation\n        bool newHasSupermajority = hasSupermajority(newUpdate.syncAggregate.participation);\n        bool oldHasSupermajority = hasSupermajority(oldUpdate.syncAggregate.participation);\n        if (newHasSupermajority != oldHasSupermajority) {\n            // the new update is a better one if new has supermajority but old doesn't\n            return newHasSupermajority && !oldHasSupermajority;\n        }\n        if (!newHasSupermajority && newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            // a better update is the one with higher participation when both new and old doesn't have supermajority\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Compare presence of relevant sync committee\n        bool newHasSyncCommittee = hasRelavantSyncCommittee(newUpdate);\n        bool oldHasSyncCommittee = hasRelavantSyncCommittee(oldUpdate);\n        if (newHasSyncCommittee != oldHasSyncCommittee) {\n            return newHasSyncCommittee;\n        }\n\n        // Compare indication of any fin\n        bool newHasFinality = hasFinalityProof(newUpdate);\n        bool oldHasFinality = hasFinalityProof(oldUpdate);\n        if (newHasFinality != oldHasFinality) {\n            return newHasFinality;\n        }\n\n        // Compare sync committee fin\n        if (newHasFinality) {\n            bool newHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(newUpdate.finalizedHeader.slot) ==\n                computeSyncCommitteePeriodAtSlot(newUpdate.attestedHeader.slot);\n            bool oldHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(oldUpdate.finalizedHeader.slot) ==\n                computeSyncCommitteePeriodAtSlot(oldUpdate.attestedHeader.slot);\n            if (newHasCommitteeFinality != oldHasCommitteeFinality) {\n                return newHasCommitteeFinality;\n            }\n        }\n\n        // Tiebreaker 1: Sync committee participation beyond supermajority\n        if (newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Tiebreaker 2: Prefer older data (fewer changes to best)\n        if (newUpdate.attestedHeader.slot != oldUpdate.attestedHeader.slot) {\n            return newUpdate.attestedHeader.slot < oldUpdate.attestedHeader.slot;\n        }\n\n        return newUpdate.signatureSlot < oldUpdate.signatureSlot;\n    }\n\n    function hasRelavantSyncCommittee(LightClientUpdate memory update) private pure returns (bool) {\n        return\n            hasNextSyncCommitteeProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.signatureSlot);\n    }\n\n    function hasNextSyncCommitteeProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.nextSyncCommitteeBranch.length > 0;\n    }\n\n    function hasFinalityProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.finalityBranch.length > 0;\n    }\n\n    function hasExecutionFinalityProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.finalizedExecutionStateRootBranch.length > 0;\n    }\n\n    function hasSupermajority(uint64 participation) private pure returns (bool) {\n        return participation * 3 >= SYNC_COMMITTEE_SIZE * 2;\n    }\n\n    function isEmptyHeader(BeaconBlockHeader memory header) private pure returns (bool) {\n        return header.stateRoot == bytes32(0);\n    }\n\n    function currentSlot() private view returns (uint64) {\n        return uint64((block.timestamp - GENESIS_TIME) / SLOT_LENGTH_SECONDS);\n    }\n\n    function computeForkVersion(uint64 epoch) private view returns (bytes4) {\n        for (uint256 i = forkVersions.length - 1; i >= 0; i--) {\n            if (epoch >= forkEpochs[i]) {\n                return forkVersions[i];\n            }\n        }\n        revert(\"fork versions not set\");\n    }\n\n    function computeSyncCommitteePeriodAtSlot(uint64 slot) private pure returns (uint64) {\n        return computeSyncCommitteePeriod(computeEpochAtSlot(slot));\n    }\n\n    function computeEpochAtSlot(uint64 slot) private pure returns (uint64) {\n        return slot / SLOTS_PER_EPOCH;\n    }\n\n    function computeSyncCommitteePeriod(uint64 epoch) private pure returns (uint64) {\n        return epoch / EPOCHS_PER_SYNC_COMMITTEE_PERIOD;\n    }\n\n    /**\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_domain\n     */\n    function computeDomain(bytes4 forkVersion) public view returns (bytes32) {\n        return DOMAIN_SYNC_COMMITTEE | (sha256(abi.encode(forkVersion, GENESIS_VALIDATOR_ROOT)) >> 32);\n    }\n\n    // computeDomain(forkVersion, genesisValidatorsRoot)\n    function computeSigningRoot(BeaconBlockHeader memory header, bytes32 domain) public pure returns (bytes32) {\n        return sha256(bytes.concat(SSZ.hashTreeRoot(header), domain));\n    }\n}\n"
    },
    "contracts/light-client/IZkVerifier.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\n\ninterface IZkVerifier {\n    function verifySignatureProof(\n        bytes32 signingRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        uint256 participation,\n        Proof memory p\n    ) external view returns (bool);\n\n    function verifySyncCommitteeRootMappingProof(\n        bytes32 sszRoot,\n        bytes32 poseidonRoot,\n        Proof memory p\n    ) external view returns (bool);\n}\n"
    },
    "contracts/light-client/LightClientStore.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\nimport \"./IZkVerifier.sol\";\n\nabstract contract LightClientStore {\n    // beacon chain genesis information\n    uint256 immutable GENESIS_TIME;\n    bytes32 immutable GENESIS_VALIDATOR_ROOT;\n\n    // light client store\n    BeaconBlockHeader public finalizedHeader;\n    bytes32 public finalizedExecutionStateRoot;\n    uint64 public finalizedExecutionStateRootSlot;\n\n    bytes32 public currentSyncCommitteeRoot;\n    bytes32 public currentSyncCommitteePoseidonRoot;\n    bytes32 public nextSyncCommitteeRoot;\n    bytes32 public nextSyncCommitteePoseidonRoot;\n\n    LightClientUpdate public bestValidUpdate;\n\n    // fork versions\n    uint64[] public forkEpochs;\n    bytes4[] public forkVersions;\n\n    // zk verifier\n    IZkVerifier public zkVerifier; // contract too big. need to move this one out\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        BeaconBlockHeader memory _finalizedHeader,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    ) {\n        GENESIS_TIME = genesisTime;\n        GENESIS_VALIDATOR_ROOT = genesisValidatorsRoot;\n        forkEpochs = _forkEpochs;\n        forkVersions = _forkVersions;\n        finalizedHeader = _finalizedHeader;\n        currentSyncCommitteeRoot = syncCommitteeRoot;\n        currentSyncCommitteePoseidonRoot = syncCommitteePoseidonRoot;\n        zkVerifier = IZkVerifier(_zkVerifier);\n    }\n}\n"
    },
    "contracts/light-client/SSZ.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\n\nlibrary SSZ {\n    function isValidMerkleBranch(\n        bytes32 leaf,\n        bytes32[] memory branch,\n        uint256 index,\n        bytes32 root\n    ) internal pure returns (bool) {\n        bytes32 restoredMerkleRoot = restoreMerkleRoot(leaf, branch, index);\n        return root == restoredMerkleRoot;\n    }\n\n    function restoreMerkleRoot(bytes32 leaf, bytes32[] memory branch, uint256 index) internal pure returns (bytes32) {\n        bytes32 value = leaf;\n        for (uint256 i = 0; i < branch.length; i++) {\n            if ((index / (2 ** i)) % 2 == 1) {\n                value = sha256(bytes.concat(branch[i], value));\n            } else {\n                value = sha256(bytes.concat(value, branch[i]));\n            }\n        }\n        return value;\n    }\n\n    function hashTreeRoot(BeaconBlockHeader memory header) internal pure returns (bytes32) {\n        bytes32 left = sha256(\n            bytes.concat(\n                sha256(bytes.concat(toLittleEndian(header.slot), toLittleEndian(header.proposerIndex))),\n                sha256(bytes.concat(header.parentRoot, header.stateRoot))\n            )\n        );\n        bytes32 right = sha256(\n            bytes.concat(\n                sha256(bytes.concat(header.bodyRoot, bytes32(0))),\n                sha256(bytes.concat(bytes32(0), bytes32(0)))\n            )\n        );\n        return sha256(bytes.concat(left, right));\n    }\n\n    function toLittleEndian(uint256 x) internal pure returns (bytes32) {\n        bytes32 res;\n        for (uint256 i = 0; i < 32; i++) {\n            res = (res << 8) | bytes32(x & 0xff);\n            x >>= 8;\n        }\n        return res;\n    }\n}\n"
    },
    "contracts/light-client/Types.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nstruct BeaconBlockHeader {\n    uint64 slot;\n    uint64 proposerIndex;\n    bytes32 parentRoot;\n    bytes32 stateRoot;\n    bytes32 bodyRoot;\n}\n\nstruct LightClientUpdate {\n    // Header attested to by the sync committee\n    BeaconBlockHeader attestedHeader;\n    // Finalized header corresponding to `attested_header.state_root`\n    BeaconBlockHeader finalizedHeader;\n    bytes32[] finalityBranch;\n    bytes32 finalizedExecutionStateRoot;\n    bytes32[] finalizedExecutionStateRootBranch;\n    bytes32 optimisticExecutionStateRoot;\n    bytes32[] optimisticExecutionStateRootBranch;\n    bytes32 nextSyncCommitteeRoot;\n    bytes32[] nextSyncCommitteeBranch;\n    bytes32 nextSyncCommitteePoseidonRoot;\n    Proof nextSyncCommitteeRootMappingProof;\n    // Sync committee aggregate signature participation & zk proof\n    SyncAggregate syncAggregate;\n    // Slot at which the aggregate signature was created (untrusted)\n    uint64 signatureSlot;\n}\n\nstruct SyncAggregate {\n    uint64 participation;\n    bytes32 poseidonRoot;\n    Proof proof;\n}\n\nstruct Proof {\n    uint256[2] a;\n    uint256[2][2] b;\n    uint256[2] c;\n}\n"
    },
    "contracts/light-client/verifier/BlsSigVerifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nimport \"./Pairing.sol\";\nimport \"./Constants.sol\";\nimport \"./Common.sol\";\n\ncontract BlsSigVerifier {\n    using Pairing for *;\n\n    function verifyingKey() private pure returns (Common.VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(16911711186432120094406167952308296783564962360374508997397923087832927523452),\n            uint256(16958111314286347510013353583140722938285661155928524007535396770300838300222)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(21454251991495730986643805295888501473970840601709532226318584490387104913729),\n                uint256(2917062111691328343612382672934083503565040996308880671892843648583219631215)\n            ],\n            [\n                uint256(4419476390750848540709862654466988414739774496710365131232573979016190662595),\n                uint256(13653004255625935239293213309837544816691204037906162416550104024082724917315)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(15219969119829449138309592099329963783251841001409110697736829604991747979575),\n                uint256(17225388966463464940867935119463804194147922955543503595549710044505610844770)\n            ],\n            [\n                uint256(11563468903980449231408312646957393861328856628694432594786520425329872358600),\n                uint256(706820252680189564096877097428266348420040781303176388943186460279432102461)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(12083865704820074402462203960356089131476391298814939806867269987290753762105),\n                uint256(15645577226473362415126385246308031281847607817067507717642865677524561312981)\n            ],\n            [\n                uint256(16742870416334534904854353803269526218812791193653910121429357546811002238433),\n                uint256(20267684942693645290380344212030129170448709320791114897364490210911267895477)\n            ]\n        );\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyBlsSigProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[34] memory input\n    ) public view returns (bool r) {\n        Common.Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        Common.VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(12628260047188721507402633572995239077937465141748636929238871325335042470774); // vk.K[0].X\n        vk_x.Y = uint256(374789106514435308939729333607432253212262633183545468974313779774353433426); // vk.K[0].Y\n        mul_input[0] = uint256(1072443897841180600163641601173187924428220322332724971415613421073836408489); // vk.K[1].X\n        mul_input[1] = uint256(4995382102156471285721396039805495655782916921575596803961169040955147774338); // vk.K[1].Y\n        mul_input[2] = input[0];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(18252974797331972274985655684137646318400168312221555400987483207654257070281); // vk.K[2].X\n        mul_input[1] = uint256(16928944298363927119154420018269922467448269470448218505594531097208963212143); // vk.K[2].Y\n        mul_input[2] = input[1];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(4425337740353557481318571761178146926947584186381173192062792213436605318547); // vk.K[3].X\n        mul_input[1] = uint256(19427759890194882166272523429160693945920351915924522239532980595367924118162); // vk.K[3].Y\n        mul_input[2] = input[2];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(13640284200681140681407549825532425813350148952869847691776951618133176542455); // vk.K[4].X\n        mul_input[1] = uint256(7025978338041945589224611251722859194117725028315631703368077901535120766859); // vk.K[4].Y\n        mul_input[2] = input[3];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(8658424862592342188795330819844700701096576319545711515893400180524795599678); // vk.K[5].X\n        mul_input[1] = uint256(20450945819588409845557804924050204847722887217960737817464330299352250714930); // vk.K[5].Y\n        mul_input[2] = input[4];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(21243287687814808516158088857316120483050088403601726296541579441120757352220); // vk.K[6].X\n        mul_input[1] = uint256(21438047297038843517334679174245728209162192884601612662176914812523868435468); // vk.K[6].Y\n        mul_input[2] = input[5];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(2433387358401656449613957154303466738602656950437276570994754300616567288439); // vk.K[7].X\n        mul_input[1] = uint256(20455243795479100491327901749169333756530917770430254010608375582199416302174); // vk.K[7].Y\n        mul_input[2] = input[6];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(18960645297220457104332100207500703973596448854206260187438282349034498265411); // vk.K[8].X\n        mul_input[1] = uint256(19139838243136029476040879738841229097357599751672713342079755268606834466697); // vk.K[8].Y\n        mul_input[2] = input[7];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(11033798223370376678670638812721448076487073146582619347863987920254417862252); // vk.K[9].X\n        mul_input[1] = uint256(287051572523895364214048767124627333425065007705625697958480971988128634144); // vk.K[9].Y\n        mul_input[2] = input[8];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        mul_input[0] = uint256(10710156256797398670222936384446577143639871295394864506398796536162751962909); // vk.K[10].X\n        mul_input[1] = uint256(19273903692155197084974834255476390307359855002486716922159792395039118848197); // vk.K[10].Y\n        mul_input[2] = input[9];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[10] * input[9]\n        mul_input[0] = uint256(7366801162991697325367172022977550142149821321998574416408094104306208042309); // vk.K[11].X\n        mul_input[1] = uint256(9969616086934282601393217502521124400558534738778892720747769640381308947725); // vk.K[11].Y\n        mul_input[2] = input[10];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[11] * input[10]\n        mul_input[0] = uint256(5536228715011047005866030482072014108057898617107700906148557340654503387588); // vk.K[12].X\n        mul_input[1] = uint256(17772299551741198074885905842679715740578221372934859767521271139501187072725); // vk.K[12].Y\n        mul_input[2] = input[11];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[12] * input[11]\n        mul_input[0] = uint256(16169150204788585645250055797748003762002964717871975367929629952583543401611); // vk.K[13].X\n        mul_input[1] = uint256(10788429556912820269669464718359677619307053873486465832301407268967585488354); // vk.K[13].Y\n        mul_input[2] = input[12];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[13] * input[12]\n        mul_input[0] = uint256(19979642897840262729273269654874785964127219562757810008034999661224396097376); // vk.K[14].X\n        mul_input[1] = uint256(10604433911528439841191819424753161527482748012086469029511203310378560756055); // vk.K[14].Y\n        mul_input[2] = input[13];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[14] * input[13]\n        mul_input[0] = uint256(17927106286797314061872177899945551858599347264206317639453828087058026261446); // vk.K[15].X\n        mul_input[1] = uint256(7692060075693548618946812296562858633401575135185673058948093439470566841213); // vk.K[15].Y\n        mul_input[2] = input[14];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[15] * input[14]\n        mul_input[0] = uint256(395483824020665764559647914552594160823121457095235004954966047407103834894); // vk.K[16].X\n        mul_input[1] = uint256(16763381344448438323911162393874859126137568311090205787929020221361878935317); // vk.K[16].Y\n        mul_input[2] = input[15];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[16] * input[15]\n        mul_input[0] = uint256(253150307890974161841275657883975744252994969466488212347958566248304135331); // vk.K[17].X\n        mul_input[1] = uint256(6223359866456963285959976578616089600325345074498740648806060765631001998291); // vk.K[17].Y\n        mul_input[2] = input[16];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[17] * input[16]\n        mul_input[0] = uint256(2691289317617486181380289288057336036420181220111513555400971865839421081786); // vk.K[18].X\n        mul_input[1] = uint256(12913067672747548954794333763004639473665624479453914647540312355193511894442); // vk.K[18].Y\n        mul_input[2] = input[17];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[18] * input[17]\n        mul_input[0] = uint256(11192982996815173459524496659381739373508844926456670547425589402174263650491); // vk.K[19].X\n        mul_input[1] = uint256(20004674939422575968276195043329195805812091570591284070099266965879732549725); // vk.K[19].Y\n        mul_input[2] = input[18];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[19] * input[18]\n        mul_input[0] = uint256(16775890840806524149552398247516548352368839674540260586584779619524209304445); // vk.K[20].X\n        mul_input[1] = uint256(1944206053755229848785756636372446556261209361785746197003985069704991303692); // vk.K[20].Y\n        mul_input[2] = input[19];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[20] * input[19]\n        mul_input[0] = uint256(10183877289549149912455401534381587912943418816850599592062244334062507171004); // vk.K[21].X\n        mul_input[1] = uint256(20392678916251726826728319401809513489429155697589219660726565125376894480418); // vk.K[21].Y\n        mul_input[2] = input[20];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[21] * input[20]\n        mul_input[0] = uint256(16339897172778517614624922887922370698092792408420035506222165497382802115571); // vk.K[22].X\n        mul_input[1] = uint256(12230163396700856129808531969616650849301079294701392193160758325303289393079); // vk.K[22].Y\n        mul_input[2] = input[21];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[22] * input[21]\n        mul_input[0] = uint256(12848584757986097532484632232050695147066406616017488284126616044852467869163); // vk.K[23].X\n        mul_input[1] = uint256(5529292646503014771969209314350873523270294814550049414091542742443591935763); // vk.K[23].Y\n        mul_input[2] = input[22];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[23] * input[22]\n        mul_input[0] = uint256(18607839562927600650680177834109435418584727893308693982036443225820026193005); // vk.K[24].X\n        mul_input[1] = uint256(18355061292307891277826921033187809703510759623103920051220431966922567943728); // vk.K[24].Y\n        mul_input[2] = input[23];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[24] * input[23]\n        mul_input[0] = uint256(11776122599137721875039861084790890814230852007207309418748915950065528602891); // vk.K[25].X\n        mul_input[1] = uint256(13118059925572606040444526359631045121250882673881761566671010925908214248721); // vk.K[25].Y\n        mul_input[2] = input[24];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[25] * input[24]\n        mul_input[0] = uint256(7958469121513806956473578350245786819269710803041121520986751190795820047711); // vk.K[26].X\n        mul_input[1] = uint256(8269260228843793008652484913146033096576995359296227061601512123377617721521); // vk.K[26].Y\n        mul_input[2] = input[25];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[26] * input[25]\n        mul_input[0] = uint256(3396407134920897667140178688458126868805115573848982021828462514002549756730); // vk.K[27].X\n        mul_input[1] = uint256(14156872680357932804005359197816107099972170493184489569701759478167418957188); // vk.K[27].Y\n        mul_input[2] = input[26];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[27] * input[26]\n        mul_input[0] = uint256(407434957491776994318968471809416187244837302259409458282280394410788993158); // vk.K[28].X\n        mul_input[1] = uint256(14913448679081592164038565992375432799937805076336099077165724038770287152854); // vk.K[28].Y\n        mul_input[2] = input[27];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[28] * input[27]\n        mul_input[0] = uint256(20074465334970524781241769265610964350202992417876614221969280727360185338826); // vk.K[29].X\n        mul_input[1] = uint256(11569884215367828378364815419149887451790811627379327502722039492289546990179); // vk.K[29].Y\n        mul_input[2] = input[28];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[29] * input[28]\n        mul_input[0] = uint256(2245839810470645464304430655076245698876013080906928556640881180365676227353); // vk.K[30].X\n        mul_input[1] = uint256(16919211048082078917279398514014956245044155707390493185336231856649349762231); // vk.K[30].Y\n        mul_input[2] = input[29];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[30] * input[29]\n        mul_input[0] = uint256(3630516425127221582906147290098507422702966115807369239981676054664480517863); // vk.K[31].X\n        mul_input[1] = uint256(15461515398272909285282260230950747775889585742468844770963966913453134460926); // vk.K[31].Y\n        mul_input[2] = input[30];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[31] * input[30]\n        mul_input[0] = uint256(12130462563258209656316724665629072935608513477467453252974467982530426838331); // vk.K[32].X\n        mul_input[1] = uint256(7009738295704514125062244256960881550658845480051552904990593672233616340171); // vk.K[32].Y\n        mul_input[2] = input[31];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[32] * input[31]\n        mul_input[0] = uint256(12227577516196054791997178461830393925748012653108793261373780533544790893502); // vk.K[33].X\n        mul_input[1] = uint256(19348977655838679484032219316113257421951361143660915497460119056888916008383); // vk.K[33].Y\n        mul_input[2] = input[32];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[33] * input[32]\n        mul_input[0] = uint256(2943645815399107884111796483545309610563337607753506951583833118419993893430); // vk.K[34].X\n        mul_input[1] = uint256(11078238039340022043432700763827306045295792807330961408021695949310536879453); // vk.K[34].Y\n        mul_input[2] = input[33];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[34] * input[33]\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/light-client/verifier/CommitteeRootMappingVerifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nimport \"./Pairing.sol\";\nimport \"./Constants.sol\";\nimport \"./Common.sol\";\n\ncontract CommitteeRootMappingVerifier {\n    using Pairing for *;\n\n    function verifyingKey1() private pure returns (Common.VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(4625995678875839184227102343980957941553435037863367632170514069470978075482),\n            uint256(7745472346822620166365670179252096531675980956628675937691452644416704349631)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(16133906051290029359415836500687237322258320219528941728637152470582101797559),\n                uint256(9982592290591904397750372202184781412509742437847499064025507928193374812763)\n            ],\n            [\n                uint256(20447084996628162496147084243623314997274147610235538549283479856317752366847),\n                uint256(10652060452474388359080900509291122865897396777233890537481945528644944582649)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(14205774305928561884273671177098614973303096843515928049981466843882075090453),\n                uint256(6194647019556442694746623566240152360142526955447025858054760757353994166695)\n            ],\n            [\n                uint256(720177741655577944140882804072173464461234581005085937938128202222496044348),\n                uint256(15180859461535417805311870856102250988010112023636345871703449475067945282517)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(2075341858515413383107490988194322113274273165071779395977011288835607214232),\n                uint256(21779842329350845285414688998042134519611654255235365675696046856282966715158)\n            ],\n            [\n                uint256(4310903133868833376693610009744123646701594778591654462646551313203044329349),\n                uint256(8934039419334185533732134671857943150009456594043165319933471646801466475060)\n            ]\n        );\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyCommitteeRootMappingProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[33] memory input\n    ) public view returns (bool r) {\n        Common.Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        Common.VerifyingKey memory vk = verifyingKey1();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(20552480178503420105472757749758256930777503163697981232418248899738739436302); // vk.K[0].X\n        vk_x.Y = uint256(21874644052683447189335205444383300629386926406593895540736254865290692175330); // vk.K[0].Y\n        mul_input[0] = uint256(2419465434811246925970456918943785845329721675292263546063218305166868830301); // vk.K[1].X\n        mul_input[1] = uint256(224414837900933448241244127409926533084118787014653569685139207760162770563); // vk.K[1].Y\n        mul_input[2] = input[0];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(20237582094031100903111658800543003981446659818658320070287593450545147260932); // vk.K[2].X\n        mul_input[1] = uint256(9498936270692258262448475366106441134297508170417707117017418182506243810929); // vk.K[2].Y\n        mul_input[2] = input[1];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(21686431407509598771022896245105442713057757617842882639916055310118549735455); // vk.K[3].X\n        mul_input[1] = uint256(18587475580363988870337779644366478839186363821430368900189877147428300473925); // vk.K[3].Y\n        mul_input[2] = input[2];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(4190323520659374373641761976155873288531237902311450285189695279890286046705); // vk.K[4].X\n        mul_input[1] = uint256(8044837422277408304807431419004307582225876792722238390231063677200212676904); // vk.K[4].Y\n        mul_input[2] = input[3];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(2652622379392044318082038991710242104342228971779836360052332572087628421201); // vk.K[5].X\n        mul_input[1] = uint256(406860223885500452975843681654102213552218004006375181643914225581644355831); // vk.K[5].Y\n        mul_input[2] = input[4];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(6057918943482398019697118579402810827270820344972408585195554580949838772589); // vk.K[6].X\n        mul_input[1] = uint256(5060377211716517826689871487122513539243478809827924728351043431363438746264); // vk.K[6].Y\n        mul_input[2] = input[5];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(3687702938753468537462497928786246235243684882237823906440956320376037461563); // vk.K[7].X\n        mul_input[1] = uint256(1208686206265801496727901652555022795816232879429721718984614404615694111083); // vk.K[7].Y\n        mul_input[2] = input[6];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(11710614008104008246282861623202747769385618500144669344475214097509828684593); // vk.K[8].X\n        mul_input[1] = uint256(5065836875015911503963590142184023993405575153173968399414211124081308802733); // vk.K[8].Y\n        mul_input[2] = input[7];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(544404787870686540959136485911507545335221912755631162384362056307403363961); // vk.K[9].X\n        mul_input[1] = uint256(2345869893991024974950769006226913293849021455623995373213361343160988457751); // vk.K[9].Y\n        mul_input[2] = input[8];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        mul_input[0] = uint256(2209389364146280288951908471817129375141759543141552284740145921306411049406); // vk.K[10].X\n        mul_input[1] = uint256(9042259349973012497614444570261244747029883119587798835387806797437998198439); // vk.K[10].Y\n        mul_input[2] = input[9];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[10] * input[9]\n        mul_input[0] = uint256(5329749415213215279150815169017002879660981652478899879932293459107956198272); // vk.K[11].X\n        mul_input[1] = uint256(1269241490245981774317800992176787362067828005821041854984670483140659381972); // vk.K[11].Y\n        mul_input[2] = input[10];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[11] * input[10]\n        mul_input[0] = uint256(4943793813361186613838184379271444100858893499387902057809188182513783485846); // vk.K[12].X\n        mul_input[1] = uint256(9275690329715777324103642003412034648418070562981699307031172873365106078545); // vk.K[12].Y\n        mul_input[2] = input[11];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[12] * input[11]\n        mul_input[0] = uint256(12729498268013982038852548044563174517696421517428254680176367740849220266709); // vk.K[13].X\n        mul_input[1] = uint256(7546589572574852665535613703939452808321148398493753492131740521875420626909); // vk.K[13].Y\n        mul_input[2] = input[12];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[13] * input[12]\n        mul_input[0] = uint256(9333085734209829031122997463964247926338222396225058317742956090059153031592); // vk.K[14].X\n        mul_input[1] = uint256(4043123151744068929699760825751364162242644369436915556155534564396462636465); // vk.K[14].Y\n        mul_input[2] = input[13];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[14] * input[13]\n        mul_input[0] = uint256(3698686717106590496650986585007797659650605418055308742433506982460764492730); // vk.K[15].X\n        mul_input[1] = uint256(9179617523334761636265229485895993306228474412981061346064728177636515751968); // vk.K[15].Y\n        mul_input[2] = input[14];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[15] * input[14]\n        mul_input[0] = uint256(15521850592660810728436432508964964041834382081916421935161893482249902884387); // vk.K[16].X\n        mul_input[1] = uint256(5449901017503560405242500659614777785834634841695450826672263537767974100219); // vk.K[16].Y\n        mul_input[2] = input[15];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[16] * input[15]\n        mul_input[0] = uint256(20102906107256118088436001377164222872704427733042089123636772674622559816716); // vk.K[17].X\n        mul_input[1] = uint256(12498854682789208487185327670228889940757953195079617884138082484806034246784); // vk.K[17].Y\n        mul_input[2] = input[16];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[17] * input[16]\n        mul_input[0] = uint256(9455841695606475800176819517076441035373288808813491909032241063291148788930); // vk.K[18].X\n        mul_input[1] = uint256(5760837211388967374979882368837632355372021503182733102840122488409476353553); // vk.K[18].Y\n        mul_input[2] = input[17];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[18] * input[17]\n        mul_input[0] = uint256(1446991383552871512734012954692326283314249519870143612600792757960520781278); // vk.K[19].X\n        mul_input[1] = uint256(9834470268591454131741863361237282178002203711883219940241340793939995038767); // vk.K[19].Y\n        mul_input[2] = input[18];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[19] * input[18]\n        mul_input[0] = uint256(1059357485615144832413353841149751938707953460935522780194084907196702253731); // vk.K[20].X\n        mul_input[1] = uint256(10815569476482003993766770423385630209543201328293985898718647153832884016017); // vk.K[20].Y\n        mul_input[2] = input[19];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[20] * input[19]\n        mul_input[0] = uint256(7433245970798099608332042376067563625513377267096206052430761000239299269566); // vk.K[21].X\n        mul_input[1] = uint256(12741834193487831964894419250386047831198155854304448707022734193570700410821); // vk.K[21].Y\n        mul_input[2] = input[20];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[21] * input[20]\n        mul_input[0] = uint256(8648224634225961431530490440075030243542463588893169022877288417966438069777); // vk.K[22].X\n        mul_input[1] = uint256(16540610842070555034877322476339116325277917786072762919274678110762172365508); // vk.K[22].Y\n        mul_input[2] = input[21];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[22] * input[21]\n        mul_input[0] = uint256(16908648218709781420138074614673957046034248547088691701260866141074824824919); // vk.K[23].X\n        mul_input[1] = uint256(20980273428957053574278769661356962533672481733183512384951407225298181139010); // vk.K[23].Y\n        mul_input[2] = input[22];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[23] * input[22]\n        mul_input[0] = uint256(20934252423600973663175987808002009495824217352345209099319606411155218995932); // vk.K[24].X\n        mul_input[1] = uint256(9987927206019920292163635872827487165514620975045002130414615160938718715749); // vk.K[24].Y\n        mul_input[2] = input[23];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[24] * input[23]\n        mul_input[0] = uint256(9602737041922572073213386264444643405537681976425696147506639312256088109115); // vk.K[25].X\n        mul_input[1] = uint256(5030838233095700558123674330813925820525997306253984515590208165812087573689); // vk.K[25].Y\n        mul_input[2] = input[24];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[25] * input[24]\n        mul_input[0] = uint256(20088832978375886523413495106079569725269630343909328763686584839952109161933); // vk.K[26].X\n        mul_input[1] = uint256(8311397503596416021728705867174781915782892850820869993294450806608979293432); // vk.K[26].Y\n        mul_input[2] = input[25];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[26] * input[25]\n        mul_input[0] = uint256(15729968276421379987872047780863974781795109674620595131198333451598870913212); // vk.K[27].X\n        mul_input[1] = uint256(11755585053459843437112320638816029546922021127794137048950074210155862560131); // vk.K[27].Y\n        mul_input[2] = input[26];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[27] * input[26]\n        mul_input[0] = uint256(5783930197610380391486193680213891260111080319012345925622032738683845648623); // vk.K[28].X\n        mul_input[1] = uint256(15914052883335873414184612431500787588848752068877353731383121390711998005745); // vk.K[28].Y\n        mul_input[2] = input[27];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[28] * input[27]\n        mul_input[0] = uint256(13576027419855184371737615151659181815220661446877879847199764825219880625500); // vk.K[29].X\n        mul_input[1] = uint256(2191728030944522062213775267825510142676636904535936426097088151735038661017); // vk.K[29].Y\n        mul_input[2] = input[28];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[29] * input[28]\n        mul_input[0] = uint256(17443744306907421274656073114832682866914815795994710278637727590770342132904); // vk.K[30].X\n        mul_input[1] = uint256(6204265850197846880732314988280474321915051365218910504902500465319260176648); // vk.K[30].Y\n        mul_input[2] = input[29];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[30] * input[29]\n        mul_input[0] = uint256(7667236600173703281656707827902729453577123223272717952708859478183847798002); // vk.K[31].X\n        mul_input[1] = uint256(3073364345901477288521870238026227645583520851820532416933060479253244595356); // vk.K[31].Y\n        mul_input[2] = input[30];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[31] * input[30]\n        mul_input[0] = uint256(9980877541970177898146397507672456369445448128646497326829193893755401659297); // vk.K[32].X\n        mul_input[1] = uint256(11845859001496825643147981605740249183632753870257747701403057774143489519069); // vk.K[32].Y\n        mul_input[2] = input[31];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[32] * input[31]\n        mul_input[0] = uint256(12453897189547283279636360437482740153245209912090247350145743599538029507132); // vk.K[33].X\n        mul_input[1] = uint256(6469937287375115226432040539121250021511388797917475330256634615436829876816); // vk.K[33].Y\n        mul_input[2] = input[32];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[33] * input[32]\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/light-client/verifier/Common.sol": {
      "content": "// SPDX-License-Identifier: AML\n\npragma solidity ^0.8.0;\n\nimport \"./Pairing.sol\";\n\nlibrary Common {\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n    }\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n}\n"
    },
    "contracts/light-client/verifier/Constants.sol": {
      "content": "// SPDX-License-Identifier: AML\n\npragma solidity ^0.8.0;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n"
    },
    "contracts/light-client/verifier/Pairing.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nlibrary Pairing {\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n"
    },
    "contracts/light-client/verifier/ZkVerifier.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.18;\n\nimport \"../Types.sol\";\nimport \"./BlsSigVerifier.sol\";\nimport \"./CommitteeRootMappingVerifier.sol\";\n\ncontract ZkVerifier is BlsSigVerifier, CommitteeRootMappingVerifier {\n    function verifySignatureProof(\n        bytes32 signingRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        uint256 participation,\n        Proof memory p\n    ) public view returns (bool) {\n        uint256[34] memory input;\n        uint256 root = uint256(signingRoot);\n        // slice the signing root into 32 individual bytes and assign them in order to the first 32 slots of input[]\n        for (uint256 i = 0; i < 32; i++) {\n            input[(32 - 1 - i)] = root % 256;\n            root = root / 256;\n        }\n        input[32] = participation;\n        input[33] = uint256(syncCommitteePoseidonRoot);\n        return verifyBlsSigProof(p.a, p.b, p.c, input);\n    }\n\n    function verifySyncCommitteeRootMappingProof(\n        bytes32 sszRoot,\n        bytes32 poseidonRoot,\n        Proof memory p\n    ) public view returns (bool) {\n        uint256[33] memory input;\n        uint256 root = uint256(sszRoot);\n        for (uint256 i = 0; i < 32; i++) {\n            input[(32 - 1 - i)] = root % 256;\n            root = root / 256;\n        }\n        input[32] = uint256(poseidonRoot);\n        return verifyCommitteeRootMappingProof(p.a, p.b, p.c, input);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}