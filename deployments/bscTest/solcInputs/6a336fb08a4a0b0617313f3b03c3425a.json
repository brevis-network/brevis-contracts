{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/external/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IDynamicFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\n\n/// @notice The dynamic fee manager determines fees for pools\n/// @dev note that this pool is only called if the PoolKey fee value is equal to the DYNAMIC_FEE magic value\ninterface IDynamicFeeManager {\n    function getFee(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata data)\n        external\n        returns (uint24);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IFees.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.19;\n\nimport {Currency} from \"../types/Currency.sol\";\n\ninterface IFees {\n    /// @notice Thrown when the protocol fee denominator is less than 4. Also thrown when the static or dynamic fee on a pool is exceeds 100%.\n    error FeeTooLarge();\n    /// @notice Thrown when not enough gas is provided to look up the protocol fee\n    error ProtocolFeeCannotBeFetched();\n\n    event ProtocolFeeControllerUpdated(address protocolFeeController);\n\n    /// @notice Returns the minimum denominator for the protocol fee, which restricts it to a maximum of 25%\n    function MIN_PROTOCOL_FEE_DENOMINATOR() external view returns (uint8);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    function protocolFeesAccrued(Currency) external view returns (uint256);\n\n    /// @notice Given a hook and a currency address, returns the fees accrued\n    function hookFeesAccrued(address, Currency) external view returns (uint256);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IHookFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\n/// @notice The interface for setting a fee on swap or fee on withdraw to the hook\n/// @dev This callback is only made if the Fee.HOOK_SWAP_FEE_FLAG or Fee.HOOK_WITHDRAW_FEE_FLAG in set in the pool's key.fee.\ninterface IHookFeeManager {\n    /// @notice Gets the fee a hook can take at swap/withdraw. Upper bits used for swap and lower bits for withdraw.\n    /// @param key The pool key\n    /// @return The hook fees for swapping (upper bits set) and withdrawing (lower bits set).\n    function getHookFees(PoolKey calldata key) external view returns (uint24);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IHooks.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\n\n/// @notice The PoolManager contract decides whether to invoke specific hooks by inspecting the leading bits\n/// of the hooks contract address. For example, a 1 bit in the first bit of the address will\n/// cause the 'before swap' hook to be invoked. See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(\n        address sender,\n        PoolKey calldata key,\n        uint160 sqrtPriceX96,\n        int24 tick,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before a position is modified\n    /// @param sender The initial msg.sender for the modify position call\n    /// @param key The key for the pool\n    /// @param params The parameters for modifying the position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeModifyPosition(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyPositionParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after a position is modified\n    /// @param sender The initial msg.sender for the modify position call\n    /// @param key The key for the pool\n    /// @param params The parameters for modifying the position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterModifyPosition(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyPositionParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the locker (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"
    },
    "@uniswap/v4-core/contracts/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {Pool} from \"../libraries/Pool.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IHooks} from \"./IHooks.sol\";\nimport {IFees} from \"./IFees.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {Position} from \"../libraries/Position.sol\";\n\ninterface IPoolManager is IFees, IERC1155 {\n    /// @notice Thrown when currencies touched has exceeded max of 256\n    error MaxCurrenciesTouched();\n\n    /// @notice Thrown when a currency is not netted out after a lock\n    error CurrencyNotSettled();\n\n    /// @notice Thrown when a function is called by an address that is not the current locker\n    /// @param locker The current locker\n    error LockedBy(address locker);\n\n    /// @notice The ERC1155 being deposited is not the Uniswap ERC1155\n    error NotPoolManagerToken();\n\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n    error TickSpacingTooLarge();\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n    error TickSpacingTooSmall();\n\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n    error CurrenciesInitializedOutOfOrder();\n\n    /// @notice Emitted when a new pool is initialized\n    /// @param id The abi encoded hash of the pool key struct for the new pool\n    /// @param currency0 The first currency of the pool by address sort order\n    /// @param currency1 The second currency of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\n    event Initialize(\n        PoolId indexed id,\n        Currency indexed currency0,\n        Currency indexed currency1,\n        uint24 fee,\n        int24 tickSpacing,\n        IHooks hooks\n    );\n\n    /// @notice Emitted when a liquidity position is modified\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that modified the pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidityDelta The amount of liquidity that was added or removed\n    event ModifyPosition(\n        PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta\n    );\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param amount0 The delta of the currency0 balance of the pool\n    /// @param amount1 The delta of the currency1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        int128 amount0,\n        int128 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick,\n        uint24 fee\n    );\n\n    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFees);\n\n    event HookFeeUpdated(PoolId indexed id, uint24 hookFees);\n\n    /// @notice Returns the constant representing the maximum tickSpacing for an initialized pool key\n    function MAX_TICK_SPACING() external view returns (int24);\n\n    /// @notice Returns the constant representing the minimum tickSpacing for an initialized pool key\n    function MIN_TICK_SPACING() external view returns (int24);\n\n    /// @notice Get the current value in slot0 of the given pool\n    function getSlot0(PoolId id)\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees);\n\n    /// @notice Get the current value of liquidity of the given pool\n    function getLiquidity(PoolId id) external view returns (uint128 liquidity);\n\n    /// @notice Get the current value of liquidity for the specified pool and position\n    function getLiquidity(PoolId id, address owner, int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (uint128 liquidity);\n\n    /// @notice Get the position struct for a specified pool and position\n    function getPosition(PoolId id, address owner, int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (Position.Info memory position);\n\n    /// @notice Returns the reserves for a given ERC20 currency\n    function reservesOf(Currency currency) external view returns (uint256);\n\n    /// @notice Contains data about pool lockers.\n    struct LockData {\n        /// @notice The current number of active lockers\n        uint128 length;\n        /// @notice The total number of nonzero deltas over all active + completed lockers\n        uint128 nonzeroDeltaCount;\n    }\n\n    /// @notice Returns the locker in the ith position of the locker queue.\n    function getLock(uint256 i) external view returns (address locker);\n\n    /// @notice Returns lock data\n    function lockData() external view returns (uint128 length, uint128 nonzeroDeltaCount);\n\n    /// @notice Initialize the state for a given pool ID\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96, bytes calldata hookData)\n        external\n        returns (int24 tick);\n\n    /// @notice Get the current delta for a locker in the given currency\n    /// @param locker The address of the locker\n    /// @param currency The currency for which to lookup the delta\n    function currencyDelta(address locker, Currency currency) external view returns (int256);\n\n    /// @notice All operations go through this function\n    /// @param data Any data to pass to the callback, via `ILockCallback(msg.sender).lockCallback(data)`\n    /// @return The data returned by the call to `ILockCallback(msg.sender).lockCallback(data)`\n    function lock(bytes calldata data) external returns (bytes memory);\n\n    struct ModifyPositionParams {\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // how to modify the liquidity\n        int256 liquidityDelta;\n    }\n\n    /// @notice Modify the position for the given pool\n    function modifyPosition(PoolKey memory key, ModifyPositionParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    struct SwapParams {\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swap against the given pool\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Donate the given currency amounts to the pool with the given pool key\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Can also be used as a mechanism for _free_ flash loans\n    function take(Currency currency, address to, uint256 amount) external;\n\n    /// @notice Called by the user to move value into ERC1155 balance\n    function mint(Currency token, address to, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    function settle(Currency token) external payable returns (uint256 paid);\n\n    /// @notice Sets the protocol's swap and withdrawal fees for the given pool\n    /// Protocol fees are always a portion of a fee that is owed. If that underlying fee is 0, no protocol fees will accrue even if it is set to > 0.\n    function setProtocolFees(PoolKey memory key) external;\n\n    /// @notice Sets the hook's swap and withdrawal fees for the given pool\n    function setHookFees(PoolKey memory key) external;\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to sload\n    /// @return value The value of the slot as bytes32\n    function extsload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to start sloading from\n    /// @param nSlots Number of slots to load into return value\n    /// @return value The value of the sload-ed slots concatenated as dynamic bytes\n    function extsload(bytes32 slot, uint256 nSlots) external view returns (bytes memory value);\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            if (x >= 0x100000000000000000000000000000000) {\n                x >>= 128;\n                r += 128;\n            }\n            if (x >= 0x10000000000000000) {\n                x >>= 64;\n                r += 64;\n            }\n            if (x >= 0x100000000) {\n                x >>= 32;\n                r += 32;\n            }\n            if (x >= 0x10000) {\n                x >>= 16;\n                r += 16;\n            }\n            if (x >= 0x100) {\n                x >>= 8;\n                r += 8;\n            }\n            if (x >= 0x10) {\n                x >>= 4;\n                r += 4;\n            }\n            if (x >= 0x4) {\n                x >>= 2;\n                r += 2;\n            }\n            if (x >= 0x2) r += 1;\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            r = 255;\n            if (x & type(uint128).max > 0) {\n                r -= 128;\n            } else {\n                x >>= 128;\n            }\n            if (x & type(uint64).max > 0) {\n                r -= 64;\n            } else {\n                x >>= 64;\n            }\n            if (x & type(uint32).max > 0) {\n                r -= 32;\n            } else {\n                x >>= 32;\n            }\n            if (x & type(uint16).max > 0) {\n                r -= 16;\n            } else {\n                x >>= 16;\n            }\n            if (x & type(uint8).max > 0) {\n                r -= 8;\n            } else {\n                x >>= 8;\n            }\n            if (x & 0xf > 0) {\n                r -= 4;\n            } else {\n                x >>= 4;\n            }\n            if (x & 0x3 > 0) {\n                r -= 2;\n            } else {\n                x >>= 2;\n            }\n            if (x & 0x1 > 0) r -= 1;\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/FeeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nlibrary FeeLibrary {\n    uint24 public constant STATIC_FEE_MASK = 0x0FFFFF;\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000; // 1000\n    uint24 public constant HOOK_SWAP_FEE_FLAG = 0x400000; // 0100\n    uint24 public constant HOOK_WITHDRAW_FEE_FLAG = 0x200000; // 0010\n\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\n        return self & DYNAMIC_FEE_FLAG != 0;\n    }\n\n    function hasHookSwapFee(uint24 self) internal pure returns (bool) {\n        return self & HOOK_SWAP_FEE_FLAG != 0;\n    }\n\n    function hasHookWithdrawFee(uint24 self) internal pure returns (bool) {\n        return self & HOOK_WITHDRAW_FEE_FLAG != 0;\n    }\n\n    function isStaticFeeTooLarge(uint24 self) internal pure returns (bool) {\n        return self & STATIC_FEE_MASK >= 1000000;\n    }\n\n    function getStaticFee(uint24 self) internal pure returns (uint24) {\n        return self & STATIC_FEE_MASK;\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/FixedPoint128.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/Hooks.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {FeeLibrary} from \"../libraries/FeeLibrary.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the leading bits of the address that\n/// the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x9000000000000000000000000000000000000000\n/// has leading bits '1001' which would cause the 'before initialize' and 'after modify position' hooks to be used.\nlibrary Hooks {\n    using FeeLibrary for uint24;\n\n    uint256 internal constant BEFORE_INITIALIZE_FLAG = 1 << 159;\n    uint256 internal constant AFTER_INITIALIZE_FLAG = 1 << 158;\n    uint256 internal constant BEFORE_MODIFY_POSITION_FLAG = 1 << 157;\n    uint256 internal constant AFTER_MODIFY_POSITION_FLAG = 1 << 156;\n    uint256 internal constant BEFORE_SWAP_FLAG = 1 << 155;\n    uint256 internal constant AFTER_SWAP_FLAG = 1 << 154;\n    uint256 internal constant BEFORE_DONATE_FLAG = 1 << 153;\n    uint256 internal constant AFTER_DONATE_FLAG = 1 << 152;\n\n    struct Calls {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeModifyPosition;\n        bool afterModifyPosition;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n    }\n\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\n    /// @param hooks The address of the hooks contract\n    error HookAddressNotValid(address hooks);\n\n    /// @notice Hook did not return its selector\n    error InvalidHookResponse();\n\n    /// @notice Utility function intended to be used in hook constructors to ensure\n    /// the deployed hooks address causes the intended hooks to be called\n    /// @param calls The hooks that are intended to be called\n    /// @dev calls param is memory as the function will be called from constructors\n    function validateHookAddress(IHooks self, Calls memory calls) internal pure {\n        if (\n            calls.beforeInitialize != shouldCallBeforeInitialize(self)\n                || calls.afterInitialize != shouldCallAfterInitialize(self)\n                || calls.beforeModifyPosition != shouldCallBeforeModifyPosition(self)\n                || calls.afterModifyPosition != shouldCallAfterModifyPosition(self)\n                || calls.beforeSwap != shouldCallBeforeSwap(self) || calls.afterSwap != shouldCallAfterSwap(self)\n                || calls.beforeDonate != shouldCallBeforeDonate(self) || calls.afterDonate != shouldCallAfterDonate(self)\n        ) {\n            revert HookAddressNotValid(address(self));\n        }\n    }\n\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\n    /// @param hook The hook to verify\n    function isValidHookAddress(IHooks hook, uint24 fee) internal pure returns (bool) {\n        // If there is no hook contract set, then fee cannot be dynamic and there cannot be a hook fee on swap or withdrawal.\n        return address(hook) == address(0)\n            ? !fee.isDynamicFee() && !fee.hasHookSwapFee() && !fee.hasHookWithdrawFee()\n            : (\n                uint160(address(hook)) >= AFTER_DONATE_FLAG || fee.isDynamicFee() || fee.hasHookSwapFee()\n                    || fee.hasHookWithdrawFee()\n            );\n    }\n\n    function shouldCallBeforeInitialize(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_INITIALIZE_FLAG != 0;\n    }\n\n    function shouldCallAfterInitialize(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_INITIALIZE_FLAG != 0;\n    }\n\n    function shouldCallBeforeModifyPosition(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_MODIFY_POSITION_FLAG != 0;\n    }\n\n    function shouldCallAfterModifyPosition(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_MODIFY_POSITION_FLAG != 0;\n    }\n\n    function shouldCallBeforeSwap(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_SWAP_FLAG != 0;\n    }\n\n    function shouldCallAfterSwap(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_SWAP_FLAG != 0;\n    }\n\n    function shouldCallBeforeDonate(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_DONATE_FLAG != 0;\n    }\n\n    function shouldCallAfterDonate(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_DONATE_FLAG != 0;\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {TickBitmap} from \"./TickBitmap.sol\";\nimport {Position} from \"./Position.sol\";\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\nimport {SwapMath} from \"./SwapMath.sol\";\nimport {BalanceDelta, toBalanceDelta} from \"../types/BalanceDelta.sol\";\n\nlibrary Pool {\n    using SafeCast for *;\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => Position.Info);\n    using Position for Position.Info;\n\n    /// @notice Thrown when tickLower is not below tickUpper\n    /// @param tickLower The invalid tickLower\n    /// @param tickUpper The invalid tickUpper\n    error TicksMisordered(int24 tickLower, int24 tickUpper);\n\n    /// @notice Thrown when tickLower is less than min tick\n    /// @param tickLower The invalid tickLower\n    error TickLowerOutOfBounds(int24 tickLower);\n\n    /// @notice Thrown when tickUpper exceeds max tick\n    /// @param tickUpper The invalid tickUpper\n    error TickUpperOutOfBounds(int24 tickUpper);\n\n    /// @notice For the tick spacing, the tick has too much liquidity\n    error TickLiquidityOverflow(int24 tick);\n\n    /// @notice Thrown when interacting with an uninitialized tick that must be initialized\n    /// @param tick The uninitialized tick\n    error TickNotInitialized(int24 tick);\n\n    /// @notice Thrown when trying to initalize an already initialized pool\n    error PoolAlreadyInitialized();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    /// @notice Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit\n    /// @param sqrtPriceCurrentX96 The invalid, already surpassed sqrtPriceLimitX96\n    /// @param sqrtPriceLimitX96 The surpassed price limit\n    error PriceLimitAlreadyExceeded(uint160 sqrtPriceCurrentX96, uint160 sqrtPriceLimitX96);\n\n    /// @notice Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range\n    /// @param sqrtPriceLimitX96 The invalid, out-of-bounds sqrtPriceLimitX96\n    error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);\n\n    /// @notice Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers\n    error NoLiquidityToReceiveFees();\n\n    /// Each uint24 variable packs both the swap fees and the withdraw fees represented as integer denominators (1/x). The upper 12 bits are the swap fees, and the lower 12 bits\n    /// are the withdraw fees. For swap fees, the upper 6 bits are the fee for trading 1 for 0, and the lower 6 are for 0 for 1 and are taken as a percentage of the lp swap fee.\n    /// For withdraw fees the upper 6 bits are the fee on amount1, and the lower 6 are for amount0 and are taken as a percentage of the principle amount of the underlying position.\n    /// bits          24 22 20 18 16 14 12 10 8  6  4  2  0\n    ///               |    swapFees     |   withdrawFees  |\n    ///               ┌────────┬────────┬────────┬────────┐\n    /// protocolFees: | 1->0   |  0->1  |  fee1  |  fee0  |\n    /// hookFees:     | 1->0   |  0->1  |  fee1  |  fee0  |\n    ///               └────────┴────────┴────────┴────────┘\n    struct Slot0 {\n        // the current price\n        uint160 sqrtPriceX96;\n        // the current tick\n        int24 tick;\n        uint24 protocolFees;\n        uint24 hookFees;\n    }\n    // 24 bits left!\n\n    // info stored for each initialized individual tick\n    struct TickInfo {\n        // the total position liquidity that references this tick\n        uint128 liquidityGross;\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n        int128 liquidityNet;\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint256 feeGrowthOutside0X128;\n        uint256 feeGrowthOutside1X128;\n    }\n\n    /// @dev The state of a pool\n    struct State {\n        Slot0 slot0;\n        uint256 feeGrowthGlobal0X128;\n        uint256 feeGrowthGlobal1X128;\n        uint128 liquidity;\n        mapping(int24 => TickInfo) ticks;\n        mapping(int16 => uint256) tickBitmap;\n        mapping(bytes32 => Position.Info) positions;\n    }\n\n    /// @dev Common checks for valid tick inputs.\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        if (tickLower >= tickUpper) revert TicksMisordered(tickLower, tickUpper);\n        if (tickLower < TickMath.MIN_TICK) revert TickLowerOutOfBounds(tickLower);\n        if (tickUpper > TickMath.MAX_TICK) revert TickUpperOutOfBounds(tickUpper);\n    }\n\n    function initialize(State storage self, uint160 sqrtPriceX96, uint24 protocolFees, uint24 hookFees)\n        internal\n        returns (int24 tick)\n    {\n        if (self.slot0.sqrtPriceX96 != 0) revert PoolAlreadyInitialized();\n\n        tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n\n        self.slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick, protocolFees: protocolFees, hookFees: hookFees});\n    }\n\n    function getSwapFee(uint24 feesStorage) internal pure returns (uint16) {\n        return uint16(feesStorage >> 12);\n    }\n\n    function getWithdrawFee(uint24 feesStorage) internal pure returns (uint16) {\n        return uint16(feesStorage & 0xFFF);\n    }\n\n    function setProtocolFees(State storage self, uint24 protocolFees) internal {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        self.slot0.protocolFees = protocolFees;\n    }\n\n    function setHookFees(State storage self, uint24 hookFees) internal {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        self.slot0.hookFees = hookFees;\n    }\n\n    struct ModifyPositionParams {\n        // the address that owns the position\n        address owner;\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // any change in liquidity\n        int128 liquidityDelta;\n        // the spacing between ticks\n        int24 tickSpacing;\n    }\n\n    struct ModifyPositionState {\n        bool flippedLower;\n        uint128 liquidityGrossAfterLower;\n        bool flippedUpper;\n        uint128 liquidityGrossAfterUpper;\n        uint256 feeGrowthInside0X128;\n        uint256 feeGrowthInside1X128;\n    }\n\n    struct FeeAmounts {\n        uint256 feeForProtocol0;\n        uint256 feeForProtocol1;\n        uint256 feeForHook0;\n        uint256 feeForHook1;\n    }\n\n    /// @dev Effect changes to a position in a pool\n    /// @param params the position details and the change to the position's liquidity to effect\n    /// @return result the deltas of the token balances of the pool\n    function modifyPosition(State storage self, ModifyPositionParams memory params)\n        internal\n        returns (BalanceDelta result, FeeAmounts memory fees)\n    {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        checkTicks(params.tickLower, params.tickUpper);\n\n        uint256 feesOwed0;\n        uint256 feesOwed1;\n        {\n            ModifyPositionState memory state;\n            // if we need to update the ticks, do it\n\n            if (params.liquidityDelta != 0) {\n                (state.flippedLower, state.liquidityGrossAfterLower) =\n                    updateTick(self, params.tickLower, params.liquidityDelta, false);\n                (state.flippedUpper, state.liquidityGrossAfterUpper) =\n                    updateTick(self, params.tickUpper, params.liquidityDelta, true);\n\n                if (params.liquidityDelta > 0) {\n                    uint128 maxLiquidityPerTick = tickSpacingToMaxLiquidityPerTick(params.tickSpacing);\n                    if (state.liquidityGrossAfterLower > maxLiquidityPerTick) {\n                        revert TickLiquidityOverflow(params.tickLower);\n                    }\n                    if (state.liquidityGrossAfterUpper > maxLiquidityPerTick) {\n                        revert TickLiquidityOverflow(params.tickUpper);\n                    }\n                }\n\n                if (state.flippedLower) {\n                    self.tickBitmap.flipTick(params.tickLower, params.tickSpacing);\n                }\n                if (state.flippedUpper) {\n                    self.tickBitmap.flipTick(params.tickUpper, params.tickSpacing);\n                }\n            }\n\n            (state.feeGrowthInside0X128, state.feeGrowthInside1X128) =\n                getFeeGrowthInside(self, params.tickLower, params.tickUpper);\n\n            (feesOwed0, feesOwed1) = self.positions.get(params.owner, params.tickLower, params.tickUpper).update(\n                params.liquidityDelta, state.feeGrowthInside0X128, state.feeGrowthInside1X128\n            );\n\n            // clear any tick data that is no longer needed\n            if (params.liquidityDelta < 0) {\n                if (state.flippedLower) {\n                    clearTick(self, params.tickLower);\n                }\n                if (state.flippedUpper) {\n                    clearTick(self, params.tickUpper);\n                }\n            }\n        }\n\n        if (params.liquidityDelta != 0) {\n            if (self.slot0.tick < params.tickLower) {\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\n                // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it\n                result = result\n                    + toBalanceDelta(\n                        SqrtPriceMath.getAmount0Delta(\n                            TickMath.getSqrtRatioAtTick(params.tickLower),\n                            TickMath.getSqrtRatioAtTick(params.tickUpper),\n                            params.liquidityDelta\n                        ).toInt128(),\n                        0\n                    );\n            } else if (self.slot0.tick < params.tickUpper) {\n                result = result\n                    + toBalanceDelta(\n                        SqrtPriceMath.getAmount0Delta(\n                            self.slot0.sqrtPriceX96, TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta\n                        ).toInt128(),\n                        SqrtPriceMath.getAmount1Delta(\n                            TickMath.getSqrtRatioAtTick(params.tickLower), self.slot0.sqrtPriceX96, params.liquidityDelta\n                        ).toInt128()\n                    );\n\n                self.liquidity = params.liquidityDelta < 0\n                    ? self.liquidity - uint128(-params.liquidityDelta)\n                    : self.liquidity + uint128(params.liquidityDelta);\n            } else {\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\n                // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it\n                result = result\n                    + toBalanceDelta(\n                        0,\n                        SqrtPriceMath.getAmount1Delta(\n                            TickMath.getSqrtRatioAtTick(params.tickLower),\n                            TickMath.getSqrtRatioAtTick(params.tickUpper),\n                            params.liquidityDelta\n                        ).toInt128()\n                    );\n            }\n        }\n\n        if (params.liquidityDelta < 0 && getWithdrawFee(self.slot0.hookFees) > 0) {\n            // Only take fees if the hook withdraw fee is set and the liquidity is being removed.\n            fees = _calculateExternalFees(self, result);\n\n            // Amounts are balances owed to the pool. When negative, they represent the balance a user can take.\n            // Since protocol and hook fees are extracted on the balance a user can take\n            // they are owed (added) back to the pool where they are kept to be collected by the fee recipients.\n            result = result\n                + toBalanceDelta(\n                    fees.feeForHook0.toInt128() + fees.feeForProtocol0.toInt128(),\n                    fees.feeForHook1.toInt128() + fees.feeForProtocol1.toInt128()\n                );\n        }\n\n        // Fees earned from LPing are removed from the pool balance.\n        result = result - toBalanceDelta(feesOwed0.toInt128(), feesOwed1.toInt128());\n    }\n\n    function _calculateExternalFees(State storage self, BalanceDelta result)\n        internal\n        view\n        returns (FeeAmounts memory fees)\n    {\n        int128 amount0 = result.amount0();\n        int128 amount1 = result.amount1();\n\n        Slot0 memory slot0Cache = self.slot0;\n        uint24 hookFees = slot0Cache.hookFees;\n        uint24 protocolFees = slot0Cache.protocolFees;\n\n        uint16 hookFee0 = getWithdrawFee(hookFees) % 64;\n        uint16 hookFee1 = getWithdrawFee(hookFees) >> 6;\n\n        uint16 protocolFee0 = getWithdrawFee(protocolFees) % 64;\n        uint16 protocolFee1 = getWithdrawFee(protocolFees) >> 6;\n\n        if (amount0 < 0 && hookFee0 > 0) {\n            fees.feeForHook0 = uint128(-amount0) / hookFee0;\n        }\n        if (amount1 < 0 && hookFee1 > 0) {\n            fees.feeForHook1 = uint128(-amount1) / hookFee1;\n        }\n\n        // A protocol fee is only applied if the hook fee is applied.\n        if (protocolFee0 > 0 && fees.feeForHook0 > 0) {\n            fees.feeForProtocol0 = fees.feeForHook0 / protocolFee0;\n            fees.feeForHook0 -= fees.feeForProtocol0;\n        }\n\n        if (protocolFee1 > 0 && fees.feeForHook1 > 0) {\n            fees.feeForProtocol1 = fees.feeForHook1 / protocolFee1;\n            fees.feeForHook1 -= fees.feeForProtocol1;\n        }\n\n        return fees;\n    }\n\n    struct SwapCache {\n        // liquidity at the beginning of the swap\n        uint128 liquidityStart;\n        // the protocol fee for the input token\n        uint16 protocolFee;\n        // the hook fee for the input token\n        uint16 hookFee;\n    }\n\n    // the top level state of the swap, the results of which are recorded in storage at the end\n    struct SwapState {\n        // the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        // the amount already swapped out/in of the output/input asset\n        int256 amountCalculated;\n        // current sqrt(price)\n        uint160 sqrtPriceX96;\n        // the tick associated with the current price\n        int24 tick;\n        // the global fee growth of the input token\n        uint256 feeGrowthGlobalX128;\n        // the current liquidity in range\n        uint128 liquidity;\n    }\n\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint160 sqrtPriceStartX96;\n        // the next tick to swap to from the current tick in the swap direction\n        int24 tickNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // sqrt(price) for the next tick (1/0)\n        uint160 sqrtPriceNextX96;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n    }\n\n    struct SwapParams {\n        uint24 fee;\n        int24 tickSpacing;\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @dev Executes a swap against the state, and returns the amount deltas of the pool\n    function swap(State storage self, SwapParams memory params)\n        internal\n        returns (BalanceDelta result, uint256 feeForProtocol, uint256 feeForHook, SwapState memory state)\n    {\n        if (params.amountSpecified == 0) revert SwapAmountCannotBeZero();\n\n        Slot0 memory slot0Start = self.slot0;\n        if (slot0Start.sqrtPriceX96 == 0) revert PoolNotInitialized();\n        if (params.zeroForOne) {\n            if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96) {\n                revert PriceLimitAlreadyExceeded(slot0Start.sqrtPriceX96, params.sqrtPriceLimitX96);\n            }\n            if (params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_RATIO) {\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\n            }\n        } else {\n            if (params.sqrtPriceLimitX96 <= slot0Start.sqrtPriceX96) {\n                revert PriceLimitAlreadyExceeded(slot0Start.sqrtPriceX96, params.sqrtPriceLimitX96);\n            }\n            if (params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_RATIO) {\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\n            }\n        }\n\n        SwapCache memory cache = SwapCache({\n            liquidityStart: self.liquidity,\n            protocolFee: params.zeroForOne\n                ? (getSwapFee(slot0Start.protocolFees) % 64)\n                : (getSwapFee(slot0Start.protocolFees) >> 6),\n            hookFee: params.zeroForOne ? (getSwapFee(slot0Start.hookFees) % 64) : (getSwapFee(slot0Start.hookFees) >> 6)\n        });\n\n        bool exactInput = params.amountSpecified > 0;\n\n        state = SwapState({\n            amountSpecifiedRemaining: params.amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            feeGrowthGlobalX128: params.zeroForOne ? self.feeGrowthGlobal0X128 : self.feeGrowthGlobal1X128,\n            liquidity: cache.liquidityStart\n        });\n\n        StepComputations memory step;\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != params.sqrtPriceLimitX96) {\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) =\n                self.tickBitmap.nextInitializedTickWithinOneWord(state.tick, params.tickSpacing, params.zeroForOne);\n\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            } else if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            // get the price for the next tick\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n                state.sqrtPriceX96,\n                (\n                    params.zeroForOne\n                        ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96\n                        : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96\n                ) ? params.sqrtPriceLimitX96 : step.sqrtPriceNextX96,\n                state.liquidity,\n                state.amountSpecifiedRemaining,\n                params.fee\n            );\n\n            if (exactInput) {\n                // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\n                unchecked {\n                    state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\n                }\n                state.amountCalculated = state.amountCalculated - step.amountOut.toInt256();\n            } else {\n                unchecked {\n                    state.amountSpecifiedRemaining += step.amountOut.toInt256();\n                }\n                state.amountCalculated = state.amountCalculated + (step.amountIn + step.feeAmount).toInt256();\n            }\n\n            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n            if (cache.protocolFee > 0) {\n                // A: calculate the amount of the fee that should go to the protocol\n                uint256 delta = step.feeAmount / cache.protocolFee;\n                // A: subtract it from the regular fee and add it to the protocol fee\n                unchecked {\n                    step.feeAmount -= delta;\n                    feeForProtocol += delta;\n                }\n            }\n\n            if (cache.hookFee > 0) {\n                // step.feeAmount has already been updated to account for the protocol fee\n                uint256 delta = step.feeAmount / cache.hookFee;\n                unchecked {\n                    step.feeAmount -= delta;\n                    feeForHook += delta;\n                }\n            }\n\n            // update global fee tracker\n            if (state.liquidity > 0) {\n                unchecked {\n                    state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\n                }\n            }\n\n            // shift tick if we reached the next price\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                // if the tick is initialized, run the tick transition\n                if (step.initialized) {\n                    int128 liquidityNet = Pool.crossTick(\n                        self,\n                        step.tickNext,\n                        (params.zeroForOne ? state.feeGrowthGlobalX128 : self.feeGrowthGlobal0X128),\n                        (params.zeroForOne ? self.feeGrowthGlobal1X128 : state.feeGrowthGlobalX128)\n                    );\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\n                    // safe because liquidityNet cannot be type(int128).min\n                    unchecked {\n                        if (params.zeroForOne) liquidityNet = -liquidityNet;\n                    }\n\n                    state.liquidity = liquidityNet < 0\n                        ? state.liquidity - uint128(-liquidityNet)\n                        : state.liquidity + uint128(liquidityNet);\n                }\n\n                unchecked {\n                    state.tick = params.zeroForOne ? step.tickNext - 1 : step.tickNext;\n                }\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        (self.slot0.sqrtPriceX96, self.slot0.tick) = (state.sqrtPriceX96, state.tick);\n\n        // update liquidity if it changed\n        if (cache.liquidityStart != state.liquidity) self.liquidity = state.liquidity;\n\n        // update fee growth global\n        if (params.zeroForOne) {\n            self.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n        } else {\n            self.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n        }\n\n        unchecked {\n            if (params.zeroForOne == exactInput) {\n                result = toBalanceDelta(\n                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128(),\n                    state.amountCalculated.toInt128()\n                );\n            } else {\n                result = toBalanceDelta(\n                    state.amountCalculated.toInt128(),\n                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128()\n                );\n            }\n        }\n    }\n\n    /// @notice Donates the given amount of currency0 and currency1 to the pool\n    function donate(State storage state, uint256 amount0, uint256 amount1) internal returns (BalanceDelta delta) {\n        if (state.liquidity == 0) revert NoLiquidityToReceiveFees();\n        delta = toBalanceDelta(amount0.toInt128(), amount1.toInt128());\n        unchecked {\n            if (amount0 > 0) {\n                state.feeGrowthGlobal0X128 += FullMath.mulDiv(amount0, FixedPoint128.Q128, state.liquidity);\n            }\n            if (amount1 > 0) {\n                state.feeGrowthGlobal1X128 += FullMath.mulDiv(amount1, FixedPoint128.Q128, state.liquidity);\n            }\n        }\n    }\n\n    /// @notice Retrieves fee growth data\n    /// @param self The Pool state struct\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function getFeeGrowthInside(State storage self, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\n    {\n        TickInfo storage lower = self.ticks[tickLower];\n        TickInfo storage upper = self.ticks[tickUpper];\n        int24 tickCurrent = self.slot0.tick;\n\n        unchecked {\n            if (tickCurrent < tickLower) {\n                feeGrowthInside0X128 = lower.feeGrowthOutside0X128 - upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 = lower.feeGrowthOutside1X128 - upper.feeGrowthOutside1X128;\n            } else if (tickCurrent >= tickUpper) {\n                feeGrowthInside0X128 = upper.feeGrowthOutside0X128 - lower.feeGrowthOutside0X128;\n                feeGrowthInside1X128 = upper.feeGrowthOutside1X128 - lower.feeGrowthOutside1X128;\n            } else {\n                feeGrowthInside0X128 =\n                    self.feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128 - upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    self.feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128 - upper.feeGrowthOutside1X128;\n            }\n        }\n    }\n\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The tick that will be updated\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n    /// @return liquidityGrossAfter The total amount of  liquidity for all positions that references the tick after the update\n    function updateTick(State storage self, int24 tick, int128 liquidityDelta, bool upper)\n        internal\n        returns (bool flipped, uint128 liquidityGrossAfter)\n    {\n        TickInfo storage info = self.ticks[tick];\n\n        uint128 liquidityGrossBefore;\n        int128 liquidityNetBefore;\n        assembly {\n            // load first slot of info which contains liquidityGross and liquidityNet packed\n            // where the top 128 bits are liquidityNet and the bottom 128 bits are liquidityGross\n            let liquidity := sload(info.slot)\n            // slice off top 128 bits of liquidity (liquidityNet) to get just liquidityGross\n            liquidityGrossBefore := shr(128, shl(128, liquidity))\n            // shift right 128 bits to get just liquidityNet\n            liquidityNetBefore := shr(128, liquidity)\n        }\n\n        liquidityGrossAfter = liquidityDelta < 0\n            ? liquidityGrossBefore - uint128(-liquidityDelta)\n            : liquidityGrossBefore + uint128(liquidityDelta);\n\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n        if (liquidityGrossBefore == 0) {\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n            if (tick <= self.slot0.tick) {\n                info.feeGrowthOutside0X128 = self.feeGrowthGlobal0X128;\n                info.feeGrowthOutside1X128 = self.feeGrowthGlobal1X128;\n            }\n        }\n\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n        int128 liquidityNet = upper ? liquidityNetBefore - liquidityDelta : liquidityNetBefore + liquidityDelta;\n        assembly {\n            // liquidityGrossAfter and liquidityNet are packed in the first slot of `info`\n            // So we can store them with a single sstore by packing them ourselves first\n            sstore(\n                info.slot,\n                // bitwise OR to pack liquidityGrossAfter and liquidityNet\n                or(\n                    // liquidityGross is in the low bits, upper bits are already 0\n                    liquidityGrossAfter,\n                    // shift liquidityNet to take the upper bits and lower bits get filled with 0\n                    shl(128, liquidityNet)\n                )\n            )\n        }\n    }\n\n    /// @notice Derives max liquidity per tick from given tick spacing\n    /// @dev Executed within the pool constructor\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n    /// @return The max liquidity per tick\n    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {\n        unchecked {\n            return uint128(\n                (type(uint128).max * uint256(int256(tickSpacing)))\n                    / uint256(int256(TickMath.MAX_TICK * 2 + tickSpacing))\n            );\n        }\n    }\n\n    /// @notice Clears tick data\n    /// @param self The mapping containing all initialized tick information for initialized ticks\n    /// @param tick The tick that will be cleared\n    function clearTick(State storage self, int24 tick) internal {\n        delete self.ticks[tick];\n    }\n\n    /// @notice Transitions to next tick as needed by price movement\n    /// @param self The Pool state struct\n    /// @param tick The destination tick of the transition\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n    function crossTick(State storage self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128)\n        internal\n        returns (int128 liquidityNet)\n    {\n        unchecked {\n            TickInfo storage info = self.ticks[tick];\n            info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;\n            info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;\n            liquidityNet = info.liquidityNet;\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/Position.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\n\n/// @title Position\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\n/// @dev Positions store additional state for tracking fees owed to the position\nlibrary Position {\n    /// @notice Cannot update a position with no liquidity\n    error CannotUpdateEmptyPosition();\n\n    // info stored for each user's position\n    struct Info {\n        // the amount of liquidity owned by this position\n        uint128 liquidity;\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n    }\n\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\n    /// @param self The mapping containing all user positions\n    /// @param owner The address of the position owner\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return position The position info struct of the given owners' position\n    function get(mapping(bytes32 => Info) storage self, address owner, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (Position.Info storage position)\n    {\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\n    }\n\n    /// @notice Credits accumulated fees to a user's position\n    /// @param self The individual position to update\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\n    /// @param feeGrowthInside0X128 The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries\n    /// @param feeGrowthInside1X128 The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries\n    /// @return feesOwed0 The amount of currency0 owed to the position owner\n    /// @return feesOwed1 The amount of currency1 owed to the position owner\n    function update(\n        Info storage self,\n        int128 liquidityDelta,\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128\n    ) internal returns (uint256 feesOwed0, uint256 feesOwed1) {\n        Info memory _self = self;\n\n        uint128 liquidityNext;\n        if (liquidityDelta == 0) {\n            if (_self.liquidity == 0) revert CannotUpdateEmptyPosition(); // disallow pokes for 0 liquidity positions\n            liquidityNext = _self.liquidity;\n        } else {\n            liquidityNext = liquidityDelta < 0\n                ? _self.liquidity - uint128(-liquidityDelta)\n                : _self.liquidity + uint128(liquidityDelta);\n        }\n\n        // calculate accumulated fees. overflow in the subtraction of fee growth is expected\n        unchecked {\n            feesOwed0 = FullMath.mulDiv(\n                feeGrowthInside0X128 - _self.feeGrowthInside0LastX128, _self.liquidity, FixedPoint128.Q128\n            );\n            feesOwed1 = FullMath.mulDiv(\n                feeGrowthInside1X128 - _self.feeGrowthInside1LastX128, _self.liquidity, FixedPoint128.Q128\n            );\n        }\n\n        // update the position\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y <= uint256(type(int256).max));\n        z = int256(y);\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(uint256 y) internal pure returns (int128 z) {\n        require(y <= uint128(type(int128).max));\n        z = int128(int256(y));\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/SqrtPriceMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {UnsafeMath} from \"./UnsafeMath.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of currency0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of currency0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product;\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1) {\n                        // always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                    }\n                }\n            }\n            // denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of currency1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of currency1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            return uint160(sqrtPX96 - quotient);\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\n    /// @return sqrtQX96 The price after adding the input amount to currency0 or currency1\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\n        internal\n        pure\n        returns (uint160 sqrtQX96)\n    {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\n    /// @param zeroForOne Whether the amount out is currency0 or currency1\n    /// @return sqrtQX96 The price after removing the output amount of currency0 or currency1\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\n        internal\n        pure\n        returns (uint160 sqrtQX96)\n    {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of currency0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount0)\n    {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n            require(sqrtRatioAX96 > 0);\n\n            return roundUp\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), sqrtRatioAX96)\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return roundUp\n            ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n            : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Helper that gets signed currency0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256 amount0)\n    {\n        unchecked {\n            return liquidity < 0\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed currency1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256 amount1)\n    {\n        unchecked {\n            return liquidity < 0\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/SwapMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\n        unchecked {\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n            bool exactIn = amountRemaining >= 0;\n\n            if (exactIn) {\n                uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n                if (amountRemainingLessFee >= amountIn) {\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\n                } else {\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                        sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne\n                    );\n                }\n            } else {\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n                if (uint256(-amountRemaining) >= amountOut) {\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\n                } else {\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                        sqrtRatioCurrentX96, liquidity, uint256(-amountRemaining), zeroForOne\n                    );\n                }\n            }\n\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n            // get the input/output amounts\n            if (zeroForOne) {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n            } else {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n            }\n\n            // cap the output amount to not exceed the remaining output amount\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\n                amountOut = uint256(-amountRemaining);\n            }\n\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n                // we didn't reach the target, so take the remainder of the maximum input as fee\n                feeAmount = uint256(amountRemaining) - amountIn;\n            } else {\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/TickBitmap.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n    /// @notice Thrown when the tick is not enumerated by the tick spacing\n    /// @param tick the invalid tick\n    /// @param tickSpacing The tick spacing of the pool\n    error TickMisaligned(int24 tick, int24 tickSpacing);\n\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\n        unchecked {\n            wordPos = int16(tick >> 8);\n            bitPos = uint8(int8(tick % 256));\n        }\n    }\n\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n    /// @param self The mapping in which to flip the tick\n    /// @param tick The tick to flip\n    /// @param tickSpacing The spacing between usable ticks\n    function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal {\n        unchecked {\n            if (tick % tickSpacing != 0) revert TickMisaligned(tick, tickSpacing); // ensure that the tick is spaced\n            (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\n            uint256 mask = 1 << bitPos;\n            self[wordPos] ^= mask;\n        }\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param self The mapping in which to compute the next initialized tick\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) internal view returns (int24 next, bool initialized) {\n        unchecked {\n            int24 compressed = tick / tickSpacing;\n            if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n            if (lte) {\n                (int16 wordPos, uint8 bitPos) = position(compressed);\n                // all the 1s at or to the right of the current bitPos\n                uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\n                    : (compressed - int24(uint24(bitPos))) * tickSpacing;\n            } else {\n                // start from the word of the next tick, since the current tick state doesn't matter\n                (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n                // all the 1s at or to the left of the bitPos\n                uint256 mask = ~((1 << bitPos) - 1);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\n                    : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @notice Thrown when the tick passed to #getSqrtRatioAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick();\n    /// @notice Thrown when the ratio passed to #getTickAtSqrtRatio does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtRatio();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert InvalidTick();\n\n            uint256 ratio =\n                absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert InvalidSqrtRatio();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            assembly {\n                z := add(div(x, y), gt(mod(x, y), 0))\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/types/BalanceDelta.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        balanceDelta :=\n            or(shl(128, _amount0), and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff, _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    return toBalanceDelta(a.amount0() + b.amount0(), a.amount1() + b.amount1());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    return toBalanceDelta(a.amount0() - b.amount0(), a.amount1() - b.amount1());\n}\n\nlibrary BalanceDeltaLibrary {\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            _amount0 := shr(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            _amount1 := balanceDelta\n        }\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/types/Currency.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, equals as ==} for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    using CurrencyLibrary for Currency;\n\n    /// @notice Thrown when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Thrown when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    Currency public constant NATIVE = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // implementation from\n        // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\n\n        bool success;\n        if (currency.isNative()) {\n            assembly {\n                // Transfer the ETH and store if it succeeded or not.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n\n            if (!success) revert NativeTransferFailed();\n        } else {\n            assembly {\n                // We'll write our calldata to this slot below, but restore it later.\n                let memPointer := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(4, to) // Append the \"to\" argument.\n                mstore(36, amount) // Append the \"amount\" argument.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                        // Counterintuitively, this call() must be positioned after the or() in the\n                        // surrounding and() because and() evaluates its arguments from right to left.\n                        call(gas(), currency, 0, 0, 68, 0, 32)\n                    )\n\n                mstore(0x60, 0) // Restore the zero slot to zero.\n                mstore(0x40, memPointer) // Restore the memPointer.\n            }\n\n            if (!success) revert ERC20TransferFailed();\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isNative()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isNative()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isNative(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/types/PoolId.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId) {\n        return PoolId.wrap(keccak256(abi.encode(poolKey)));\n    }\n}\n"
    },
    "@uniswap/v4-core/contracts/types/PoolKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.19;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool swap fee, capped at 1_000_000. The upper 4 bits determine if the hook sets any fees.\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-sum/IUniswapSumVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IUniswapSumVolume {\n    function getAttestedSwapSumVolume(address swapper) external view returns (uint256 volume);\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-sum/UniswapSumVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../../interfaces/ISMT.sol\";\nimport \"../../../verifiers/interfaces/IZkpVerifier.sol\";\nimport \"./IUniswapSumVolume.sol\";\n\ncontract UniswapSumVolume is Ownable, IUniswapSumVolume {\n    // retrieved from proofData, to align the fields with circuit...\n    struct ProofData {\n        address recipient;\n        uint256 volume;\n        bytes32 smtRoot;\n        uint256 length;\n        uint256 cPub;\n        uint256 vkHash;\n    }\n\n    uint256[6] public batchTierVkHashes;\n    uint32 constant PUBLIC_BYTES_START_IDX = 10 * 32; // the first 10 32bytes are groth16 proof (A/B/C/Commitment)\n\n    mapping(address => uint256) public volumes;\n    mapping(uint64 => address) public verifierAddresses; // chainid => snark verifier contract address\n\n    ISMT public smtContract;\n\n    event UpdateVerifierAddress(uint64 chainId, address newAddress);\n    event UpdateSmtContract(ISMT smtContract);\n    event SumVolume(address user, uint64 fromChain, uint256 volume);\n\n    constructor(ISMT _smtContract) {\n        smtContract = _smtContract;\n    }\n\n    function submitUniswapSumVolumeProof(uint64 _chainId, bytes calldata _proof) external {\n        require(verifyRaw(_chainId, _proof), \"proof not valid\");\n\n        ProofData memory data = getProofData(_proof);\n        require(data.volume > 0, \"volume should be larger than 0\");\n        require(data.vkHash > 0, \"vkHash should be larger than 0\");\n        require(isIn(data.vkHash), \"vkHash is not valid\");\n        require(volumes[data.recipient] == 0, \"already proved for this user\");\n        require(smtContract.isSmtRootValid(_chainId, data.smtRoot), \"smt root not valid\");\n\n        volumes[data.recipient] = data.volume;\n        emit SumVolume(data.recipient, _chainId, data.volume);\n    }\n\n    function isIn(uint256 vkHash) internal view returns (bool exists) {\n        exists = false;\n        for (uint256 i = 0; i < 6; i++) {\n            if (vkHash == batchTierVkHashes[i]) {\n                exists = true;\n                break;\n            }\n        }\n    }\n\n    function verifyRaw(uint64 chainId, bytes calldata proofData) private view returns (bool) {\n        require(verifierAddresses[chainId] != address(0), \"chain verifier not set\");\n        return (IZkpVerifier)(verifierAddresses[chainId]).verifyRaw(proofData);\n    }\n\n    function getProofData(bytes calldata _proofData) internal pure returns (ProofData memory data) {\n        data.cPub = uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32]));\n        data.recipient = address(bytes20(_proofData[PUBLIC_BYTES_START_IDX + 32 + 12:PUBLIC_BYTES_START_IDX + 2 * 32]));\n        data.volume = uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32]));\n        data.smtRoot = bytes32(\n            (uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX + 3 * 32:PUBLIC_BYTES_START_IDX + 4 * 32])) << 128) |\n                uint128(bytes16(_proofData[PUBLIC_BYTES_START_IDX + 4 * 32 + 16:PUBLIC_BYTES_START_IDX + 5 * 32]))\n        );\n        data.length = uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX + 5 * 32:PUBLIC_BYTES_START_IDX + 6 * 32]));\n        data.vkHash = uint256(bytes32(_proofData[PUBLIC_BYTES_START_IDX + 6 * 32:PUBLIC_BYTES_START_IDX + 7 * 32]));\n    }\n\n    function updateSmtContract(ISMT _smtContract) external onlyOwner {\n        smtContract = _smtContract;\n        emit UpdateSmtContract(smtContract);\n    }\n\n    function updateVerifierAddress(uint64 _chainId, address _verifierAddress) external onlyOwner {\n        verifierAddresses[_chainId] = _verifierAddress;\n        emit UpdateVerifierAddress(_chainId, _verifierAddress);\n    }\n\n    function getAttestedSwapSumVolume(address swapper) external view returns (uint256) {\n        return volumes[swapper];\n    }\n\n    function setBatchTierVkHashes(bytes calldata hashes) external onlyOwner {\n        uint256 len = hashes.length / 32;\n        require(len <= 6, \"exceeds max tiers\");\n        for (uint256 i = 0; i < len; i++) {\n            batchTierVkHashes[i] = uint256(bytes32(hashes[i * 32:(i + 1) * 32]));\n        }\n    }\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-v4-hook/BaseFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IPoolManager} from \"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\";\nimport {Hooks} from \"@uniswap/v4-core/contracts/libraries/Hooks.sol\";\n\nabstract contract BaseFactory {\n    /// @notice zero out all but the first byte of the address which is all 1's\n    uint160 public constant UNISWAP_FLAG_MASK = 0xff << 152;\n\n    // Uniswap hook contracts must have specific flags encoded in the first byte of their address\n    address public immutable TargetPrefix;\n\n    constructor(address _targetPrefix) {\n        TargetPrefix = _targetPrefix;\n    }\n\n    function deploy(IPoolManager poolManager, bytes32 salt) public virtual returns (address);\n\n    function mineDeploy(IPoolManager poolManager) external returns (address) {\n        return mineDeploy(poolManager, 0);\n    }\n\n    function mineDeploy(IPoolManager poolManager, uint256 startSalt) public returns (address) {\n        bytes32 salt = mineSalt(poolManager, startSalt);\n        return deploy(poolManager, salt);\n    }\n\n    function mineSalt(IPoolManager poolManager, uint256 startSalt) public view returns (bytes32 salt) {\n        uint256 endSalt = uint256(startSalt) + 1000;\n        unchecked {\n            for (uint256 i = startSalt; i < endSalt; ++i) {\n                salt = bytes32(i);\n                address hookAddress = _computeHookAddress(poolManager, salt);\n\n                if (_isPrefix(hookAddress)) {\n                    return salt;\n                }\n            }\n            revert(\"Failed to find a salt\");\n        }\n    }\n\n    function _computeHookAddress(IPoolManager poolManager, bytes32 salt) internal view returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, _hashBytecode(poolManager)));\n        return address(uint160(uint256(hash)));\n    }\n\n    /// @dev The implementing contract must override this function to return the bytecode hash of its contract\n    /// For example, the CounterHook contract would return:\n    /// bytecodeHash = keccak256(abi.encodePacked(type(CounterHook).creationCode, abi.encode(poolManager)));\n    function _hashBytecode(IPoolManager poolManager) internal pure virtual returns (bytes32 bytecodeHash);\n\n    function _isPrefix(address _address) internal view returns (bool) {\n        // zero out all but the first byte of the address\n        address actualPrefix = address(uint160(_address) & UNISWAP_FLAG_MASK);\n        return actualPrefix == TargetPrefix;\n    }\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-v4-hook/BaseHook.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Hooks} from \"@uniswap/v4-core/contracts/libraries/Hooks.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\";\nimport {IHooks} from \"@uniswap/v4-core/contracts/interfaces/IHooks.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/contracts/types/BalanceDelta.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/contracts/types/PoolKey.sol\";\n\nabstract contract BaseHook is IHooks, Ownable {\n    error NotPoolManager();\n    error NotSelf();\n    error InvalidPool();\n    error LockFailure();\n    error HookNotImplemented();\n    error MustUseDynamicFee();\n\n    /// @notice The address of the pool manager\n    IPoolManager public immutable poolManager;\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n        validateHookAddress(this);\n    }\n\n    /// @dev Only the pool manager may call this function\n    modifier poolManagerOnly() {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n        _;\n    }\n\n    /// @dev Only this address may call this function\n    modifier selfOnly() {\n        if (msg.sender != address(this)) revert NotSelf();\n        _;\n    }\n\n    /// @dev Only pools with hooks set to this contract may call this function\n    modifier onlyValidPools(IHooks hooks) {\n        if (hooks != this) revert InvalidPool();\n        _;\n    }\n\n    function getHooksCalls() public pure virtual returns (Hooks.Calls memory);\n\n    // this function is virtual so that we can override it during testing,\n    // which allows us to deploy an implementation to any address\n    // and then etch the bytecode into the correct address\n    function validateHookAddress(BaseHook _this) internal pure virtual {\n        Hooks.validateHookAddress(_this, getHooksCalls());\n    }\n\n    function lockAcquired(bytes calldata data) external virtual poolManagerOnly returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).call(data);\n        if (success) return returnData;\n        if (returnData.length == 0) revert LockFailure();\n        // if the call failed, bubble up the reason\n        /// @solidity memory-safe-assembly\n        assembly {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function beforeInitialize(address, PoolKey calldata, uint160, bytes calldata) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterInitialize(\n        address,\n        PoolKey calldata,\n        uint160,\n        int24,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function beforeModifyPosition(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyPositionParams calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterModifyPosition(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyPositionParams calldata,\n        BalanceDelta,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function beforeSwap(\n        address,\n        PoolKey calldata,\n        IPoolManager.SwapParams calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterSwap(\n        address,\n        PoolKey calldata,\n        IPoolManager.SwapParams calldata,\n        BalanceDelta,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function beforeDonate(\n        address,\n        PoolKey calldata,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterDonate(\n        address,\n        PoolKey calldata,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n}\n"
    },
    "contracts/apps/uniswap-v4/uniswap-v4-hook/TierHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Hooks} from \"@uniswap/v4-core/contracts/libraries/Hooks.sol\";\nimport {IHookFeeManager} from \"@uniswap/v4-core/contracts/interfaces/IHookFeeManager.sol\";\nimport {IDynamicFeeManager} from \"@uniswap/v4-core/contracts/interfaces/IDynamicFeeManager.sol\";\nimport {FeeLibrary} from \"@uniswap/v4-core/contracts/libraries/FeeLibrary.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/contracts/types/BalanceDelta.sol\";\nimport {PoolId, PoolIdLibrary} from \"@uniswap/v4-core/contracts/types/PoolId.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/contracts/types/PoolKey.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\";\nimport {BaseHook} from \"./BaseHook.sol\";\nimport {BaseFactory} from \"./BaseFactory.sol\";\nimport {UniswapSumVolume} from \"../uniswap-sum/UniswapSumVolume.sol\";\nimport {IUniswapSumVolume} from \"../uniswap-sum/IUniswapSumVolume.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TierHook is BaseHook, IHookFeeManager, IDynamicFeeManager {\n    using FeeLibrary for uint24;\n    using PoolIdLibrary for PoolKey;\n\n    address public sumVolumeAddress;\n\n    event UpdateSumVolumeAddress(address newAddress);\n    event Swap(PoolId indexed id, address indexed sender, int128 amount0, int128 amount1);\n\n    uint256 internal constant TIER_NONE = 0;\n    uint256 internal constant TIER_SILVER = 1;\n    uint256 internal constant TIER_GOLD = 2;\n\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    function getHooksCalls() public pure override returns (Hooks.Calls memory) {\n        return\n            Hooks.Calls({\n                beforeInitialize: true,\n                afterInitialize: false,\n                beforeModifyPosition: false,\n                afterModifyPosition: false,\n                beforeSwap: false,\n                afterSwap: true,\n                beforeDonate: false,\n                afterDonate: false\n            });\n    }\n\n    /// @notice The interface for setting a fee on swap or fee on withdraw to the hook\n    /// @dev This callback is only made if the Fee.HOOK_SWAP_FEE_FLAG or Fee.HOOK_WITHDRAW_FEE_FLAG in set in the pool's key.fee.\n    function getHookFees(PoolKey calldata) external pure returns (uint24 fee) {\n        // Swap fee is upper bits.\n        // 20% fee as 85 = hex55 which is 5 in both directions. 1/5 = 20%\n        // Withdraw fee is lower bits\n        // 33% fee as 51 = hex33 which is 3 in both directions. 1/3 = 33%\n        fee = 0x5533;\n    }\n\n    function getHookWithdrawFee(PoolKey calldata key) external view returns (uint8 fee) {}\n\n    function beforeInitialize(\n        address,\n        PoolKey calldata key,\n        uint160,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        if (!key.fee.isDynamicFee()) revert MustUseDynamicFee();\n        return BaseHook.beforeInitialize.selector;\n    }\n\n    function afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata,\n        BalanceDelta delta,\n        bytes calldata\n    ) external override returns (bytes4 selector) {\n        emit Swap(key.toId(), tx.origin, delta.amount0(), delta.amount1());\n\n        selector = BaseHook.afterSwap.selector;\n    }\n\n    function updateSumVolumeAddress(address _sumVolumeAddress) external onlyOwner {\n        sumVolumeAddress = _sumVolumeAddress;\n        emit UpdateSumVolumeAddress(_sumVolumeAddress);\n    }\n\n    function senderTier(address _sender) internal view returns (uint256) {\n        uint256 existingVolume = (IUniswapSumVolume)(sumVolumeAddress).getAttestedSwapSumVolume(_sender); //  uint256(sumVolume.volumes[address(0)]);\n\n        // existingVolume uses 6 as decimals. 1000000000 means $1000\n        if (existingVolume > 1000000000) {\n            return TIER_GOLD;\n        } else if (existingVolume > 0) {\n            return TIER_SILVER;\n        }\n        return TIER_NONE;\n    }\n\n    function getFeeBySwapper(address swapper) external view returns (uint24) {\n        return calcFee(swapper);\n    }\n\n    // invoke by PoolManager contract\n    function getFee(\n        address,\n        PoolKey calldata,\n        IPoolManager.SwapParams calldata,\n        bytes calldata\n    ) external view returns (uint24) {\n        return calcFee(tx.origin);\n    }\n\n    function calcFee(address user) internal view returns (uint24) {\n        uint256 tier = senderTier(user);\n        uint24 fee = 10000;\n        if (tier == TIER_GOLD) {\n            fee = fee / 2;\n        } else if (tier == TIER_SILVER) {\n            fee = (fee * 4) / 5;\n        }\n        return fee;\n    }\n}\n\ncontract TierFactory is BaseFactory, Ownable {\n    constructor() BaseFactory(address(uint160(Hooks.BEFORE_INITIALIZE_FLAG | Hooks.AFTER_SWAP_FLAG))) {}\n\n    function deploy(IPoolManager poolManager, bytes32 salt) public override returns (address) {\n        return address(new TierHook{salt: salt}(poolManager));\n    }\n\n    function _hashBytecode(IPoolManager poolManager) internal pure override returns (bytes32 bytecodeHash) {\n        bytecodeHash = keccak256(abi.encodePacked(type(TierHook).creationCode, abi.encode(poolManager)));\n    }\n\n    function updateHookSumVolumeAddress(TierHook _tierHook, address _sumVolumeAddress) public onlyOwner {\n        _tierHook.updateSumVolumeAddress(_sumVolumeAddress);\n    }\n}\n"
    },
    "contracts/interfaces/ISigsVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IBvnSigsVerifier {\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msg signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes memory _msg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msgHash hash of signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes32 _msgHash,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n\n    struct SigInfo {\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n}\n\ninterface IAvsSigsVerifier {\n    struct BN254_G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[1] * i + X[0]\n    struct BN254_G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    struct NonSignerStakesAndSignature {\n        uint32[] nonSignerQuorumBitmapIndices; // is the indices of all nonsigner quorum bitmaps\n        BN254_G1Point[] nonSignerPubkeys; // is the G1 pubkeys of all nonsigners\n        BN254_G1Point[] quorumApks; // is the aggregate G1 pubkey of each quorum\n        BN254_G2Point apkG2; // is the aggregate G2 pubkey of all signers\n        BN254_G1Point sigma; // is the aggregate G1 signature of all signers\n        uint32[] quorumApkIndices; // is the indices of each quorum aggregate pubkey\n        uint32[] totalStakeIndices; // is the indices of each quorums total stake\n        uint32[][] nonSignerStakeIndices; // is the indices of each non signers stake within a quorum\n    }\n\n    struct SigInfo {\n        uint64 blockNum;\n        NonSignerStakesAndSignature params;\n    }\n\n    function verifySigs(bytes32 msgHash, uint64 blockNum, NonSignerStakesAndSignature calldata params) external view;\n}\n"
    },
    "contracts/interfaces/ISMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../verifiers/zk-verifiers/common/IVerifier.sol\";\n\ninterface ISMT {\n    struct SmtUpdate {\n        bytes32 newSmtRoot;\n        uint64 endBlockNum;\n        bytes32 endBlockHash;\n        bytes32 nextChunkMerkleRoot;\n        bytes32 circuitDigest;\n        uint256[8] proof;\n        uint256[2] commit;\n        uint256[2] knowledgeProof;\n    }\n\n    function updateRoot(uint64 chainId, SmtUpdate memory u) external;\n\n    function isSmtRootValid(uint64 chainId, bytes32 smtRoot) external view returns (bool);\n}\n"
    },
    "contracts/lib/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity >=0.5.10 <0.9.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    },
    "contracts/lib/Utils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary Utils {\n    // https://ethereum.stackexchange.com/a/83577\n    // https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/base/Multicall.sol\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n"
    },
    "contracts/light-client-eth/interfaces/IAnchorBlocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IAnchorBlocks {\n    function blocks(uint256 blockNum) external view returns (bytes32);\n}\n"
    },
    "contracts/light-client-eth/SameChainAnchorBlock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IAnchorBlocks.sol\";\n\ncontract SameChainAnchorBlocks is IAnchorBlocks {\n   function blocks(uint256 blockNum) external view returns (bytes32) {\n        return blockhash(blockNum);\n    }\n}\n"
    },
    "contracts/safeguard/BrevisAccess.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"./Pauser.sol\";\n\n// prover and pauser access control using a single map lookup\nabstract contract BrevisAccess is Pauser {\n    enum ProverState {\n        Null,\n        Active,\n        Paused\n    }\n    mapping(address => ProverState) public proverStates;\n    address[] public provers;\n\n    event ProverAdded(address account);\n    event ProverRemoved(address account);\n\n    modifier onlyProver() {\n        require(proverStates[msg.sender] != ProverState.Null, \"invalid prover\");\n        _;\n    }\n\n    modifier onlyActiveProver() {\n        require(proverStates[msg.sender] == ProverState.Active, \"invalid prover\");\n        _;\n    }\n\n    function addProvers(address[] memory _accounts) public onlyOwner {\n        ProverState state = paused() ? ProverState.Paused : ProverState.Active;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addProver(_accounts[i], state);\n        }\n    }\n\n    function removeProvers(address[] memory _accounts) public onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _removeProver(_accounts[i]);\n        }\n    }\n\n    function pause() public override onlyPauser {\n        _pause();\n        for (uint256 i = 0; i < provers.length; i++) {\n            proverStates[provers[i]] = ProverState.Paused;\n        }\n    }\n\n    function unpause() public override onlyPauser {\n        _unpause();\n        for (uint256 i = 0; i < provers.length; i++) {\n            proverStates[provers[i]] = ProverState.Active;\n        }\n    }\n\n    function numProvers() public view returns (uint256) {\n        return provers.length;\n    }\n\n    function isActiveProver(address _account) public view returns (bool) {\n        return proverStates[_account] == ProverState.Active;\n    }\n\n    function _addProver(address _account, ProverState _state) private {\n        require(proverStates[_account] == ProverState.Null, \"account is prover\");\n        provers.push(_account);\n        proverStates[_account] = _state;\n        emit ProverAdded(_account);\n    }\n\n    function _removeProver(address _account) private {\n        require(proverStates[_account] != ProverState.Null, \"account is not prover\");\n        uint256 lastIndex = provers.length - 1;\n        for (uint256 i = 0; i < provers.length; i++) {\n            if (provers[i] == _account) {\n                if (i < lastIndex) {\n                    provers[i] = provers[lastIndex];\n                }\n                provers.pop();\n                delete proverStates[_account];\n                emit ProverRemoved(_account);\n                return;\n            }\n        }\n        revert(\"prover not found\"); // this should never happen\n    }\n}\n"
    },
    "contracts/safeguard/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\n * This adds a normal func that setOwner if _owner is address(0). So we can't allow\n * renounceOwnership. So we can support Proxy based upgradable contract\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Only to be called by inherit contracts, in their init func called by Proxy\n     * we require _owner == address(0), which is only possible when it's a delegateCall\n     * because constructor sets _owner in contract state.\n     */\n    function initOwner() internal {\n        require(_owner == address(0), \"owner already set\");\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/safeguard/Pauser.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./Ownable.sol\";\n\nabstract contract Pauser is Ownable, Pausable {\n    mapping(address => bool) public pausers;\n    address[] public pauserList;\n\n    event PauserAdded(address account);\n    event PauserRemoved(address account);\n\n    constructor() {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"Caller is not pauser\");\n        _;\n    }\n\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return pausers[account];\n    }\n\n    function addPauser(address account) public onlyOwner {\n        _addPauser(account);\n    }\n\n    function addPausers(address[] memory accounts) public onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _addPauser(accounts[i]);\n        }\n    }\n\n    function removePauser(address account) public onlyOwner {\n        _removePauser(account);\n    }\n\n    function removePausers(address[] memory accounts) public onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _removePauser(accounts[i]);\n        }\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function numPausers() public view returns (uint256) {\n        return pauserList.length;\n    }\n\n    function _addPauser(address account) private {\n        require(!isPauser(account), \"Account is already pauser\");\n        pauserList.push(account);\n        pausers[account] = true;\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) private {\n        require(isPauser(account), \"Account is not pauser\");\n        uint256 lastIndex = pauserList.length - 1;\n        for (uint256 i = 0; i < pauserList.length; i++) {\n            if (pauserList[i] == account) {\n                if (i < lastIndex) {\n                    pauserList[i] = pauserList[lastIndex];\n                }\n                pauserList.pop();\n                pausers[account] = false;\n                emit PauserRemoved(account);\n                return;\n            }\n        }\n        revert(\"pauser not found\"); // this should never happen\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisAggProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/Lib.sol\";\nimport \"../../interfaces/ISMT.sol\";\nimport \"../../verifiers/interfaces/IZkpVerifier.sol\";\nimport \"../../safeguard/BrevisAccess.sol\";\n\ncontract BrevisAggProof is BrevisAccess {\n    uint32 constant PUBLIC_BYTES_START_IDX = 12 * 32; // the first 12 32bytes are groth16 proof (A/B/C/Commitment/CommitmentPOK)\n    uint8 constant TREE_DEPTH = 4;\n    uint256 constant LEAF_NODES_LEN = 2 ** TREE_DEPTH;\n\n    ISMT public smtContract;\n\n    mapping(bytes32 => bool) public merkleRoots;\n    mapping(uint64 => IZkpVerifier) public aggProofVerifierAddress;\n    mapping(uint64 => bytes32) public dummyInputCommitments;\n    bytes32 public aggVkHash; // aggregation verifying key hash\n    event SmtContractUpdated(address smtContract);\n    event AggProofVerifierAddressesUpdated(uint64[] chainIds, IZkpVerifier[] newAddresses);\n    event DummyInputCommitmentsUpdated(uint64[] chainIds, bytes32[] updatedDummyInputCommitments);\n    event AggVkHashUpdated(bytes32 aggVkHash);\n\n    constructor(ISMT _smtContract) {\n        smtContract = _smtContract;\n    }\n\n    /*********************************\n     * External and Public Functions *\n     *********************************/\n\n    function submitAggProof(\n        uint64 _chainId,\n        bytes32[] calldata _proofIds,\n        bytes calldata _proofWithPubInputs\n    ) external onlyActiveProver {\n        (bytes32 root, bytes32 proofIdsCommit, bytes32 _aggVkHash) = unpack(_proofWithPubInputs);\n        require(_aggVkHash == aggVkHash, \"agg verifying key not valid\");\n        IZkpVerifier verifier = aggProofVerifierAddress[_chainId];\n        require(address(verifier) != address(0), \"chain agg proof verifier not set\");\n        require(verifier.verifyRaw(_proofWithPubInputs), \"proof not valid\");\n\n        uint dataLen = _proofIds.length;\n        bytes32[LEAF_NODES_LEN] memory rIds;\n        for (uint i = 0; i < dataLen; i++) {\n            rIds[i] = _proofIds[i];\n        }\n        // note, to align with circuit, rIds[dataLen] to rIds[LEAF_NODES_LEN - 1] filled with last real one\n        if (dataLen < LEAF_NODES_LEN) {\n            for (uint i = dataLen; i < LEAF_NODES_LEN; i++) {\n                rIds[i] = rIds[dataLen - 1];\n            }\n        }\n        require(keccak256(abi.encodePacked(rIds)) == proofIdsCommit, \"proofIds not right\");\n        merkleRoots[root] = true;\n    }\n\n    // validate all leaf nodes in the agg proof data\n    function validateAggProofData(uint64 _chainId, Brevis.ProofData[] calldata _proofDataArray) external view {\n        uint dataLen = _proofDataArray.length;\n        require(dataLen <= LEAF_NODES_LEN, \"size exceeds\");\n        bytes32[2 * LEAF_NODES_LEN - 1] memory hashes;\n        for (uint i = 0; i < dataLen; i++) {\n            require(smtContract.isSmtRootValid(_chainId, _proofDataArray[i].smtRoot), \"invalid smt root\");\n            require(dummyInputCommitments[_chainId] == _proofDataArray[i].dummyInputCommitment, \"invalid dummy input\");\n            hashes[i] = keccak256(\n                abi.encodePacked(\n                    _proofDataArray[i].commitHash,\n                    _proofDataArray[i].smtRoot,\n                    _proofDataArray[i].appCommitHash,\n                    _proofDataArray[i].appVkHash,\n                    _proofDataArray[i].dummyInputCommitment\n                )\n            );\n        }\n        // note, hashes[dataLen] to hashes[LEAF_NODES_LEN - 1] filled with last real one\n        if (dataLen < LEAF_NODES_LEN) {\n            for (uint i = dataLen; i < LEAF_NODES_LEN; i++) {\n                hashes[i] = hashes[dataLen - 1];\n            }\n        }\n\n        uint shift = 0;\n        uint counter = LEAF_NODES_LEN;\n        while (counter > 0) {\n            for (uint i = 0; i < counter - 1; i += 2) {\n                hashes[shift + counter + i / 2] = keccak256(abi.encodePacked(hashes[shift + i], hashes[shift + i + 1]));\n            }\n            shift += counter;\n            counter /= 2;\n        }\n\n        require(merkleRoots[hashes[hashes.length - 1]], \"merkle root not exists\");\n    }\n\n    // validate a single leaf node in the agg proof data\n    function validateAggProofData(\n        uint64 _chainId,\n        Brevis.ProofData calldata _proofData,\n        bytes32 _merkleRoot,\n        bytes32[] calldata _merkleProof,\n        uint8 _nodeIndex\n    ) external view {\n        require(merkleRoots[_merkleRoot], \"merkle root not exists\");\n        require(smtContract.isSmtRootValid(_chainId, _proofData.smtRoot), \"invalid smt root\");\n        require(dummyInputCommitments[_chainId] == _proofData.dummyInputCommitment, \"invalid dummy input\");\n\n        bytes32 proofDataHash = keccak256(\n            abi.encodePacked(\n                _proofData.commitHash,\n                _proofData.smtRoot,\n                _proofData.appCommitHash,\n                _proofData.appVkHash,\n                _proofData.dummyInputCommitment\n            )\n        );\n        bytes32 root = proofDataHash;\n        for (uint8 depth = 0; depth < TREE_DEPTH; depth++) {\n            if ((_nodeIndex >> depth) & 1 == 0) {\n                root = keccak256(abi.encodePacked(root, _merkleProof[depth]));\n            } else {\n                root = keccak256(abi.encodePacked(_merkleProof[depth], root));\n            }\n        }\n        require(_merkleRoot == root, \"invalid data\");\n    }\n\n    // -------- owner functions --------\n\n    function updateSmtContract(ISMT _smtContract) public onlyOwner {\n        smtContract = _smtContract;\n        emit SmtContractUpdated(address(smtContract));\n    }\n\n    function updateAggProofVerifierAddresses(\n        uint64[] calldata _chainIds,\n        IZkpVerifier[] calldata _verifierAddresses\n    ) public onlyOwner {\n        require(_chainIds.length == _verifierAddresses.length, \"length not match\");\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            aggProofVerifierAddress[_chainIds[i]] = _verifierAddresses[i];\n        }\n        emit AggProofVerifierAddressesUpdated(_chainIds, _verifierAddresses);\n    }\n\n    function setDummyInputCommitments(\n        uint64[] calldata _chainIds,\n        bytes32[] calldata _dummyInputCommitments\n    ) public onlyOwner {\n        require(_chainIds.length == _dummyInputCommitments.length, \"length not match\");\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            dummyInputCommitments[_chainIds[i]] = _dummyInputCommitments[i];\n        }\n        emit DummyInputCommitmentsUpdated(_chainIds, _dummyInputCommitments);\n    }\n\n     function setAggVkHash(\n        bytes32 _aggVkHash\n    ) public onlyOwner {\n        aggVkHash = _aggVkHash;\n        emit AggVkHashUpdated(_aggVkHash);\n    }\n\n    /**********************************\n     * Internal and Private Functions *\n     **********************************/\n\n    function unpack(\n        bytes calldata _proofWithPubInputs\n    ) internal pure returns (bytes32 merkleRoot, bytes32 proofIdsCommit, bytes32 aggVk) {\n        merkleRoot = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32]);\n        proofIdsCommit = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 32:PUBLIC_BYTES_START_IDX + 2 * 32]);\n        aggVk = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 2*32:PUBLIC_BYTES_START_IDX + 3 * 32]);\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisDispute.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./BrevisRequest.sol\";\nimport \"../interface/IBrevisDispute.sol\";\n\n// TODO: handle dispute fee\ncontract BrevisDispute is IBrevisDispute {\n    BrevisRequest immutable brevisRequest;\n\n    uint256 public challengeWindow;\n    uint256 public responseTimeout;\n    uint256 public depositAskForData;\n    uint256 public depositAskForProof;\n\n    mapping(bytes32 => Dispute) public disputes; // requestKey => Dispute\n\n    modifier onlyActiveProver() {\n        require(brevisRequest.isActiveProver(msg.sender), \"invalid prover\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(brevisRequest.owner() == msg.sender, \"invalid prover\");\n        _;\n    }\n\n    constructor(BrevisRequest _brevisRequest) {\n        brevisRequest = _brevisRequest;\n    }\n\n    function askForRequestData(bytes32 _proofId, uint64 _nonce) external payable {\n        require(msg.value > depositAskForData, \"insufficient deposit\");\n\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, uint64 timestamp, ) = brevisRequest.requests(requestKey);\n        require(status == RequestStatus.OpSubmitted, \"not in a disputable status\");\n        require(timestamp + challengeWindow > block.timestamp, \"pass challenge window\");\n        brevisRequest.setRequestStatus(requestKey, RequestStatus.OpDisputing);\n\n        Dispute storage dispute = disputes[requestKey];\n        dispute.status = DisputeStatus.WaitingForRequestData;\n        dispute.responseDeadline = block.timestamp + responseTimeout;\n        dispute.challenger = msg.sender;\n        dispute.deposit = msg.value;\n\n        emit AskFor(_proofId, _nonce, DisputeStatus.WaitingForRequestData, msg.sender);\n    }\n\n    function postRequestData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes[] calldata _data,\n        uint256 _index,\n        bool _done\n    ) external onlyActiveProver {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, , ) = brevisRequest.requests(requestKey);\n        require(status == RequestStatus.OpDisputing, \"invalid request status\");\n\n        Dispute storage dispute = disputes[requestKey];\n        require(dispute.status == DisputeStatus.WaitingForRequestData, \"invalid dispute status\");\n        RequestDataHash storage dataHash = dispute.requestDataHash;\n        require(dataHash.hashes.length == _index, \"invalid index\");\n        for (uint i = 0; i < _data.length; i++) {\n            dataHash.hashes.push(keccak256(_data[i]));\n        }\n        if (_done) {\n            dataHash.root = keccak256(abi.encodePacked(dataHash.hashes)); // todo: consider merkle\n            disputes[requestKey].status = DisputeStatus.RequestDataPosted;\n        }\n        emit RequestDataPosted(_proofId, _nonce, _data, _index, _done);\n    }\n\n    function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) external payable {\n        require(msg.value > depositAskForProof, \"insufficient deposit\");\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, uint64 timestamp, ) = brevisRequest.requests(requestKey);\n        require(timestamp + challengeWindow > block.timestamp, \"pass challenge window\");\n        brevisRequest.setRequestStatus(requestKey, RequestStatus.OpDisputing);\n\n        Dispute storage dispute = disputes[requestKey];\n        require(\n            status == RequestStatus.OpDisputing && dispute.status == DisputeStatus.RequestDataPosted,\n            \"invalid states\"\n        );\n\n        dispute.status = DisputeStatus.WaitingForDataAvailabilityProof;\n        dispute.responseDeadline = block.timestamp + responseTimeout;\n        dispute.challenger = msg.sender;\n        dispute.deposit = msg.value;\n\n        emit AskFor(_proofId, _nonce, DisputeStatus.WaitingForDataAvailabilityProof, msg.sender);\n    }\n\n    function postDataAvailabilityProof(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes calldata // proof\n    ) external onlyActiveProver {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, , ) = brevisRequest.requests(requestKey);\n        Dispute storage dispute = disputes[requestKey];\n        require(\n            status == RequestStatus.OpDisputing && dispute.status == DisputeStatus.WaitingForDataAvailabilityProof,\n            \"invalid states\"\n        );\n        disputes[requestKey].status = DisputeStatus.DataAvailabilityProofPosted;\n        // todo: validate proof\n\n        emit DataAvailabilityProofPosted(_proofId, _nonce);\n    }\n\n    function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) external payable {\n        require(msg.value > depositAskForProof, \"insufficient deposit\");\n\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, uint64 timestamp, ) = brevisRequest.requests(requestKey);\n        require(timestamp + challengeWindow > block.timestamp, \"pass challenge window\");\n        brevisRequest.setRequestStatus(requestKey, RequestStatus.OpDisputing);\n\n        Dispute storage dispute = disputes[requestKey];\n        require(\n            status == RequestStatus.OpSubmitted ||\n                (status == RequestStatus.OpDisputing && dispute.status != DisputeStatus.WaitingForDataValidityProof),\n            \"invalid states\"\n        );\n\n        dispute.status = DisputeStatus.WaitingForDataValidityProof;\n        dispute.responseDeadline = block.timestamp + responseTimeout;\n        dispute.challenger = msg.sender;\n        dispute.deposit = msg.value;\n\n        emit AskFor(_proofId, _nonce, DisputeStatus.WaitingForDataValidityProof, msg.sender);\n    }\n\n    function postDataValidityProof(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _chainId,\n        bytes calldata _proof\n    ) external onlyActiveProver {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        (RequestStatus status, , ) = brevisRequest.requests(requestKey);\n        Dispute storage dispute = disputes[requestKey];\n        require(\n            status == RequestStatus.OpDisputing && dispute.status == DisputeStatus.WaitingForDataValidityProof,\n            \"invalid states\"\n        );\n\n        (bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash) = brevisRequest.brevisProof().submitProof(\n            _chainId,\n            _proof\n        );\n        require(_proofId == proofId, \"invalid proof: proofId\");\n        require(\n            brevisRequest.opdata(requestKey) == keccak256(abi.encodePacked(appCommitHash, appVkHash)),\n            \"invalid proof: appHash\"\n        );\n        brevisRequest.setRequestStatus(requestKey, RequestStatus.ZkAttested);\n        dispute.status = DisputeStatus.DataValidityProofPosted;\n\n        emit DataValidityProofProofPosted(_proofId, _nonce);\n    }\n\n    function getChallengeWindow() external view returns (uint256) {\n        return challengeWindow;\n    }\n\n    function getDisputeStatus(bytes32 _requestKey) external view returns (DisputeStatus) {\n        return disputes[_requestKey].status;\n    }\n\n    function getResponseDeadline(bytes32 _requestKey) external view returns (uint256) {\n        return disputes[_requestKey].responseDeadline;\n    }\n\n    // --------------------- owner functions ---------------------\n\n    function setChallengeWindow(uint256 _challengeWindow) external onlyOwner {\n        uint256 oldChallengeWindow = challengeWindow;\n        challengeWindow = _challengeWindow;\n        emit ChallengeWindowUpdated(oldChallengeWindow, _challengeWindow);\n    }\n\n    function setResponseTimeout(uint256 _responseTimeout) external onlyOwner {\n        uint256 oldResponseTimeout = responseTimeout;\n        responseTimeout = _responseTimeout;\n        emit ResponseTimeoutUpdated(oldResponseTimeout, _responseTimeout);\n    }\n\n    function setDisputeDeposits(uint256 _amtAskForData, uint256 _amtAskForProof) external onlyOwner {\n        depositAskForData = _amtAskForData;\n        depositAskForProof = _amtAskForProof;\n        emit DisputeDepositsUpdated(_amtAskForData, _amtAskForProof);\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./BrevisAggProof.sol\";\nimport \"../lib/Lib.sol\";\nimport \"../../interfaces/ISMT.sol\";\nimport \"../../verifiers/interfaces/IZkpVerifier.sol\";\n\ncontract BrevisProof is BrevisAggProof {\n    mapping(uint64 => IZkpVerifier) public verifierAddresses; // chainid => snark verifier contract address\n    mapping(bytes32 => bytes32) public proofs; // proofId => keccak256(abi.encodePacked(appCommitHash, appVkHash));\n    event VerifierAddressesUpdated(uint64[] chainIds, IZkpVerifier[] newAddresses);\n\n    constructor(ISMT _smtContract) BrevisAggProof(_smtContract) {}\n\n    // To support upgradable deployment.\n    // Can only be called once by Proxy via delegateCall, as initOwner will require _owner is 0.\n    function init(ISMT _smtContract) external {\n        initOwner();\n        smtContract = _smtContract;\n    }\n\n    /*********************************\n     * External and Public Functions *\n     *********************************/\n\n    function submitProof(\n        uint64 _chainId,\n        bytes calldata _proofWithPubInputs\n    ) external onlyActiveProver returns (bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash) {\n        require(verifyRaw(_chainId, _proofWithPubInputs), \"proof not valid\");\n        Brevis.ProofData memory data = unpackProofData(_proofWithPubInputs);\n\n        appCommitHash = data.appCommitHash;\n        appVkHash = data.appVkHash;\n        proofId = keccak256(abi.encodePacked(appVkHash, data.commitHash, appCommitHash));\n        require(smtContract.isSmtRootValid(_chainId, data.smtRoot), \"smt root not valid\");\n        require(dummyInputCommitments[_chainId] == data.dummyInputCommitment, \"invalid dummy input\");\n        proofs[proofId] = keccak256(abi.encodePacked(appCommitHash, appVkHash));\n    }\n\n    function validateProofAppData(\n        bytes32 _proofId,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash\n    ) external view returns (bool) {\n        require(proofs[_proofId] == keccak256(abi.encodePacked(_appCommitHash, _appVkHash)), \"invalid data\");\n        return true;\n    }\n\n    // -------- owner functions --------\n\n    function updateVerifierAddress(\n        uint64[] calldata _chainIds,\n        IZkpVerifier[] calldata _verifierAddresses\n    ) public onlyOwner {\n        require(_chainIds.length == _verifierAddresses.length, \"length not match\");\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            verifierAddresses[_chainIds[i]] = _verifierAddresses[i];\n        }\n        emit VerifierAddressesUpdated(_chainIds, _verifierAddresses);\n    }\n\n    /**********************************\n     * Internal and Private Functions *\n     **********************************/\n\n    function unpackProofData(bytes calldata _proofWithPubInputs) internal pure returns (Brevis.ProofData memory data) {\n        data.commitHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32]);\n        data.smtRoot = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 32:PUBLIC_BYTES_START_IDX + 2 * 32]);\n        data.appCommitHash = bytes32(\n            _proofWithPubInputs[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32]\n        );\n        data.appVkHash = bytes32(_proofWithPubInputs[PUBLIC_BYTES_START_IDX + 3 * 32:PUBLIC_BYTES_START_IDX + 4 * 32]);\n        data.dummyInputCommitment = bytes32(\n            _proofWithPubInputs[PUBLIC_BYTES_START_IDX + 4 * 32:PUBLIC_BYTES_START_IDX + 5 * 32]\n        );\n    }\n\n    function verifyRaw(uint64 _chainId, bytes calldata _proofWithPubInputs) private view returns (bool) {\n        IZkpVerifier verifier = verifierAddresses[_chainId];\n        require(address(verifier) != address(0), \"chain verifier not set\");\n        return verifier.verifyRaw(_proofWithPubInputs);\n    }\n}\n"
    },
    "contracts/sdk/core/BrevisRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./FeeVault.sol\";\nimport \"../interface/IBrevisRequest.sol\";\nimport \"../interface/IBrevisProof.sol\";\nimport \"../interface/IBrevisDispute.sol\";\nimport \"../interface/IBrevisApp.sol\";\nimport \"../lib/Lib.sol\";\nimport \"../../safeguard/BrevisAccess.sol\";\nimport \"../../interfaces/ISigsVerifier.sol\";\nimport \"../../lib/Utils.sol\";\n\ncontract BrevisRequest is IBrevisRequest, FeeVault, BrevisAccess {\n    // common workflow\n    IBrevisProof public brevisProof;\n    uint256 public requestTimeout;\n    mapping(bytes32 => Request) public requests; // requestKey => Request;\n    mapping(bytes32 => OnchainRequestInfo) public onchainRequests; // requestKey => OnchainRequestInfo\n\n    // optimistic workflow\n    IBvnSigsVerifier public bvnSigsVerifier;\n    IAvsSigsVerifier public avsSigsVerifier;\n    IBrevisDispute public brevisDispute;\n    string public baseDataURL;\n    mapping(bytes32 => bytes32) public opdata; // requestKey => keccak256(abi.encodePacked(appCommitHash, appVkHash))\n\n    uint8 constant OPT_IDX_SIG_BVN = 0;\n    uint8 constant OPT_IDX_SIG_AVS = 1;\n\n    constructor(\n        address _feeCollector,\n        IBrevisProof _brevisProof,\n        IBvnSigsVerifier _bvnSigsVerifier\n    ) FeeVault(_feeCollector) {\n        brevisProof = _brevisProof;\n        bvnSigsVerifier = _bvnSigsVerifier;\n    }\n\n    // To support upgradable deployment.\n    // Can only be called once by Proxy via delegateCall, as initOwner will require _owner is 0.\n    function init(\n        address _feeCollector,\n        IBrevisProof _brevisProof,\n        IBvnSigsVerifier _bvnSigsVerifier,\n        uint256 _requestTimeout\n    ) external {\n        initOwner();\n        feeCollector = _feeCollector;\n        brevisProof = _brevisProof;\n        bvnSigsVerifier = _bvnSigsVerifier;\n        requestTimeout = _requestTimeout;\n    }\n\n    /*********************************\n     * External and Public Functions *\n     *********************************/\n\n    function sendRequest(\n        bytes32 _proofId,\n        uint64 _nonce,\n        address _refundee,\n        Callback calldata _callback,\n        uint8 _option // bitmap 0: zk, 1: op bvn, 2: op avs, 3: op bvn and avs\n    ) external payable {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        RequestStatus status = requests[requestKey].status;\n        require(status == RequestStatus.Null, \"invalid status\");\n        _option = _option & 0x03; // binary 00000011\n        if (_option == 0) {\n            status == RequestStatus.ZkPending;\n        } else {\n            status = RequestStatus.OpPending;\n        }\n        requests[requestKey] = Request(status, uint64(block.timestamp), _option);\n\n        if (_refundee == address(0)) {\n            _refundee = msg.sender;\n        }\n        bytes32 feeHash = keccak256(abi.encodePacked(msg.value, _refundee));\n        onchainRequests[requestKey] = OnchainRequestInfo(feeHash, _callback);\n\n        emit RequestSent(_proofId, _nonce, _refundee, msg.value, _callback, _option);\n    }\n\n    function fulfillRequest(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _chainId,\n        bytes calldata _proof,\n        bytes calldata _appCircuitOutput,\n        address _callbackTarget\n    ) external onlyActiveProver {\n        (bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash) = brevisProof.submitProof(_chainId, _proof);\n        require(_proofId == proofId, \"invalid proofId\");\n\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        Request storage request = requests[requestKey];\n        RequestStatus status = request.status;\n        require(status == RequestStatus.ZkPending || status == RequestStatus.Null, \"invalid status\");\n        request.status = RequestStatus.ZkAttested;\n\n        if (_appCircuitOutput.length > 0) {\n            require(appCommitHash == keccak256(_appCircuitOutput), \"invalid circuit output\");\n        }\n        bool success = _brevisCallback(_callbackTarget, appVkHash, _appCircuitOutput, requestKey, status);\n        if (!success) {\n            emit RequestCallbackFailed(_proofId, _nonce);\n        }\n        emit RequestFulfilled(_proofId, _nonce);\n    }\n\n    // fulfill batch requests with aggProof\n    function fulfillRequests(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        uint64 _chainId,\n        bytes calldata _proof,\n        Brevis.ProofData[] calldata _proofDataArray,\n        bytes[] calldata _appCircuitOutputs,\n        address[] calldata _callbackTargets\n    ) external onlyActiveProver {\n        uint256 dataNum = _proofIds.length;\n        brevisProof.submitAggProof(_chainId, _proofIds, _proof);\n        brevisProof.validateAggProofData(_chainId, _proofDataArray);\n        require(_callbackTargets.length == 1 || _callbackTargets.length == dataNum, \"invalid callback length\");\n\n        uint256 numFulfilled;\n        for (uint256 i = 0; i < dataNum; i++) {\n            require(\n                keccak256(\n                    abi.encodePacked(\n                        _proofDataArray[i].appVkHash,\n                        _proofDataArray[i].commitHash,\n                        _proofDataArray[i].appCommitHash\n                    )\n                ) == _proofIds[i],\n                \"invalid proofId\"\n            );\n            require(_proofDataArray[i].appCommitHash == keccak256(_appCircuitOutputs[i]), \"invalid circuit output\");\n            bytes32 requestKey = keccak256(abi.encodePacked(_proofIds[i], _nonces[i]));\n            Request storage request = requests[requestKey];\n            RequestStatus status = request.status;\n            if (status == RequestStatus.ZkPending || status == RequestStatus.Null) {\n                request.status = RequestStatus.ZkAttested;\n                numFulfilled++;\n                if (_callbackTargets.length > 1) {\n                    bool success = _brevisCallback(\n                        _callbackTargets[i],\n                        _proofDataArray[i].appVkHash,\n                        _appCircuitOutputs[i],\n                        requestKey,\n                        status\n                    );\n                    if (!success) {\n                        emit RequestCallbackFailed(_proofIds[i], _nonces[i]);\n                    }\n                } else if (status == RequestStatus.ZkPending) {\n                    Callback memory callback = onchainRequests[requestKey].callback;\n                    require(callback.target == _callbackTargets[0], \"callback mismatch\");\n                    require(callback.gas == 0, \"invalid gas for batch callback\");\n                }\n            }\n        }\n        require(numFulfilled > 0, \"no fulfilled requests\");\n        if (_callbackTargets.length == 1) {\n            bytes32[] memory appVkHashes = new bytes32[](_proofDataArray.length);\n            for (uint256 i = 0; i < appVkHashes.length; i++) {\n                appVkHashes[i] = _proofDataArray[i].appVkHash;\n            }\n            // If the call failed due any reason, anyone can trigger retry later by calling applyBrevisAggProof.\n            (bool success, ) = _callbackTargets[0].call(\n                abi.encodeWithSelector(IBrevisApp.brevisBatchCallback.selector, appVkHashes, _appCircuitOutputs)\n            );\n            if (!success) {\n                emit RequestsCallbackFailed(_proofIds, _nonces);\n            }\n        }\n        emit RequestsFulfilled(_proofIds, _nonces);\n    }\n\n    function increaseGasFee(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _addGas,\n        uint256 _currentFee,\n        address _refundee\n    ) external payable {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        RequestStatus status = requests[requestKey].status;\n        require(status == RequestStatus.ZkPending || status == RequestStatus.OpPending, \"invalid status\");\n\n        OnchainRequestInfo storage info = onchainRequests[requestKey];\n        require(info.feeHash == keccak256(abi.encodePacked(_currentFee, _refundee)), \"invalid input\");\n        uint256 newFee = _currentFee + msg.value;\n        info.feeHash == keccak256(abi.encodePacked(newFee, _refundee));\n        if (_addGas > 0) {\n            info.callback.gas += _addGas;\n        }\n        emit RequestFeeIncreased(_proofId, _nonce, info.callback.gas, newFee);\n    }\n\n    function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) external {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        Request memory request = requests[requestKey];\n        RequestStatus status = request.status;\n        require(status == RequestStatus.ZkPending || status == RequestStatus.OpPending, \"invalid status\");\n        require(block.timestamp > request.timestamp + requestTimeout);\n\n        bytes32 feeHash = onchainRequests[requestKey].feeHash;\n        require(feeHash == keccak256(abi.encodePacked(_amount, _refundee)), \"invalid input\");\n        (bool sent, ) = _refundee.call{value: _amount, gas: 50000}(\"\");\n        require(sent, \"send native failed\");\n        requests[requestKey].status = RequestStatus.Refunded;\n        emit RequestRefunded(_proofId, _nonce);\n    }\n\n    // --------------------- optimistic workflow functions ---------------------\n\n    function fulfillOpRequests(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        IBvnSigsVerifier.SigInfo calldata _bvnSigInfo,\n        IAvsSigsVerifier.SigInfo calldata _avsSigInfo\n    ) external onlyActiveProver {\n        uint8 option = 0;\n        require(_bvnSigInfo.sigs.length > 0 || _avsSigInfo.blockNum > 0, \"empty sigs\");\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \"FulfillRequests\"));\n        bytes32 signedHash = keccak256(abi.encodePacked(domain, _proofIds, _nonces, _appCommitHashes, _appVkHashes));\n        if (_bvnSigInfo.sigs.length > 0) {\n            bvnSigsVerifier.verifySigs(signedHash, _bvnSigInfo.sigs, _bvnSigInfo.signers, _bvnSigInfo.powers);\n            option = _bitSet(option, OPT_IDX_SIG_BVN);\n        }\n        if (_avsSigInfo.blockNum > 0) {\n            avsSigsVerifier.verifySigs(signedHash, _avsSigInfo.blockNum, _avsSigInfo.params);\n            option = _bitSet(option, OPT_IDX_SIG_AVS);\n        }\n        _submitOpStates(_proofIds, _nonces, _appCommitHashes, _appVkHashes, option); // to avoid \"stack too deep\"\n        emit OpRequestsFulfilled(_proofIds, _nonces, _appCommitHashes, _appVkHashes);\n    }\n\n    function setRequestStatus(bytes32 requestKey, RequestStatus _status) external {\n        require(msg.sender == address(brevisDispute), \"invalid setter\");\n        requests[requestKey].status = _status;\n    }\n\n    // --------------------- app helper functions ---------------------\n\n    // apply proved data to a target contract\n    function applyBrevisProof(\n        bytes32 _proofId,\n        bytes32 _appVkHash,\n        bytes32 _appCommitHash,\n        bytes calldata _appCircuitOutput,\n        address _callbackTarget\n    ) external {\n        brevisProof.validateProofAppData(_proofId, _appCommitHash, _appVkHash);\n        require(_appCommitHash == keccak256(_appCircuitOutput), \"invalid circuit output\");\n        IBrevisApp(_callbackTarget).brevisCallback(_appVkHash, _appCircuitOutput);\n    }\n\n    // apply multiple proved data fulfilled through AggProof to a target contract\n    function applyBrevisAggProof(\n        uint64 _chainId,\n        Brevis.ProofData[] calldata _proofDataArray,\n        bytes[] calldata _appCircuitOutputs,\n        address[] calldata _callbackTargets\n    ) external {\n        uint256 dataNum = _proofDataArray.length;\n        brevisProof.validateAggProofData(_chainId, _proofDataArray);\n        for (uint256 i = 0; i < dataNum; i++) {\n            if (_callbackTargets[i] != address(0)) {\n                require(_proofDataArray[i].appCommitHash == keccak256(_appCircuitOutputs[i]), \"invalid circuit output\");\n                (bool success, bytes memory res) = _callbackTargets[i].call(\n                    abi.encodeWithSelector(\n                        IBrevisApp.brevisCallback.selector,\n                        _proofDataArray[i].appVkHash,\n                        _appCircuitOutputs[i]\n                    )\n                );\n                require(success, string.concat(Strings.toString(i), \":\", Utils.getRevertMsg(res)));\n            }\n        }\n    }\n\n    // apply single proved data fulfilled through AggProof to a target contract\n    function applyBrevisAggProof(\n        uint64 _chainId,\n        Brevis.ProofData calldata _proofData,\n        bytes32 _merkleRoot,\n        bytes32[] calldata _merkleProof,\n        uint8 _nodeIndex,\n        bytes calldata _appCircuitOutput,\n        address _callbackTarget\n    ) external {\n        brevisProof.validateAggProofData(_chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex);\n        require(_proofData.appCommitHash == keccak256(_appCircuitOutput), \"invalid circuit output\");\n        IBrevisApp(_callbackTarget).brevisCallback(_proofData.appVkHash, _appCircuitOutput);\n    }\n\n    // --------------------- owner functions ---------------------\n\n    function setRequestTimeout(uint256 _timeout) external onlyOwner {\n        uint256 oldTimeout = requestTimeout;\n        requestTimeout = _timeout;\n        emit RequestTimeoutUpdated(oldTimeout, _timeout);\n    }\n\n    function setBaseDataURL(string memory _url) external onlyOwner {\n        string memory oldURL = baseDataURL;\n        baseDataURL = _url;\n        emit BaseDataUrlUpdated(oldURL, _url);\n    }\n\n    function setBrevisProof(address _brevisProof) external onlyOwner {\n        address oldAddr = address(brevisProof);\n        brevisProof = IBrevisProof(_brevisProof);\n        emit BrevisProofUpdated(oldAddr, _brevisProof);\n    }\n\n    function setBrevisDispute(address _brevisDispute) external onlyOwner {\n        address oldAddr = address(brevisDispute);\n        brevisDispute = IBrevisDispute(_brevisDispute);\n        emit BrevisDisputeUpdated(oldAddr, _brevisDispute);\n    }\n\n    function setBvnSigsVerifier(address _bvnSigsVerifier) external onlyOwner {\n        address oldAddr = address(bvnSigsVerifier);\n        bvnSigsVerifier = IBvnSigsVerifier(_bvnSigsVerifier);\n        emit BvnSigsVerifierUpdated(oldAddr, _bvnSigsVerifier);\n    }\n\n    function setAvsSigsVerifier(address _avsSigsVerifier) external onlyOwner {\n        address oldAddr = address(avsSigsVerifier);\n        avsSigsVerifier = IAvsSigsVerifier(_avsSigsVerifier);\n        emit BvnSigsVerifierUpdated(oldAddr, _avsSigsVerifier);\n    }\n\n    // --------------------- view functions ---------------------\n\n    function queryRequestStatus(bytes32 _proofId, uint64 _nonce) external view returns (RequestStatus, uint8) {\n        return _queryRequestStatus(keccak256(abi.encodePacked(_proofId, _nonce)), brevisDispute.getChallengeWindow());\n    }\n\n    function queryRequestStatus(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint256 _challengeWindow\n    ) external view returns (RequestStatus, uint8) {\n        return _queryRequestStatus(keccak256(abi.encodePacked(_proofId, _nonce)), _challengeWindow);\n    }\n\n    function validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint8 _option\n    ) external view returns (bool) {\n        uint256 challengeWindow = brevisDispute.getChallengeWindow();\n        return _validateOpAppData(_proofId, _nonce, _appCommitHash, _appVkHash, challengeWindow, _option);\n    }\n\n    function validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint256 _challengeWindow,\n        uint8 _option\n    ) external view returns (bool) {\n        return _validateOpAppData(_proofId, _nonce, _appCommitHash, _appVkHash, _challengeWindow, _option);\n    }\n\n    function validateOpAppData(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        uint256 _challengeWindow,\n        uint8 _option\n    ) external view returns (bool) {\n        for (uint256 i = 0; i < _proofIds.length; i++) {\n            if (\n                !_validateOpAppData(\n                    _proofIds[i],\n                    _nonces[i],\n                    _appCommitHashes[i],\n                    _appVkHashes[i],\n                    _challengeWindow,\n                    _option\n                )\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function dataURL(bytes32 _proofId) external view returns (string memory) {\n        if (bytes(baseDataURL).length == 0) {\n            return \"\";\n        }\n        return string.concat(baseDataURL, Strings.toHexString(uint256(_proofId), 32));\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    function _brevisCallback(\n        address _callbackTarget,\n        bytes32 _appVkHash,\n        bytes calldata _appCircuitOutput,\n        bytes32 _requestKey,\n        RequestStatus _status\n    ) private returns (bool) {\n        uint256 gas;\n        if (_status == RequestStatus.ZkPending /* is onchain request*/) {\n            Callback memory callback = onchainRequests[_requestKey].callback;\n            require(callback.target == _callbackTarget, \"callback mismatch\");\n            gas = callback.gas;\n        }\n        if (_callbackTarget != address(0)) {\n            if (gas == 0) {\n                gas = gasleft();\n            }\n            // If the call failed due any reason, anyone can trigger retry later by calling applyBrevisProof.\n            (bool success, ) = _callbackTarget.call{gas: gas}(\n                abi.encodeWithSelector(IBrevisApp.brevisCallback.selector, _appVkHash, _appCircuitOutput)\n            );\n            if (!success) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _submitOpStates(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        uint8 option\n    ) private {\n        uint64 timestamp = uint64(block.timestamp);\n        for (uint i = 0; i < _proofIds.length; i++) {\n            bytes32 requestKey = keccak256(abi.encodePacked(_proofIds[i], _nonces[i]));\n            Request memory request = requests[requestKey];\n            if (request.status == RequestStatus.OpPending) {\n                require(request.option == option, \"insufficient types of sigs\");\n            } else {\n                require(request.status == RequestStatus.Null, \"invalid status\");\n            }\n            requests[requestKey] = Request(RequestStatus.OpSubmitted, timestamp, option);\n            opdata[requestKey] = keccak256(abi.encodePacked(_appCommitHashes[i], _appVkHashes[i]));\n        }\n    }\n\n    function _queryRequestStatus(\n        bytes32 _requestKey, // keccak256(abi.encodePacked(_proofId, _nonce))\n        uint256 _challengeWindow\n    ) private view returns (RequestStatus, uint8) {\n        Request memory request = requests[_requestKey];\n        if (request.status == RequestStatus.OpSubmitted) {\n            if (request.timestamp + _challengeWindow < block.timestamp) {\n                return (RequestStatus.OpAttested, request.option);\n            }\n        } else if (request.status == RequestStatus.OpDisputing) {\n            DisputeStatus dstatus = brevisDispute.getDisputeStatus(_requestKey);\n            if (dstatus == DisputeStatus.RequestDataPosted || dstatus == DisputeStatus.DataAvailabilityProofPosted) {\n                if (request.timestamp + _challengeWindow < block.timestamp) {\n                    return (RequestStatus.OpAttested, request.option);\n                }\n            } else if (brevisDispute.getResponseDeadline(_requestKey) < block.timestamp) {\n                // did not respond in time for WaitingForXXX\n                return (RequestStatus.OpDisputed, request.option);\n            }\n        }\n        return (request.status, request.option);\n    }\n\n    function _validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint256 _challengeWindow,\n        uint8 _option\n    ) private view returns (bool readyToUse) {\n        bytes32 requestKey = keccak256(abi.encodePacked(_proofId, _nonce));\n        require(opdata[requestKey] == keccak256(abi.encodePacked(_appCommitHash, _appVkHash)), \"invalid data\");\n        (RequestStatus status, uint8 option) = _queryRequestStatus(requestKey, _challengeWindow);\n        if (status == RequestStatus.OpAttested) {\n            return (_option & option) == _option;\n        } else if (status == RequestStatus.ZkAttested) {\n            return true;\n        }\n        return false;\n    }\n\n    function _bitSet(uint8 _value, uint8 _index) private pure returns (uint8) {\n        uint8 mask = uint8(1 << _index);\n        return _value | mask;\n    }\n}\n"
    },
    "contracts/sdk/core/FeeVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.18;\n\nimport \"../../safeguard/Ownable.sol\";\n\n/**\n * @title Allows the owner to set fee collector and allows fee collectors to collect fees\n */\ncontract FeeVault is Ownable {\n    address public feeCollector;\n\n    event FeeCollected(uint256 amount, address receiver);\n    event FeeCollectorUpdated(address from, address to);\n\n    constructor(address _feeCollector) {\n        feeCollector = _feeCollector;\n    }\n\n    modifier onlyFeeCollector() {\n        require(msg.sender == feeCollector, \"not fee collector\");\n        _;\n    }\n\n    function collectFee(uint256 _amount, address _to) external onlyFeeCollector {\n        (bool sent, ) = _to.call{value: _amount, gas: 50000}(\"\");\n        require(sent, \"send native failed\");\n        emit FeeCollected(_amount, _to);\n    }\n\n    function setFeeCollector(address _feeCollector) external onlyOwner {\n        address oldFeeCollector = feeCollector;\n        feeCollector = _feeCollector;\n        emit FeeCollectorUpdated(oldFeeCollector, _feeCollector);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/sdk/core/verifiers/Plonky2AggProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract Plonky2AggProofVerifier {\n\n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 20130115150190108019054123324150266355963634520665803044119931121920433877502;\n    uint256 constant ALPHA_Y = 14285561117546692228188264117658849531292193248102265302826521527658774130730;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 12173582291697991928038706774854257923669411098639177950151278294306876399185;\n    uint256 constant BETA_NEG_X_1 = 15132618022772140126948816923300076218627540588695058850129828561330319272394;\n    uint256 constant BETA_NEG_Y_0 = 21443297657689754130694783041616163165528212213189433353793846678725256110968;\n    uint256 constant BETA_NEG_Y_1 = 10501575552957665887945655290567158183091839264534194878186069451520528855363;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 21190170695766197642735844330659825381395925533125398227031524291838460125060;\n    uint256 constant GAMMA_NEG_X_1 = 19203026818133896529218674625910724378196155667663875895123556718339151509868;\n    uint256 constant GAMMA_NEG_Y_0 = 11205639707683230252739576378165133363686151523964908586275163372934586463856;\n    uint256 constant GAMMA_NEG_Y_1 = 10214449308851856821972963282423085145860104790900192284349190463458888620188;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 10399319314398376417820802724200232724959666061017285602953069221524861793753;\n    uint256 constant DELTA_NEG_X_1 = 452886078276742855748568059052645802297245110497791390730521524044942878705;\n    uint256 constant DELTA_NEG_Y_0 = 18843179484068923140237924738630828752463118041111414293311624672247179311708;\n    uint256 constant DELTA_NEG_Y_1 = 6578419443316232797720362393723449118629184777106657540493243117798965076474;\n    // Pedersen G point in G2 in powers of i\n    uint256 constant PEDERSEN_G_X_0 = 18840956241968029731100325856496885824192733037252226446060524528156530111308;\n    uint256 constant PEDERSEN_G_X_1 = 21274503460330121600530385632507567737303199317766957577320329332713158025884;\n    uint256 constant PEDERSEN_G_Y_0 = 21703706571156547469091964352250046820952425344667079956389688490794984176885;\n    uint256 constant PEDERSEN_G_Y_1 = 17581065412830892652496072086768587586258265586086612253128718326201955073618;\n\n    // Pedersen GRootSigmaNeg point in G2 in powers of i\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_0 = 9477073819196801833214615315952587768947385509800268046198048251598908341847;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_1 = 8733489005457477856766509430546022763271987272883810365436552332880971951842;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_0 = 855147140980254462115987301424675648082659807931923152867586423105627459442;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_1 = 21617656332261003847761610550493473011912376763721964847518217346669211124634;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 12096385008008835625928732081395595134182198718451766067043585113744474120373;\n    uint256 constant CONSTANT_Y = 7743770677267848242696443432401875246365945607818899290902759876388111845102;\n    uint256 constant PUB_0_X = 11517708531354116769553564301121006653788372143772228218883516720808567029236;\n    uint256 constant PUB_0_Y = 2152127335932304681966390681193568647248500526879538976519507779251881398051;\n    uint256 constant PUB_1_X = 2411623673232227440182427003605066260447834996624159200713714450678525673813;\n    uint256 constant PUB_1_Y = 20302495699790144734302725144246911109225787328411619703039824705266308249975;\n    uint256 constant PUB_2_X = 18806945557217583070771738455262435430543222198660506094198443254708010681201;\n    uint256 constant PUB_2_Y = 488608118252318333241074170519058509672247917809847727458802505257044789554;\n    uint256 constant PUB_3_X = 3271889172046179794175799562498488678635115520079974329494182174355427750959;\n    uint256 constant PUB_3_Y = 13888544571628847530483236925932420001521195941868097389115207259520893393129;\n    uint256 constant PUB_4_X = 15735991015174072795703790087522471561699190385808970605894593460553789112495;\n    uint256 constant PUB_4_Y = 12221542038876261891140618611503962465999310138418282525833171556590552238586;\n    uint256 constant PUB_5_X = 8008225254116302360001416404876069698232064530453411337872616393927786537230;\n    uint256 constant PUB_5_Y = 10268217310132774904598799980256756069898428929972715439619293670935450693965;\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(\n        uint256[5] calldata input,\n        uint256 publicCommit,\n        uint256[2] calldata commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s := calldataload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s := calldataload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_2_X)\n            mstore(add(g, 0x20), PUB_2_Y)\n            s := calldataload(add(input, 64))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_3_X)\n            mstore(add(g, 0x20), PUB_3_Y)\n            s := calldataload(add(input, 96))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_4_X)\n            mstore(add(g, 0x20), PUB_4_Y)\n            s := calldataload(add(input, 128))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_5_X)\n            mstore(add(g, 0x20), PUB_5_Y)\n\n            s := calldataload(add(input, 160))\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := calldataload(commit)\n            mstore(g, s) // save commit[0]\n            s := calldataload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Verify an uncompressed Groth16 proof.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\n    /// of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyProof(\n        uint256[8] calldata proof,\n        uint256[2] calldata commit,\n        uint256[2] calldata knowledgeProof,\n        uint256[5] calldata input\n    ) public view returns (bool) {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commit[0], commit[1]))) % MOD_R;\n        (uint256 x, uint256 y) = publicInputMSM(input, inputFr, commit);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n            // Copy points (A, B, C) to memory. They are already in correct encoding.\n            // This is pairing e(A, B) and G1 of e(C, -δ).\n            calldatacopy(f, proof, 0x100)\n\n            // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n            // OPT: This could be better done using a single codecopy, but\n            //      Solidity (unlike standalone Yul) doesn't provide a way to\n            //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := calldataload(commit)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := calldataload(add(commit, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), PEDERSEN_G_Y_0)\n\n            c := calldataload(knowledgeProof)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := calldataload(add(knowledgeProof, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), PEDERSEN_GROOTSIGMANEG_X_1)\n            mstore(add(f, 0x420), PEDERSEN_GROOTSIGMANEG_X_0)\n            mstore(add(f, 0x440), PEDERSEN_GROOTSIGMANEG_Y_1)\n            mstore(add(f, 0x460), PEDERSEN_GROOTSIGMANEG_Y_0)\n\n            // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n            // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n        return success;\n    }\n\n    function verifyRaw(bytes calldata proofData) external view returns (bool) {\n        uint256[8] memory proof;\n        proof[0] = uint256(bytes32(proofData[:32]));\n        proof[1] = uint256(bytes32(proofData[32:64]));\n        proof[2] = uint256(bytes32(proofData[64:96]));\n        proof[3] = uint256(bytes32(proofData[96:128]));\n        proof[4] = uint256(bytes32(proofData[128:160]));\n        proof[5] = uint256(bytes32(proofData[160:192]));\n        proof[6] = uint256(bytes32(proofData[192:224]));\n        proof[7] = uint256(bytes32(proofData[224:256]));\n\n        uint256[2] memory commitment;\n        commitment[0] = uint256(bytes32(proofData[256:288]));\n        commitment[1] = uint256(bytes32(proofData[288:320]));\n\n        uint256[2] memory commitmentPOK;\n        commitmentPOK[0] = uint256(bytes32(proofData[320:352]));\n        commitmentPOK[1] = uint256(bytes32(proofData[352:384]));\n\n        uint256[5] memory input;\n        input[1] = uint256(uint128(bytes16(proofData[384:400]))); // merkleRoot 0\n        input[0] = uint256(uint128(bytes16(proofData[400:416]))); // merkleRoot 1\n        input[3] = uint256(uint128(bytes16(proofData[416:432]))); // proofIdsCommit 0\n        input[2] = uint256(uint128(bytes16(proofData[432:448]))); // proofIdsCommit 1\n        input[4] = uint256(bytes32(proofData[448:480])); // sub proof vk hash, mimc bn254\n\n        return this.verifyProof(proof, commitment, commitmentPOK, input);\n    }\n}\n"
    },
    "contracts/sdk/core/verifiers/Plonky2ProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract Plonky2ProofVerifier {\n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 3630180744704320788844233763608291127950106285684998507223106347915185149792;\n    uint256 constant ALPHA_Y = 13196198558047642402967732277888811606425784559073035773689603364150396504816;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 4793484071695097477578958515547222684223988209770319530038156381048085979731;\n    uint256 constant BETA_NEG_X_1 = 498684634633471661575694288850467457247566219699189449452930818924949618182;\n    uint256 constant BETA_NEG_Y_0 = 11815609728158707801899957509825248461371039895071057944908382533378624078558;\n    uint256 constant BETA_NEG_Y_1 = 12070313006730149903002039026455163366723840475641524599405320033715241375801;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 5955796502819209530519694682997659119464302455444832863178103707638947420117;\n    uint256 constant GAMMA_NEG_X_1 = 1915485519747312921250251119556669374406920349125905464211566252925045075994;\n    uint256 constant GAMMA_NEG_Y_0 = 7307269706974652445827026828173386359328065570805643722662315112380547144827;\n    uint256 constant GAMMA_NEG_Y_1 = 13985735928739904577303054467633195478887414235040255108511623137484769155804;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 863848829239739785718979233236880605336144624213666685025715876762701006720;\n    uint256 constant DELTA_NEG_X_1 = 16231221169861854000828594997407132192455085048582418933589026320111871068020;\n    uint256 constant DELTA_NEG_Y_0 = 5181202426557983626764339767300839679945679900175004234699592936768828651190;\n    uint256 constant DELTA_NEG_Y_1 = 3615832298736737239987675125624399578544079718482934521984705578417868497258;\n    // Pedersen G point in G2 in powers of i\n    uint256 constant PEDERSEN_G_X_0 = 7490179471310076975591245968955394447981648517543123204182300937475283823331;\n    uint256 constant PEDERSEN_G_X_1 = 12956451950241817505957304150968014606470514673841286287720322402761079477557;\n    uint256 constant PEDERSEN_G_Y_0 = 6245856491266623046114236797309693711346785601144287735799792298891246888721;\n    uint256 constant PEDERSEN_G_Y_1 = 10443758596703157728252362115676625834776649185200184484507739795379033706117;\n\n    // Pedersen GRootSigmaNeg point in G2 in powers of i\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_0 = 454433384312897944445468187729925984500371054333846261197128896848710713215;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_1 = 6453903701314664536774415567386846109194149516037532722713971365679979026008;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_0 = 2438098120394322163257888186400283184889733431347369635949505540595910719330;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_1 = 15513178767012717087202831195810534996444208792857470280610978549375725820641;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 17100475366564672631107870126486416833993880904421683020986652350482564384631;\n    uint256 constant CONSTANT_Y = 17667009527642897780017359415718756539919338267490647166315147697136741525785;\n    uint256 constant PUB_0_X = 1162852544627308225421003907682595293344096140811042622844919183028795576201;\n    uint256 constant PUB_0_Y = 7462326333469811331153404954093896712181871303015088728085232937141224405929;\n    uint256 constant PUB_1_X = 4955364365495882637301685169891321575266518387465780561256018367011097407776;\n    uint256 constant PUB_1_Y = 12439330526017835811033560419106034135998021806744525240192427062115544584553;\n    uint256 constant PUB_2_X = 2747792336525268850053625398296340810331081221680706277168008824034195872355;\n    uint256 constant PUB_2_Y = 9146052361846171427848138313940203788569600522894449772237133413389577964215;\n    uint256 constant PUB_3_X = 18081740525633248696447681034992326116157316831281073798185445101652768447345;\n    uint256 constant PUB_3_Y = 1588444792118132375127633317817753266297216226458154078288830827076574968059;\n    uint256 constant PUB_4_X = 21760296273730010311495962498587571131667815332153224334956544183781331427572;\n    uint256 constant PUB_4_Y = 12564232489115746913193058182111092693244146295891199517091630967938194376453;\n    uint256 constant PUB_5_X = 4662912319109720615072141400110727933479753451024261708289527382129800918464;\n    uint256 constant PUB_5_Y = 8884623790550273249384602209236593267811238907637146916915700944193893627995;\n    uint256 constant PUB_6_X = 21861092172552514086480735533251208693499259630614811201696984182597580526413;\n    uint256 constant PUB_6_Y = 21736171081614810269854279746900244530163073334501317356413534930524969873024;\n    uint256 constant PUB_7_X = 5947951566350892334973722370211902525393523821140620996059752326072442750740;\n    uint256 constant PUB_7_Y = 5739604200024524486432918263958527581964498791531698017848663948450362781421;\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(\n        uint256[7] memory input,\n        uint256 publicCommit,\n        uint256[2] memory commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s := mload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s := mload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_2_X)\n            mstore(add(g, 0x20), PUB_2_Y)\n            s := mload(add(input, 64))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_3_X)\n            mstore(add(g, 0x20), PUB_3_Y)\n            s := mload(add(input, 96))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_4_X)\n            mstore(add(g, 0x20), PUB_4_Y)\n            s := mload(add(input, 128))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_5_X)\n            mstore(add(g, 0x20), PUB_5_Y)\n            s := mload(add(input, 160))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_6_X)\n            mstore(add(g, 0x20), PUB_6_Y)\n            s := mload(add(input, 192))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_7_X)\n            mstore(add(g, 0x20), PUB_7_Y)\n\n            s := mload(add(input, 224))\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := mload(commit)\n            mstore(g, s) // save commit[0]\n            s := mload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Verify an uncompressed Groth16 proof.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\n    /// of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyProof(\n        uint256[8] memory proof,\n        uint256[2] memory commitment,\n        uint256[2] memory commitmentPOK,\n        uint256[7] memory input\n    ) public view returns (bool) {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commitment[0], commitment[1]))) % MOD_R;\n        (uint256 x, uint256 y) = publicInputMSM(input, inputFr, commitment);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n\n        uint256 a0 = proof[0];\n        uint256 a1 = proof[1];\n        uint256 b00 = proof[2];\n        uint256 b01 = proof[3];\n        uint256 b10 = proof[4];\n        uint256 b11 = proof[5];\n        uint256 c0 = proof[6];\n        uint256 c1 = proof[7];\n\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n            // Copy points (A, B, C) to memory. They are already in correct encoding.\n            // This is pairing e(A, B) and G1 of e(C, -δ).\n            mstore(f, a0)\n            mstore(add(f, 0x20), a1)\n            mstore(add(f, 0x40), b00)\n            mstore(add(f, 0x60), b01)\n            mstore(add(f, 0x80), b10)\n            mstore(add(f, 0xa0), b11)\n            mstore(add(f, 0xc0), c0)\n            mstore(add(f, 0xe0), c1)\n\n            // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n            // OPT: This could be better done using a single codecopy, but\n            //      Solidity (unlike standalone Yul) doesn't provide a way to\n            //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := mload(commitment)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := mload(add(commitment, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), PEDERSEN_G_Y_0)\n\n            c := mload(commitmentPOK)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := mload(add(commitmentPOK, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), PEDERSEN_GROOTSIGMANEG_X_1)\n            mstore(add(f, 0x420), PEDERSEN_GROOTSIGMANEG_X_0)\n            mstore(add(f, 0x440), PEDERSEN_GROOTSIGMANEG_Y_1)\n            mstore(add(f, 0x460), PEDERSEN_GROOTSIGMANEG_Y_0)\n\n            // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n            // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n        return success;\n    }\n\n    function verifyRaw(bytes calldata proofData) external view returns (bool) {\n        uint256[8] memory proof;\n        proof[0] = uint256(bytes32(proofData[:32]));\n        proof[1] = uint256(bytes32(proofData[32:64]));\n        proof[2] = uint256(bytes32(proofData[64:96]));\n        proof[3] = uint256(bytes32(proofData[96:128]));\n        proof[4] = uint256(bytes32(proofData[128:160]));\n        proof[5] = uint256(bytes32(proofData[160:192]));\n        proof[6] = uint256(bytes32(proofData[192:224]));\n        proof[7] = uint256(bytes32(proofData[224:256]));\n\n        uint256[2] memory commitment;\n        commitment[0] = uint256(bytes32(proofData[256:288]));\n        commitment[1] = uint256(bytes32(proofData[288:320]));\n\n        uint256[2] memory commitmentPOK;\n        commitmentPOK[0] = uint256(bytes32(proofData[320:352]));\n        commitmentPOK[1] = uint256(bytes32(proofData[352:384]));\n\n        uint256[7] memory input;\n        input[0] = uint256(bytes32(proofData[384:416])); // commit hash\n        input[1] = uint256(uint128(bytes16(proofData[416:432]))); // smt root 0\n        input[2] = uint256(uint128(bytes16(proofData[432:448]))); // smt root 1\n        input[3] = uint256(uint128(bytes16(proofData[448:464]))); // output commitment 0\n        input[4] = uint256(uint128(bytes16(proofData[464:480]))); // output commitment 1\n        input[5] = uint256(bytes32(proofData[480:512])); // app vk hash\n        input[6] = uint256(bytes32(proofData[512:544])); // dummy commitment\n\n        return this.verifyProof(proof, commitment, commitmentPOK, input);\n    }\n}\n"
    },
    "contracts/sdk/interface/IBrevisApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IBrevisApp {\n    function brevisCallback(bytes32 _appVkHash, bytes calldata _appCircuitOutput) external;\n\n    function brevisBatchCallback(bytes32[] calldata _appVkHashs, bytes[] calldata _appCircuitOutputs) external;\n}\n"
    },
    "contracts/sdk/interface/IBrevisDispute.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./IBrevisTypes.sol\";\n\ninterface IBrevisDispute is IBrevisTypes {\n    event AskFor(bytes32 indexed proofId, uint64 nonce, DisputeStatus status, address from);\n    event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done);\n    event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce);\n    event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce);\n\n    event ChallengeWindowUpdated(uint256 from, uint256 to);\n    event ResponseTimeoutUpdated(uint256 from, uint256 to);\n    event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof);\n\n    function askForRequestData(bytes32 _proofId, uint64 _nonce) external payable;\n\n    function postRequestData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes[] calldata _requestData,\n        uint256 _index,\n        bool _done\n    ) external;\n\n    function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) external payable;\n\n    function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes calldata _proof) external;\n\n    function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) external payable;\n\n    function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes calldata _proof) external;\n\n    function getChallengeWindow() external view returns (uint256);\n\n    function getDisputeStatus(bytes32 _requestKey) external view returns (DisputeStatus);\n\n    function getResponseDeadline(bytes32 _requestKey) external view returns (uint256);\n}\n"
    },
    "contracts/sdk/interface/IBrevisProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/Lib.sol\";\n\ninterface IBrevisProof {\n    function submitProof(\n        uint64 _chainId,\n        bytes calldata _proofWithPubInputs\n    ) external returns (bytes32 requestId, bytes32 appCommitHash, bytes32 appVkHash);\n\n    function validateProofAppData(\n        bytes32 _requestId,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash\n    ) external view returns (bool);\n\n    function submitAggProof(\n        uint64 _chainId,\n        bytes32[] calldata _requestIds,\n        bytes calldata _proofWithPubInputs\n    ) external;\n\n    function validateAggProofData(uint64 _chainId, Brevis.ProofData[] calldata _proofDataArray) external view;\n\n    function validateAggProofData(\n        uint64 _chainId,\n        Brevis.ProofData calldata _proofData,\n        bytes32 _merkleRoot,\n        bytes32[] calldata _merkleProof,\n        uint8 _nodeIndex\n    ) external view;\n}\n"
    },
    "contracts/sdk/interface/IBrevisRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./IBrevisTypes.sol\";\nimport \"../lib/Lib.sol\";\nimport \"../../interfaces/ISigsVerifier.sol\";\n\ninterface IBrevisRequest is IBrevisTypes {\n    // todo: reduce event fields\n    event RequestSent(bytes32 proofId, uint64 nonce, address refundee, uint256 fee, Callback callback, uint8 option);\n\n    event RequestFulfilled(bytes32 proofId, uint64 nonce);\n    event RequestsFulfilled(bytes32[] proofIds, uint64[] nonces);\n    event OpRequestsFulfilled(bytes32[] proofIds, uint64[] nonces, bytes32[] appCommitHashes, bytes32[] appVkHashes);\n\n    event RequestRefunded(bytes32 proofId, uint64 nonce);\n    event RequestCallbackFailed(bytes32 proofId, uint64 nonce);\n    event RequestsCallbackFailed(bytes32[] proofIds, uint64[] nonces);\n    event RequestFeeIncreased(bytes32 proofId, uint64 nonce, uint256 gas, uint256 fee);\n\n    event RequestTimeoutUpdated(uint256 from, uint256 to);\n    event BaseDataUrlUpdated(string from, string to);\n    event BrevisProofUpdated(address from, address to);\n    event BrevisDisputeUpdated(address from, address to);\n    event BvnSigsVerifierUpdated(address from, address to);\n    event AvsSigsVerifierUpdated(address from, address to);\n\n    function sendRequest(\n        bytes32 _proofId,\n        uint64 _nonce,\n        address _refundee,\n        Callback calldata _callback,\n        uint8 _option // bitmap 0: zk, 1: op bvn, 2: op avs, 3: op bvn and avs\n    ) external payable;\n\n    function fulfillRequest(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _chainId,\n        bytes calldata _proof,\n        bytes calldata _appCircuitOutput,\n        address _callbackTarget\n    ) external;\n\n    function fulfillRequests(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        uint64 _chainId,\n        bytes calldata _proof,\n        Brevis.ProofData[] calldata _proofDataArray,\n        bytes[] calldata _appCircuitOutputs,\n        address[] calldata _callbackTargets\n    ) external;\n\n    function fulfillOpRequests(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        IBvnSigsVerifier.SigInfo calldata _bvnSigInfo,\n        IAvsSigsVerifier.SigInfo calldata _eigenSigInfo\n    ) external;\n\n    function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) external;\n\n    function increaseGasFee(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint64 _addGas,\n        uint256 _currentFee,\n        address _refundee\n    ) external payable;\n\n    function queryRequestStatus(bytes32 _proofId, uint64 _nonce) external view returns (RequestStatus, uint8);\n\n    function queryRequestStatus(\n        bytes32 _proofId,\n        uint64 _nonce,\n        uint256 _appChallengeWindow\n    ) external view returns (RequestStatus, uint8);\n\n    function validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint8 _option\n    ) external view returns (bool);\n\n    function validateOpAppData(\n        bytes32 _proofId,\n        uint64 _nonce,\n        bytes32 _appCommitHash,\n        bytes32 _appVkHash,\n        uint256 _appChallengeWindow,\n        uint8 _option\n    ) external view returns (bool);\n\n    function validateOpAppData(\n        bytes32[] calldata _proofIds,\n        uint64[] calldata _nonces,\n        bytes32[] calldata _appCommitHashes,\n        bytes32[] calldata _appVkHashes,\n        uint256 _appChallengeWindow,\n        uint8 _option\n    ) external view returns (bool);\n\n    function dataURL(bytes32 _proofId) external view returns (string memory);\n}\n"
    },
    "contracts/sdk/interface/IBrevisTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IBrevisTypes {\n    enum RequestStatus {\n        Null,\n        ZkPending,\n        ZkAttested,\n        OpPending,\n        OpSubmitted,\n        OpDisputing,\n        OpDisputed,\n        OpAttested,\n        Refunded\n    }\n\n    struct Request {\n        RequestStatus status;\n        uint64 timestamp;\n        uint8 option;\n    }\n\n    struct OnchainRequestInfo {\n        bytes32 feeHash; // keccak256(abi.encodePacked(amount, refundee))\n        Callback callback;\n    }\n\n    struct Callback {\n        address target;\n        uint64 gas;\n    }\n\n    enum DisputeStatus {\n        Null,\n        WaitingForRequestData,\n        RequestDataPosted,\n        WaitingForDataAvailabilityProof,\n        DataAvailabilityProofPosted,\n        WaitingForDataValidityProof,\n        DataValidityProofPosted\n    }\n\n    struct RequestDataHash {\n        bytes32[] hashes;\n        bytes32 root;\n    }\n\n    struct Dispute {\n        DisputeStatus status;\n        address challenger;\n        RequestDataHash requestDataHash;\n        uint256 responseDeadline;\n        uint256 deposit;\n    }\n}\n"
    },
    "contracts/sdk/lib/Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../lib/RLPReader.sol\";\n\nlibrary Brevis {\n    // retrieved from proofData, to align the logs with circuit...\n    struct ProofData {\n        bytes32 commitHash;\n        bytes32 appCommitHash; // zk-program computing circuit commit hash\n        bytes32 appVkHash; // zk-program computing circuit Verify Key hash\n        bytes32 smtRoot;\n        bytes32 dummyInputCommitment; // zk-program computing circuit dummy input commitment\n    }\n\n    struct ProofAppData {\n        bytes32 appCommitHash;\n        bytes32 appVkHash;\n    }\n}\n\nlibrary Tx {\n    using RLPReader for bytes;\n    using RLPReader for uint;\n    using RLPReader for RLPReader.RLPItem;\n\n    struct TxInfo {\n        uint64 chainId;\n        uint64 nonce;\n        uint256 gasTipCap;\n        uint256 gasFeeCap;\n        uint256 gas;\n        address to;\n        uint256 value;\n        bytes data;\n        address from; // calculate from V R S\n    }\n\n    // support DynamicFeeTxType for now\n    function decodeTx(bytes calldata txRaw) public pure returns (TxInfo memory info) {\n        uint8 txType = uint8(txRaw[0]);\n        require(txType == 2, \"not a DynamicFeeTxType\");\n\n        bytes memory rlpData = txRaw[1:];\n        RLPReader.RLPItem[] memory values = rlpData.toRlpItem().toList();\n        info.chainId = uint64(values[0].toUint());\n        info.nonce = uint64(values[1].toUint());\n        info.gasTipCap = values[2].toUint();\n        info.gasFeeCap = values[3].toUint();\n        info.gas = values[4].toUint();\n        info.to = values[5].toAddress();\n        info.value = values[6].toUint();\n        info.data = values[7].toBytes();\n\n        (uint8 v, bytes32 r, bytes32 s) = (\n            uint8(values[9].toUint()),\n            bytes32(values[10].toBytes()),\n            bytes32(values[11].toBytes())\n        );\n        // remove r,s,v and adjust length field\n        bytes memory unsignedTxRaw;\n        uint16 unsignedTxRawDataLength;\n        uint8 prefix = uint8(txRaw[1]);\n        uint8 lenBytes = prefix - 0xf7; // assume lenBytes won't larger than 2, means the tx rlp data size won't exceed 2^16\n        if (lenBytes == 1) {\n            unsignedTxRawDataLength = uint8(bytes1(txRaw[2:3])) - 67; //67 is the bytes of r,s,v\n        } else {\n            unsignedTxRawDataLength = uint16(bytes2(txRaw[2:2 + lenBytes])) - 67;\n        }\n        if (unsignedTxRawDataLength <= 55) {\n            unsignedTxRaw = abi.encodePacked(txRaw[:2], txRaw[3:txRaw.length - 67]);\n            unsignedTxRaw[1] = bytes1(0xc0 + uint8(unsignedTxRawDataLength));\n        } else {\n            if (unsignedTxRawDataLength <= 255) {\n                unsignedTxRaw = abi.encodePacked(\n                    txRaw[0],\n                    bytes1(0xf8),\n                    bytes1(uint8(unsignedTxRawDataLength)),\n                    txRaw[2 + lenBytes:txRaw.length - 67]\n                );\n            } else {\n                unsignedTxRaw = abi.encodePacked(\n                    txRaw[0],\n                    bytes1(0xf9),\n                    bytes2(unsignedTxRawDataLength),\n                    txRaw[2 + lenBytes:txRaw.length - 67]\n                );\n            }\n        }\n        info.from = recover(keccak256(unsignedTxRaw), r, s, v);\n    }\n\n    function recover(bytes32 message, bytes32 r, bytes32 s, uint8 v) internal pure returns (address) {\n        if (v < 27) {\n            v += 27;\n        }\n        return ecrecover(message, v, r, s);\n    }\n}\n"
    },
    "contracts/smt/SMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../light-client-eth/interfaces/IAnchorBlocks.sol\";\nimport \"../interfaces/ISMT.sol\";\nimport \"../safeguard/BrevisAccess.sol\";\n\ncontract SMT is ISMT, BrevisAccess {\n    event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum, uint64 chainId);\n    event AnchorProviderUpdated(uint64 chainId, address anchorProvider);\n    event VerifierUpdated(uint64 chainId, address verifier);\n    event CircuitDigestUpdated(bytes32 circuitDigest);\n\n    mapping(uint64 => IAnchorBlocks) public anchorProviders;\n    mapping(uint64 => IVerifier) public verifiers;\n\n    mapping(uint64 => mapping(bytes32 => bool)) public smtRoots;\n    mapping(uint64 => bytes32) public latestRoots;\n    bytes32 public circuitDigest; \n\n    constructor(\n        uint64[] memory _chainIds,\n        address[] memory _anchorProviders,\n        address[] memory _verifiers,\n        bytes32[] memory _initRoots\n    ) {\n        require(_chainIds.length == _anchorProviders.length, \"len mismatch\");\n        require(_chainIds.length == _verifiers.length, \"len mismatch\");\n        require(_chainIds.length == _initRoots.length, \"len mismatch\");\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            uint64 chid = _chainIds[i];\n            anchorProviders[chid] = IAnchorBlocks(_anchorProviders[i]);\n            verifiers[chid] = IVerifier(_verifiers[i]);\n            smtRoots[chid][_initRoots[i]] = true;\n            latestRoots[chid] = _initRoots[i];\n        }\n    }\n\n    function getLatestRoot(uint64 chainId) public view returns (bytes32) {\n        return latestRoots[chainId];\n    }\n\n    function isSmtRootValid(uint64 chainId, bytes32 smtRoot) public view returns (bool) {\n        return smtRoots[chainId][smtRoot];\n    }\n\n    function updateRoot(uint64 chainId, SmtUpdate memory u) external onlyActiveProver {\n        // If nextChunkMerkleRoot is empty, it means the zk proof bypasses checking if the updated chunk anchors to a known chunk.\n        // Instead, the responsibility of checking the validity of endBlockHash is deferred to this contract.\n        if (u.nextChunkMerkleRoot == 0) {\n            IAnchorBlocks anchorProvider = anchorProviders[chainId];\n            require(address(anchorProvider) != address(0), \"unknown anchor provider\");\n            bytes32 anchorHash = anchorProvider.blocks(u.endBlockNum);\n            require(anchorHash == u.endBlockHash, \"anchor check failed\");\n        }\n        bytes32 root = latestRoots[chainId];\n        bool success = verifyProof(chainId, root, u);\n        require(success, \"invalid zk proof\");\n\n        smtRoots[chainId][u.newSmtRoot] = true;\n        latestRoots[chainId] = u.newSmtRoot;\n        emit SmtRootUpdated(u.newSmtRoot, u.endBlockNum, chainId);\n    }\n\n    function verifyProof(uint64 chainId, bytes32 oldSmtRoot, SmtUpdate memory u) private view returns (bool) {\n        IVerifier verifier = verifiers[chainId];\n        require(address(verifier) != address(0), \"no verifier for chainId\");\n        require(circuitDigest == u.circuitDigest, \"not valid circuit digest\");\n        uint256[9] memory input;\n        uint256 m = 1 << 128;\n        input[0] = uint256(u.endBlockHash) >> 128;\n        input[1] = uint256(u.endBlockHash) % m;\n        input[2] = uint256(u.newSmtRoot) >> 128;\n        input[3] = uint256(u.newSmtRoot) % m;\n        input[4] = uint256(oldSmtRoot) >> 128;\n        input[5] = uint256(oldSmtRoot) % m;\n        input[6] = uint256(u.nextChunkMerkleRoot) >> 128;\n        input[7] = uint256(u.nextChunkMerkleRoot) % m;\n        input[8] = uint256(u.circuitDigest);\n\n        return verifier.verifyProof(u.proof, u.commit, u.knowledgeProof, input);\n    }\n\n    function setAnchorProvider(uint64 chainId, address anchorProvider) external onlyOwner {\n        anchorProviders[chainId] = IAnchorBlocks(anchorProvider);\n        emit AnchorProviderUpdated(chainId, anchorProvider);\n    }\n\n    function setVerifier(uint64 chainId, address verifier) external onlyOwner {\n        verifiers[chainId] = IVerifier(verifier);\n        emit VerifierUpdated(chainId, verifier);\n    }\n\n    function setCircuitDigest(bytes32 _circuitDigest) external onlyOwner {\n        circuitDigest = _circuitDigest;\n        emit CircuitDigestUpdated(_circuitDigest);\n    }\n}\n"
    },
    "contracts/smt/TestSMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../light-client-eth/interfaces/IAnchorBlocks.sol\";\nimport \"../interfaces/ISMT.sol\";\nimport \"./SMT.sol\";\n\ncontract TestSMT is SMT {\n    constructor(\n        uint64[] memory _chainIds,\n        address[] memory _anchorProviders,\n        address[] memory _verifiers,\n        bytes32[] memory _initRoots\n    ) SMT(_chainIds, _anchorProviders, _verifiers, _initRoots) {}\n\n    // function for testing convenience\n    function addRootForTesting(uint64 chainId, bytes32 newRoot, uint64 endBlockNum) external onlyOwner {\n        smtRoots[chainId][newRoot] = true;\n        latestRoots[chainId] = newRoot;\n        emit SmtRootUpdated(newRoot, endBlockNum, chainId);\n    }\n}\n"
    },
    "contracts/test-helper/MockSMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/ISMT.sol\";\n\ncontract MockSMT is ISMT {\n    function updateRoot(uint64 chainId, SmtUpdate memory u) external {}\n\n    function isSmtRootValid(uint64, bytes32) external pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/verifiers/interfaces/IZkpVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IZkpVerifier {\n    function verifyRaw(bytes calldata proofData) external view returns (bool r);\n}\n"
    },
    "contracts/verifiers/zk-verifiers/BrevisPlonky2SmtVerifier.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Groth16 verifier template.\n/// @author Remco Bloemen\n/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed\n/// (256 bytes) and compressed (128 bytes) format. A view function is provided\n/// to compress proofs.\n/// @notice See <https://2π.com/23/bn254-compression> for further explanation.\ncontract BrevisPlonky2SmtVerifier {\n\n    /// Some of the provided public input values are larger than the field modulus.\n    /// @dev Public input elements are not automatically reduced, as this is can be\n    /// a dangerous source of bugs.\n    error PublicInputNotInField();\n\n    /// The proof is invalid.\n    /// @dev This can mean that provided Groth16 proof points are not on their\n    /// curves, that pairing equation fails, or that the proof is not for the\n    /// provided public input.\n    error ProofInvalid();\n\n    // Addresses of precompiles\n    uint256 constant PRECOMPILE_MODEXP = 0x05;\n    uint256 constant PRECOMPILE_ADD = 0x06;\n    uint256 constant PRECOMPILE_MUL = 0x07;\n    uint256 constant PRECOMPILE_VERIFY = 0x08;\n\n    // Base field Fp order P and scalar field Fr order R.\n    // For BN254 these are computed as follows:\n    //     t = 4965661367192848881\n    //     P = 36⋅t⁴ + 36⋅t³ + 24⋅t² + 6⋅t + 1\n    //     R = 36⋅t⁴ + 36⋅t³ + 18⋅t² + 6⋅t + 1\n    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n\n    uint256 constant MOD_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // Extension field Fp2 = Fp[i] / (i² + 1)\n    // Note: This is the complex extension field of Fp with i² = -1.\n    //       Values in Fp2 are represented as a pair of Fp elements (a₀, a₁) as a₀ + a₁⋅i.\n    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which\n    //       expects Fp2 elements in order (a₁, a₀). This is also the order in which\n    //       Fp2 elements are encoded in the public interface as this became convention.\n\n    // Constants in Fp\n    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;\n    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;\n\n    // Exponents for inversions and square roots mod P\n    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2\n    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;\n\n    // Groth16 alpha point in G1\n    uint256 constant ALPHA_X = 16674961759665994220547130734498453246698070037530669858372207333033413731417;\n    uint256 constant ALPHA_Y = 6911200766160494893801835071078730894862166751034428332209087625882296445779;\n\n    // Groth16 beta point in G2 in powers of i\n    uint256 constant BETA_NEG_X_0 = 13536139394958172751503139069743787749621840250547110104493403742374108935707;\n    uint256 constant BETA_NEG_X_1 = 11102837187904135625307413435026641709334584381137979686243311919180292671054;\n    uint256 constant BETA_NEG_Y_0 = 19281487587562212498559570188845144433402594574027000624914936059133234223423;\n    uint256 constant BETA_NEG_Y_1 = 17611956866946945035550581180406869113463861394727221366079877437664543098877;\n\n    // Groth16 gamma point in G2 in powers of i\n    uint256 constant GAMMA_NEG_X_0 = 21869970720403837836069105727101561984556504927398890797700572961963940142289;\n    uint256 constant GAMMA_NEG_X_1 = 7544179524898651400069274552044174190409119042279917191311868152460077682305;\n    uint256 constant GAMMA_NEG_Y_0 = 12856443559481956347081353006362994975852738789507196674370306840658653257049;\n    uint256 constant GAMMA_NEG_Y_1 = 4478417527849754235590126751372660101209283862196605753220162666566931926943;\n\n    // Groth16 delta point in G2 in powers of i\n    uint256 constant DELTA_NEG_X_0 = 12098390187342850307928066710647009228852240446256104708800865653532999029045;\n    uint256 constant DELTA_NEG_X_1 = 10431018757232294932556939298326165116713515602022172882197940894146795786503;\n    uint256 constant DELTA_NEG_Y_0 = 5120875434737626216784267985855285017748455788325473709943354377044785625163;\n    uint256 constant DELTA_NEG_Y_1 = 1958951624994736526402023784513889484287569177130777677778703607272513892644;\n    // Pedersen G point in G2 in powers of i\n    uint256 constant PEDERSEN_G_X_0 = 826033962502871230897580264308244787159166898709172352520187721374310347388;\n    uint256 constant PEDERSEN_G_X_1 = 12191498427084538501516628373400886973061774287739661186360639951220493389336;\n    uint256 constant PEDERSEN_G_Y_0 = 8301927948889305299480981445298038817487602530230158851481344098749294196585;\n    uint256 constant PEDERSEN_G_Y_1 = 551589694187369368634779053507897402385062756812904326828804113502236084014;\n\n    // Pedersen GRootSigmaNeg point in G2 in powers of i\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_0 = 53088002417291775537396221051538852792197848029404100186591642007161959558;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_X_1 = 19597848842672933074920327560258496468956192541553850947563758766440996493825;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_0 = 21281875887759119483749454663188117767572918313930107894411064290445209611126;\n    uint256 constant PEDERSEN_GROOTSIGMANEG_Y_1 = 17821642346953516826973884048231142870757796204350980410923780265981668669722;\n\n    // Constant and public input points\n    uint256 constant CONSTANT_X = 11298226711337283265623225420392962314677983160850350677780306256965363185765;\n    uint256 constant CONSTANT_Y = 19390214609591030827409202807579621835341439761287131574418912055959718659320;\n    uint256 constant PUB_0_X = 4727097145600381236806120067307325398528191313491549634977635893644021683559;\n    uint256 constant PUB_0_Y = 11416361546466942010610812918915277800585013812287682943269895630397313718831;\n    uint256 constant PUB_1_X = 2047781801787210790592861692310046375079548499331683350083246018498450631793;\n    uint256 constant PUB_1_Y = 16027790840917191274906797614313124689470390247755734579711689514678588705211;\n    uint256 constant PUB_2_X = 3039595374727551288315942479059853256435422514515502555918406897265306383703;\n    uint256 constant PUB_2_Y = 946624788817616749061208863705590356042887026973746249130514096854398477352;\n    uint256 constant PUB_3_X = 15709547050805490599617595727091539700764579549235046736482096076662263101896;\n    uint256 constant PUB_3_Y = 16681093520223380980565245528725261820842770529145676901047654983389895283715;\n    uint256 constant PUB_4_X = 7194416977522373011498892601168884854908622535213901989498503901408707449288;\n    uint256 constant PUB_4_Y = 5424780462303510647845173136156091472328154741121247118686143152337934526278;\n    uint256 constant PUB_5_X = 12849770793102164046204718836242697731134077607861195978948765224911295139726;\n    uint256 constant PUB_5_Y = 17712002664714174793341340199425248738748949917478885917339103718039572768504;\n    uint256 constant PUB_6_X = 10055676369244820830413644682274790480176004878497730318485060809101201665500;\n    uint256 constant PUB_6_Y = 3892684337234939573729175222957138946216495163644321189142798681215468324629;\n    uint256 constant PUB_7_X = 19444660026385905296832289034106198244544978011357669627332830631858041575852;\n    uint256 constant PUB_7_Y = 1395506953562601961281229497383323023196617908979281282953781112293183016764;\n    uint256 constant PUB_8_X = 3589249598293801584017034223971150770827122339578275141251315121795895984278;\n    uint256 constant PUB_8_Y = 7477874028623432168804359929799228491761628203964820274549738291193101874108;\n    uint256 constant PUB_9_X = 14283258596850447985882708107497645287945627775297713821349003560770479546383;\n    uint256 constant PUB_9_Y = 842054409955375638287186478016001710940078223708979150795490581269581020258;\n\n\n    /// Compute the public input linear combination.\n    /// @notice Reverts with PublicInputNotInField if the input is not in the field.\n    /// @notice Computes the multi-scalar-multiplication of the public input\n    /// elements and the verification key including the constant term.\n    /// @param input The public inputs. These are elements of the scalar field Fr.\n    /// @return x The X coordinate of the resulting G1 point.\n    /// @return y The Y coordinate of the resulting G1 point.\n    function publicInputMSM(\n        uint256[9] memory input,\n        uint256 publicCommit,\n        uint256[2] memory commit\n    ) internal view returns (uint256 x, uint256 y) {\n        // Note: The ECMUL precompile does not reject unreduced values, so we check this.\n        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the\n        //       code-size is in the PUB_ constants.\n        // ECMUL has input (x, y, scalar) and output (x', y').\n        // ECADD has input (x1, y1, x2, y2) and output (x', y').\n        // We call them such that ecmul output is already in the second point\n        // argument to ECADD so we can have a tight loop.\n        bool success = true;\n        assembly (\"memory-safe\") {\n            let f := mload(0x40)\n            let g := add(f, 0x40)\n            let s\n            mstore(f, CONSTANT_X)\n            mstore(add(f, 0x20), CONSTANT_Y)\n            mstore(g, PUB_0_X)\n            mstore(add(g, 0x20), PUB_0_Y)\n            s := mload(input)\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_1_X)\n            mstore(add(g, 0x20), PUB_1_Y)\n            s := mload(add(input, 32))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_2_X)\n            mstore(add(g, 0x20), PUB_2_Y)\n            s := mload(add(input, 64))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_3_X)\n            mstore(add(g, 0x20), PUB_3_Y)\n            s := mload(add(input, 96))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_4_X)\n            mstore(add(g, 0x20), PUB_4_Y)\n            s := mload(add(input, 128))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_5_X)\n            mstore(add(g, 0x20), PUB_5_Y)\n            s := mload(add(input, 160))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_6_X)\n            mstore(add(g, 0x20), PUB_6_Y)\n\n            s := mload(add(input, 192))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_7_X)\n            mstore(add(g, 0x20), PUB_7_Y)\n\n            s := mload(add(input, 224))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_8_X)\n            mstore(add(g, 0x20), PUB_8_Y)\n\n            s := mload(add(input, 256))\n            mstore(add(g, 0x40), s)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n            mstore(g, PUB_9_X)\n            mstore(add(g, 0x20), PUB_9_Y)\n\n            s := mload(add(input, 288))\n            mstore(add(g, 0x40), publicCommit)\n            success := and(success, lt(s, R))\n            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            s := mload(commit)\n            mstore(g, s) // save commit[0]\n            s := mload(add(commit, 32))\n            mstore(add(g, 0x20), s) // save commit[1]\n\n            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))\n\n            x := mload(f)\n            y := mload(add(f, 0x20))\n        }\n        if (!success) {\n            // Either Public input not in field, or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert PublicInputNotInField();\n        }\n    }\n\n    /// Verify an uncompressed Groth16 proof.\n    /// @notice Reverts with InvalidProof if the proof is invalid or\n    /// with PublicInputNotInField the public input is not reduced.\n    /// @notice There is no return value. If the function does not revert, the\n    /// proof was successfully verified.\n    /// @param proof the points (A, B, C) in EIP-197 format matching the output\n    /// of compressProof.\n    /// @param input the public input field elements in the scalar field Fr.\n    /// Elements must be reduced.\n    function verifyProof(\n        uint256[8] memory proof,\n        uint256[2] memory commitment,\n        uint256[2] memory commitmentPOK,\n        uint256[9] memory input\n    ) public view returns (bool) {\n        uint256 inputFr = uint256(keccak256(abi.encodePacked(commitment[0], commitment[1]))) % MOD_R;\n        (uint256 x, uint256 y) = publicInputMSM(input, inputFr, commitment);\n\n        // Note: The precompile expects the F2 coefficients in big-endian order.\n        // Note: The pairing precompile rejects unreduced values, so we won't check that here.\n\n        bool success;\n\n        uint256 a0 = proof[0];\n        uint256 a1 = proof[1];\n        uint256 b00 = proof[2];\n        uint256 b01 = proof[3];\n        uint256 b10 = proof[4];\n        uint256 b11 = proof[5];\n        uint256 c0 = proof[6];\n        uint256 c1 = proof[7];\n\n        assembly (\"memory-safe\") {\n            let f := mload(0x40) // Free memory pointer.\n\n        // Copy points (A, B, C) to memory. They are already in correct encoding.\n        // This is pairing e(A, B) and G1 of e(C, -δ).\n            mstore(f, a0)\n            mstore(add(f, 0x20), a1)\n            mstore(add(f, 0x40), b00)\n            mstore(add(f, 0x60), b01)\n            mstore(add(f, 0x80), b10)\n            mstore(add(f, 0xa0), b11)\n            mstore(add(f, 0xc0), c0)\n            mstore(add(f, 0xe0), c1)\n\n        // Complete e(C, -δ) and write e(α, -β), e(L_pub, -γ) to memory.\n        // OPT: This could be better done using a single codecopy, but\n        //      Solidity (unlike standalone Yul) doesn't provide a way to\n        //      to do this.\n            mstore(add(f, 0x100), DELTA_NEG_X_1)\n            mstore(add(f, 0x120), DELTA_NEG_X_0)\n            mstore(add(f, 0x140), DELTA_NEG_Y_1)\n            mstore(add(f, 0x160), DELTA_NEG_Y_0)\n            mstore(add(f, 0x180), ALPHA_X)\n            mstore(add(f, 0x1a0), ALPHA_Y)\n            mstore(add(f, 0x1c0), BETA_NEG_X_1)\n            mstore(add(f, 0x1e0), BETA_NEG_X_0)\n            mstore(add(f, 0x200), BETA_NEG_Y_1)\n            mstore(add(f, 0x220), BETA_NEG_Y_0)\n            mstore(add(f, 0x240), x)\n            mstore(add(f, 0x260), y)\n            mstore(add(f, 0x280), GAMMA_NEG_X_1)\n            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)\n            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)\n            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)\n\n            let c\n            c := mload(commitment)\n            mstore(add(f, 0x300), c) // save commitment[0]\n            c := mload(add(commitment, 32))\n            mstore(add(f, 0x320), c) // save commitment[1]\n\n            mstore(add(f, 0x340), PEDERSEN_G_X_1)\n            mstore(add(f, 0x360), PEDERSEN_G_X_0)\n            mstore(add(f, 0x380), PEDERSEN_G_Y_1)\n            mstore(add(f, 0x3a0), PEDERSEN_G_Y_0)\n\n            c := mload(commitmentPOK)\n            mstore(add(f, 0x3c0), c) // save knowledgeProof[0]\n            c := mload(add(commitmentPOK, 32))\n            mstore(add(f, 0x3e0), c) // save knowledgeProof[1]\n\n            mstore(add(f, 0x400), PEDERSEN_GROOTSIGMANEG_X_1)\n            mstore(add(f, 0x420), PEDERSEN_GROOTSIGMANEG_X_0)\n            mstore(add(f, 0x440), PEDERSEN_GROOTSIGMANEG_Y_1)\n            mstore(add(f, 0x460), PEDERSEN_GROOTSIGMANEG_Y_0)\n\n        // Check pairing equation.\n            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x480, f, 0x20)\n        // Also check returned value (both are either 1 or 0).\n            success := and(success, mload(f))\n        }\n        if (!success) {\n            // Either proof or verification key invalid.\n            // We assume the contract is correctly generated, so the verification key is valid.\n            revert ProofInvalid();\n        }\n        return success;\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/common/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IVerifier {\n    function verifyProof(\n        uint256[8] calldata proof,\n        uint256[2] calldata commit,\n        uint256[2] calldata knowledgeProof,\n        uint256[9] calldata input\n    ) external view returns (bool r);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}